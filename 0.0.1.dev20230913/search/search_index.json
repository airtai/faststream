{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>FastStream</li> <li>Features</li> <li>Tutorial<ul> <li>Getting Started</li> <li>Subscription and Serialization<ul> <li>Annotation Serialization</li> <li>Pydantic Serialization</li> <li>Filtering</li> <li>Testing</li> </ul> </li> <li>Publishing<ul> <li>Broker Publish</li> <li>Decorator</li> <li>Object Decorator</li> <li>Direct Publishing</li> <li>Testing</li> </ul> </li> <li>Routers</li> <li>Dependencies<ul> <li>Classes as Dependencies</li> <li>Sub-dependencies</li> <li>Global Dependencies</li> <li>Dependencies with yield</li> <li>Testing</li> </ul> </li> <li>Context<ul> <li>Existed Fields</li> <li>Custom Context</li> <li>Fields Access</li> <li>Extra Options</li> </ul> </li> <li>Custom Serialization<ul> <li>Parser</li> <li>Decoder</li> <li>Examples</li> </ul> </li> <li>Lifespan<ul> <li>Lifespan Hooks</li> <li>Lifespan Testing</li> </ul> </li> <li>Middlewares</li> <li>AsyncAPI<ul> <li>Schema Export</li> <li>Schema Hosting</li> <li>Customize Information</li> </ul> </li> <li>Integrations</li> <li>FastAPI Plugin</li> <li>CLI commands</li> <li>Logging</li> <li>Config Management</li> <li>Contributing<ul> <li>Development</li> <li>Documentation</li> </ul> </li> </ul> </li> <li>Kafka<ul> <li>Subscription</li> <li>Publishing</li> <li>Batch Pub/Sub</li> <li>Message Information</li> </ul> </li> <li>RabbitMQ<ul> <li>Subsctiption<ul> <li>Direct</li> <li>Fanout</li> <li>Topic</li> <li>Headers</li> <li>Stream</li> </ul> </li> <li>Publishing</li> <li>RPC</li> <li>Acknowledgement</li> <li>Declare Queue/Exchange</li> <li>Message Information</li> </ul> </li> <li>Reference<ul> <li>faststream<ul> <li>app<ul> <li>ABCApp</li> <li>FastStream</li> </ul> </li> <li>asyncapi<ul> <li>base<ul> <li>AsyncAPIOperation</li> </ul> </li> <li>generate<ul> <li>get_app_broker_channels</li> <li>get_app_broker_server</li> <li>get_app_schema</li> </ul> </li> <li>message<ul> <li>get_model_schema</li> <li>get_response_schema</li> <li>parse_handler_params</li> </ul> </li> <li>schema<ul> <li>bindings<ul> <li>amqp<ul> <li>ChannelBinding</li> <li>Exchange</li> <li>OperationBinding</li> <li>Queue</li> <li>ServerBinding</li> </ul> </li> <li>kafka<ul> <li>ChannelBinding</li> <li>OperationBinding</li> <li>ServerBinding</li> </ul> </li> <li>main<ul> <li>ChannelBinding</li> <li>OperationBinding</li> <li>ServerBinding</li> </ul> </li> <li>nats<ul> <li>ChannelBinding</li> <li>OperationBinding</li> <li>ServerBinding</li> </ul> </li> <li>redis<ul> <li>ChannelBinding</li> <li>OperationBinding</li> <li>ServerBinding</li> </ul> </li> <li>sqs<ul> <li>ChannelBinding</li> <li>OperationBinding</li> <li>ServerBinding</li> </ul> </li> </ul> </li> <li>channels<ul> <li>Channel</li> </ul> </li> <li>info<ul> <li>Contact</li> <li>ContactDict</li> <li>EmailStr</li> <li>Info</li> <li>License</li> <li>LicenseDict</li> </ul> </li> <li>main<ul> <li>Components</li> <li>Schema</li> </ul> </li> <li>message<ul> <li>CorrelationId</li> <li>Message</li> </ul> </li> <li>operations<ul> <li>Operation</li> </ul> </li> <li>security<ul> <li>OauthFlowObj</li> <li>OauthFlows</li> <li>SecuritySchemaComponent</li> </ul> </li> <li>servers<ul> <li>Server</li> <li>ServerVariable</li> </ul> </li> <li>utils<ul> <li>ExternalDocs</li> <li>ExternalDocsDict</li> <li>Parameter</li> <li>Reference</li> <li>Tag</li> <li>TagDict</li> </ul> </li> </ul> </li> <li>site<ul> <li>get_asyncapi_html</li> <li>serve_app</li> </ul> </li> <li>utils<ul> <li>resolve_payloads</li> <li>to_camelcase</li> </ul> </li> </ul> </li> <li>broker<ul> <li>core<ul> <li>abc<ul> <li>BrokerUsecase</li> <li>extend_dependencies</li> </ul> </li> <li>asyncronous<ul> <li>BrokerAsyncUsecase</li> <li>default_filter</li> </ul> </li> <li>mixins<ul> <li>LoggingMixin</li> </ul> </li> </ul> </li> <li>fastapi<ul> <li>route<ul> <li>StreamMessage</li> <li>StreamRoute</li> <li>get_app</li> </ul> </li> <li>router<ul> <li>StreamRouter</li> </ul> </li> </ul> </li> <li>handler<ul> <li>AsyncHandler</li> <li>BaseHandler</li> </ul> </li> <li>message<ul> <li>ABCStreamMessage</li> <li>StreamMessage</li> <li>SyncStreamMessage</li> </ul> </li> <li>middlewares<ul> <li>BaseMiddleware</li> <li>CriticalLogMiddleware</li> </ul> </li> <li>parsers<ul> <li>decode_message</li> <li>encode_message</li> <li>resolve_custom_func</li> </ul> </li> <li>publisher<ul> <li>BasePublisher</li> </ul> </li> <li>push_back_watcher<ul> <li>BaseWatcher</li> <li>CounterWatcher</li> <li>EndlessWatcher</li> <li>OneTryWatcher</li> <li>WatcherContext</li> </ul> </li> <li>router<ul> <li>BrokerRoute</li> <li>BrokerRouter</li> </ul> </li> <li>schemas<ul> <li>NameRequired</li> <li>RawDecoced</li> </ul> </li> <li>security<ul> <li>BaseSecurity</li> <li>SASLPlaintext</li> <li>SASLScram256</li> <li>SASLScram512</li> </ul> </li> <li>test<ul> <li>TestApp</li> <li>call_handler</li> <li>patch_broker_calls</li> </ul> </li> <li>types<ul> <li>AsyncPublisherProtocol</li> </ul> </li> <li>utils<ul> <li>change_logger_handlers</li> <li>get_watcher</li> <li>set_message_context</li> </ul> </li> <li>wrapper<ul> <li>FakePublisher</li> <li>HandlerCallWrapper</li> </ul> </li> </ul> </li> <li>cli<ul> <li>docs<ul> <li>app<ul> <li>gen</li> <li>serve</li> </ul> </li> </ul> </li> <li>main<ul> <li>main</li> <li>run</li> <li>version_callback</li> </ul> </li> <li>supervisors<ul> <li>basereload<ul> <li>BaseReload</li> </ul> </li> <li>multiprocess<ul> <li>Multiprocess</li> </ul> </li> <li>utils<ul> <li>get_subprocess</li> <li>set_exit</li> <li>subprocess_started</li> </ul> </li> <li>watchfiles<ul> <li>ExtendedFilter</li> <li>WatchReloader</li> </ul> </li> </ul> </li> <li>utils<ul> <li>imports<ul> <li>get_app_path</li> <li>import_object</li> <li>try_import_app</li> </ul> </li> <li>logs<ul> <li>LogLevels</li> <li>get_log_level</li> <li>set_log_level</li> </ul> </li> <li>parser<ul> <li>parse_cli_args</li> <li>remove_prefix</li> </ul> </li> </ul> </li> </ul> </li> <li>constants<ul> <li>ContentTypes</li> </ul> </li> <li>exceptions<ul> <li>AckMessage</li> <li>HandlerException</li> <li>NackMessage</li> <li>RejectMessage</li> <li>SkipMessage</li> <li>StopConsume</li> </ul> </li> <li>kafka<ul> <li>asyncapi<ul> <li>Handler</li> <li>Publisher</li> </ul> </li> <li>broker<ul> <li>KafkaBroker</li> </ul> </li> <li>fastapi<ul> <li>KafkaRouter</li> </ul> </li> <li>handler<ul> <li>LogicHandler</li> </ul> </li> <li>message<ul> <li>KafkaMessage</li> </ul> </li> <li>parser<ul> <li>AioKafkaParser</li> </ul> </li> <li>producer<ul> <li>AioKafkaFastProducer</li> </ul> </li> <li>publisher<ul> <li>LogicPublisher</li> </ul> </li> <li>router<ul> <li>KafkaRouter</li> </ul> </li> <li>security<ul> <li>parse_security</li> </ul> </li> <li>shared<ul> <li>logging<ul> <li>KafkaLoggingMixin</li> </ul> </li> <li>publisher<ul> <li>ABCPublisher</li> </ul> </li> <li>router<ul> <li>KafkaRouter</li> </ul> </li> <li>schemas<ul> <li>ConsumerConnectionParams</li> </ul> </li> </ul> </li> <li>test<ul> <li>FakeProducer</li> <li>TestKafkaBroker</li> <li>build_message</li> </ul> </li> </ul> </li> <li>log<ul> <li>formatter<ul> <li>ColourizedFormatter</li> <li>expand_log_field</li> <li>make_record_with_extra</li> </ul> </li> <li>logging<ul> <li>configure_formatter</li> </ul> </li> </ul> </li> <li>rabbit<ul> <li>asyncapi<ul> <li>Handler</li> <li>Publisher</li> <li>RMQAsyncAPIChannel</li> </ul> </li> <li>broker<ul> <li>RabbitBroker</li> </ul> </li> <li>fastapi<ul> <li>RabbitRouter</li> </ul> </li> <li>handler<ul> <li>LogicHandler</li> </ul> </li> <li>helpers<ul> <li>RabbitDeclarer</li> </ul> </li> <li>message<ul> <li>RabbitMessage</li> </ul> </li> <li>parser<ul> <li>AioPikaParser</li> </ul> </li> <li>producer<ul> <li>AioPikaFastProducer</li> </ul> </li> <li>publisher<ul> <li>LogicPublisher</li> </ul> </li> <li>router<ul> <li>RabbitRouter</li> </ul> </li> <li>security<ul> <li>parse_security</li> </ul> </li> <li>shared<ul> <li>constants<ul> <li>ExchangeType</li> </ul> </li> <li>logging<ul> <li>RabbitLoggingMixin</li> </ul> </li> <li>publisher<ul> <li>ABCPublisher</li> </ul> </li> <li>router<ul> <li>RabbitRouter</li> </ul> </li> <li>schemas<ul> <li>BaseRMQInformation</li> <li>RabbitExchange</li> <li>RabbitQueue</li> <li>get_routing_hash</li> </ul> </li> </ul> </li> <li>test<ul> <li>FakeProducer</li> <li>PatchedMessage</li> <li>TestRabbitBroker</li> <li>build_message</li> </ul> </li> </ul> </li> <li>utils<ul> <li>classes<ul> <li>Singleton</li> </ul> </li> <li>context<ul> <li>main<ul> <li>ContextRepo</li> </ul> </li> <li>types<ul> <li>Context</li> <li>resolve_context</li> </ul> </li> </ul> </li> <li>data<ul> <li>filter_by_dict</li> </ul> </li> <li>functions<ul> <li>get_function_positional_arguments</li> <li>to_async</li> </ul> </li> <li>no_cast<ul> <li>NoCast</li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> <li>Release Notes</li> </ul>"},{"location":"","title":"FastStream","text":"<p>Effortless event stream integration for your services</p> <p> </p> <p>FastStream is a powerful and easy-to-use Python library for building asynchronous services that interact with event streams.  Built on top of Pydantic and AsyncAPI, FastStream simplifies the process of writing producers and consumers for message queues, handling all the parsing, networking, task scheduling and data generation automatically. With FastStream, you can quickly prototype and develop high-performance event-based services with minimal code, making it an ideal choice for developers looking to streamline their workflow and accelerate their projects.</p>"},{"location":"#history","title":"History","text":"<p>FastStream is a new package based on the ideas and experiences gained from FastKafka and Propan. By joining our forces, we  picked up the best from both packages and created the unified way to write   services capable of processing streamed data regradless of the underliying protocol.</p> <p>We'll continue to maintain both packages, but new development will be in this   project. If you are starting a new service, this package is the recommended way to do it.</p>"},{"location":"#stay-in-touch","title":"\u2b50\u2b50\u2b50 Stay in touch \u2b50\u2b50\u2b50","text":"<p>Please show your support and stay in touch by:</p> <ul> <li> <p>giving our GitHub repository a   star, and</p> </li> <li> <p>joining our Discord server.</p> </li> </ul> <p>Your support helps us to stay in touch with you and encourages us to continue developing and improving the library. Thank you for your support!</p>"},{"location":"#install","title":"Install","text":"<p>FastStream works on Linux, macOS, Windows and most Unix-style operating systems. You can install it with <code>pip</code> as usual:</p> <pre><code>pip install faststream\n</code></pre>"},{"location":"#writing-app-code","title":"Writing app code","text":"<p>Here is an example python app using FastStream that consumes data from a topic, increments the value, and outputs the data to another topic.</p> <pre><code>from pydantic import BaseModel, Field, NonNegativeFloat\n\nfrom faststream import FastStream, Logger\nfrom faststream.kafka import KafkaBroker\n\n\nclass DataBasic(BaseModel):\n    data: NonNegativeFloat = Field(\n        ..., examples=[0.5], description=\"Float data example\"\n    )\n\n\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\n\n\n@broker.publisher(\"output_data\")\n@broker.subscriber(\"input_data\")\nasync def on_input_data(msg: DataBasic, logger: Logger) -&gt; DataBasic:\n    logger.info(msg)\n    return DataBasic(data=msg.data + 1.0)\n</code></pre>"},{"location":"#messages","title":"Messages","text":"<p>FastStream uses Pydantic to parse input JSON-encoded data into Python objects, making it easy to work with structured data in your Kafka-based applications. Pydantic\u2019s <code>BaseModel</code> class allows you to define messages using a declarative syntax, making it easy to specify the fields and types of your messages.</p> <p>This example defines one message class for use in a FastStream application, <code>Data</code>.</p> <pre><code>from pydantic import BaseModel, Field, NonNegativeFloat\nfrom faststream import FastStream, Logger\nfrom faststream.kafka import KafkaBroker\n\n\nclass DataBasic(BaseModel):\ndata: NonNegativeFloat = Field(\n..., examples=[0.5], description=\"Float data example\"\n)\n# Code below omitted \ud83d\udc47\n</code></pre> \ud83d\udc40 Full file preview <pre><code>from pydantic import BaseModel, Field, NonNegativeFloat\n\nfrom faststream import FastStream, Logger\nfrom faststream.kafka import KafkaBroker\n\n\nclass DataBasic(BaseModel):\n    data: NonNegativeFloat = Field(\n        ..., examples=[0.5], description=\"Float data example\"\n    )\n\n\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\n\n\n@broker.publisher(\"output_data\")\n@broker.subscriber(\"input_data\")\nasync def on_input_data(msg: DataBasic, logger: Logger) -&gt; DataBasic:\n    logger.info(msg)\n    return DataBasic(data=msg.data + 1.0)\n</code></pre> <p>These message class will be used to parse and validate incoming data when consuming and to produce a JSON-encoded message when producing. Using Pydantic\u2019s BaseModel in combination with FastStream makes it easy to work with structured data in your Event-based applications.</p>"},{"location":"#application","title":"Application","text":"<p>This example shows how to initialize a FastStream application.</p> <p>It starts by initialising a <code>Broker</code> object with the address of the Message broker.</p> <p>Next, an object of the <code>FastStream</code> class is created and a <code>Broker</code> object is passed to it.</p> <pre><code># Code above omitted \ud83d\udc46\n\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\n# Code below omitted \ud83d\udc47\n</code></pre> \ud83d\udc40 Full file preview <pre><code>from pydantic import BaseModel, Field, NonNegativeFloat\n\nfrom faststream import FastStream, Logger\nfrom faststream.kafka import KafkaBroker\n\n\nclass DataBasic(BaseModel):\n    data: NonNegativeFloat = Field(\n        ..., examples=[0.5], description=\"Float data example\"\n    )\n\n\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\n\n\n@broker.publisher(\"output_data\")\n@broker.subscriber(\"input_data\")\nasync def on_input_data(msg: DataBasic, logger: Logger) -&gt; DataBasic:\n    logger.info(msg)\n    return DataBasic(data=msg.data + 1.0)\n</code></pre>"},{"location":"#function-decorators","title":"Function decorators","text":"<p>FastStream brokers provide convenient function decorators <code>broker.subscriber</code> and <code>@broker.publisher</code> to allow you to delegate the actual process of</p> <ul> <li> <p>consuming and producing data to Event queues, and</p> </li> <li> <p>decoding and encoding JSON encoded messages</p> </li> </ul> <p>from user defined functions to the framework. The FastStream framework delegates these jobs to AIOKafka and Pydantic libraries.</p> <p>These decorators make it easy to specify the processing logic for your consumers and producers, allowing you to focus on the core business logic of your application without worrying about the underlying integration.</p> <p>This following example shows how to use the <code>@broker.subscriber</code> and <code>@broker.publisher</code> decorators in a FastStream application:</p> <ul> <li> <p>The <code>@broker.subscriber</code> decorator is applied to the <code>on_input_data</code>   function, which specifies that this function should be called whenever   a message is received on the \u201cinput_data\u201d Kafka topic. The   <code>on_input_data</code> function takes a single argument which is expected to   be an instance of the <code>Data</code> message class. Specifying the type   of the single argument is instructing the Pydantic to use   <code>InputData.parse_raw()</code> on the consumed message before passing it to   the user defined function <code>on_input_data</code>.</p> </li> <li> <p>The <code>@broker.publisher</code> decorator is applied also to the <code>on_input_data</code> function,   which specifies that this function should produce a message to the   \u201coutput_data\u201d topic whenever it is called. The <code>on_input_data</code>   function takes the input data and creates a new   <code>Data</code> message with incremented value and then returns it. The   framework will call the <code>Data.json().encode(\"utf-8\")</code> function   on the returned value and produce it to the specified topic.</p> </li> </ul> <pre><code>from pydantic import BaseModel, Field, NonNegativeFloat\n\nfrom faststream import FastStream, Logger\nfrom faststream.kafka import KafkaBroker\n\n\nclass DataBasic(BaseModel):\n    data: NonNegativeFloat = Field(\n        ..., examples=[0.5], description=\"Float data example\"\n    )\n\n\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\n\n\n@broker.publisher(\"output_data\")\n@broker.subscriber(\"input_data\")\nasync def on_input_data(msg: DataBasic, logger: Logger) -&gt; DataBasic:\nlogger.info(msg)\nreturn DataBasic(data=msg.data + 1.0)\n</code></pre>"},{"location":"#testing-the-service","title":"Testing the service","text":"<p>The service can be tested using the <code>TestBroker</code> context managers which, by default, puts the Broker into \"testing mode\".</p> <p>The Tester will redirect your <code>subscriber</code> and <code>publisher</code> decorated functions to the InMemory brokers so that you can quickly test your app without the need for a running broker and all its dependencies.</p> <p>Using pytest, the test for our service would look like this:</p> <pre><code>import pytest\n\nfrom faststream.kafka import TestKafkaBroker\n\nfrom .basic import DataBasic, broker, on_input_data\n\n\n@pytest.mark.asyncio\nasync def test_base_app():\n    @broker.subscriber(\"output_data\")\n    async def on_output_data(msg: DataBasic):\n        pass\n\n    async with TestKafkaBroker(broker):\n        await broker.publish(DataBasic(data=0.2), \"input_data\")\n\n        on_input_data.mock.assert_called_once_with(dict(DataBasic(data=0.2)))\n\n        on_output_data.mock.assert_called_once_with(dict(DataBasic(data=1.2)))\n</code></pre> <p>First we pass our broker to the <code>TestKafkaBroker</code></p> <pre><code>import pytest\n\nfrom faststream.kafka import TestKafkaBroker\nfrom .basic import DataBasic, broker, on_input_data\n\n\n@pytest.mark.asyncio\nasync def test_base_app():\n    @broker.subscriber(\"output_data\")\n    async def on_output_data(msg: DataBasic):\n        pass\n\nasync with TestKafkaBroker(broker):\nawait broker.publish(DataBasic(data=0.2), \"input_data\")\n\n        on_input_data.mock.assert_called_once_with(dict(DataBasic(data=0.2)))\n\n        on_output_data.mock.assert_called_once_with(dict(DataBasic(data=1.2)))\n</code></pre> <p>After passing the broker to the <code>TestKafkaBroker</code> we can publish an event to \"input_data\" and check if the tested broker produced a response as a reaction to it.</p> <p>To check the response, we registered an additional <code>on_output_data</code> subscriber which will capture events on \"output_data\" topic.</p> <pre><code>import pytest\n\nfrom faststream.kafka import TestKafkaBroker\n\nfrom .basic import DataBasic, broker, on_input_data\n\n\n@pytest.mark.asyncio\nasync def test_base_app():\n@broker.subscriber(\"output_data\")\nasync def on_output_data(msg: DataBasic):\npass\nasync with TestKafkaBroker(broker):\n        await broker.publish(DataBasic(data=0.2), \"input_data\")\n\n        on_input_data.mock.assert_called_once_with(dict(DataBasic(data=0.2)))\n\non_output_data.mock.assert_called_once_with(dict(DataBasic(data=1.2)))\n</code></pre>"},{"location":"#running-the-application","title":"Running the application","text":"<p>The application can be started using builtin FastStream CLI command.</p> <p>First we will save our application code to <code>app.py</code> file. Here is the application code again:</p> <pre><code>from pydantic import BaseModel, Field, NonNegativeFloat\n\nfrom faststream import FastStream, Logger\nfrom faststream.kafka import KafkaBroker\n\n\nclass DataBasic(BaseModel):\n    data: NonNegativeFloat = Field(\n        ..., examples=[0.5], description=\"Float data example\"\n    )\n\n\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\n\n\n@broker.publisher(\"output_data\")\n@broker.subscriber(\"input_data\")\nasync def on_input_data(msg: DataBasic, logger: Logger) -&gt; DataBasic:\n    logger.info(msg)\n    return DataBasic(data=msg.data + 1.0)\n</code></pre> <p>In order to get all Kafka or RabbitMQ related dependancies, you must install FastStream with the <code>kafka</code> or <code>rabbit</code> options, respectively:</p> <pre><code>pip install faststream[kafka]\n</code></pre> <p>To run the service, use the FastStream CLI command and pass the module (in this case, the file where the app implementation is located) and the app simbol to the command.</p> <pre><code>faststream run basic:app\n</code></pre> <p>After running the command you should see the following output:</p> <pre><code>INFO     - FastStream app starting...\nINFO     - input_data |            - `OnInputData` waiting for messages\nINFO     - FastStream app started successfully! To exit press CTRL+C\n</code></pre>"},{"location":"#license","title":"License","text":"<p>FastStream is licensed under the Apache License 2.0</p> <p>A permissive license whose main conditions require preservation of copyright and license notices. Contributors provide an express grant of patent rights. Licensed works, modifications, and larger works may be distributed under different terms and without source code.</p> <p>The full text of the license can be found here.</p>"},{"location":"#contributors","title":"Contributors","text":"<p>Thanks for all of these amazing peoples made the project better!</p> <p> </p>"},{"location":"contact/","title":"Contact FastStream","text":"<p>Media information about creators, how to contact them and the project media pages</p>"},{"location":"features/","title":"Features","text":"<p>Should be as simple as possible, we are making PR for junior, not senior users</p> <p>Inspirations: * FastAPI: https://fastapi.tiangolo.com/features * Propan Readme: https://githib.com/Lancetnik/Propan</p> <p>Pydantic and AsyncAPI - based, support all Pydantic features, etc</p> <p>Core features overview:</p> <ul> <li>multiple brokers support</li> <li>pydantic validation (annotation-based/model)</li> <li>automtic docs (with images)</li> <li>editor support (full typed)</li> <li>powerfull dependency injection system</li> <li>testable (in-memory tests)</li> <li>extendable (lifespans, custom serialization, middlewares)</li> </ul>"},{"location":"release/","title":"Release Notes","text":""},{"location":"api/faststream/app/ABCApp/","title":"ABCApp","text":""},{"location":"api/faststream/app/ABCApp/#faststream.app.ABCApp","title":"faststream.app.ABCApp","text":"<p>             Bases: <code>ABC</code></p> <p>A class representing an ABC App.</p> <p>Attributes:</p> Name Type Description <code>_on_startup_calling</code> <p>List of callable functions to be called on startup</p> <code>_after_startup_calling</code> <p>List of callable functions to be called after startup</p> <code>_on_shutdown_calling</code> <p>List of callable functions to be called on shutdown</p> <code>_after_shutdown_calling</code> <p>List of callable functions to be called after shutdown</p> <code>broker</code> <p>Optional broker object</p> <code>logger</code> <p>Optional logger object</p> <code>title</code> <p>Title of the app</p> <code>version</code> <p>Version of the app</p> <code>description</code> <p>Description of the app</p> <code>terms_of_service</code> <p>Optional terms of service URL</p> <code>license</code> <p>Optional license information</p> <code>contact</code> <p>Optional contact information</p> <code>identifier</code> <p>Optional identifier</p> <code>asyncapi_tags</code> <p>Optional list of tags</p> <code>external_docs</code> <p>Optional external documentation</p> <p>Methods:</p> Name Description <code>set_broker </code> <p>Set the broker object</p> <code>on_startup </code> <p>Add a hook to be run before the broker is connected</p> <code>on_shutdown </code> <p>Add a hook to be run before the broker is disconnected</p> <code>after_startup </code> <p>Add a hook to be run after the broker is connected</p> <code>after_shutdown </code> <p>Add a hook to be run after the broker is disconnected</p> <code>_log </code> <p>Log a message at a specified</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/app.py</code> <pre><code>class ABCApp(ABC):\n\"\"\"A class representing an ABC App.\n\n    Attributes:\n        _on_startup_calling : List of callable functions to be called on startup\n        _after_startup_calling : List of callable functions to be called after startup\n        _on_shutdown_calling : List of callable functions to be called on shutdown\n        _after_shutdown_calling : List of callable functions to be called after shutdown\n        broker : Optional broker object\n        logger : Optional logger object\n        title : Title of the app\n        version : Version of the app\n        description : Description of the app\n        terms_of_service : Optional terms of service URL\n        license : Optional license information\n        contact : Optional contact information\n        identifier : Optional identifier\n        asyncapi_tags : Optional list of tags\n        external_docs : Optional external documentation\n\n    Methods:\n        set_broker : Set the broker object\n        on_startup : Add a hook to be run before the broker is connected\n        on_shutdown : Add a hook to be run before the broker is disconnected\n        after_startup : Add a hook to be run after the broker is connected\n        after_shutdown : Add a hook to be run after the broker is disconnected\n        _log : Log a message at a specified\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    _on_startup_calling: List[AnyCallable]\n    _after_startup_calling: List[AnyCallable]\n    _on_shutdown_calling: List[AnyCallable]\n    _after_shutdown_calling: List[AnyCallable]\n\n    def __init__(\n        self,\n        broker: Optional[BrokerAsyncUsecase[Any, Any]] = None,\n        logger: Optional[logging.Logger] = logger,\n        # AsyncAPI information\n        title: str = \"FastStream\",\n        version: str = \"0.1.0\",\n        description: str = \"\",\n        terms_of_service: Optional[AnyHttpUrl] = None,\n        license: Optional[Union[License, LicenseDict, AnyDict]] = None,\n        contact: Optional[Union[Contact, ContactDict, AnyDict]] = None,\n        identifier: Optional[str] = None,\n        tags: Optional[Sequence[Union[Tag, TagDict, AnyDict]]] = None,\n        external_docs: Optional[Union[ExternalDocs, ExternalDocsDict, AnyDict]] = None,\n    ):\n\"\"\"Initialize an instance of the class.\n\n        Args:\n            broker: An optional instance of the BrokerAsyncUsecase class.\n            logger: An optional instance of the logging.Logger class.\n            title: A string representing the title of the AsyncAPI.\n            version: A string representing the version of the AsyncAPI.\n            description: A string representing the description of the AsyncAPI.\n            terms_of_service: An optional URL representing the terms of service of the AsyncAPI.\n            license: An optional instance of the License class.\n            contact: An optional instance of the Contact class.\n            identifier: An optional string representing the identifier of the AsyncAPI.\n            tags: An optional sequence of Tag instances.\n            external_docs: An optional instance of the ExternalDocs class.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        self.broker = broker\n        self.logger = logger\n        self.context = context\n        context.set_global(\"app\", self)\n\n        self._on_startup_calling = []\n        self._after_startup_calling = []\n        self._on_shutdown_calling = []\n        self._after_shutdown_calling = []\n\n        # AsyncAPI information\n        self.title = title\n        self.version = version\n        self.description = description\n        self.terms_of_service = terms_of_service\n        self.license = license\n        self.contact = contact\n        self.identifier = identifier\n        self.asyncapi_tags = tags\n        self.external_docs = external_docs\n\n    def set_broker(self, broker: BrokerAsyncUsecase[Any, Any]) -&gt; None:\n\"\"\"Set already existed App object broker\n        Usefull then you create/init broker in `on_startup` hook\"\"\"\n        self.broker = broker\n\n    def on_startup(\n        self,\n        func: Callable[P_HookParams, T_HookReturn],\n    ) -&gt; Callable[P_HookParams, T_HookReturn]:\n\"\"\"Add hook running BEFORE broker connected\n        This hook also takes an extra CLI options as a kwargs\"\"\"\n        self._on_startup_calling.append(apply_types(func))\n        return func\n\n    def on_shutdown(\n        self,\n        func: Callable[P_HookParams, T_HookReturn],\n    ) -&gt; Callable[P_HookParams, T_HookReturn]:\n\"\"\"Add hook running BEFORE broker disconnected\"\"\"\n        self._on_shutdown_calling.append(apply_types(func))\n        return func\n\n    def after_startup(\n        self,\n        func: Callable[P_HookParams, T_HookReturn],\n    ) -&gt; Callable[P_HookParams, T_HookReturn]:\n\"\"\"Add hook running AFTER broker connected\"\"\"\n        self._after_startup_calling.append(apply_types(func))\n        return func\n\n    def after_shutdown(\n        self,\n        func: Callable[P_HookParams, T_HookReturn],\n    ) -&gt; Callable[P_HookParams, T_HookReturn]:\n\"\"\"Add hook running AFTER broker disconnected\"\"\"\n        self._after_shutdown_calling.append(apply_types(func))\n        return func\n\n    def _log(self, level: int, message: str) -&gt; None:\n\"\"\"Logs a message with the specified log level.\n\n        Args:\n            level (int): The log level.\n            message (str): The message to be logged.\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        if self.logger is not None:\n            self.logger.log(level, message)\n</code></pre>"},{"location":"api/faststream/app/ABCApp/#faststream.app.ABCApp-attributes","title":"Attributes","text":""},{"location":"api/faststream/app/ABCApp/#faststream.app.ABCApp.asyncapi_tags","title":"asyncapi_tags  <code>instance-attribute</code>","text":"<pre><code>asyncapi_tags = tags\n</code></pre>"},{"location":"api/faststream/app/ABCApp/#faststream.app.ABCApp.broker","title":"broker  <code>instance-attribute</code>","text":"<pre><code>broker = broker\n</code></pre>"},{"location":"api/faststream/app/ABCApp/#faststream.app.ABCApp.contact","title":"contact  <code>instance-attribute</code>","text":"<pre><code>contact = contact\n</code></pre>"},{"location":"api/faststream/app/ABCApp/#faststream.app.ABCApp.context","title":"context  <code>instance-attribute</code>","text":"<pre><code>context = context\n</code></pre>"},{"location":"api/faststream/app/ABCApp/#faststream.app.ABCApp.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description = description\n</code></pre>"},{"location":"api/faststream/app/ABCApp/#faststream.app.ABCApp.external_docs","title":"external_docs  <code>instance-attribute</code>","text":"<pre><code>external_docs = external_docs\n</code></pre>"},{"location":"api/faststream/app/ABCApp/#faststream.app.ABCApp.identifier","title":"identifier  <code>instance-attribute</code>","text":"<pre><code>identifier = identifier\n</code></pre>"},{"location":"api/faststream/app/ABCApp/#faststream.app.ABCApp.license","title":"license  <code>instance-attribute</code>","text":"<pre><code>license = license\n</code></pre>"},{"location":"api/faststream/app/ABCApp/#faststream.app.ABCApp.logger","title":"logger  <code>instance-attribute</code>","text":"<pre><code>logger = logger\n</code></pre>"},{"location":"api/faststream/app/ABCApp/#faststream.app.ABCApp.terms_of_service","title":"terms_of_service  <code>instance-attribute</code>","text":"<pre><code>terms_of_service = terms_of_service\n</code></pre>"},{"location":"api/faststream/app/ABCApp/#faststream.app.ABCApp.title","title":"title  <code>instance-attribute</code>","text":"<pre><code>title = title\n</code></pre>"},{"location":"api/faststream/app/ABCApp/#faststream.app.ABCApp.version","title":"version  <code>instance-attribute</code>","text":"<pre><code>version = version\n</code></pre>"},{"location":"api/faststream/app/ABCApp/#faststream.app.ABCApp-functions","title":"Functions","text":""},{"location":"api/faststream/app/ABCApp/#faststream.app.ABCApp.__init__","title":"__init__","text":"<pre><code>__init__(\n    broker: Optional[BrokerAsyncUsecase[Any, Any]] = None,\n    logger: Optional[logging.Logger] = logger,\n    title: str = \"FastStream\",\n    version: str = \"0.1.0\",\n    description: str = \"\",\n    terms_of_service: Optional[AnyHttpUrl] = None,\n    license: Optional[\n        Union[License, LicenseDict, AnyDict]\n    ] = None,\n    contact: Optional[\n        Union[Contact, ContactDict, AnyDict]\n    ] = None,\n    identifier: Optional[str] = None,\n    tags: Optional[\n        Sequence[Union[Tag, TagDict, AnyDict]]\n    ] = None,\n    external_docs: Optional[\n        Union[ExternalDocs, ExternalDocsDict, AnyDict]\n    ] = None,\n)\n</code></pre> <p>Initialize an instance of the class.</p> <p>Parameters:</p> Name Type Description Default <code>broker</code> <code>Optional[BrokerAsyncUsecase[Any, Any]]</code> <p>An optional instance of the BrokerAsyncUsecase class.</p> <code>None</code> <code>logger</code> <code>Optional[Logger]</code> <p>An optional instance of the logging.Logger class.</p> <code>logger</code> <code>title</code> <code>str</code> <p>A string representing the title of the AsyncAPI.</p> <code>'FastStream'</code> <code>version</code> <code>str</code> <p>A string representing the version of the AsyncAPI.</p> <code>'0.1.0'</code> <code>description</code> <code>str</code> <p>A string representing the description of the AsyncAPI.</p> <code>''</code> <code>terms_of_service</code> <code>Optional[AnyHttpUrl]</code> <p>An optional URL representing the terms of service of the AsyncAPI.</p> <code>None</code> <code>license</code> <code>Optional[Union[License, LicenseDict, AnyDict]]</code> <p>An optional instance of the License class.</p> <code>None</code> <code>contact</code> <code>Optional[Union[Contact, ContactDict, AnyDict]]</code> <p>An optional instance of the Contact class.</p> <code>None</code> <code>identifier</code> <code>Optional[str]</code> <p>An optional string representing the identifier of the AsyncAPI.</p> <code>None</code> <code>tags</code> <code>Optional[Sequence[Union[Tag, TagDict, AnyDict]]]</code> <p>An optional sequence of Tag instances.</p> <code>None</code> <code>external_docs</code> <code>Optional[Union[ExternalDocs, ExternalDocsDict, AnyDict]]</code> <p>An optional instance of the ExternalDocs class.</p> <code>None</code> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/app.py</code> <pre><code>def __init__(\n    self,\n    broker: Optional[BrokerAsyncUsecase[Any, Any]] = None,\n    logger: Optional[logging.Logger] = logger,\n    # AsyncAPI information\n    title: str = \"FastStream\",\n    version: str = \"0.1.0\",\n    description: str = \"\",\n    terms_of_service: Optional[AnyHttpUrl] = None,\n    license: Optional[Union[License, LicenseDict, AnyDict]] = None,\n    contact: Optional[Union[Contact, ContactDict, AnyDict]] = None,\n    identifier: Optional[str] = None,\n    tags: Optional[Sequence[Union[Tag, TagDict, AnyDict]]] = None,\n    external_docs: Optional[Union[ExternalDocs, ExternalDocsDict, AnyDict]] = None,\n):\n\"\"\"Initialize an instance of the class.\n\n    Args:\n        broker: An optional instance of the BrokerAsyncUsecase class.\n        logger: An optional instance of the logging.Logger class.\n        title: A string representing the title of the AsyncAPI.\n        version: A string representing the version of the AsyncAPI.\n        description: A string representing the description of the AsyncAPI.\n        terms_of_service: An optional URL representing the terms of service of the AsyncAPI.\n        license: An optional instance of the License class.\n        contact: An optional instance of the Contact class.\n        identifier: An optional string representing the identifier of the AsyncAPI.\n        tags: An optional sequence of Tag instances.\n        external_docs: An optional instance of the ExternalDocs class.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    self.broker = broker\n    self.logger = logger\n    self.context = context\n    context.set_global(\"app\", self)\n\n    self._on_startup_calling = []\n    self._after_startup_calling = []\n    self._on_shutdown_calling = []\n    self._after_shutdown_calling = []\n\n    # AsyncAPI information\n    self.title = title\n    self.version = version\n    self.description = description\n    self.terms_of_service = terms_of_service\n    self.license = license\n    self.contact = contact\n    self.identifier = identifier\n    self.asyncapi_tags = tags\n    self.external_docs = external_docs\n</code></pre>"},{"location":"api/faststream/app/ABCApp/#faststream.app.ABCApp.after_shutdown","title":"after_shutdown","text":"<pre><code>after_shutdown(\n    func: Callable[P_HookParams, T_HookReturn]\n) -&gt; Callable[P_HookParams, T_HookReturn]\n</code></pre> <p>Add hook running AFTER broker disconnected</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/app.py</code> <pre><code>def after_shutdown(\n    self,\n    func: Callable[P_HookParams, T_HookReturn],\n) -&gt; Callable[P_HookParams, T_HookReturn]:\n\"\"\"Add hook running AFTER broker disconnected\"\"\"\n    self._after_shutdown_calling.append(apply_types(func))\n    return func\n</code></pre>"},{"location":"api/faststream/app/ABCApp/#faststream.app.ABCApp.after_startup","title":"after_startup","text":"<pre><code>after_startup(\n    func: Callable[P_HookParams, T_HookReturn]\n) -&gt; Callable[P_HookParams, T_HookReturn]\n</code></pre> <p>Add hook running AFTER broker connected</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/app.py</code> <pre><code>def after_startup(\n    self,\n    func: Callable[P_HookParams, T_HookReturn],\n) -&gt; Callable[P_HookParams, T_HookReturn]:\n\"\"\"Add hook running AFTER broker connected\"\"\"\n    self._after_startup_calling.append(apply_types(func))\n    return func\n</code></pre>"},{"location":"api/faststream/app/ABCApp/#faststream.app.ABCApp.on_shutdown","title":"on_shutdown","text":"<pre><code>on_shutdown(\n    func: Callable[P_HookParams, T_HookReturn]\n) -&gt; Callable[P_HookParams, T_HookReturn]\n</code></pre> <p>Add hook running BEFORE broker disconnected</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/app.py</code> <pre><code>def on_shutdown(\n    self,\n    func: Callable[P_HookParams, T_HookReturn],\n) -&gt; Callable[P_HookParams, T_HookReturn]:\n\"\"\"Add hook running BEFORE broker disconnected\"\"\"\n    self._on_shutdown_calling.append(apply_types(func))\n    return func\n</code></pre>"},{"location":"api/faststream/app/ABCApp/#faststream.app.ABCApp.on_startup","title":"on_startup","text":"<pre><code>on_startup(\n    func: Callable[P_HookParams, T_HookReturn]\n) -&gt; Callable[P_HookParams, T_HookReturn]\n</code></pre> <p>Add hook running BEFORE broker connected This hook also takes an extra CLI options as a kwargs</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/app.py</code> <pre><code>def on_startup(\n    self,\n    func: Callable[P_HookParams, T_HookReturn],\n) -&gt; Callable[P_HookParams, T_HookReturn]:\n\"\"\"Add hook running BEFORE broker connected\n    This hook also takes an extra CLI options as a kwargs\"\"\"\n    self._on_startup_calling.append(apply_types(func))\n    return func\n</code></pre>"},{"location":"api/faststream/app/ABCApp/#faststream.app.ABCApp.set_broker","title":"set_broker","text":"<pre><code>set_broker(broker: BrokerAsyncUsecase[Any, Any]) -&gt; None\n</code></pre> <p>Set already existed App object broker Usefull then you create/init broker in <code>on_startup</code> hook</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/app.py</code> <pre><code>def set_broker(self, broker: BrokerAsyncUsecase[Any, Any]) -&gt; None:\n\"\"\"Set already existed App object broker\n    Usefull then you create/init broker in `on_startup` hook\"\"\"\n    self.broker = broker\n</code></pre>"},{"location":"api/faststream/app/FastStream/","title":"FastStream","text":""},{"location":"api/faststream/app/FastStream/#faststream.app.FastStream","title":"faststream.app.FastStream","text":"<p>             Bases: <code>ABCApp</code></p> <p>A class representing a FastStream application.</p> <p>Attributes:</p> Name Type Description <code>_on_startup_calling</code> <p>list of async functions to be called on startup</p> <code>_after_startup_calling</code> <p>list of async functions to be called after startup</p> <code>_on_shutdown_calling</code> <p>list of async functions to be called on shutdown</p> <code>_after_shutdown_calling</code> <p>list of async functions to be called after shutdown</p> <code>_stop_event</code> <p>event to stop the application</p> <p>Methods:</p> Name Description <code>__init__ </code> <p>initializes the FastStream application</p> <code>on_startup </code> <p>adds a hook to run before the broker is connected</p> <code>on_shutdown </code> <p>adds a hook to run before the broker is disconnected</p> <code>after_startup </code> <p>adds a hook to run after the broker is connected</p> <code>after_shutdown </code> <p>adds a hook to run after the broker is disconnected</p> <code>run </code> <p>runs the FastStream application</p> <code>_init_async_cycle </code> <p>initializes the async cycle</p> <code>_start </code> <p>starts the FastStream application</p> <code>_stop </code> <p>stops the FastStream application</p> <code>_startup </code> <p>runs the startup hooks</p> <code>_shutdown </code> <p>runs the shutdown hooks</p> <code>__exit </code> <p>exits the FastStream application</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/app.py</code> <pre><code>class FastStream(ABCApp):\n\"\"\"A class representing a FastStream application.\n\n    Attributes:\n        _on_startup_calling : list of async functions to be called on startup\n        _after_startup_calling : list of async functions to be called after startup\n        _on_shutdown_calling : list of async functions to be called on shutdown\n        _after_shutdown_calling : list of async functions to be called after shutdown\n        _stop_event : event to stop the application\n\n    Methods:\n        __init__ : initializes the FastStream application\n        on_startup : adds a hook to run before the broker is connected\n        on_shutdown : adds a hook to run before the broker is disconnected\n        after_startup : adds a hook to run after the broker is connected\n        after_shutdown : adds a hook to run after the broker is disconnected\n        run : runs the FastStream application\n        _init_async_cycle : initializes the async cycle\n        _start : starts the FastStream application\n        _stop : stops the FastStream application\n        _startup : runs the startup hooks\n        _shutdown : runs the shutdown hooks\n        __exit : exits the FastStream application\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    _on_startup_calling: List[AsyncFunc]\n    _after_startup_calling: List[AsyncFunc]\n    _on_shutdown_calling: List[AsyncFunc]\n    _after_shutdown_calling: List[AsyncFunc]\n\n    _stop_event: Optional[anyio.Event]\n\n    def __init__(\n        self,\n        broker: Optional[BrokerAsyncUsecase[Any, Any]] = None,\n        logger: Optional[logging.Logger] = logger,\n        # AsyncAPI args,\n        title: str = \"FastStream\",\n        version: str = \"0.1.0\",\n        description: str = \"\",\n        terms_of_service: Optional[AnyHttpUrl] = None,\n        license: Optional[Union[License, LicenseDict, AnyDict]] = None,\n        contact: Optional[Union[Contact, ContactDict, AnyDict]] = None,\n        identifier: Optional[str] = None,\n        tags: Optional[Sequence[Union[Tag, TagDict, AnyDict]]] = None,\n        external_docs: Optional[Union[ExternalDocs, ExternalDocsDict, AnyDict]] = None,\n    ):\n\"\"\"Asyncronous FastStream Application class\n\n        stores and run broker, control hooks\n\n        Args:\n            broker: async broker to run (may be `None`, then specify by `set_broker`)\n            logger: logger object to log startup/shutdown messages (`None` to disable)\n            title: application title - for AsyncAPI docs\n            version: application version - for AsyncAPI docs\n            description: application description - for AsyncAPI docs\n        \"\"\"\n        super().__init__(\n            broker=broker,\n            logger=logger,\n            title=title,\n            version=version,\n            description=description,\n            terms_of_service=terms_of_service,\n            license=license,\n            contact=contact,\n            identifier=identifier,\n            tags=tags,\n            external_docs=external_docs,\n        )\n\n        self._stop_event = None\n\n        set_exit(lambda *_: self.__exit())\n\n    def on_startup(\n        self,\n        func: Callable[P_HookParams, T_HookReturn],\n    ) -&gt; Callable[P_HookParams, T_HookReturn]:\n\"\"\"Add hook running BEFORE broker connected\n\n        This hook also takes an extra CLI options as a kwargs\n\n        Args:\n            func: async or sync func to call as a hook\n\n        Returns:\n            Async version of the func argument\n        \"\"\"\n        super().on_startup(to_async(func))\n        return func\n\n    def on_shutdown(\n        self,\n        func: Callable[P_HookParams, T_HookReturn],\n    ) -&gt; Callable[P_HookParams, T_HookReturn]:\n\"\"\"Add hook running BEFORE broker disconnected\n\n        Args:\n            func: async or sync func to call as a hook\n\n        Returns:\n            Async version of the func argument\n        \"\"\"\n        super().on_shutdown(to_async(func))\n        return func\n\n    def after_startup(\n        self,\n        func: Callable[P_HookParams, T_HookReturn],\n    ) -&gt; Callable[P_HookParams, T_HookReturn]:\n\"\"\"Add hook running AFTER broker connected\n\n        Args:\n            func: async or sync func to call as a hook\n\n        Returns:\n            Async version of the func argument\n        \"\"\"\n        super().after_startup(to_async(func))\n        return func\n\n    def after_shutdown(\n        self,\n        func: Callable[P_HookParams, T_HookReturn],\n    ) -&gt; Callable[P_HookParams, T_HookReturn]:\n\"\"\"Add hook running AFTER broker disconnected\n\n        Args:\n            func: async or sync func to call as a hook\n\n        Returns:\n            Async version of the func argument\n        \"\"\"\n        super().after_shutdown(to_async(func))\n        return func\n\n    async def run(\n        self,\n        log_level: int = logging.INFO,\n        run_extra_options: Optional[Dict[str, SettingField]] = None,\n    ) -&gt; None:\n\"\"\"Run FastStream Application\n\n        Args:\n            log_level: force application log level\n\n        Returns:\n            Block an event loop until stopped\n        \"\"\"\n        assert self.broker, \"You should setup a broker\"  # nosec B101\n\n        self._init_async_cycle()\n        async with anyio.create_task_group() as tg:\n            tg.start_soon(self._start, log_level, run_extra_options)\n            await self._stop(log_level)\n            tg.cancel_scope.cancel()\n\n    def _init_async_cycle(self) -&gt; None:\n        if self._stop_event is None:\n            self._stop_event = anyio.Event()\n\n    async def _start(\n        self,\n        log_level: int = logging.INFO,\n        run_extra_options: Optional[Dict[str, SettingField]] = None,\n    ) -&gt; None:\n\"\"\"Start the FastStream app.\n\n        Args:\n            log_level (int): log level (default: logging.INFO)\n            run_extra_options (Optional[Dict[str, SettingField]]): extra options for running the app (default: None)\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        self._log(log_level, \"FastStream app starting...\")\n        await self._startup(**(run_extra_options or {}))\n        self._log(\n            log_level, \"FastStream app started successfully! To exit press CTRL+C\"\n        )\n\n    async def _stop(self, log_level: int = logging.INFO) -&gt; None:\n\"\"\"Stop the application gracefully.\n\n        Args:\n            log_level (int): log level for logging messages (default: logging.INFO)\n\n        Raises:\n            AssertionError: If `_init_async_cycle` has not been called before calling `_stop`\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        assert (  # nosec B101\n            self._stop_event\n        ), \"You should call `_init_async_cycle` first\"\n        await self._stop_event.wait()\n        self._stop_event = None\n\n        self._log(log_level, \"FastStream app shutting down...\")\n        await self._shutdown()\n        self._log(log_level, \"FastStream app shut down gracefully.\")\n\n    async def _startup(self, **run_extra_options: SettingField) -&gt; None:\n\"\"\"Executes startup tasks.\n\n        Args:\n            run_extra_options: Additional options to be passed to the startup tasks.\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        for func in self._on_startup_calling:\n            await func(**run_extra_options)\n\n        if self.broker is not None:\n            await self.broker.start()\n\n        for func in self._after_startup_calling:\n            await func()\n\n    async def _shutdown(self) -&gt; None:\n        for func in self._on_shutdown_calling:\n            await func()\n\n        if self.broker is not None:\n            await self.broker.close()\n\n        for func in self._after_shutdown_calling:\n            await func()\n\n    def __exit(self) -&gt; None:\n        if self._stop_event is not None:  # pragma: no branch\n            self._stop_event.set()\n</code></pre>"},{"location":"api/faststream/app/FastStream/#faststream.app.FastStream-functions","title":"Functions","text":""},{"location":"api/faststream/app/FastStream/#faststream.app.FastStream.__exit","title":"__exit","text":"<pre><code>__exit() -&gt; None\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/app.py</code> <pre><code>def __exit(self) -&gt; None:\n    if self._stop_event is not None:  # pragma: no branch\n        self._stop_event.set()\n</code></pre>"},{"location":"api/faststream/app/FastStream/#faststream.app.FastStream.__init__","title":"__init__","text":"<pre><code>__init__(\n    broker: Optional[BrokerAsyncUsecase[Any, Any]] = None,\n    logger: Optional[logging.Logger] = logger,\n    title: str = \"FastStream\",\n    version: str = \"0.1.0\",\n    description: str = \"\",\n    terms_of_service: Optional[AnyHttpUrl] = None,\n    license: Optional[\n        Union[License, LicenseDict, AnyDict]\n    ] = None,\n    contact: Optional[\n        Union[Contact, ContactDict, AnyDict]\n    ] = None,\n    identifier: Optional[str] = None,\n    tags: Optional[\n        Sequence[Union[Tag, TagDict, AnyDict]]\n    ] = None,\n    external_docs: Optional[\n        Union[ExternalDocs, ExternalDocsDict, AnyDict]\n    ] = None,\n)\n</code></pre> <p>Asyncronous FastStream Application class</p> <p>stores and run broker, control hooks</p> <p>Parameters:</p> Name Type Description Default <code>broker</code> <code>Optional[BrokerAsyncUsecase[Any, Any]]</code> <p>async broker to run (may be <code>None</code>, then specify by <code>set_broker</code>)</p> <code>None</code> <code>logger</code> <code>Optional[Logger]</code> <p>logger object to log startup/shutdown messages (<code>None</code> to disable)</p> <code>logger</code> <code>title</code> <code>str</code> <p>application title - for AsyncAPI docs</p> <code>'FastStream'</code> <code>version</code> <code>str</code> <p>application version - for AsyncAPI docs</p> <code>'0.1.0'</code> <code>description</code> <code>str</code> <p>application description - for AsyncAPI docs</p> <code>''</code> Source code in <code>/home/runner/work/faststream/faststream/faststream/app.py</code> <pre><code>def __init__(\n    self,\n    broker: Optional[BrokerAsyncUsecase[Any, Any]] = None,\n    logger: Optional[logging.Logger] = logger,\n    # AsyncAPI args,\n    title: str = \"FastStream\",\n    version: str = \"0.1.0\",\n    description: str = \"\",\n    terms_of_service: Optional[AnyHttpUrl] = None,\n    license: Optional[Union[License, LicenseDict, AnyDict]] = None,\n    contact: Optional[Union[Contact, ContactDict, AnyDict]] = None,\n    identifier: Optional[str] = None,\n    tags: Optional[Sequence[Union[Tag, TagDict, AnyDict]]] = None,\n    external_docs: Optional[Union[ExternalDocs, ExternalDocsDict, AnyDict]] = None,\n):\n\"\"\"Asyncronous FastStream Application class\n\n    stores and run broker, control hooks\n\n    Args:\n        broker: async broker to run (may be `None`, then specify by `set_broker`)\n        logger: logger object to log startup/shutdown messages (`None` to disable)\n        title: application title - for AsyncAPI docs\n        version: application version - for AsyncAPI docs\n        description: application description - for AsyncAPI docs\n    \"\"\"\n    super().__init__(\n        broker=broker,\n        logger=logger,\n        title=title,\n        version=version,\n        description=description,\n        terms_of_service=terms_of_service,\n        license=license,\n        contact=contact,\n        identifier=identifier,\n        tags=tags,\n        external_docs=external_docs,\n    )\n\n    self._stop_event = None\n\n    set_exit(lambda *_: self.__exit())\n</code></pre>"},{"location":"api/faststream/app/FastStream/#faststream.app.FastStream.after_shutdown","title":"after_shutdown","text":"<pre><code>after_shutdown(\n    func: Callable[P_HookParams, T_HookReturn]\n) -&gt; Callable[P_HookParams, T_HookReturn]\n</code></pre> <p>Add hook running AFTER broker disconnected</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[P_HookParams, T_HookReturn]</code> <p>async or sync func to call as a hook</p> required <p>Returns:</p> Type Description <code>Callable[P_HookParams, T_HookReturn]</code> <p>Async version of the func argument</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/app.py</code> <pre><code>def after_shutdown(\n    self,\n    func: Callable[P_HookParams, T_HookReturn],\n) -&gt; Callable[P_HookParams, T_HookReturn]:\n\"\"\"Add hook running AFTER broker disconnected\n\n    Args:\n        func: async or sync func to call as a hook\n\n    Returns:\n        Async version of the func argument\n    \"\"\"\n    super().after_shutdown(to_async(func))\n    return func\n</code></pre>"},{"location":"api/faststream/app/FastStream/#faststream.app.FastStream.after_startup","title":"after_startup","text":"<pre><code>after_startup(\n    func: Callable[P_HookParams, T_HookReturn]\n) -&gt; Callable[P_HookParams, T_HookReturn]\n</code></pre> <p>Add hook running AFTER broker connected</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[P_HookParams, T_HookReturn]</code> <p>async or sync func to call as a hook</p> required <p>Returns:</p> Type Description <code>Callable[P_HookParams, T_HookReturn]</code> <p>Async version of the func argument</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/app.py</code> <pre><code>def after_startup(\n    self,\n    func: Callable[P_HookParams, T_HookReturn],\n) -&gt; Callable[P_HookParams, T_HookReturn]:\n\"\"\"Add hook running AFTER broker connected\n\n    Args:\n        func: async or sync func to call as a hook\n\n    Returns:\n        Async version of the func argument\n    \"\"\"\n    super().after_startup(to_async(func))\n    return func\n</code></pre>"},{"location":"api/faststream/app/FastStream/#faststream.app.FastStream.on_shutdown","title":"on_shutdown","text":"<pre><code>on_shutdown(\n    func: Callable[P_HookParams, T_HookReturn]\n) -&gt; Callable[P_HookParams, T_HookReturn]\n</code></pre> <p>Add hook running BEFORE broker disconnected</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[P_HookParams, T_HookReturn]</code> <p>async or sync func to call as a hook</p> required <p>Returns:</p> Type Description <code>Callable[P_HookParams, T_HookReturn]</code> <p>Async version of the func argument</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/app.py</code> <pre><code>def on_shutdown(\n    self,\n    func: Callable[P_HookParams, T_HookReturn],\n) -&gt; Callable[P_HookParams, T_HookReturn]:\n\"\"\"Add hook running BEFORE broker disconnected\n\n    Args:\n        func: async or sync func to call as a hook\n\n    Returns:\n        Async version of the func argument\n    \"\"\"\n    super().on_shutdown(to_async(func))\n    return func\n</code></pre>"},{"location":"api/faststream/app/FastStream/#faststream.app.FastStream.on_startup","title":"on_startup","text":"<pre><code>on_startup(\n    func: Callable[P_HookParams, T_HookReturn]\n) -&gt; Callable[P_HookParams, T_HookReturn]\n</code></pre> <p>Add hook running BEFORE broker connected</p> <p>This hook also takes an extra CLI options as a kwargs</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[P_HookParams, T_HookReturn]</code> <p>async or sync func to call as a hook</p> required <p>Returns:</p> Type Description <code>Callable[P_HookParams, T_HookReturn]</code> <p>Async version of the func argument</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/app.py</code> <pre><code>def on_startup(\n    self,\n    func: Callable[P_HookParams, T_HookReturn],\n) -&gt; Callable[P_HookParams, T_HookReturn]:\n\"\"\"Add hook running BEFORE broker connected\n\n    This hook also takes an extra CLI options as a kwargs\n\n    Args:\n        func: async or sync func to call as a hook\n\n    Returns:\n        Async version of the func argument\n    \"\"\"\n    super().on_startup(to_async(func))\n    return func\n</code></pre>"},{"location":"api/faststream/app/FastStream/#faststream.app.FastStream.run","title":"run  <code>async</code>","text":"<pre><code>run(\n    log_level: int = logging.INFO,\n    run_extra_options: Optional[\n        Dict[str, SettingField]\n    ] = None,\n) -&gt; None\n</code></pre> <p>Run FastStream Application</p> <p>Parameters:</p> Name Type Description Default <code>log_level</code> <code>int</code> <p>force application log level</p> <code>INFO</code> <p>Returns:</p> Type Description <code>None</code> <p>Block an event loop until stopped</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/app.py</code> <pre><code>async def run(\n    self,\n    log_level: int = logging.INFO,\n    run_extra_options: Optional[Dict[str, SettingField]] = None,\n) -&gt; None:\n\"\"\"Run FastStream Application\n\n    Args:\n        log_level: force application log level\n\n    Returns:\n        Block an event loop until stopped\n    \"\"\"\n    assert self.broker, \"You should setup a broker\"  # nosec B101\n\n    self._init_async_cycle()\n    async with anyio.create_task_group() as tg:\n        tg.start_soon(self._start, log_level, run_extra_options)\n        await self._stop(log_level)\n        tg.cancel_scope.cancel()\n</code></pre>"},{"location":"api/faststream/asyncapi/base/AsyncAPIOperation/","title":"AsyncAPIOperation","text":""},{"location":"api/faststream/asyncapi/base/AsyncAPIOperation/#faststream.asyncapi.base.AsyncAPIOperation","title":"faststream.asyncapi.base.AsyncAPIOperation","text":"<p>A class representing an asynchronous API operation.</p> <p>Attributes:</p> Name Type Description <code>name</code> <p>name of the API operation</p> <p>Methods:</p> Name Description <code>schema</code> <p>returns the schema of the API operation as a dictionary of channel names and channel objects</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/base.py</code> <pre><code>class AsyncAPIOperation:\n\"\"\"A class representing an asynchronous API operation.\n\n    Attributes:\n        name : name of the API operation\n\n    Methods:\n        schema() : returns the schema of the API operation as a dictionary of channel names and channel objects\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    @abstractproperty\n    def name(self) -&gt; str:\n        raise NotImplementedError()\n\n    def schema(self) -&gt; Dict[str, Channel]:  # pragma: no cover\n        return {}\n</code></pre>"},{"location":"api/faststream/asyncapi/base/AsyncAPIOperation/#faststream.asyncapi.base.AsyncAPIOperation-functions","title":"Functions","text":""},{"location":"api/faststream/asyncapi/base/AsyncAPIOperation/#faststream.asyncapi.base.AsyncAPIOperation.name","title":"name","text":"<pre><code>name() -&gt; str\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/base.py</code> <pre><code>@abstractproperty\ndef name(self) -&gt; str:\n    raise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/asyncapi/base/AsyncAPIOperation/#faststream.asyncapi.base.AsyncAPIOperation.schema","title":"schema","text":"<pre><code>schema() -&gt; Dict[str, Channel]\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/base.py</code> <pre><code>def schema(self) -&gt; Dict[str, Channel]:  # pragma: no cover\n    return {}\n</code></pre>"},{"location":"api/faststream/asyncapi/generate/get_app_broker_channels/","title":"get_app_broker_channels","text":""},{"location":"api/faststream/asyncapi/generate/get_app_broker_channels/#faststream.asyncapi.generate.get_app_broker_channels","title":"faststream.asyncapi.generate.get_app_broker_channels","text":"<pre><code>get_app_broker_channels(\n    app: Union[FastStream, StreamRouter[Any]]\n) -&gt; Dict[str, Channel]\n</code></pre> <p>Get the broker channels for an application.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>Union[FastStream, StreamRouter[Any]]</code> <p>An instance of FastStream or StreamRouter.</p> required <p>Returns:</p> Type Description <code>Dict[str, Channel]</code> <p>A dictionary of channel names and their corresponding Channel objects.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If the app does not have a broker.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/generate.py</code> <pre><code>def get_app_broker_channels(\n    app: Union[FastStream, \"StreamRouter[Any]\"]\n) -&gt; Dict[str, Channel]:\n\"\"\"Get the broker channels for an application.\n\n    Args:\n        app: An instance of FastStream or StreamRouter.\n\n    Returns:\n        A dictionary of channel names and their corresponding Channel objects.\n\n    Raises:\n        AssertionError: If the app does not have a broker.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    channels = {}\n    assert app.broker  # nosec B101\n\n    for h in app.broker.handlers.values():\n        channels.update(h.schema())\n\n    for p in app.broker._publishers.values():\n        channels.update(p.schema())\n\n    return channels\n</code></pre>"},{"location":"api/faststream/asyncapi/generate/get_app_broker_server/","title":"get_app_broker_server","text":""},{"location":"api/faststream/asyncapi/generate/get_app_broker_server/#faststream.asyncapi.generate.get_app_broker_server","title":"faststream.asyncapi.generate.get_app_broker_server","text":"<pre><code>get_app_broker_server(\n    app: Union[FastStream, StreamRouter[Any]]\n) -&gt; Dict[str, Server]\n</code></pre> <p>Get the broker server for an application.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>Union[FastStream, StreamRouter[Any]]</code> <p>An instance of <code>FastStream</code> or <code>StreamRouter</code> representing the application.</p> required <p>Returns:</p> Type Description <code>Dict[str, Server]</code> <p>A dictionary containing the broker servers. The keys are the server names and the values are instances of <code>Server</code> class.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If the <code>broker</code> attribute of the app is not present.</p> Note <p>This function is currently incomplete and the following fields in the <code>broker_meta</code> dictionary are not populated: \"security\", \"variables\", \"bindings\".</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/generate.py</code> <pre><code>def get_app_broker_server(\n    app: Union[FastStream, \"StreamRouter[Any]\"]\n) -&gt; Dict[str, Server]:\n\"\"\"Get the broker server for an application.\n\n    Args:\n        app: An instance of `FastStream` or `StreamRouter` representing the application.\n\n    Returns:\n        A dictionary containing the broker servers. The keys are the server names and the values are instances of `Server` class.\n\n    Raises:\n        AssertionError: If the `broker` attribute of the app is not present.\n\n    Note:\n        This function is currently incomplete and the following fields in the `broker_meta` dictionary are not populated: \"security\", \"variables\", \"bindings\".\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    servers = {}\n\n    broker = app.broker\n    assert broker  # nosec B101\n\n    broker_meta: Dict[str, Any] = {\n        \"protocol\": broker.protocol,\n        \"protocolVersion\": broker.protocol_version,\n        \"description\": broker.description,\n        \"tags\": broker.tags,\n        # TODO\n        # \"variables\": \"\",\n        # \"bindings\": \"\",\n    }\n\n    if broker.security is not None:\n        broker_meta[\"security\"] = broker.security.get_requirement()\n\n    if isinstance(broker.url, str):\n        servers[\"development\"] = Server(\n            url=broker.url,\n            **broker_meta,\n        )\n\n    else:\n        for i, url in enumerate(broker.url, 1):\n            servers[f\"Server{i}\"] = Server(\n                url=url,\n                **broker_meta,\n            )\n\n    return servers\n</code></pre>"},{"location":"api/faststream/asyncapi/generate/get_app_schema/","title":"get_app_schema","text":""},{"location":"api/faststream/asyncapi/generate/get_app_schema/#faststream.asyncapi.generate.get_app_schema","title":"faststream.asyncapi.generate.get_app_schema","text":"<pre><code>get_app_schema(\n    app: Union[FastStream, StreamRouter[Any]]\n) -&gt; Schema\n</code></pre> <p>Get the application schema.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>Union[FastStream, StreamRouter[Any]]</code> <p>An instance of FastStream or StreamRouter.</p> required <p>Returns:</p> Type Description <code>Schema</code> <p>The schema object.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/generate.py</code> <pre><code>def get_app_schema(app: Union[FastStream, \"StreamRouter[Any]\"]) -&gt; Schema:\n\"\"\"Get the application schema.\n\n    Args:\n        app: An instance of FastStream or StreamRouter.\n\n    Returns:\n        The schema object.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    servers = get_app_broker_server(app)\n    channels = get_app_broker_channels(app)\n\n    messages: Dict[str, Message] = {}\n    payloads: Dict[str, Dict[str, Any]] = {}\n    for channel_name, ch in channels.items():\n        ch.servers = list(servers.keys())\n\n        if ch.subscribe is not None:\n            m = ch.subscribe.message\n\n            if isinstance(m, Message):\n                p = m.payload\n                p_title = p.get(\"title\", f\"{channel_name}Payload\")\n                payloads[p_title] = p\n                m.payload = {\"$ref\": f\"#/components/schemas/{p_title}\"}\n\n                assert m.title  # nosec B101\n                messages[m.title] = m\n                ch.subscribe.message = Reference(\n                    **{\"$ref\": f\"#/components/messages/{m.title}\"}\n                )\n\n        if ch.publish is not None:\n            m = ch.publish.message\n\n            if isinstance(m, Message):\n                p = m.payload\n                p_title = p.get(\"title\", f\"{channel_name}Payload\")\n                payloads[p_title] = p\n                m.payload = {\"$ref\": f\"#/components/schemas/{p_title}\"}\n\n                assert m.title  # nosec B101\n                messages[m.title] = m\n                ch.publish.message = Reference(\n                    **{\"$ref\": f\"#/components/messages/{m.title}\"}\n                )\n\n    broker = app.broker\n    if broker is None:\n        raise RuntimeError()\n\n    schema = Schema(\n        info=Info(\n            title=app.title,\n            version=app.version,\n            description=app.description,\n            termsOfService=app.terms_of_service,\n            contact=app.contact,\n            license=app.license,\n        ),\n        defaultContentType=ContentTypes.json.value,\n        id=app.identifier,\n        tags=list(app.asyncapi_tags) if app.asyncapi_tags else None,\n        externalDocs=app.external_docs,\n        servers=servers,\n        channels=channels,\n        components=Components(\n            messages=messages,\n            schemas=payloads,\n            securitySchemes=None\n            if broker.security is None\n            else broker.security.get_schema(),\n        ),\n    )\n    return schema\n</code></pre>"},{"location":"api/faststream/asyncapi/message/get_model_schema/","title":"get_model_schema","text":""},{"location":"api/faststream/asyncapi/message/get_model_schema/#faststream.asyncapi.message.get_model_schema","title":"faststream.asyncapi.message.get_model_schema","text":"<pre><code>get_model_schema(\n    call: Optional[Type[BaseModel]],\n    prefix: str = \"\",\n    exclude: Sequence[str] = (),\n) -&gt; Optional[Dict[str, Any]]\n</code></pre> <p>Get the schema of a model.</p> <p>Parameters:</p> Name Type Description Default <code>call</code> <code>Optional[Type[BaseModel]]</code> <p>The model class to get the schema for.</p> required <code>prefix</code> <code>str</code> <p>A prefix to add to the schema title.</p> <code>''</code> <code>exclude</code> <code>Sequence[str]</code> <p>A sequence of field names to exclude from the schema.</p> <code>()</code> <p>Returns:</p> Type Description <code>Optional[Dict[str, Any]]</code> <p>The schema of the model as a dictionary, or None if the model has no fields.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the model is a silent animal.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/message.py</code> <pre><code>def get_model_schema(\n    call: Optional[Type[BaseModel]],\n    prefix: str = \"\",\n    exclude: Sequence[str] = (),\n) -&gt; Optional[Dict[str, Any]]:\n\"\"\"Get the schema of a model.\n\n    Args:\n        call: The model class to get the schema for.\n        prefix: A prefix to add to the schema title.\n        exclude: A sequence of field names to exclude from the schema.\n\n    Returns:\n        The schema of the model as a dictionary, or None if the model has no fields.\n\n    Raises:\n        NotImplementedError: If the model is a silent animal.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    if call is None:\n        return None\n\n    params = {k: v for k, v in get_model_fields(call).items() if k not in exclude}\n    params_number = len(params)\n\n    if params_number == 0:\n        return None\n\n    model = None\n    use_original_model = False\n    if params_number == 1:\n        name, param = tuple(params.items())[0]\n\n        if (\n            param.annotation\n            and isclass(param.annotation)\n            and issubclass(param.annotation, BaseModel)  # NOTE: 3.7-3.10 compatibility\n        ):\n            model = param.annotation\n            use_original_model = True\n\n    if model is None:\n        model = call\n\n    body = model_schema(model)\n\n    if params_number == 1 and not use_original_model:\n        param_body = body.get(\"properties\", {})\n        param_body = param_body[name]\n\n        if PYDANTIC_V2:\n            original_title = param.title\n        else:\n            original_title = param.field_info.title  # type: ignore[attr-defined]\n\n        if original_title:\n            use_original_model = True\n            param_body[\"title\"] = original_title\n        else:\n            param_body[\"title\"] = name\n\n        body = param_body\n\n    camel_body = to_camelcase(body[\"title\"])\n    if not use_original_model:\n        if prefix.lower() != camel_body.lower():\n            body[\"title\"] = f\"{prefix}{camel_body}Payload\"\n        else:\n            body[\"title\"] = f\"{camel_body}Payload\"\n\n    return body\n</code></pre>"},{"location":"api/faststream/asyncapi/message/get_response_schema/","title":"get_response_schema","text":""},{"location":"api/faststream/asyncapi/message/get_response_schema/#faststream.asyncapi.message.get_response_schema","title":"faststream.asyncapi.message.get_response_schema","text":"<pre><code>get_response_schema(\n    call: Optional[CallModel[Any, Any]], prefix: str = \"\"\n) -&gt; Optional[Dict[str, Any]]\n</code></pre> <p>Get the response schema for a given call.</p> <p>Parameters:</p> Name Type Description Default <code>call</code> <code>Optional[CallModel[Any, Any]]</code> <p>The call model.</p> required <code>prefix</code> <code>str</code> <p>A prefix to add to the schema keys.</p> <code>''</code> <p>Returns:</p> Type Description <code>Optional[Dict[str, Any]]</code> <p>The response schema as a dictionary.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/message.py</code> <pre><code>def get_response_schema(\n    call: Optional[CallModel[Any, Any]],\n    prefix: str = \"\",\n) -&gt; Optional[Dict[str, Any]]:\n\"\"\"Get the response schema for a given call.\n\n    Args:\n        call: The call model.\n        prefix: A prefix to add to the schema keys.\n\n    Returns:\n        The response schema as a dictionary.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    return get_model_schema(\n        getattr(\n            call, \"response_model\", None\n        ),  # NOTE: FastAPI Dependant object compatibility\n        prefix=prefix,\n    )\n</code></pre>"},{"location":"api/faststream/asyncapi/message/parse_handler_params/","title":"parse_handler_params","text":""},{"location":"api/faststream/asyncapi/message/parse_handler_params/#faststream.asyncapi.message.parse_handler_params","title":"faststream.asyncapi.message.parse_handler_params","text":"<pre><code>parse_handler_params(\n    call: CallModel[Any, Any], prefix: str = \"\"\n) -&gt; Dict[str, Any]\n</code></pre> <p>Parses the handler parameters.</p> <p>Parameters:</p> Name Type Description Default <code>call</code> <code>CallModel[Any, Any]</code> <p>The call model.</p> required <code>prefix</code> <code>str</code> <p>The prefix for the model schema.</p> <code>''</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>A dictionary containing the parsed parameters.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/message.py</code> <pre><code>def parse_handler_params(call: CallModel[Any, Any], prefix: str = \"\") -&gt; Dict[str, Any]:\n\"\"\"Parses the handler parameters.\n\n    Args:\n        call: The call model.\n        prefix: The prefix for the model schema.\n\n    Returns:\n        A dictionary containing the parsed parameters.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    body = get_model_schema(\n        call.model, prefix=prefix, exclude=tuple(call.custom_fields.keys())\n    )\n    if body is None:\n        return {\"title\": \"EmptyPayload\", \"type\": \"null\"}\n\n    return body\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/amqp/ChannelBinding/","title":"ChannelBinding","text":""},{"location":"api/faststream/asyncapi/schema/bindings/amqp/ChannelBinding/#faststream.asyncapi.schema.bindings.amqp.ChannelBinding","title":"faststream.asyncapi.schema.bindings.amqp.ChannelBinding","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent channel binding.</p> <p>Attributes:</p> Name Type Description <code>is_</code> <p>Type of binding, can be \"queue\" or \"routingKey\"</p> <code>bindingVersion</code> <p>Version of the binding</p> <code>queue</code> <p>Optional queue object</p> <code>exchange</code> <p>Optional exchange object</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/bindings/amqp.py</code> <pre><code>class ChannelBinding(BaseModel):\n\"\"\"A class to represent channel binding.\n\n    Attributes:\n        is_ : Type of binding, can be \"queue\" or \"routingKey\"\n        bindingVersion : Version of the binding\n        queue : Optional queue object\n        exchange : Optional exchange object\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    is_: Literal[\"queue\", \"routingKey\"] = Field(..., alias=\"is\")\n    bindingVersion: str = \"0.2.0\"\n    queue: Optional[Queue] = None\n    exchange: Optional[Exchange] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/amqp/ChannelBinding/#faststream.asyncapi.schema.bindings.amqp.ChannelBinding-attributes","title":"Attributes","text":""},{"location":"api/faststream/asyncapi/schema/bindings/amqp/ChannelBinding/#faststream.asyncapi.schema.bindings.amqp.ChannelBinding.bindingVersion","title":"bindingVersion  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bindingVersion: str = '0.2.0'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/amqp/ChannelBinding/#faststream.asyncapi.schema.bindings.amqp.ChannelBinding.exchange","title":"exchange  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>exchange: Optional[Exchange] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/amqp/ChannelBinding/#faststream.asyncapi.schema.bindings.amqp.ChannelBinding.is_","title":"is_  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>is_: Literal[\"queue\", \"routingKey\"] = Field(..., alias=\"is\")\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/amqp/ChannelBinding/#faststream.asyncapi.schema.bindings.amqp.ChannelBinding.queue","title":"queue  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>queue: Optional[Queue] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/amqp/Exchange/","title":"Exchange","text":""},{"location":"api/faststream/asyncapi/schema/bindings/amqp/Exchange/#faststream.asyncapi.schema.bindings.amqp.Exchange","title":"faststream.asyncapi.schema.bindings.amqp.Exchange","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent an exchange.</p> <p>Attributes:</p> Name Type Description <code>name</code> <p>name of the exchange (optional)</p> <code>type</code> <p>type of the exchange, can be one of \"default\", \"direct\", \"topic\", \"fanout\", \"headers\"</p> <code>durable</code> <p>whether the exchange is durable (optional)</p> <code>autoDelete</code> <p>whether the exchange is automatically deleted (optional)</p> <code>vhost</code> <p>virtual host of the exchange, default is \"/\"</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/bindings/amqp.py</code> <pre><code>class Exchange(BaseModel):\n\"\"\"A class to represent an exchange.\n\n    Attributes:\n        name : name of the exchange (optional)\n        type : type of the exchange, can be one of \"default\", \"direct\", \"topic\", \"fanout\", \"headers\"\n        durable : whether the exchange is durable (optional)\n        autoDelete : whether the exchange is automatically deleted (optional)\n        vhost : virtual host of the exchange, default is \"/\"\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    name: Optional[str] = None\n    type: Literal[\"default\", \"direct\", \"topic\", \"fanout\", \"headers\"]\n    durable: Optional[bool] = None\n    autoDelete: Optional[bool] = None\n    vhost: str = \"/\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/amqp/Exchange/#faststream.asyncapi.schema.bindings.amqp.Exchange-attributes","title":"Attributes","text":""},{"location":"api/faststream/asyncapi/schema/bindings/amqp/Exchange/#faststream.asyncapi.schema.bindings.amqp.Exchange.autoDelete","title":"autoDelete  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>autoDelete: Optional[bool] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/amqp/Exchange/#faststream.asyncapi.schema.bindings.amqp.Exchange.durable","title":"durable  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>durable: Optional[bool] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/amqp/Exchange/#faststream.asyncapi.schema.bindings.amqp.Exchange.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/amqp/Exchange/#faststream.asyncapi.schema.bindings.amqp.Exchange.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: Literal[\n    \"default\", \"direct\", \"topic\", \"fanout\", \"headers\"\n]\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/amqp/Exchange/#faststream.asyncapi.schema.bindings.amqp.Exchange.vhost","title":"vhost  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>vhost: str = '/'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/amqp/OperationBinding/","title":"OperationBinding","text":""},{"location":"api/faststream/asyncapi/schema/bindings/amqp/OperationBinding/#faststream.asyncapi.schema.bindings.amqp.OperationBinding","title":"faststream.asyncapi.schema.bindings.amqp.OperationBinding","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent an operation binding.</p> <p>Attributes:</p> Name Type Description <code>cc</code> <p>optional string representing the cc</p> <code>ack</code> <p>boolean indicating if the operation is acknowledged</p> <code>replyTo</code> <p>optional dictionary representing the replyTo</p> <code>bindingVersion</code> <p>string representing the binding version</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/bindings/amqp.py</code> <pre><code>class OperationBinding(BaseModel):\n\"\"\"A class to represent an operation binding.\n\n    Attributes:\n        cc : optional string representing the cc\n        ack : boolean indicating if the operation is acknowledged\n        replyTo : optional dictionary representing the replyTo\n        bindingVersion : string representing the binding version\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    cc: Optional[str] = None\n    ack: bool = True\n    replyTo: Optional[Dict[str, Any]] = None\n    bindingVersion: str = \"0.2.0\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/amqp/OperationBinding/#faststream.asyncapi.schema.bindings.amqp.OperationBinding-attributes","title":"Attributes","text":""},{"location":"api/faststream/asyncapi/schema/bindings/amqp/OperationBinding/#faststream.asyncapi.schema.bindings.amqp.OperationBinding.ack","title":"ack  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ack: bool = True\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/amqp/OperationBinding/#faststream.asyncapi.schema.bindings.amqp.OperationBinding.bindingVersion","title":"bindingVersion  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bindingVersion: str = '0.2.0'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/amqp/OperationBinding/#faststream.asyncapi.schema.bindings.amqp.OperationBinding.cc","title":"cc  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cc: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/amqp/OperationBinding/#faststream.asyncapi.schema.bindings.amqp.OperationBinding.replyTo","title":"replyTo  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>replyTo: Optional[Dict[str, Any]] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/amqp/Queue/","title":"Queue","text":""},{"location":"api/faststream/asyncapi/schema/bindings/amqp/Queue/#faststream.asyncapi.schema.bindings.amqp.Queue","title":"faststream.asyncapi.schema.bindings.amqp.Queue","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent a queue.</p> <p>Attributes:</p> Name Type Description <code>name</code> <p>name of the queue</p> <code>durable</code> <p>indicates if the queue is durable</p> <code>exclusive</code> <p>indicates if the queue is exclusive</p> <code>autoDelete</code> <p>indicates if the queue should be automatically deleted</p> <code>vhost</code> <p>virtual host of the queue (default is \"/\")</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/bindings/amqp.py</code> <pre><code>class Queue(BaseModel):\n\"\"\"A class to represent a queue.\n\n    Attributes:\n        name : name of the queue\n        durable : indicates if the queue is durable\n        exclusive : indicates if the queue is exclusive\n        autoDelete : indicates if the queue should be automatically deleted\n        vhost : virtual host of the queue (default is \"/\")\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    name: str\n    durable: bool\n    exclusive: bool\n    autoDelete: bool\n    vhost: str = \"/\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/amqp/Queue/#faststream.asyncapi.schema.bindings.amqp.Queue-attributes","title":"Attributes","text":""},{"location":"api/faststream/asyncapi/schema/bindings/amqp/Queue/#faststream.asyncapi.schema.bindings.amqp.Queue.autoDelete","title":"autoDelete  <code>instance-attribute</code>","text":"<pre><code>autoDelete: bool\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/amqp/Queue/#faststream.asyncapi.schema.bindings.amqp.Queue.durable","title":"durable  <code>instance-attribute</code>","text":"<pre><code>durable: bool\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/amqp/Queue/#faststream.asyncapi.schema.bindings.amqp.Queue.exclusive","title":"exclusive  <code>instance-attribute</code>","text":"<pre><code>exclusive: bool\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/amqp/Queue/#faststream.asyncapi.schema.bindings.amqp.Queue.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/amqp/Queue/#faststream.asyncapi.schema.bindings.amqp.Queue.vhost","title":"vhost  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>vhost: str = '/'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/amqp/ServerBinding/","title":"ServerBinding","text":""},{"location":"api/faststream/asyncapi/schema/bindings/amqp/ServerBinding/#faststream.asyncapi.schema.bindings.amqp.ServerBinding","title":"faststream.asyncapi.schema.bindings.amqp.ServerBinding","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent a server binding.</p> <p>Attributes:</p> Name Type Description <code>bindingVersion</code> <p>version of the binding (default: \"0.2.0\")</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/bindings/amqp.py</code> <pre><code>class ServerBinding(BaseModel):\n\"\"\"A class to represent a server binding.\n\n    Attributes:\n        bindingVersion : version of the binding (default: \"0.2.0\")\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    bindingVersion: str = \"0.2.0\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/amqp/ServerBinding/#faststream.asyncapi.schema.bindings.amqp.ServerBinding-attributes","title":"Attributes","text":""},{"location":"api/faststream/asyncapi/schema/bindings/amqp/ServerBinding/#faststream.asyncapi.schema.bindings.amqp.ServerBinding.bindingVersion","title":"bindingVersion  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bindingVersion: str = '0.2.0'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/kafka/ChannelBinding/","title":"ChannelBinding","text":""},{"location":"api/faststream/asyncapi/schema/bindings/kafka/ChannelBinding/#faststream.asyncapi.schema.bindings.kafka.ChannelBinding","title":"faststream.asyncapi.schema.bindings.kafka.ChannelBinding","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent a channel binding.</p> <p>Attributes:</p> Name Type Description <code>topic</code> <p>optional string representing the topic</p> <code>partitions</code> <p>optional positive integer representing the number of partitions</p> <code>replicas</code> <p>optional positive integer representing the number of replicas</p> <code>bindingVersion</code> <p>string representing the binding version</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/bindings/kafka.py</code> <pre><code>class ChannelBinding(BaseModel):\n\"\"\"A class to represent a channel binding.\n\n    Attributes:\n        topic : optional string representing the topic\n        partitions : optional positive integer representing the number of partitions\n        replicas : optional positive integer representing the number of replicas\n        bindingVersion : string representing the binding version\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    topic: Optional[str] = None\n    partitions: Optional[PositiveInt] = None\n    replicas: Optional[PositiveInt] = None\n    # TODO:\n    # topicConfiguration\n    bindingVersion: str = \"0.4.0\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/kafka/ChannelBinding/#faststream.asyncapi.schema.bindings.kafka.ChannelBinding-attributes","title":"Attributes","text":""},{"location":"api/faststream/asyncapi/schema/bindings/kafka/ChannelBinding/#faststream.asyncapi.schema.bindings.kafka.ChannelBinding.bindingVersion","title":"bindingVersion  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bindingVersion: str = '0.4.0'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/kafka/ChannelBinding/#faststream.asyncapi.schema.bindings.kafka.ChannelBinding.partitions","title":"partitions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>partitions: Optional[PositiveInt] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/kafka/ChannelBinding/#faststream.asyncapi.schema.bindings.kafka.ChannelBinding.replicas","title":"replicas  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>replicas: Optional[PositiveInt] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/kafka/ChannelBinding/#faststream.asyncapi.schema.bindings.kafka.ChannelBinding.topic","title":"topic  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>topic: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/kafka/OperationBinding/","title":"OperationBinding","text":""},{"location":"api/faststream/asyncapi/schema/bindings/kafka/OperationBinding/#faststream.asyncapi.schema.bindings.kafka.OperationBinding","title":"faststream.asyncapi.schema.bindings.kafka.OperationBinding","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent an operation binding.</p> <p>Attributes:</p> Name Type Description <code>groupId</code> <p>optional dictionary representing the group ID</p> <code>clientId</code> <p>optional dictionary representing the client ID</p> <code>replyTo</code> <p>optional dictionary representing the reply-to</p> <code>bindingVersion</code> <p>version of the binding (default: \"0.4.0\")</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/bindings/kafka.py</code> <pre><code>class OperationBinding(BaseModel):\n\"\"\"A class to represent an operation binding.\n\n    Attributes:\n        groupId : optional dictionary representing the group ID\n        clientId : optional dictionary representing the client ID\n        replyTo : optional dictionary representing the reply-to\n        bindingVersion : version of the binding (default: \"0.4.0\")\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    groupId: Optional[Dict[str, Any]] = None\n    clientId: Optional[Dict[str, Any]] = None\n    replyTo: Optional[Dict[str, Any]] = None\n    bindingVersion: str = \"0.4.0\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/kafka/OperationBinding/#faststream.asyncapi.schema.bindings.kafka.OperationBinding-attributes","title":"Attributes","text":""},{"location":"api/faststream/asyncapi/schema/bindings/kafka/OperationBinding/#faststream.asyncapi.schema.bindings.kafka.OperationBinding.bindingVersion","title":"bindingVersion  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bindingVersion: str = '0.4.0'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/kafka/OperationBinding/#faststream.asyncapi.schema.bindings.kafka.OperationBinding.clientId","title":"clientId  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>clientId: Optional[Dict[str, Any]] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/kafka/OperationBinding/#faststream.asyncapi.schema.bindings.kafka.OperationBinding.groupId","title":"groupId  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>groupId: Optional[Dict[str, Any]] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/kafka/OperationBinding/#faststream.asyncapi.schema.bindings.kafka.OperationBinding.replyTo","title":"replyTo  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>replyTo: Optional[Dict[str, Any]] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/kafka/ServerBinding/","title":"ServerBinding","text":""},{"location":"api/faststream/asyncapi/schema/bindings/kafka/ServerBinding/#faststream.asyncapi.schema.bindings.kafka.ServerBinding","title":"faststream.asyncapi.schema.bindings.kafka.ServerBinding","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent a server binding.</p> <p>Attributes:</p> Name Type Description <code>bindingVersion</code> <p>version of the binding (default: \"0.4.0\")</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/bindings/kafka.py</code> <pre><code>class ServerBinding(BaseModel):\n\"\"\"A class to represent a server binding.\n\n    Attributes:\n        bindingVersion : version of the binding (default: \"0.4.0\")\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    bindingVersion: str = \"0.4.0\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/kafka/ServerBinding/#faststream.asyncapi.schema.bindings.kafka.ServerBinding-attributes","title":"Attributes","text":""},{"location":"api/faststream/asyncapi/schema/bindings/kafka/ServerBinding/#faststream.asyncapi.schema.bindings.kafka.ServerBinding.bindingVersion","title":"bindingVersion  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bindingVersion: str = '0.4.0'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/ChannelBinding/","title":"ChannelBinding","text":""},{"location":"api/faststream/asyncapi/schema/bindings/main/ChannelBinding/#faststream.asyncapi.schema.bindings.main.ChannelBinding","title":"faststream.asyncapi.schema.bindings.main.ChannelBinding","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent channel bindings.</p> <p>Attributes:</p> Name Type Description <code>amqp</code> <p>AMQP channel binding (optional)</p> <code>kafka</code> <p>Kafka channel binding (optional)</p> <code>sqs</code> <p>SQS channel binding (optional)</p> <code>nats</code> <p>NATS channel binding (optional)</p> <code>redis</code> <p>Redis channel binding (optional)</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/bindings/main.py</code> <pre><code>class ChannelBinding(BaseModel):\n\"\"\"A class to represent channel bindings.\n\n    Attributes:\n        amqp : AMQP channel binding (optional)\n        kafka : Kafka channel binding (optional)\n        sqs : SQS channel binding (optional)\n        nats : NATS channel binding (optional)\n        redis : Redis channel binding (optional)\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    amqp: Optional[amqp_bindings.ChannelBinding] = None\n    kafka: Optional[kafka_bindings.ChannelBinding] = None\n    sqs: Optional[sqs_bindings.ChannelBinding] = None\n    nats: Optional[nats_bindings.ChannelBinding] = None\n    redis: Optional[redis_bindings.ChannelBinding] = None\n\n    if PYDANTIC_V2:\n        model_config = {\"extra\": \"allow\"}\n\n    else:\n\n        class Config:\n            extra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/ChannelBinding/#faststream.asyncapi.schema.bindings.main.ChannelBinding-attributes","title":"Attributes","text":""},{"location":"api/faststream/asyncapi/schema/bindings/main/ChannelBinding/#faststream.asyncapi.schema.bindings.main.ChannelBinding.amqp","title":"amqp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>amqp: Optional[amqp_bindings.ChannelBinding] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/ChannelBinding/#faststream.asyncapi.schema.bindings.main.ChannelBinding.kafka","title":"kafka  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>kafka: Optional[kafka_bindings.ChannelBinding] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/ChannelBinding/#faststream.asyncapi.schema.bindings.main.ChannelBinding.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = {'extra': 'allow'}\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/ChannelBinding/#faststream.asyncapi.schema.bindings.main.ChannelBinding.nats","title":"nats  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>nats: Optional[nats_bindings.ChannelBinding] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/ChannelBinding/#faststream.asyncapi.schema.bindings.main.ChannelBinding.redis","title":"redis  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>redis: Optional[redis_bindings.ChannelBinding] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/ChannelBinding/#faststream.asyncapi.schema.bindings.main.ChannelBinding.sqs","title":"sqs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sqs: Optional[sqs_bindings.ChannelBinding] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/ChannelBinding/#faststream.asyncapi.schema.bindings.main.ChannelBinding-classes","title":"Classes","text":""},{"location":"api/faststream/asyncapi/schema/bindings/main/ChannelBinding/#faststream.asyncapi.schema.bindings.main.ChannelBinding.Config","title":"Config","text":"Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/bindings/main.py</code> <pre><code>class Config:\n    extra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/ChannelBinding/#faststream.asyncapi.schema.bindings.main.ChannelBinding.Config-attributes","title":"Attributes","text":""},{"location":"api/faststream/asyncapi/schema/bindings/main/ChannelBinding/#faststream.asyncapi.schema.bindings.main.ChannelBinding.Config.extra","title":"extra  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extra = 'allow'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/OperationBinding/","title":"OperationBinding","text":""},{"location":"api/faststream/asyncapi/schema/bindings/main/OperationBinding/#faststream.asyncapi.schema.bindings.main.OperationBinding","title":"faststream.asyncapi.schema.bindings.main.OperationBinding","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent an operation binding.</p> <p>Attributes:</p> Name Type Description <code>amqp</code> <p>AMQP operation binding (optional)</p> <code>kafka</code> <p>Kafka operation binding (optional)</p> <code>sqs</code> <p>SQS operation binding (optional)</p> <code>nats</code> <p>NATS operation binding (optional)</p> <code>redis</code> <p>Redis operation binding (optional)</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/bindings/main.py</code> <pre><code>class OperationBinding(BaseModel):\n\"\"\"A class to represent an operation binding.\n\n    Attributes:\n        amqp : AMQP operation binding (optional)\n        kafka : Kafka operation binding (optional)\n        sqs : SQS operation binding (optional)\n        nats : NATS operation binding (optional)\n        redis : Redis operation binding (optional)\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    amqp: Optional[amqp_bindings.OperationBinding] = None\n    kafka: Optional[kafka_bindings.OperationBinding] = None\n    sqs: Optional[sqs_bindings.OperationBinding] = None\n    nats: Optional[nats_bindings.OperationBinding] = None\n    redis: Optional[redis_bindings.OperationBinding] = None\n\n    if PYDANTIC_V2:\n        model_config = {\"extra\": \"allow\"}\n\n    else:\n\n        class Config:\n            extra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/OperationBinding/#faststream.asyncapi.schema.bindings.main.OperationBinding-attributes","title":"Attributes","text":""},{"location":"api/faststream/asyncapi/schema/bindings/main/OperationBinding/#faststream.asyncapi.schema.bindings.main.OperationBinding.amqp","title":"amqp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>amqp: Optional[amqp_bindings.OperationBinding] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/OperationBinding/#faststream.asyncapi.schema.bindings.main.OperationBinding.kafka","title":"kafka  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>kafka: Optional[kafka_bindings.OperationBinding] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/OperationBinding/#faststream.asyncapi.schema.bindings.main.OperationBinding.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = {'extra': 'allow'}\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/OperationBinding/#faststream.asyncapi.schema.bindings.main.OperationBinding.nats","title":"nats  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>nats: Optional[nats_bindings.OperationBinding] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/OperationBinding/#faststream.asyncapi.schema.bindings.main.OperationBinding.redis","title":"redis  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>redis: Optional[redis_bindings.OperationBinding] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/OperationBinding/#faststream.asyncapi.schema.bindings.main.OperationBinding.sqs","title":"sqs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sqs: Optional[sqs_bindings.OperationBinding] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/OperationBinding/#faststream.asyncapi.schema.bindings.main.OperationBinding-classes","title":"Classes","text":""},{"location":"api/faststream/asyncapi/schema/bindings/main/OperationBinding/#faststream.asyncapi.schema.bindings.main.OperationBinding.Config","title":"Config","text":"Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/bindings/main.py</code> <pre><code>class Config:\n    extra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/OperationBinding/#faststream.asyncapi.schema.bindings.main.OperationBinding.Config-attributes","title":"Attributes","text":""},{"location":"api/faststream/asyncapi/schema/bindings/main/OperationBinding/#faststream.asyncapi.schema.bindings.main.OperationBinding.Config.extra","title":"extra  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extra = 'allow'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/ServerBinding/","title":"ServerBinding","text":""},{"location":"api/faststream/asyncapi/schema/bindings/main/ServerBinding/#faststream.asyncapi.schema.bindings.main.ServerBinding","title":"faststream.asyncapi.schema.bindings.main.ServerBinding","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent server bindings.</p> <p>Attributes:</p> Name Type Description <code>amqp</code> <p>AMQP server binding (optional)</p> <code>kafka</code> <p>Kafka server binding (optional)</p> <code>sqs</code> <p>SQS server binding (optional)</p> <code>nats</code> <p>NATS server binding (optional)</p> <code>redis</code> <p>Redis server binding (optional)</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/bindings/main.py</code> <pre><code>class ServerBinding(BaseModel):\n\"\"\"A class to represent server bindings.\n\n    Attributes:\n        amqp : AMQP server binding (optional)\n        kafka : Kafka server binding (optional)\n        sqs : SQS server binding (optional)\n        nats : NATS server binding (optional)\n        redis : Redis server binding (optional)\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    amqp: Optional[amqp_bindings.ServerBinding] = None\n    kafka: Optional[kafka_bindings.ServerBinding] = None\n    sqs: Optional[sqs_bindings.ServerBinding] = None\n    nats: Optional[nats_bindings.ServerBinding] = None\n    redis: Optional[redis_bindings.ServerBinding] = None\n\n    if PYDANTIC_V2:\n        model_config = {\"extra\": \"allow\"}\n\n    else:\n\n        class Config:\n            extra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/ServerBinding/#faststream.asyncapi.schema.bindings.main.ServerBinding-attributes","title":"Attributes","text":""},{"location":"api/faststream/asyncapi/schema/bindings/main/ServerBinding/#faststream.asyncapi.schema.bindings.main.ServerBinding.amqp","title":"amqp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>amqp: Optional[amqp_bindings.ServerBinding] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/ServerBinding/#faststream.asyncapi.schema.bindings.main.ServerBinding.kafka","title":"kafka  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>kafka: Optional[kafka_bindings.ServerBinding] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/ServerBinding/#faststream.asyncapi.schema.bindings.main.ServerBinding.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = {'extra': 'allow'}\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/ServerBinding/#faststream.asyncapi.schema.bindings.main.ServerBinding.nats","title":"nats  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>nats: Optional[nats_bindings.ServerBinding] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/ServerBinding/#faststream.asyncapi.schema.bindings.main.ServerBinding.redis","title":"redis  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>redis: Optional[redis_bindings.ServerBinding] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/ServerBinding/#faststream.asyncapi.schema.bindings.main.ServerBinding.sqs","title":"sqs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sqs: Optional[sqs_bindings.ServerBinding] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/ServerBinding/#faststream.asyncapi.schema.bindings.main.ServerBinding-classes","title":"Classes","text":""},{"location":"api/faststream/asyncapi/schema/bindings/main/ServerBinding/#faststream.asyncapi.schema.bindings.main.ServerBinding.Config","title":"Config","text":"Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/bindings/main.py</code> <pre><code>class Config:\n    extra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/ServerBinding/#faststream.asyncapi.schema.bindings.main.ServerBinding.Config-attributes","title":"Attributes","text":""},{"location":"api/faststream/asyncapi/schema/bindings/main/ServerBinding/#faststream.asyncapi.schema.bindings.main.ServerBinding.Config.extra","title":"extra  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extra = 'allow'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/nats/ChannelBinding/","title":"ChannelBinding","text":""},{"location":"api/faststream/asyncapi/schema/bindings/nats/ChannelBinding/#faststream.asyncapi.schema.bindings.nats.ChannelBinding","title":"faststream.asyncapi.schema.bindings.nats.ChannelBinding","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent channel binding.</p> <p>Attributes:</p> Name Type Description <code>subject</code> <p>subject of the channel binding</p> <code>queue</code> <p>optional queue for the channel binding</p> <code>bindingVersion</code> <p>version of the channel binding, default is \"custom\"</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/bindings/nats.py</code> <pre><code>class ChannelBinding(BaseModel):\n\"\"\"A class to represent channel binding.\n\n    Attributes:\n        subject : subject of the channel binding\n        queue : optional queue for the channel binding\n        bindingVersion : version of the channel binding, default is \"custom\"\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    subject: str\n    queue: Optional[str] = None\n    bindingVersion: str = \"custom\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/nats/ChannelBinding/#faststream.asyncapi.schema.bindings.nats.ChannelBinding-attributes","title":"Attributes","text":""},{"location":"api/faststream/asyncapi/schema/bindings/nats/ChannelBinding/#faststream.asyncapi.schema.bindings.nats.ChannelBinding.bindingVersion","title":"bindingVersion  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bindingVersion: str = 'custom'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/nats/ChannelBinding/#faststream.asyncapi.schema.bindings.nats.ChannelBinding.queue","title":"queue  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>queue: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/nats/ChannelBinding/#faststream.asyncapi.schema.bindings.nats.ChannelBinding.subject","title":"subject  <code>instance-attribute</code>","text":"<pre><code>subject: str\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/nats/OperationBinding/","title":"OperationBinding","text":""},{"location":"api/faststream/asyncapi/schema/bindings/nats/OperationBinding/#faststream.asyncapi.schema.bindings.nats.OperationBinding","title":"faststream.asyncapi.schema.bindings.nats.OperationBinding","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent an operation binding.</p> <p>Attributes:</p> Name Type Description <code>replyTo</code> <p>optional dictionary containing reply information</p> <code>bindingVersion</code> <p>version of the binding (default is \"custom\")</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/bindings/nats.py</code> <pre><code>class OperationBinding(BaseModel):\n\"\"\"A class to represent an operation binding.\n\n    Attributes:\n        replyTo : optional dictionary containing reply information\n        bindingVersion : version of the binding (default is \"custom\")\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    replyTo: Optional[Dict[str, Any]] = None\n    bindingVersion: str = \"custom\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/nats/OperationBinding/#faststream.asyncapi.schema.bindings.nats.OperationBinding-attributes","title":"Attributes","text":""},{"location":"api/faststream/asyncapi/schema/bindings/nats/OperationBinding/#faststream.asyncapi.schema.bindings.nats.OperationBinding.bindingVersion","title":"bindingVersion  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bindingVersion: str = 'custom'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/nats/OperationBinding/#faststream.asyncapi.schema.bindings.nats.OperationBinding.replyTo","title":"replyTo  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>replyTo: Optional[Dict[str, Any]] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/nats/ServerBinding/","title":"ServerBinding","text":""},{"location":"api/faststream/asyncapi/schema/bindings/nats/ServerBinding/#faststream.asyncapi.schema.bindings.nats.ServerBinding","title":"faststream.asyncapi.schema.bindings.nats.ServerBinding","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent a server binding.</p> <p>Attributes:</p> Name Type Description <code>bindingVersion</code> <p>version of the binding (default: \"custom\")</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/bindings/nats.py</code> <pre><code>class ServerBinding(BaseModel):\n\"\"\"A class to represent a server binding.\n\n    Attributes:\n        bindingVersion : version of the binding (default: \"custom\")\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    bindingVersion: str = \"custom\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/nats/ServerBinding/#faststream.asyncapi.schema.bindings.nats.ServerBinding-attributes","title":"Attributes","text":""},{"location":"api/faststream/asyncapi/schema/bindings/nats/ServerBinding/#faststream.asyncapi.schema.bindings.nats.ServerBinding.bindingVersion","title":"bindingVersion  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bindingVersion: str = 'custom'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/redis/ChannelBinding/","title":"ChannelBinding","text":""},{"location":"api/faststream/asyncapi/schema/bindings/redis/ChannelBinding/#faststream.asyncapi.schema.bindings.redis.ChannelBinding","title":"faststream.asyncapi.schema.bindings.redis.ChannelBinding","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent channel binding.</p> <p>Attributes:</p> Name Type Description <code>channel</code> <p>the channel name</p> <code>method</code> <p>the method used for binding (ssubscribe, psubscribe, subscribe)</p> <code>bindingVersion</code> <p>the version of the binding</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/bindings/redis.py</code> <pre><code>class ChannelBinding(BaseModel):\n\"\"\"A class to represent channel binding.\n\n    Attributes:\n        channel : the channel name\n        method : the method used for binding (ssubscribe, psubscribe, subscribe)\n        bindingVersion : the version of the binding\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    channel: str\n    method: Literal[\"ssubscribe\", \"psubscribe\", \"subscribe\"] = \"subscribe\"\n    bindingVersion: str = \"custom\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/redis/ChannelBinding/#faststream.asyncapi.schema.bindings.redis.ChannelBinding-attributes","title":"Attributes","text":""},{"location":"api/faststream/asyncapi/schema/bindings/redis/ChannelBinding/#faststream.asyncapi.schema.bindings.redis.ChannelBinding.bindingVersion","title":"bindingVersion  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bindingVersion: str = 'custom'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/redis/ChannelBinding/#faststream.asyncapi.schema.bindings.redis.ChannelBinding.channel","title":"channel  <code>instance-attribute</code>","text":"<pre><code>channel: str\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/redis/ChannelBinding/#faststream.asyncapi.schema.bindings.redis.ChannelBinding.method","title":"method  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>method: Literal[\n    \"ssubscribe\", \"psubscribe\", \"subscribe\"\n] = \"subscribe\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/redis/OperationBinding/","title":"OperationBinding","text":""},{"location":"api/faststream/asyncapi/schema/bindings/redis/OperationBinding/#faststream.asyncapi.schema.bindings.redis.OperationBinding","title":"faststream.asyncapi.schema.bindings.redis.OperationBinding","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent an operation binding.</p> <p>Attributes:</p> Name Type Description <code>replyTo</code> <p>optional dictionary containing reply information</p> <code>bindingVersion</code> <p>version of the binding (default is \"custom\")</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/bindings/redis.py</code> <pre><code>class OperationBinding(BaseModel):\n\"\"\"A class to represent an operation binding.\n\n    Attributes:\n        replyTo : optional dictionary containing reply information\n        bindingVersion : version of the binding (default is \"custom\")\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    replyTo: Optional[Dict[str, Any]] = None\n    bindingVersion: str = \"custom\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/redis/OperationBinding/#faststream.asyncapi.schema.bindings.redis.OperationBinding-attributes","title":"Attributes","text":""},{"location":"api/faststream/asyncapi/schema/bindings/redis/OperationBinding/#faststream.asyncapi.schema.bindings.redis.OperationBinding.bindingVersion","title":"bindingVersion  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bindingVersion: str = 'custom'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/redis/OperationBinding/#faststream.asyncapi.schema.bindings.redis.OperationBinding.replyTo","title":"replyTo  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>replyTo: Optional[Dict[str, Any]] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/redis/ServerBinding/","title":"ServerBinding","text":""},{"location":"api/faststream/asyncapi/schema/bindings/redis/ServerBinding/#faststream.asyncapi.schema.bindings.redis.ServerBinding","title":"faststream.asyncapi.schema.bindings.redis.ServerBinding","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent a server binding.</p> <p>Attributes:</p> Name Type Description <code>bindingVersion</code> <p>version of the binding (default: \"custom\")</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/bindings/redis.py</code> <pre><code>class ServerBinding(BaseModel):\n\"\"\"A class to represent a server binding.\n\n    Attributes:\n        bindingVersion : version of the binding (default: \"custom\")\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    bindingVersion: str = \"custom\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/redis/ServerBinding/#faststream.asyncapi.schema.bindings.redis.ServerBinding-attributes","title":"Attributes","text":""},{"location":"api/faststream/asyncapi/schema/bindings/redis/ServerBinding/#faststream.asyncapi.schema.bindings.redis.ServerBinding.bindingVersion","title":"bindingVersion  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bindingVersion: str = 'custom'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/sqs/ChannelBinding/","title":"ChannelBinding","text":""},{"location":"api/faststream/asyncapi/schema/bindings/sqs/ChannelBinding/#faststream.asyncapi.schema.bindings.sqs.ChannelBinding","title":"faststream.asyncapi.schema.bindings.sqs.ChannelBinding","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent channel binding.</p> <p>Attributes:</p> Name Type Description <code>queue</code> <p>a dictionary representing the queue</p> <code>bindingVersion</code> <p>a string representing the binding version (default: \"custom\")</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/bindings/sqs.py</code> <pre><code>class ChannelBinding(BaseModel):\n\"\"\"A class to represent channel binding.\n\n    Attributes:\n        queue : a dictionary representing the queue\n        bindingVersion : a string representing the binding version (default: \"custom\")\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    queue: Dict[str, Any]\n    bindingVersion: str = \"custom\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/sqs/ChannelBinding/#faststream.asyncapi.schema.bindings.sqs.ChannelBinding-attributes","title":"Attributes","text":""},{"location":"api/faststream/asyncapi/schema/bindings/sqs/ChannelBinding/#faststream.asyncapi.schema.bindings.sqs.ChannelBinding.bindingVersion","title":"bindingVersion  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bindingVersion: str = 'custom'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/sqs/ChannelBinding/#faststream.asyncapi.schema.bindings.sqs.ChannelBinding.queue","title":"queue  <code>instance-attribute</code>","text":"<pre><code>queue: Dict[str, Any]\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/sqs/OperationBinding/","title":"OperationBinding","text":""},{"location":"api/faststream/asyncapi/schema/bindings/sqs/OperationBinding/#faststream.asyncapi.schema.bindings.sqs.OperationBinding","title":"faststream.asyncapi.schema.bindings.sqs.OperationBinding","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent an operation binding.</p> <p>Attributes:</p> Name Type Description <code>replyTo</code> <p>optional dictionary containing reply information</p> <code>bindingVersion</code> <p>version of the binding, default is \"custom\"</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/bindings/sqs.py</code> <pre><code>class OperationBinding(BaseModel):\n\"\"\"A class to represent an operation binding.\n\n    Attributes:\n        replyTo : optional dictionary containing reply information\n        bindingVersion : version of the binding, default is \"custom\"\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    replyTo: Optional[Dict[str, Any]] = None\n    bindingVersion: str = \"custom\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/sqs/OperationBinding/#faststream.asyncapi.schema.bindings.sqs.OperationBinding-attributes","title":"Attributes","text":""},{"location":"api/faststream/asyncapi/schema/bindings/sqs/OperationBinding/#faststream.asyncapi.schema.bindings.sqs.OperationBinding.bindingVersion","title":"bindingVersion  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bindingVersion: str = 'custom'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/sqs/OperationBinding/#faststream.asyncapi.schema.bindings.sqs.OperationBinding.replyTo","title":"replyTo  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>replyTo: Optional[Dict[str, Any]] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/sqs/ServerBinding/","title":"ServerBinding","text":""},{"location":"api/faststream/asyncapi/schema/bindings/sqs/ServerBinding/#faststream.asyncapi.schema.bindings.sqs.ServerBinding","title":"faststream.asyncapi.schema.bindings.sqs.ServerBinding","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent a server binding.</p> <p>Attributes:</p> Name Type Description <code>bindingVersion</code> <p>version of the binding (default: \"custom\")</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/bindings/sqs.py</code> <pre><code>class ServerBinding(BaseModel):\n\"\"\"A class to represent a server binding.\n\n    Attributes:\n        bindingVersion : version of the binding (default: \"custom\")\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    bindingVersion: str = \"custom\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/sqs/ServerBinding/#faststream.asyncapi.schema.bindings.sqs.ServerBinding-attributes","title":"Attributes","text":""},{"location":"api/faststream/asyncapi/schema/bindings/sqs/ServerBinding/#faststream.asyncapi.schema.bindings.sqs.ServerBinding.bindingVersion","title":"bindingVersion  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bindingVersion: str = 'custom'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/channels/Channel/","title":"Channel","text":""},{"location":"api/faststream/asyncapi/schema/channels/Channel/#faststream.asyncapi.schema.channels.Channel","title":"faststream.asyncapi.schema.channels.Channel","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent a channel.</p> <p>Attributes:</p> Name Type Description <code>description</code> <p>optional description of the channel</p> <code>servers</code> <p>optional list of servers associated with the channel</p> <code>bindings</code> <p>optional channel binding</p> <code>subscribe</code> <p>optional operation for subscribing to the channel</p> <code>publish</code> <p>optional operation for publishing to the channel</p> <code>parameters</code> <p>optional parameters associated with the channel</p> Configurations <p>model_config : configuration for the model (only applicable for Pydantic version 2) Config : configuration for the class (only applicable for Pydantic version 1)</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/channels.py</code> <pre><code>class Channel(BaseModel):\n\"\"\"A class to represent a channel.\n\n    Attributes:\n        description : optional description of the channel\n        servers : optional list of servers associated with the channel\n        bindings : optional channel binding\n        subscribe : optional operation for subscribing to the channel\n        publish : optional operation for publishing to the channel\n        parameters : optional parameters associated with the channel\n\n    Configurations:\n        model_config : configuration for the model (only applicable for Pydantic version 2)\n        Config : configuration for the class (only applicable for Pydantic version 1)\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    description: Optional[str] = None\n    servers: Optional[List[str]] = None\n    bindings: Optional[ChannelBinding] = None\n    subscribe: Optional[Operation] = None\n    publish: Optional[Operation] = None\n    parameters: Optional[Parameter] = None\n\n    if PYDANTIC_V2:\n        model_config = {\"extra\": \"allow\"}\n\n    else:\n\n        class Config:\n            extra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/channels/Channel/#faststream.asyncapi.schema.channels.Channel-attributes","title":"Attributes","text":""},{"location":"api/faststream/asyncapi/schema/channels/Channel/#faststream.asyncapi.schema.channels.Channel.bindings","title":"bindings  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bindings: Optional[ChannelBinding] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/channels/Channel/#faststream.asyncapi.schema.channels.Channel.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/channels/Channel/#faststream.asyncapi.schema.channels.Channel.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = {'extra': 'allow'}\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/channels/Channel/#faststream.asyncapi.schema.channels.Channel.parameters","title":"parameters  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>parameters: Optional[Parameter] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/channels/Channel/#faststream.asyncapi.schema.channels.Channel.publish","title":"publish  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>publish: Optional[Operation] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/channels/Channel/#faststream.asyncapi.schema.channels.Channel.servers","title":"servers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>servers: Optional[List[str]] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/channels/Channel/#faststream.asyncapi.schema.channels.Channel.subscribe","title":"subscribe  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>subscribe: Optional[Operation] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/channels/Channel/#faststream.asyncapi.schema.channels.Channel-classes","title":"Classes","text":""},{"location":"api/faststream/asyncapi/schema/channels/Channel/#faststream.asyncapi.schema.channels.Channel.Config","title":"Config","text":"Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/channels.py</code> <pre><code>class Config:\n    extra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/channels/Channel/#faststream.asyncapi.schema.channels.Channel.Config-attributes","title":"Attributes","text":""},{"location":"api/faststream/asyncapi/schema/channels/Channel/#faststream.asyncapi.schema.channels.Channel.Config.extra","title":"extra  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extra = 'allow'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/Contact/","title":"Contact","text":""},{"location":"api/faststream/asyncapi/schema/info/Contact/#faststream.asyncapi.schema.info.Contact","title":"faststream.asyncapi.schema.info.Contact","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent a contact.</p> <p>Attributes:</p> Name Type Description <code>name</code> <p>name of the contact (str)</p> <code>url</code> <p>URL of the contact (Optional[AnyHttpUrl])</p> <code>email</code> <p>email of the contact (Optional[EmailStr])</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/info.py</code> <pre><code>class Contact(BaseModel):\n\"\"\"A class to represent a contact.\n\n    Attributes:\n        name : name of the contact (str)\n        url : URL of the contact (Optional[AnyHttpUrl])\n        email : email of the contact (Optional[EmailStr])\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    name: str\n    url: Optional[AnyHttpUrl] = None\n    email: Optional[EmailStr] = None\n\n    if PYDANTIC_V2:\n        model_config = {\"extra\": \"allow\"}\n\n    else:\n\n        class Config:\n            extra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/Contact/#faststream.asyncapi.schema.info.Contact-attributes","title":"Attributes","text":""},{"location":"api/faststream/asyncapi/schema/info/Contact/#faststream.asyncapi.schema.info.Contact.email","title":"email  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>email: Optional[EmailStr] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/Contact/#faststream.asyncapi.schema.info.Contact.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = {'extra': 'allow'}\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/Contact/#faststream.asyncapi.schema.info.Contact.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/Contact/#faststream.asyncapi.schema.info.Contact.url","title":"url  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>url: Optional[AnyHttpUrl] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/Contact/#faststream.asyncapi.schema.info.Contact-classes","title":"Classes","text":""},{"location":"api/faststream/asyncapi/schema/info/Contact/#faststream.asyncapi.schema.info.Contact.Config","title":"Config","text":"Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/info.py</code> <pre><code>class Config:\n    extra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/Contact/#faststream.asyncapi.schema.info.Contact.Config-attributes","title":"Attributes","text":""},{"location":"api/faststream/asyncapi/schema/info/Contact/#faststream.asyncapi.schema.info.Contact.Config.extra","title":"extra  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extra = 'allow'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/ContactDict/","title":"ContactDict","text":""},{"location":"api/faststream/asyncapi/schema/info/ContactDict/#faststream.asyncapi.schema.info.ContactDict","title":"faststream.asyncapi.schema.info.ContactDict","text":"<p>             Bases: <code>TypedDict</code></p> <p>A class to represent a dictionary of contact information.</p> <p>Attributes:</p> Name Type Description <code>name</code> <p>required name of the contact (type: str)</p> <code>url</code> <p>URL of the contact (type: AnyHttpUrl)</p> <code>email</code> <p>email address of the contact (type: EmailStr)</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/info.py</code> <pre><code>class ContactDict(TypedDict, total=False):\n\"\"\"A class to represent a dictionary of contact information.\n\n    Attributes:\n        name : required name of the contact (type: str)\n        url : URL of the contact (type: AnyHttpUrl)\n        email : email address of the contact (type: EmailStr)\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    name: Required[str]\n    url: AnyHttpUrl\n    email: EmailStr\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/ContactDict/#faststream.asyncapi.schema.info.ContactDict-attributes","title":"Attributes","text":""},{"location":"api/faststream/asyncapi/schema/info/ContactDict/#faststream.asyncapi.schema.info.ContactDict.email","title":"email  <code>instance-attribute</code>","text":"<pre><code>email: EmailStr\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/ContactDict/#faststream.asyncapi.schema.info.ContactDict.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: Required[str]\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/ContactDict/#faststream.asyncapi.schema.info.ContactDict.url","title":"url  <code>instance-attribute</code>","text":"<pre><code>url: AnyHttpUrl\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/EmailStr/","title":"EmailStr","text":""},{"location":"api/faststream/asyncapi/schema/info/EmailStr/#faststream.asyncapi.schema.info.EmailStr","title":"faststream.asyncapi.schema.info.EmailStr","text":"<p>             Bases: <code>str</code></p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/info.py</code> <pre><code>class EmailStr(str):  # type: ignore\n    @classmethod\n    def __get_validators__(cls) -&gt; Iterable[Callable[..., Any]]:\n        yield cls.validate\n\n    @classmethod\n    def validate(cls, v: Any) -&gt; str:\n        logger.warning(\n            \"email-validator bot installed, email fields will be treated as str.\\n\"\n            \"To install, run: pip install email-validator\"\n        )\n        return str(v)\n\n    @classmethod\n    def _validate(cls, __input_value: Any, _: Any) -&gt; str:\n        logger.warning(\n            \"email-validator bot installed, email fields will be treated as str.\\n\"\n            \"To install, run: pip install email-validator\"\n        )\n        return str(__input_value)\n\n    @classmethod\n    def __get_pydantic_json_schema__(\n        cls,\n        core_schema: CoreSchema,\n        handler: GetJsonSchemaHandler,\n    ) -&gt; JsonSchemaValue:\n        return {\"type\": \"string\", \"format\": \"email\"}\n\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls,\n        source: Type[Any],\n        handler: Callable[[Any], CoreSchema],\n    ) -&gt; JsonSchemaValue:\n        return general_plain_validator_function(cls._validate)\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/EmailStr/#faststream.asyncapi.schema.info.EmailStr-functions","title":"Functions","text":""},{"location":"api/faststream/asyncapi/schema/info/EmailStr/#faststream.asyncapi.schema.info.EmailStr.__get_pydantic_core_schema__","title":"__get_pydantic_core_schema__  <code>classmethod</code>","text":"<pre><code>__get_pydantic_core_schema__(\n    source: Type[Any], handler: Callable[[Any], CoreSchema]\n) -&gt; JsonSchemaValue\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/info.py</code> <pre><code>@classmethod\ndef __get_pydantic_core_schema__(\n    cls,\n    source: Type[Any],\n    handler: Callable[[Any], CoreSchema],\n) -&gt; JsonSchemaValue:\n    return general_plain_validator_function(cls._validate)\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/EmailStr/#faststream.asyncapi.schema.info.EmailStr.__get_pydantic_json_schema__","title":"__get_pydantic_json_schema__  <code>classmethod</code>","text":"<pre><code>__get_pydantic_json_schema__(\n    core_schema: CoreSchema, handler: GetJsonSchemaHandler\n) -&gt; JsonSchemaValue\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/info.py</code> <pre><code>@classmethod\ndef __get_pydantic_json_schema__(\n    cls,\n    core_schema: CoreSchema,\n    handler: GetJsonSchemaHandler,\n) -&gt; JsonSchemaValue:\n    return {\"type\": \"string\", \"format\": \"email\"}\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/EmailStr/#faststream.asyncapi.schema.info.EmailStr.__get_validators__","title":"__get_validators__  <code>classmethod</code>","text":"<pre><code>__get_validators__() -&gt; Iterable[Callable[..., Any]]\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/info.py</code> <pre><code>@classmethod\ndef __get_validators__(cls) -&gt; Iterable[Callable[..., Any]]:\n    yield cls.validate\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/EmailStr/#faststream.asyncapi.schema.info.EmailStr.validate","title":"validate  <code>classmethod</code>","text":"<pre><code>validate(v: Any) -&gt; str\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/info.py</code> <pre><code>@classmethod\ndef validate(cls, v: Any) -&gt; str:\n    logger.warning(\n        \"email-validator bot installed, email fields will be treated as str.\\n\"\n        \"To install, run: pip install email-validator\"\n    )\n    return str(v)\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/Info/","title":"Info","text":""},{"location":"api/faststream/asyncapi/schema/info/Info/#faststream.asyncapi.schema.info.Info","title":"faststream.asyncapi.schema.info.Info","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent information.</p> <p>Attributes:</p> Name Type Description <code>title</code> <p>title of the information</p> <code>version</code> <p>version of the information (default: \"1.0.0\")</p> <code>description</code> <p>description of the information (default: \"\")</p> <code>termsOfService</code> <p>terms of service for the information (default: None)</p> <code>contact</code> <p>contact information for the information (default: None)</p> <code>license</code> <p>license information for the information (default: None)</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/info.py</code> <pre><code>class Info(BaseModel):\n\"\"\"A class to represent information.\n\n    Attributes:\n        title : title of the information\n        version : version of the information (default: \"1.0.0\")\n        description : description of the information (default: \"\")\n        termsOfService : terms of service for the information (default: None)\n        contact : contact information for the information (default: None)\n        license : license information for the information (default: None)\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    title: str\n    version: str = \"1.0.0\"\n    description: str = \"\"\n    termsOfService: Optional[AnyHttpUrl] = None\n    contact: Optional[Union[Contact, ContactDict, Dict[str, Any]]] = None\n    license: Optional[Union[License, LicenseDict, Dict[str, Any]]] = None\n\n    if PYDANTIC_V2:\n        model_config = {\"extra\": \"allow\"}\n\n    else:\n\n        class Config:\n            extra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/Info/#faststream.asyncapi.schema.info.Info-attributes","title":"Attributes","text":""},{"location":"api/faststream/asyncapi/schema/info/Info/#faststream.asyncapi.schema.info.Info.contact","title":"contact  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>contact: Optional[\n    Union[Contact, ContactDict, Dict[str, Any]]\n] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/Info/#faststream.asyncapi.schema.info.Info.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: str = ''\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/Info/#faststream.asyncapi.schema.info.Info.license","title":"license  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>license: Optional[\n    Union[License, LicenseDict, Dict[str, Any]]\n] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/Info/#faststream.asyncapi.schema.info.Info.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = {'extra': 'allow'}\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/Info/#faststream.asyncapi.schema.info.Info.termsOfService","title":"termsOfService  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>termsOfService: Optional[AnyHttpUrl] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/Info/#faststream.asyncapi.schema.info.Info.title","title":"title  <code>instance-attribute</code>","text":"<pre><code>title: str\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/Info/#faststream.asyncapi.schema.info.Info.version","title":"version  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>version: str = '1.0.0'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/Info/#faststream.asyncapi.schema.info.Info-classes","title":"Classes","text":""},{"location":"api/faststream/asyncapi/schema/info/Info/#faststream.asyncapi.schema.info.Info.Config","title":"Config","text":"Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/info.py</code> <pre><code>class Config:\n    extra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/Info/#faststream.asyncapi.schema.info.Info.Config-attributes","title":"Attributes","text":""},{"location":"api/faststream/asyncapi/schema/info/Info/#faststream.asyncapi.schema.info.Info.Config.extra","title":"extra  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extra = 'allow'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/License/","title":"License","text":""},{"location":"api/faststream/asyncapi/schema/info/License/#faststream.asyncapi.schema.info.License","title":"faststream.asyncapi.schema.info.License","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent a license.</p> <p>Attributes:</p> Name Type Description <code>name</code> <p>name of the license</p> <code>url</code> <p>URL of the license (optional)</p> Config <p>extra : allow additional attributes in the model (PYDANTIC_V2)</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/info.py</code> <pre><code>class License(BaseModel):\n\"\"\"A class to represent a license.\n\n    Attributes:\n        name : name of the license\n        url : URL of the license (optional)\n\n    Config:\n        extra : allow additional attributes in the model (PYDANTIC_V2)\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    name: str\n    url: Optional[AnyHttpUrl] = None\n\n    if PYDANTIC_V2:\n        model_config = {\"extra\": \"allow\"}\n\n    else:\n\n        class Config:\n            extra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/License/#faststream.asyncapi.schema.info.License-attributes","title":"Attributes","text":""},{"location":"api/faststream/asyncapi/schema/info/License/#faststream.asyncapi.schema.info.License.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = {'extra': 'allow'}\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/License/#faststream.asyncapi.schema.info.License.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/License/#faststream.asyncapi.schema.info.License.url","title":"url  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>url: Optional[AnyHttpUrl] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/License/#faststream.asyncapi.schema.info.License-classes","title":"Classes","text":""},{"location":"api/faststream/asyncapi/schema/info/License/#faststream.asyncapi.schema.info.License.Config","title":"Config","text":"Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/info.py</code> <pre><code>class Config:\n    extra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/License/#faststream.asyncapi.schema.info.License.Config-attributes","title":"Attributes","text":""},{"location":"api/faststream/asyncapi/schema/info/License/#faststream.asyncapi.schema.info.License.Config.extra","title":"extra  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extra = 'allow'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/LicenseDict/","title":"LicenseDict","text":""},{"location":"api/faststream/asyncapi/schema/info/LicenseDict/#faststream.asyncapi.schema.info.LicenseDict","title":"faststream.asyncapi.schema.info.LicenseDict","text":"<p>             Bases: <code>TypedDict</code></p> <p>A dictionary-like class to represent a license.</p> <p>Attributes:</p> Name Type Description <code>name</code> <p>required name of the license (type: str)</p> <code>url</code> <p>URL of the license (type: AnyHttpUrl)</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/info.py</code> <pre><code>class LicenseDict(TypedDict, total=False):\n\"\"\"A dictionary-like class to represent a license.\n\n    Attributes:\n        name : required name of the license (type: str)\n        url : URL of the license (type: AnyHttpUrl)\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    name: Required[str]\n    url: AnyHttpUrl\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/LicenseDict/#faststream.asyncapi.schema.info.LicenseDict-attributes","title":"Attributes","text":""},{"location":"api/faststream/asyncapi/schema/info/LicenseDict/#faststream.asyncapi.schema.info.LicenseDict.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: Required[str]\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/LicenseDict/#faststream.asyncapi.schema.info.LicenseDict.url","title":"url  <code>instance-attribute</code>","text":"<pre><code>url: AnyHttpUrl\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/main/Components/","title":"Components","text":""},{"location":"api/faststream/asyncapi/schema/main/Components/#faststream.asyncapi.schema.main.Components","title":"faststream.asyncapi.schema.main.Components","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent components in a system.</p> <p>Attributes:</p> Name Type Description <code>messages</code> <p>Optional dictionary of messages</p> <code>schemas</code> <p>Optional dictionary of schemas</p> Note <p>The following attributes are not implemented yet: - servers - serverVariables - channels - securitySchemes - parameters - correlationIds - operationTraits - messageTraits - serverBindings - channelBindings - operationBindings - messageBindings</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/main.py</code> <pre><code>class Components(BaseModel):\n    # TODO\n    # servers\n    # serverVariables\n    # channels\n\"\"\"A class to represent components in a system.\n\n    Attributes:\n        messages : Optional dictionary of messages\n        schemas : Optional dictionary of schemas\n\n    Note:\n        The following attributes are not implemented yet:\n        - servers\n        - serverVariables\n        - channels\n        - securitySchemes\n        - parameters\n        - correlationIds\n        - operationTraits\n        - messageTraits\n        - serverBindings\n        - channelBindings\n        - operationBindings\n        - messageBindings\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    messages: Optional[Dict[str, Message]] = None\n    schemas: Optional[Dict[str, Dict[str, Any]]] = None\n    securitySchemes: Optional[Dict[str, Dict[str, Any]]] = None\n    # parameters\n    # correlationIds\n    # operationTraits\n    # messageTraits\n    # serverBindings\n    # channelBindings\n    # operationBindings\n    # messageBindings\n\n    if PYDANTIC_V2:\n        model_config = {\"extra\": \"allow\"}\n\n    else:\n\n        class Config:\n            extra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/main/Components/#faststream.asyncapi.schema.main.Components-attributes","title":"Attributes","text":""},{"location":"api/faststream/asyncapi/schema/main/Components/#faststream.asyncapi.schema.main.Components.messages","title":"messages  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>messages: Optional[Dict[str, Message]] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/main/Components/#faststream.asyncapi.schema.main.Components.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = {'extra': 'allow'}\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/main/Components/#faststream.asyncapi.schema.main.Components.schemas","title":"schemas  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>schemas: Optional[Dict[str, Dict[str, Any]]] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/main/Components/#faststream.asyncapi.schema.main.Components.securitySchemes","title":"securitySchemes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>securitySchemes: Optional[Dict[str, Dict[str, Any]]] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/main/Components/#faststream.asyncapi.schema.main.Components-classes","title":"Classes","text":""},{"location":"api/faststream/asyncapi/schema/main/Components/#faststream.asyncapi.schema.main.Components.Config","title":"Config","text":"Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/main.py</code> <pre><code>class Config:\n    extra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/main/Components/#faststream.asyncapi.schema.main.Components.Config-attributes","title":"Attributes","text":""},{"location":"api/faststream/asyncapi/schema/main/Components/#faststream.asyncapi.schema.main.Components.Config.extra","title":"extra  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extra = 'allow'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/main/Schema/","title":"Schema","text":""},{"location":"api/faststream/asyncapi/schema/main/Schema/#faststream.asyncapi.schema.main.Schema","title":"faststream.asyncapi.schema.main.Schema","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent a schema.</p> <p>Attributes:</p> Name Type Description <code>asyncapi</code> <p>version of the async API</p> <code>id</code> <p>optional ID</p> <code>defaultContentType</code> <p>optional default content type</p> <code>info</code> <p>information about the schema</p> <code>servers</code> <p>optional dictionary of servers</p> <code>channels</code> <p>dictionary of channels</p> <code>components</code> <p>optional components of the schema</p> <code>tags</code> <p>optional list of tags</p> <code>externalDocs</code> <p>optional external documentation</p> <p>Methods:</p> Name Description <code>to_jsonable</code> <p>Convert the schema to a JSON-serializable object.</p> <code>to_json</code> <p>Convert the schema to a JSON string.</p> <code>to_yaml</code> <p>Convert the schema to a YAML string.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/main.py</code> <pre><code>class Schema(BaseModel):\n\"\"\"A class to represent a schema.\n\n    Attributes:\n        asyncapi : version of the async API\n        id : optional ID\n        defaultContentType : optional default content type\n        info : information about the schema\n        servers : optional dictionary of servers\n        channels : dictionary of channels\n        components : optional components of the schema\n        tags : optional list of tags\n        externalDocs : optional external documentation\n\n    Methods:\n        to_jsonable() -&gt; Any: Convert the schema to a JSON-serializable object.\n        to_json() -&gt; str: Convert the schema to a JSON string.\n        to_yaml() -&gt; str: Convert the schema to a YAML string.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    asyncapi: str = ASYNC_API_VERSION\n    id: Optional[str] = None\n    defaultContentType: Optional[str] = None\n    info: Info\n    servers: Optional[Dict[str, Server]] = None\n    channels: Dict[str, Channel]\n    components: Optional[Components] = None\n    tags: Optional[List[Union[Tag, TagDict, Dict[str, Any]]]] = None\n    externalDocs: Optional[Union[ExternalDocs, ExternalDocsDict, Dict[str, Any]]] = None\n\n    def to_jsonable(self) -&gt; Any:\n        return model_to_jsonable(\n            self,\n            by_alias=True,\n            exclude_none=True,\n        )\n\n    def to_json(self) -&gt; str:\n        return model_to_json(\n            self,\n            by_alias=True,\n            exclude_none=True,\n        )\n\n    def to_yaml(self) -&gt; str:\n        from io import StringIO\n\n        import yaml\n\n        io = StringIO(initial_value=\"\", newline=\"\\n\")\n        yaml.dump(self.to_jsonable(), io, sort_keys=False)\n        return io.getvalue()\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/main/Schema/#faststream.asyncapi.schema.main.Schema-attributes","title":"Attributes","text":""},{"location":"api/faststream/asyncapi/schema/main/Schema/#faststream.asyncapi.schema.main.Schema.asyncapi","title":"asyncapi  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>asyncapi: str = ASYNC_API_VERSION\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/main/Schema/#faststream.asyncapi.schema.main.Schema.channels","title":"channels  <code>instance-attribute</code>","text":"<pre><code>channels: Dict[str, Channel]\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/main/Schema/#faststream.asyncapi.schema.main.Schema.components","title":"components  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>components: Optional[Components] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/main/Schema/#faststream.asyncapi.schema.main.Schema.defaultContentType","title":"defaultContentType  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>defaultContentType: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/main/Schema/#faststream.asyncapi.schema.main.Schema.externalDocs","title":"externalDocs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>externalDocs: Optional[\n    Union[ExternalDocs, ExternalDocsDict, Dict[str, Any]]\n] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/main/Schema/#faststream.asyncapi.schema.main.Schema.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/main/Schema/#faststream.asyncapi.schema.main.Schema.info","title":"info  <code>instance-attribute</code>","text":"<pre><code>info: Info\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/main/Schema/#faststream.asyncapi.schema.main.Schema.servers","title":"servers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>servers: Optional[Dict[str, Server]] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/main/Schema/#faststream.asyncapi.schema.main.Schema.tags","title":"tags  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tags: Optional[\n    List[Union[Tag, TagDict, Dict[str, Any]]]\n] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/main/Schema/#faststream.asyncapi.schema.main.Schema-functions","title":"Functions","text":""},{"location":"api/faststream/asyncapi/schema/main/Schema/#faststream.asyncapi.schema.main.Schema.to_json","title":"to_json","text":"<pre><code>to_json() -&gt; str\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/main.py</code> <pre><code>def to_json(self) -&gt; str:\n    return model_to_json(\n        self,\n        by_alias=True,\n        exclude_none=True,\n    )\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/main/Schema/#faststream.asyncapi.schema.main.Schema.to_jsonable","title":"to_jsonable","text":"<pre><code>to_jsonable() -&gt; Any\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/main.py</code> <pre><code>def to_jsonable(self) -&gt; Any:\n    return model_to_jsonable(\n        self,\n        by_alias=True,\n        exclude_none=True,\n    )\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/main/Schema/#faststream.asyncapi.schema.main.Schema.to_yaml","title":"to_yaml","text":"<pre><code>to_yaml() -&gt; str\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/main.py</code> <pre><code>def to_yaml(self) -&gt; str:\n    from io import StringIO\n\n    import yaml\n\n    io = StringIO(initial_value=\"\", newline=\"\\n\")\n    yaml.dump(self.to_jsonable(), io, sort_keys=False)\n    return io.getvalue()\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/message/CorrelationId/","title":"CorrelationId","text":""},{"location":"api/faststream/asyncapi/schema/message/CorrelationId/#faststream.asyncapi.schema.message.CorrelationId","title":"faststream.asyncapi.schema.message.CorrelationId","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent a correlation ID.</p> <p>Attributes:</p> Name Type Description <code>description</code> <p>optional description of the correlation ID</p> <code>location</code> <p>location of the correlation ID</p> Configurations <p>extra : allows extra fields in the correlation ID model</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/message.py</code> <pre><code>class CorrelationId(BaseModel):\n\"\"\"A class to represent a correlation ID.\n\n    Attributes:\n        description : optional description of the correlation ID\n        location : location of the correlation ID\n\n    Configurations:\n        extra : allows extra fields in the correlation ID model\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    description: Optional[str] = None\n    location: str\n\n    if PYDANTIC_V2:\n        model_config = {\"extra\": \"allow\"}\n\n    else:\n\n        class Config:\n            extra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/message/CorrelationId/#faststream.asyncapi.schema.message.CorrelationId-attributes","title":"Attributes","text":""},{"location":"api/faststream/asyncapi/schema/message/CorrelationId/#faststream.asyncapi.schema.message.CorrelationId.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/message/CorrelationId/#faststream.asyncapi.schema.message.CorrelationId.location","title":"location  <code>instance-attribute</code>","text":"<pre><code>location: str\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/message/CorrelationId/#faststream.asyncapi.schema.message.CorrelationId.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = {'extra': 'allow'}\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/message/CorrelationId/#faststream.asyncapi.schema.message.CorrelationId-classes","title":"Classes","text":""},{"location":"api/faststream/asyncapi/schema/message/CorrelationId/#faststream.asyncapi.schema.message.CorrelationId.Config","title":"Config","text":"Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/message.py</code> <pre><code>class Config:\n    extra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/message/CorrelationId/#faststream.asyncapi.schema.message.CorrelationId.Config-attributes","title":"Attributes","text":""},{"location":"api/faststream/asyncapi/schema/message/CorrelationId/#faststream.asyncapi.schema.message.CorrelationId.Config.extra","title":"extra  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extra = 'allow'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/message/Message/","title":"Message","text":""},{"location":"api/faststream/asyncapi/schema/message/Message/#faststream.asyncapi.schema.message.Message","title":"faststream.asyncapi.schema.message.Message","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent a message.</p> <p>Attributes:</p> Name Type Description <code>title</code> <p>title of the message</p> <code>name</code> <p>name of the message</p> <code>summary</code> <p>summary of the message</p> <code>description</code> <p>description of the message</p> <code>messageId</code> <p>ID of the message</p> <code>correlationId</code> <p>correlation ID of the message</p> <code>contentType</code> <p>content type of the message</p> <code>payload</code> <p>dictionary representing the payload of the message</p> <code>tags</code> <p>list of tags associated with the message</p> <code>externalDocs</code> <p>external documentation associated with the message</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/message.py</code> <pre><code>class Message(BaseModel):\n\"\"\"A class to represent a message.\n\n    Attributes:\n        title : title of the message\n        name : name of the message\n        summary : summary of the message\n        description : description of the message\n        messageId : ID of the message\n        correlationId : correlation ID of the message\n        contentType : content type of the message\n        payload : dictionary representing the payload of the message\n        tags : list of tags associated with the message\n        externalDocs : external documentation associated with the message\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    title: Optional[str] = None\n    name: Optional[str] = None\n    summary: Optional[str] = None\n    description: Optional[str] = None\n    messageId: Optional[str] = None\n    correlationId: Optional[CorrelationId] = None\n    contentType: Optional[str] = None\n\n    payload: Dict[str, Any]\n    # TODO:\n    # headers\n    # schemaFormat\n    # bindings\n    # examples\n    # traits\n\n    tags: Optional[List[Union[Tag, TagDict, Dict[str, Any]]]] = None\n    externalDocs: Optional[Union[ExternalDocs, ExternalDocsDict, Dict[str, Any]]] = None\n\n    if PYDANTIC_V2:\n        model_config = {\"extra\": \"allow\"}\n\n    else:\n\n        class Config:\n            extra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/message/Message/#faststream.asyncapi.schema.message.Message-attributes","title":"Attributes","text":""},{"location":"api/faststream/asyncapi/schema/message/Message/#faststream.asyncapi.schema.message.Message.contentType","title":"contentType  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>contentType: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/message/Message/#faststream.asyncapi.schema.message.Message.correlationId","title":"correlationId  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>correlationId: Optional[CorrelationId] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/message/Message/#faststream.asyncapi.schema.message.Message.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/message/Message/#faststream.asyncapi.schema.message.Message.externalDocs","title":"externalDocs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>externalDocs: Optional[\n    Union[ExternalDocs, ExternalDocsDict, Dict[str, Any]]\n] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/message/Message/#faststream.asyncapi.schema.message.Message.messageId","title":"messageId  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>messageId: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/message/Message/#faststream.asyncapi.schema.message.Message.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = {'extra': 'allow'}\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/message/Message/#faststream.asyncapi.schema.message.Message.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/message/Message/#faststream.asyncapi.schema.message.Message.payload","title":"payload  <code>instance-attribute</code>","text":"<pre><code>payload: Dict[str, Any]\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/message/Message/#faststream.asyncapi.schema.message.Message.summary","title":"summary  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>summary: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/message/Message/#faststream.asyncapi.schema.message.Message.tags","title":"tags  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tags: Optional[\n    List[Union[Tag, TagDict, Dict[str, Any]]]\n] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/message/Message/#faststream.asyncapi.schema.message.Message.title","title":"title  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>title: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/message/Message/#faststream.asyncapi.schema.message.Message-classes","title":"Classes","text":""},{"location":"api/faststream/asyncapi/schema/message/Message/#faststream.asyncapi.schema.message.Message.Config","title":"Config","text":"Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/message.py</code> <pre><code>class Config:\n    extra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/message/Message/#faststream.asyncapi.schema.message.Message.Config-attributes","title":"Attributes","text":""},{"location":"api/faststream/asyncapi/schema/message/Message/#faststream.asyncapi.schema.message.Message.Config.extra","title":"extra  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extra = 'allow'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/operations/Operation/","title":"Operation","text":""},{"location":"api/faststream/asyncapi/schema/operations/Operation/#faststream.asyncapi.schema.operations.Operation","title":"faststream.asyncapi.schema.operations.Operation","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent an operation.</p> <p>Attributes:</p> Name Type Description <code>operationId</code> <p>ID of the operation</p> <code>summary</code> <p>summary of the operation</p> <code>description</code> <p>description of the operation</p> <code>bindings</code> <p>bindings of the operation</p> <code>message</code> <p>message of the operation</p> <code>security</code> <p>security details of the operation</p> <code>tags</code> <p>tags associated with the operation</p> <code>externalDocs</code> <p>external documentation for the operation</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/operations.py</code> <pre><code>class Operation(BaseModel):\n\"\"\"A class to represent an operation.\n\n    Attributes:\n        operationId : ID of the operation\n        summary : summary of the operation\n        description : description of the operation\n        bindings : bindings of the operation\n        message : message of the operation\n        security : security details of the operation\n        tags : tags associated with the operation\n        externalDocs : external documentation for the operation\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    operationId: Optional[str] = None\n    summary: Optional[str] = None\n    description: Optional[str] = None\n\n    bindings: Optional[OperationBinding] = None\n\n    message: Union[Message, Reference]\n\n    security: Optional[Dict[str, List[str]]] = None\n\n    # TODO\n    # traits\n\n    tags: Optional[List[Union[Tag, TagDict, Dict[str, Any]]]] = None\n    externalDocs: Optional[Union[ExternalDocs, ExternalDocsDict, Dict[str, Any]]] = None\n\n    if PYDANTIC_V2:\n        model_config = {\"extra\": \"allow\"}\n\n    else:\n\n        class Config:\n            extra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/operations/Operation/#faststream.asyncapi.schema.operations.Operation-attributes","title":"Attributes","text":""},{"location":"api/faststream/asyncapi/schema/operations/Operation/#faststream.asyncapi.schema.operations.Operation.bindings","title":"bindings  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bindings: Optional[OperationBinding] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/operations/Operation/#faststream.asyncapi.schema.operations.Operation.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/operations/Operation/#faststream.asyncapi.schema.operations.Operation.externalDocs","title":"externalDocs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>externalDocs: Optional[\n    Union[ExternalDocs, ExternalDocsDict, Dict[str, Any]]\n] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/operations/Operation/#faststream.asyncapi.schema.operations.Operation.message","title":"message  <code>instance-attribute</code>","text":"<pre><code>message: Union[Message, Reference]\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/operations/Operation/#faststream.asyncapi.schema.operations.Operation.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = {'extra': 'allow'}\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/operations/Operation/#faststream.asyncapi.schema.operations.Operation.operationId","title":"operationId  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>operationId: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/operations/Operation/#faststream.asyncapi.schema.operations.Operation.security","title":"security  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>security: Optional[Dict[str, List[str]]] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/operations/Operation/#faststream.asyncapi.schema.operations.Operation.summary","title":"summary  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>summary: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/operations/Operation/#faststream.asyncapi.schema.operations.Operation.tags","title":"tags  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tags: Optional[\n    List[Union[Tag, TagDict, Dict[str, Any]]]\n] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/operations/Operation/#faststream.asyncapi.schema.operations.Operation-classes","title":"Classes","text":""},{"location":"api/faststream/asyncapi/schema/operations/Operation/#faststream.asyncapi.schema.operations.Operation.Config","title":"Config","text":"Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/operations.py</code> <pre><code>class Config:\n    extra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/operations/Operation/#faststream.asyncapi.schema.operations.Operation.Config-attributes","title":"Attributes","text":""},{"location":"api/faststream/asyncapi/schema/operations/Operation/#faststream.asyncapi.schema.operations.Operation.Config.extra","title":"extra  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extra = 'allow'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/OauthFlowObj/","title":"OauthFlowObj","text":""},{"location":"api/faststream/asyncapi/schema/security/OauthFlowObj/#faststream.asyncapi.schema.security.OauthFlowObj","title":"faststream.asyncapi.schema.security.OauthFlowObj","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent an OAuth flow object.</p> <p>Attributes:</p> Name Type Description <code>authorizationUrl</code> <p>Optional[AnyHttpUrl] : The URL for authorization</p> <code>tokenUrl</code> <p>Optional[AnyHttpUrl] : The URL for token</p> <code>refreshUrl</code> <p>Optional[AnyHttpUrl] : The URL for refresh</p> <code>scopes</code> <p>Dict[str, str] : The scopes for the OAuth flow</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/security.py</code> <pre><code>class OauthFlowObj(BaseModel):\n\"\"\"A class to represent an OAuth flow object.\n\n    Attributes:\n        authorizationUrl : Optional[AnyHttpUrl] : The URL for authorization\n        tokenUrl : Optional[AnyHttpUrl] : The URL for token\n        refreshUrl : Optional[AnyHttpUrl] : The URL for refresh\n        scopes : Dict[str, str] : The scopes for the OAuth flow\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    authorizationUrl: Optional[AnyHttpUrl] = None\n    tokenUrl: Optional[AnyHttpUrl] = None\n    refreshUrl: Optional[AnyHttpUrl] = None\n    scopes: Dict[str, str]\n\n    if PYDANTIC_V2:\n        model_config = {\"extra\": \"allow\"}\n\n    else:\n\n        class Config:\n            extra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/OauthFlowObj/#faststream.asyncapi.schema.security.OauthFlowObj-attributes","title":"Attributes","text":""},{"location":"api/faststream/asyncapi/schema/security/OauthFlowObj/#faststream.asyncapi.schema.security.OauthFlowObj.authorizationUrl","title":"authorizationUrl  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>authorizationUrl: Optional[AnyHttpUrl] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/OauthFlowObj/#faststream.asyncapi.schema.security.OauthFlowObj.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = {'extra': 'allow'}\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/OauthFlowObj/#faststream.asyncapi.schema.security.OauthFlowObj.refreshUrl","title":"refreshUrl  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>refreshUrl: Optional[AnyHttpUrl] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/OauthFlowObj/#faststream.asyncapi.schema.security.OauthFlowObj.scopes","title":"scopes  <code>instance-attribute</code>","text":"<pre><code>scopes: Dict[str, str]\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/OauthFlowObj/#faststream.asyncapi.schema.security.OauthFlowObj.tokenUrl","title":"tokenUrl  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tokenUrl: Optional[AnyHttpUrl] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/OauthFlowObj/#faststream.asyncapi.schema.security.OauthFlowObj-classes","title":"Classes","text":""},{"location":"api/faststream/asyncapi/schema/security/OauthFlowObj/#faststream.asyncapi.schema.security.OauthFlowObj.Config","title":"Config","text":"Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/security.py</code> <pre><code>class Config:\n    extra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/OauthFlowObj/#faststream.asyncapi.schema.security.OauthFlowObj.Config-attributes","title":"Attributes","text":""},{"location":"api/faststream/asyncapi/schema/security/OauthFlowObj/#faststream.asyncapi.schema.security.OauthFlowObj.Config.extra","title":"extra  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extra = 'allow'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/OauthFlows/","title":"OauthFlows","text":""},{"location":"api/faststream/asyncapi/schema/security/OauthFlows/#faststream.asyncapi.schema.security.OauthFlows","title":"faststream.asyncapi.schema.security.OauthFlows","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent OAuth flows.</p> <p>Attributes:</p> Name Type Description <code>implicit</code> <p>Optional[OauthFlowObj] : Implicit OAuth flow object</p> <code>password</code> <p>Optional[OauthFlowObj] : Password OAuth flow object</p> <code>clientCredentials</code> <p>Optional[OauthFlowObj] : Client credentials OAuth flow object</p> <code>authorizationCode</code> <p>Optional[OauthFlowObj] : Authorization code OAuth flow object</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/security.py</code> <pre><code>class OauthFlows(BaseModel):\n\"\"\"A class to represent OAuth flows.\n\n    Attributes:\n        implicit : Optional[OauthFlowObj] : Implicit OAuth flow object\n        password : Optional[OauthFlowObj] : Password OAuth flow object\n        clientCredentials : Optional[OauthFlowObj] : Client credentials OAuth flow object\n        authorizationCode : Optional[OauthFlowObj] : Authorization code OAuth flow object\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    implicit: Optional[OauthFlowObj] = None\n    password: Optional[OauthFlowObj] = None\n    clientCredentials: Optional[OauthFlowObj] = None\n    authorizationCode: Optional[OauthFlowObj] = None\n\n    if PYDANTIC_V2:\n        model_config = {\"extra\": \"allow\"}\n\n    else:\n\n        class Config:\n            extra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/OauthFlows/#faststream.asyncapi.schema.security.OauthFlows-attributes","title":"Attributes","text":""},{"location":"api/faststream/asyncapi/schema/security/OauthFlows/#faststream.asyncapi.schema.security.OauthFlows.authorizationCode","title":"authorizationCode  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>authorizationCode: Optional[OauthFlowObj] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/OauthFlows/#faststream.asyncapi.schema.security.OauthFlows.clientCredentials","title":"clientCredentials  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>clientCredentials: Optional[OauthFlowObj] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/OauthFlows/#faststream.asyncapi.schema.security.OauthFlows.implicit","title":"implicit  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>implicit: Optional[OauthFlowObj] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/OauthFlows/#faststream.asyncapi.schema.security.OauthFlows.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = {'extra': 'allow'}\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/OauthFlows/#faststream.asyncapi.schema.security.OauthFlows.password","title":"password  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>password: Optional[OauthFlowObj] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/OauthFlows/#faststream.asyncapi.schema.security.OauthFlows-classes","title":"Classes","text":""},{"location":"api/faststream/asyncapi/schema/security/OauthFlows/#faststream.asyncapi.schema.security.OauthFlows.Config","title":"Config","text":"Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/security.py</code> <pre><code>class Config:\n    extra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/OauthFlows/#faststream.asyncapi.schema.security.OauthFlows.Config-attributes","title":"Attributes","text":""},{"location":"api/faststream/asyncapi/schema/security/OauthFlows/#faststream.asyncapi.schema.security.OauthFlows.Config.extra","title":"extra  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extra = 'allow'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/SecuritySchemaComponent/","title":"SecuritySchemaComponent","text":""},{"location":"api/faststream/asyncapi/schema/security/SecuritySchemaComponent/#faststream.asyncapi.schema.security.SecuritySchemaComponent","title":"faststream.asyncapi.schema.security.SecuritySchemaComponent","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent a security schema component.</p> <p>Attributes:</p> Name Type Description <code>type</code> <p>Literal, the type of the security schema component</p> <code>name</code> <p>optional name of the security schema component</p> <code>description</code> <p>optional description of the security schema component</p> <code>in_</code> <p>optional location of the security schema component</p> <code>schema_</code> <p>optional schema of the security schema component</p> <code>bearerFormat</code> <p>optional bearer format of the security schema component</p> <code>openIdConnectUrl</code> <p>optional OpenID Connect URL of the security schema component</p> <code>flows</code> <p>optional OAuth flows of the security schema component</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/security.py</code> <pre><code>class SecuritySchemaComponent(BaseModel):\n\"\"\"A class to represent a security schema component.\n\n    Attributes:\n        type : Literal, the type of the security schema component\n        name : optional name of the security schema component\n        description : optional description of the security schema component\n        in_ : optional location of the security schema component\n        schema_ : optional schema of the security schema component\n        bearerFormat : optional bearer format of the security schema component\n        openIdConnectUrl : optional OpenID Connect URL of the security schema component\n        flows : optional OAuth flows of the security schema component\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    type: Literal[\n        \"userPassword\",\n        \"apikey\",\n        \"X509\",\n        \"symmetricEncryption\",\n        \"asymmetricEncryption\",\n        \"httpApiKey\",\n        \"http\",\n        \"oauth2\",\n        \"openIdConnect\",\n        \"plain\",\n        \"scramSha256\",\n        \"scramSha512\",\n        \"gssapi\",\n    ]\n    name: Optional[str] = None\n    description: Optional[str] = None\n    in_: Optional[str] = Field(\n        default=None,\n        alias=\"in\",\n    )\n    schema_: Optional[str] = Field(\n        default=None,\n        alias=\"schema\",\n    )\n    bearerFormat: Optional[str] = None\n    openIdConnectUrl: Optional[str] = None\n    flows: Optional[OauthFlows] = None\n\n    if PYDANTIC_V2:\n        model_config = {\"extra\": \"allow\"}\n\n    else:\n\n        class Config:\n            extra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/SecuritySchemaComponent/#faststream.asyncapi.schema.security.SecuritySchemaComponent-attributes","title":"Attributes","text":""},{"location":"api/faststream/asyncapi/schema/security/SecuritySchemaComponent/#faststream.asyncapi.schema.security.SecuritySchemaComponent.bearerFormat","title":"bearerFormat  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bearerFormat: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/SecuritySchemaComponent/#faststream.asyncapi.schema.security.SecuritySchemaComponent.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/SecuritySchemaComponent/#faststream.asyncapi.schema.security.SecuritySchemaComponent.flows","title":"flows  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>flows: Optional[OauthFlows] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/SecuritySchemaComponent/#faststream.asyncapi.schema.security.SecuritySchemaComponent.in_","title":"in_  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>in_: Optional[str] = Field(default=None, alias='in')\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/SecuritySchemaComponent/#faststream.asyncapi.schema.security.SecuritySchemaComponent.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = {'extra': 'allow'}\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/SecuritySchemaComponent/#faststream.asyncapi.schema.security.SecuritySchemaComponent.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/SecuritySchemaComponent/#faststream.asyncapi.schema.security.SecuritySchemaComponent.openIdConnectUrl","title":"openIdConnectUrl  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>openIdConnectUrl: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/SecuritySchemaComponent/#faststream.asyncapi.schema.security.SecuritySchemaComponent.schema_","title":"schema_  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>schema_: Optional[str] = Field(default=None, alias=\"schema\")\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/SecuritySchemaComponent/#faststream.asyncapi.schema.security.SecuritySchemaComponent.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: Literal[\n    \"userPassword\",\n    \"apikey\",\n    \"X509\",\n    \"symmetricEncryption\",\n    \"asymmetricEncryption\",\n    \"httpApiKey\",\n    \"http\",\n    \"oauth2\",\n    \"openIdConnect\",\n    \"plain\",\n    \"scramSha256\",\n    \"scramSha512\",\n    \"gssapi\",\n]\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/SecuritySchemaComponent/#faststream.asyncapi.schema.security.SecuritySchemaComponent-classes","title":"Classes","text":""},{"location":"api/faststream/asyncapi/schema/security/SecuritySchemaComponent/#faststream.asyncapi.schema.security.SecuritySchemaComponent.Config","title":"Config","text":"Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/security.py</code> <pre><code>class Config:\n    extra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/SecuritySchemaComponent/#faststream.asyncapi.schema.security.SecuritySchemaComponent.Config-attributes","title":"Attributes","text":""},{"location":"api/faststream/asyncapi/schema/security/SecuritySchemaComponent/#faststream.asyncapi.schema.security.SecuritySchemaComponent.Config.extra","title":"extra  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extra = 'allow'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/servers/Server/","title":"Server","text":""},{"location":"api/faststream/asyncapi/schema/servers/Server/#faststream.asyncapi.schema.servers.Server","title":"faststream.asyncapi.schema.servers.Server","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent a server.</p> <p>Attributes:</p> Name Type Description <code>url</code> <p>URL of the server</p> <code>protocol</code> <p>protocol used by the server</p> <code>description</code> <p>optional description of the server</p> <code>protocolVersion</code> <p>optional version of the protocol used by the server</p> <code>tags</code> <p>optional list of tags associated with the server</p> <code>security</code> <p>optional security requirement for the server</p> <code>variables</code> <p>optional dictionary of server variables</p> <code>bindings</code> <p>optional server binding</p> Note <p>The attributes <code>description</code>, <code>protocolVersion</code>, <code>tags</code>, <code>security</code>, <code>variables</code>, and <code>bindings</code> are all optional.</p> Configurations <p>If <code>PYDANTIC_V2</code> is True, the model configuration is set to allow extra attributes. Otherwise, the <code>Config</code> class is defined with the <code>extra</code> attribute set to \"allow\".</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/servers.py</code> <pre><code>class Server(BaseModel):\n\"\"\"A class to represent a server.\n\n    Attributes:\n        url : URL of the server\n        protocol : protocol used by the server\n        description : optional description of the server\n        protocolVersion : optional version of the protocol used by the server\n        tags : optional list of tags associated with the server\n        security : optional security requirement for the server\n        variables : optional dictionary of server variables\n        bindings : optional server binding\n\n    Note:\n        The attributes `description`, `protocolVersion`, `tags`, `security`, `variables`, and `bindings` are all optional.\n\n    Configurations:\n        If `PYDANTIC_V2` is True, the model configuration is set to allow extra attributes.\n        Otherwise, the `Config` class is defined with the `extra` attribute set to \"allow\".\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    url: str\n    protocol: str\n    description: Optional[str] = None\n    protocolVersion: Optional[str] = None\n    tags: Optional[List[Union[Tag, TagDict, Dict[str, Any]]]] = None\n    security: Optional[SecurityRequirement] = None\n    variables: Optional[Dict[str, Union[ServerVariable, Reference]]] = None\n    bindings: Optional[Union[ServerBinding, Reference]] = None\n\n    if PYDANTIC_V2:\n        model_config = {\"extra\": \"allow\"}\n\n    else:\n\n        class Config:\n            extra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/servers/Server/#faststream.asyncapi.schema.servers.Server-attributes","title":"Attributes","text":""},{"location":"api/faststream/asyncapi/schema/servers/Server/#faststream.asyncapi.schema.servers.Server.bindings","title":"bindings  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bindings: Optional[Union[ServerBinding, Reference]] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/servers/Server/#faststream.asyncapi.schema.servers.Server.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/servers/Server/#faststream.asyncapi.schema.servers.Server.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = {'extra': 'allow'}\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/servers/Server/#faststream.asyncapi.schema.servers.Server.protocol","title":"protocol  <code>instance-attribute</code>","text":"<pre><code>protocol: str\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/servers/Server/#faststream.asyncapi.schema.servers.Server.protocolVersion","title":"protocolVersion  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>protocolVersion: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/servers/Server/#faststream.asyncapi.schema.servers.Server.security","title":"security  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>security: Optional[SecurityRequirement] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/servers/Server/#faststream.asyncapi.schema.servers.Server.tags","title":"tags  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tags: Optional[\n    List[Union[Tag, TagDict, Dict[str, Any]]]\n] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/servers/Server/#faststream.asyncapi.schema.servers.Server.url","title":"url  <code>instance-attribute</code>","text":"<pre><code>url: str\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/servers/Server/#faststream.asyncapi.schema.servers.Server.variables","title":"variables  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>variables: Optional[\n    Dict[str, Union[ServerVariable, Reference]]\n] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/servers/Server/#faststream.asyncapi.schema.servers.Server-classes","title":"Classes","text":""},{"location":"api/faststream/asyncapi/schema/servers/Server/#faststream.asyncapi.schema.servers.Server.Config","title":"Config","text":"Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/servers.py</code> <pre><code>class Config:\n    extra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/servers/Server/#faststream.asyncapi.schema.servers.Server.Config-attributes","title":"Attributes","text":""},{"location":"api/faststream/asyncapi/schema/servers/Server/#faststream.asyncapi.schema.servers.Server.Config.extra","title":"extra  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extra = 'allow'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/servers/ServerVariable/","title":"ServerVariable","text":""},{"location":"api/faststream/asyncapi/schema/servers/ServerVariable/#faststream.asyncapi.schema.servers.ServerVariable","title":"faststream.asyncapi.schema.servers.ServerVariable","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent a server variable.</p> <p>Attributes:</p> Name Type Description <code>enum</code> <p>list of possible values for the server variable (optional)</p> <code>default</code> <p>default value for the server variable (optional)</p> <code>description</code> <p>description of the server variable (optional)</p> <code>examples</code> <p>list of example values for the server variable (optional)</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/servers.py</code> <pre><code>class ServerVariable(BaseModel):\n\"\"\"A class to represent a server variable.\n\n    Attributes:\n        enum : list of possible values for the server variable (optional)\n        default : default value for the server variable (optional)\n        description : description of the server variable (optional)\n        examples : list of example values for the server variable (optional)\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    enum: Optional[List[str]] = None\n    default: Optional[str] = None\n    description: Optional[str] = None\n    examples: Optional[List[str]] = None\n\n    if PYDANTIC_V2:\n        model_config = {\"extra\": \"allow\"}\n\n    else:\n\n        class Config:\n            extra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/servers/ServerVariable/#faststream.asyncapi.schema.servers.ServerVariable-attributes","title":"Attributes","text":""},{"location":"api/faststream/asyncapi/schema/servers/ServerVariable/#faststream.asyncapi.schema.servers.ServerVariable.default","title":"default  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>default: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/servers/ServerVariable/#faststream.asyncapi.schema.servers.ServerVariable.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/servers/ServerVariable/#faststream.asyncapi.schema.servers.ServerVariable.enum","title":"enum  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>enum: Optional[List[str]] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/servers/ServerVariable/#faststream.asyncapi.schema.servers.ServerVariable.examples","title":"examples  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>examples: Optional[List[str]] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/servers/ServerVariable/#faststream.asyncapi.schema.servers.ServerVariable.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = {'extra': 'allow'}\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/servers/ServerVariable/#faststream.asyncapi.schema.servers.ServerVariable-classes","title":"Classes","text":""},{"location":"api/faststream/asyncapi/schema/servers/ServerVariable/#faststream.asyncapi.schema.servers.ServerVariable.Config","title":"Config","text":"Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/servers.py</code> <pre><code>class Config:\n    extra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/servers/ServerVariable/#faststream.asyncapi.schema.servers.ServerVariable.Config-attributes","title":"Attributes","text":""},{"location":"api/faststream/asyncapi/schema/servers/ServerVariable/#faststream.asyncapi.schema.servers.ServerVariable.Config.extra","title":"extra  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extra = 'allow'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/utils/ExternalDocs/","title":"ExternalDocs","text":""},{"location":"api/faststream/asyncapi/schema/utils/ExternalDocs/#faststream.asyncapi.schema.utils.ExternalDocs","title":"faststream.asyncapi.schema.utils.ExternalDocs","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent external documentation.</p> <p>Attributes:</p> Name Type Description <code>url</code> <p>URL of the external documentation</p> <code>description</code> <p>optional description of the external documentation</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/utils.py</code> <pre><code>class ExternalDocs(BaseModel):\n\"\"\"A class to represent external documentation.\n\n    Attributes:\n        url : URL of the external documentation\n        description : optional description of the external documentation\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    url: AnyHttpUrl\n    description: Optional[str] = None\n\n    if PYDANTIC_V2:\n        model_config = {\"extra\": \"allow\"}\n\n    else:\n\n        class Config:\n            extra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/utils/ExternalDocs/#faststream.asyncapi.schema.utils.ExternalDocs-attributes","title":"Attributes","text":""},{"location":"api/faststream/asyncapi/schema/utils/ExternalDocs/#faststream.asyncapi.schema.utils.ExternalDocs.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/utils/ExternalDocs/#faststream.asyncapi.schema.utils.ExternalDocs.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = {'extra': 'allow'}\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/utils/ExternalDocs/#faststream.asyncapi.schema.utils.ExternalDocs.url","title":"url  <code>instance-attribute</code>","text":"<pre><code>url: AnyHttpUrl\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/utils/ExternalDocs/#faststream.asyncapi.schema.utils.ExternalDocs-classes","title":"Classes","text":""},{"location":"api/faststream/asyncapi/schema/utils/ExternalDocs/#faststream.asyncapi.schema.utils.ExternalDocs.Config","title":"Config","text":"Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/utils.py</code> <pre><code>class Config:\n    extra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/utils/ExternalDocs/#faststream.asyncapi.schema.utils.ExternalDocs.Config-attributes","title":"Attributes","text":""},{"location":"api/faststream/asyncapi/schema/utils/ExternalDocs/#faststream.asyncapi.schema.utils.ExternalDocs.Config.extra","title":"extra  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extra = 'allow'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/utils/ExternalDocsDict/","title":"ExternalDocsDict","text":""},{"location":"api/faststream/asyncapi/schema/utils/ExternalDocsDict/#faststream.asyncapi.schema.utils.ExternalDocsDict","title":"faststream.asyncapi.schema.utils.ExternalDocsDict","text":"<p>             Bases: <code>TypedDict</code></p> <p>A dictionary type for representing external documentation.</p> <p>Attributes:</p> Name Type Description <code>url</code> <p>Required URL for the external documentation</p> <code>description</code> <p>Description of the external documentation</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/utils.py</code> <pre><code>class ExternalDocsDict(TypedDict, total=False):\n\"\"\"A dictionary type for representing external documentation.\n\n    Attributes:\n        url : Required URL for the external documentation\n        description : Description of the external documentation\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    url: Required[AnyHttpUrl]\n    description: str\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/utils/ExternalDocsDict/#faststream.asyncapi.schema.utils.ExternalDocsDict-attributes","title":"Attributes","text":""},{"location":"api/faststream/asyncapi/schema/utils/ExternalDocsDict/#faststream.asyncapi.schema.utils.ExternalDocsDict.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description: str\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/utils/ExternalDocsDict/#faststream.asyncapi.schema.utils.ExternalDocsDict.url","title":"url  <code>instance-attribute</code>","text":"<pre><code>url: Required[AnyHttpUrl]\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/utils/Parameter/","title":"Parameter","text":""},{"location":"api/faststream/asyncapi/schema/utils/Parameter/#faststream.asyncapi.schema.utils.Parameter","title":"faststream.asyncapi.schema.utils.Parameter","text":"<p>             Bases: <code>BaseModel</code></p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/utils.py</code> <pre><code>class Parameter(BaseModel):\n    # TODO\n    ...\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/utils/Reference/","title":"Reference","text":""},{"location":"api/faststream/asyncapi/schema/utils/Reference/#faststream.asyncapi.schema.utils.Reference","title":"faststream.asyncapi.schema.utils.Reference","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent a reference.</p> <p>Attributes:</p> Name Type Description <code>ref</code> <p>the reference string</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/utils.py</code> <pre><code>class Reference(BaseModel):\n\"\"\"A class to represent a reference.\n\n    Attributes:\n        ref : the reference string\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    ref: str = Field(..., alias=\"$ref\")\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/utils/Reference/#faststream.asyncapi.schema.utils.Reference-attributes","title":"Attributes","text":""},{"location":"api/faststream/asyncapi/schema/utils/Reference/#faststream.asyncapi.schema.utils.Reference.ref","title":"ref  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ref: str = Field(..., alias='$ref')\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/utils/Tag/","title":"Tag","text":""},{"location":"api/faststream/asyncapi/schema/utils/Tag/#faststream.asyncapi.schema.utils.Tag","title":"faststream.asyncapi.schema.utils.Tag","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent a tag.</p> <p>Attributes:</p> Name Type Description <code>name</code> <p>name of the tag</p> <code>description</code> <p>description of the tag (optional)</p> <code>externalDocs</code> <p>external documentation for the tag (optional)</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/utils.py</code> <pre><code>class Tag(BaseModel):\n\"\"\"A class to represent a tag.\n\n    Attributes:\n        name : name of the tag\n        description : description of the tag (optional)\n        externalDocs : external documentation for the tag (optional)\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    name: str\n    description: Optional[str] = None\n    externalDocs: Optional[Union[ExternalDocs, ExternalDocsDict]] = None\n\n    if PYDANTIC_V2:\n        model_config = {\"extra\": \"allow\"}\n\n    else:\n\n        class Config:\n            extra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/utils/Tag/#faststream.asyncapi.schema.utils.Tag-attributes","title":"Attributes","text":""},{"location":"api/faststream/asyncapi/schema/utils/Tag/#faststream.asyncapi.schema.utils.Tag.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/utils/Tag/#faststream.asyncapi.schema.utils.Tag.externalDocs","title":"externalDocs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>externalDocs: Optional[\n    Union[ExternalDocs, ExternalDocsDict]\n] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/utils/Tag/#faststream.asyncapi.schema.utils.Tag.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = {'extra': 'allow'}\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/utils/Tag/#faststream.asyncapi.schema.utils.Tag.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/utils/Tag/#faststream.asyncapi.schema.utils.Tag-classes","title":"Classes","text":""},{"location":"api/faststream/asyncapi/schema/utils/Tag/#faststream.asyncapi.schema.utils.Tag.Config","title":"Config","text":"Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/utils.py</code> <pre><code>class Config:\n    extra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/utils/Tag/#faststream.asyncapi.schema.utils.Tag.Config-attributes","title":"Attributes","text":""},{"location":"api/faststream/asyncapi/schema/utils/Tag/#faststream.asyncapi.schema.utils.Tag.Config.extra","title":"extra  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extra = 'allow'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/utils/TagDict/","title":"TagDict","text":""},{"location":"api/faststream/asyncapi/schema/utils/TagDict/#faststream.asyncapi.schema.utils.TagDict","title":"faststream.asyncapi.schema.utils.TagDict","text":"<p>             Bases: <code>TypedDict</code></p> <p>A dictionary-like class for storing tags.</p> <p>Attributes:</p> Name Type Description <code>name</code> <p>required name of the tag</p> <code>description</code> <p>description of the tag</p> <code>externalDocs</code> <p>external documentation for the tag</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/utils.py</code> <pre><code>class TagDict(TypedDict, total=False):\n\"\"\"A dictionary-like class for storing tags.\n\n    Attributes:\n        name : required name of the tag\n        description : description of the tag\n        externalDocs : external documentation for the tag\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    name: Required[str]\n    description: str\n    externalDocs: Union[ExternalDocs, ExternalDocsDict]\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/utils/TagDict/#faststream.asyncapi.schema.utils.TagDict-attributes","title":"Attributes","text":""},{"location":"api/faststream/asyncapi/schema/utils/TagDict/#faststream.asyncapi.schema.utils.TagDict.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description: str\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/utils/TagDict/#faststream.asyncapi.schema.utils.TagDict.externalDocs","title":"externalDocs  <code>instance-attribute</code>","text":"<pre><code>externalDocs: Union[ExternalDocs, ExternalDocsDict]\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/utils/TagDict/#faststream.asyncapi.schema.utils.TagDict.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: Required[str]\n</code></pre>"},{"location":"api/faststream/asyncapi/site/get_asyncapi_html/","title":"get_asyncapi_html","text":""},{"location":"api/faststream/asyncapi/site/get_asyncapi_html/#faststream.asyncapi.site.get_asyncapi_html","title":"faststream.asyncapi.site.get_asyncapi_html","text":"<pre><code>get_asyncapi_html(\n    schema: Schema,\n    sidebar: bool = True,\n    info: bool = True,\n    servers: bool = True,\n    operations: bool = True,\n    messages: bool = True,\n    schemas: bool = True,\n    errors: bool = True,\n    expand_message_examples: bool = True,\n    title: str = \"FastStream\",\n) -&gt; str\n</code></pre> <p>Generate HTML for displaying an AsyncAPI document.</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>Schema</code> <p>The AsyncAPI schema object.</p> required <code>sidebar</code> <code>bool</code> <p>Whether to show the sidebar. Defaults to True.</p> <code>True</code> <code>info</code> <code>bool</code> <p>Whether to show the info section. Defaults to True.</p> <code>True</code> <code>servers</code> <code>bool</code> <p>Whether to show the servers section. Defaults to True.</p> <code>True</code> <code>operations</code> <code>bool</code> <p>Whether to show the operations section. Defaults to True.</p> <code>True</code> <code>messages</code> <code>bool</code> <p>Whether to show the messages section. Defaults to True.</p> <code>True</code> <code>schemas</code> <code>bool</code> <p>Whether to show the schemas section. Defaults to True.</p> <code>True</code> <code>errors</code> <code>bool</code> <p>Whether to show the errors section. Defaults to True.</p> <code>True</code> <code>expand_message_examples</code> <code>bool</code> <p>Whether to expand message examples. Defaults to True.</p> <code>True</code> <code>title</code> <code>str</code> <p>The title of the HTML document. Defaults to \"FastStream\".</p> <code>'FastStream'</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The generated HTML document.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If silent animals are not supported.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/site.py</code> <pre><code>def get_asyncapi_html(\n    schema: \"Schema\",\n    sidebar: bool = True,\n    info: bool = True,\n    servers: bool = True,\n    operations: bool = True,\n    messages: bool = True,\n    schemas: bool = True,\n    errors: bool = True,\n    expand_message_examples: bool = True,\n    title: str = \"FastStream\",\n) -&gt; str:\n\"\"\"Generate HTML for displaying an AsyncAPI document.\n\n    Args:\n        schema (Schema): The AsyncAPI schema object.\n        sidebar (bool, optional): Whether to show the sidebar. Defaults to True.\n        info (bool, optional): Whether to show the info section. Defaults to True.\n        servers (bool, optional): Whether to show the servers section. Defaults to True.\n        operations (bool, optional): Whether to show the operations section. Defaults to True.\n        messages (bool, optional): Whether to show the messages section. Defaults to True.\n        schemas (bool, optional): Whether to show the schemas section. Defaults to True.\n        errors (bool, optional): Whether to show the errors section. Defaults to True.\n        expand_message_examples (bool, optional): Whether to expand message examples. Defaults to True.\n        title (str, optional): The title of the HTML document. Defaults to \"FastStream\".\n\n    Returns:\n        str: The generated HTML document.\n\n    Raises:\n        NotImplementedError: If silent animals are not supported.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    schema_json = schema.to_json()\n\n    config = {\n        \"schema\": schema_json,\n        \"config\": {\n            \"show\": {\n                \"sidebar\": sidebar,\n                \"info\": info,\n                \"servers\": servers,\n                \"operations\": operations,\n                \"messages\": messages,\n                \"schemas\": schemas,\n                \"errors\": errors,\n            },\n            \"expand\": {\n                \"messageExamples\": expand_message_examples,\n            },\n            \"sidebar\": {\n                \"showServers\": \"byDefault\",\n                \"showOperations\": \"byDefault\",\n            },\n        },\n    }\n\n    return (\n\"\"\"\n    &lt;!DOCTYPE html&gt;\n    &lt;html&gt;\n        &lt;head&gt;\n    \"\"\"\n        f\"\"\"\n        &lt;title&gt;{title} AsyncAPI&lt;/title&gt;\n    \"\"\"\n\"\"\"\n        &lt;link rel=\"icon\" href=\"https://www.asyncapi.com/favicon.ico\"&gt;\n        &lt;link rel=\"icon\" type=\"image/png\" sizes=\"16x16\" href=\"https://www.asyncapi.com/favicon-16x16.png\"&gt;\n        &lt;link rel=\"icon\" type=\"image/png\" sizes=\"32x32\" href=\"https://www.asyncapi.com/favicon-32x32.png\"&gt;\n        &lt;link rel=\"icon\" type=\"image/png\" sizes=\"194x194\" href=\"https://www.asyncapi.com/favicon-194x194.png\"&gt;\n        &lt;link rel=\"stylesheet\" href=\"https://unpkg.com/@asyncapi/react-component@1.0.0-next.46/styles/default.min.css\"&gt;\n        &lt;/head&gt;\n\n        &lt;style&gt;\n        html {\n            font-family: ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;\n            line-height: 1.5;\n        }\n        &lt;/style&gt;\n\n        &lt;body&gt;\n        &lt;div id=\"asyncapi\"&gt;&lt;/div&gt;\n\n        &lt;script src=\"https://unpkg.com/@asyncapi/react-component@1.0.0-next.47/browser/standalone/index.js\"&gt;&lt;/script&gt;\n        &lt;script&gt;\n    \"\"\"\n        f\"\"\"\n            AsyncApiStandalone.render({json.dumps(config)}, document.getElementById('asyncapi'));\n    \"\"\"\n\"\"\"\n        &lt;/script&gt;\n        &lt;/body&gt;\n    &lt;/html&gt;\n    \"\"\"\n    )\n</code></pre>"},{"location":"api/faststream/asyncapi/site/serve_app/","title":"serve_app","text":""},{"location":"api/faststream/asyncapi/site/serve_app/#faststream.asyncapi.site.serve_app","title":"faststream.asyncapi.site.serve_app","text":"<pre><code>serve_app(schema: Schema, host: str, port: int) -&gt; None\n</code></pre> <p>Serve the FastAPI application.</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>Schema</code> <p>The schema object representing the API specification.</p> required <code>host</code> <code>str</code> <p>The host address to run the application on.</p> required <code>port</code> <code>int</code> <p>The port number to run the application on.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/site.py</code> <pre><code>def serve_app(\n    schema: \"Schema\",\n    host: str,\n    port: int,\n) -&gt; None:\n\"\"\"Serve the FastAPI application.\n\n    Args:\n        schema: The schema object representing the API specification.\n        host: The host address to run the application on.\n        port: The port number to run the application on.\n\n    Returns:\n        None\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    import uvicorn\n    from fastapi import FastAPI\n    from fastapi.responses import HTMLResponse\n\n    app = FastAPI()\n\n    @app.get(\"/\")\n    def asyncapi(\n        sidebar: bool = True,\n        info: bool = True,\n        servers: bool = True,\n        operations: bool = True,\n        messages: bool = True,\n        schemas: bool = True,\n        errors: bool = True,\n        expandMessageExamples: bool = True,\n    ) -&gt; HTMLResponse:\n\"\"\"Generate an AsyncAPI HTML response.\n\n        Args:\n            sidebar (bool): Whether to include the sidebar. Default is True.\n            info (bool): Whether to include the info section. Default is True.\n            servers (bool): Whether to include the servers section. Default is True.\n            operations (bool): Whether to include the operations section. Default is True.\n            messages (bool): Whether to include the messages section. Default is True.\n            schemas (bool): Whether to include the schemas section. Default is True.\n            errors (bool): Whether to include the errors section. Default is True.\n            expandMessageExamples (bool): Whether to expand message examples. Default is True.\n\n        Returns:\n            HTMLResponse: The generated HTML response.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        return HTMLResponse(\n            content=get_asyncapi_html(\n                schema,\n                sidebar=sidebar,\n                info=info,\n                servers=servers,\n                operations=operations,\n                messages=messages,\n                schemas=schemas,\n                errors=errors,\n                expand_message_examples=expandMessageExamples,\n                title=schema.info.title,\n            )\n        )\n\n    uvicorn.run(app, host=host, port=port)\n</code></pre>"},{"location":"api/faststream/asyncapi/utils/resolve_payloads/","title":"resolve_payloads","text":""},{"location":"api/faststream/asyncapi/utils/resolve_payloads/#faststream.asyncapi.utils.resolve_payloads","title":"faststream.asyncapi.utils.resolve_payloads","text":"<pre><code>resolve_payloads(payloads: List[AnyDict]) -&gt; AnyDict\n</code></pre> <p>Resolve payloads.</p> <p>Parameters:</p> Name Type Description Default <code>payloads</code> <code>List[AnyDict]</code> <p>A list of dictionaries representing payloads.</p> required <p>Returns:</p> Type Description <code>AnyDict</code> <p>A dictionary representing the resolved payload.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/utils.py</code> <pre><code>def resolve_payloads(payloads: List[AnyDict]) -&gt; AnyDict:\n\"\"\"Resolve payloads.\n\n    Args:\n        payloads: A list of dictionaries representing payloads.\n\n    Returns:\n        A dictionary representing the resolved payload.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    ln = len(payloads)\n    payload: AnyDict\n    if ln &gt; 1:\n        payload = {\"oneOf\": {body[\"title\"]: body for body in payloads}}\n    elif ln == 1:\n        payload = payloads[0]\n    else:\n        payload = {}\n    return payload\n</code></pre>"},{"location":"api/faststream/asyncapi/utils/to_camelcase/","title":"to_camelcase","text":""},{"location":"api/faststream/asyncapi/utils/to_camelcase/#faststream.asyncapi.utils.to_camelcase","title":"faststream.asyncapi.utils.to_camelcase","text":"<pre><code>to_camelcase(*names: str) -&gt; str\n</code></pre> <p>Converts a list of names to camel case.</p> <p>Parameters:</p> Name Type Description Default <code>*names</code> <code>str</code> <p>Variable length list of names to be converted to camel case.</p> <code>()</code> <p>Returns:</p> Type Description <code>str</code> <p>The camel case representation of the names.</p> Example <p>to_camelcase(\"hello_world\") \"HelloWorld\"</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/utils.py</code> <pre><code>def to_camelcase(*names: str) -&gt; str:\n\"\"\"Converts a list of names to camel case.\n\n    Args:\n        *names: Variable length list of names to be converted to camel case.\n\n    Returns:\n        The camel case representation of the names.\n\n    Example:\n        &gt;&gt;&gt; to_camelcase(\"hello_world\")\n        \"HelloWorld\"\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    return \" \".join(names).replace(\"_\", \" \").title().replace(\" \", \"\")\n</code></pre>"},{"location":"api/faststream/broker/core/abc/BrokerUsecase/","title":"BrokerUsecase","text":""},{"location":"api/faststream/broker/core/abc/BrokerUsecase/#faststream.broker.core.abc.BrokerUsecase","title":"faststream.broker.core.abc.BrokerUsecase","text":"<p>             Bases: <code>ABC</code>, <code>Generic[MsgType, ConnectionType]</code>, <code>LoggingMixin</code></p> <p>A class representing a broker use case.</p> <p>Attributes:</p> Name Type Description <code>logger</code> <p>optional logger object</p> <code>log_level</code> <p>log level</p> <code>handlers</code> <p>dictionary of handlers</p> <code>_publishers</code> <p>dictionary of publishers</p> <code>dependencies</code> <p>sequence of dependencies</p> <code>started</code> <p>boolean indicating if the broker has started</p> <code>middlewares</code> <p>sequence of middleware functions</p> <code>_global_parser</code> <p>optional custom parser object</p> <code>_global_decoder</code> <p>optional custom decoder object</p> <code>_connection</code> <p>optional connection object</p> <code>_fmt</code> <p>optional string format</p> <p>Methods:</p> Name Description <code>__init__ </code> <p>constructor method</p> <code>include_router </code> <p>include a router in the broker</p> <code>include_routers </code> <p>include multiple routers in the broker</p> <code>_resolve_connection_kwargs </code> <p>resolve connection kwargs</p> <code>_wrap_handler </code> <p>wrap a handler function</p> <code>_abc_start </code> <p>start the broker</p> <code>_abc_close </code> <p>close the broker</p> <code>_abc__close </code> <p>close the broker connection</p> <code>_process_message </code> <p>process a message</p> <code>subscriber </code> <p>decorator to register a subscriber</p> <code>publisher </code> <p>register a publisher</p> <code>_wrap_decode_message </code> <p>wrap a message decoding function</p> <code>_log_execution </code> <p>log the execution of a function</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/core/abc.py</code> <pre><code>class BrokerUsecase(\n    ABC,\n    Generic[MsgType, ConnectionType],\n    LoggingMixin,\n):\n\"\"\"A class representing a broker use case.\n\n    Attributes:\n        logger : optional logger object\n        log_level : log level\n        handlers : dictionary of handlers\n        _publishers : dictionary of publishers\n        dependencies : sequence of dependencies\n        started : boolean indicating if the broker has started\n        middlewares : sequence of middleware functions\n        _global_parser : optional custom parser object\n        _global_decoder : optional custom decoder object\n        _connection : optional connection object\n        _fmt : optional string format\n\n    Methods:\n        __init__ : constructor method\n        include_router : include a router in the broker\n        include_routers : include multiple routers in the broker\n        _resolve_connection_kwargs : resolve connection kwargs\n        _wrap_handler : wrap a handler function\n        _abc_start : start the broker\n        _abc_close : close the broker\n        _abc__close : close the broker connection\n        _process_message : process a message\n        subscriber : decorator to register a subscriber\n        publisher : register a publisher\n        _wrap_decode_message : wrap a message decoding function\n        _log_execution : log the execution of a function\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    logger: Optional[logging.Logger]\n    log_level: int\n    handlers: Dict[Any, BaseHandler[MsgType]]\n    _publishers: Dict[Any, BasePublisher[MsgType]]\n\n    dependencies: Sequence[Depends]\n    started: bool\n    middlewares: Sequence[Callable[[Any], BaseMiddleware]]\n    _global_parser: Optional[CustomParser[MsgType]]\n    _global_decoder: Optional[CustomDecoder[MsgType]]\n    _connection: Optional[ConnectionType]\n    _fmt: Optional[str]\n\n    def __init__(\n        self,\n        url: Union[str, List[str]],\n        *args: Any,\n        # AsyncAPI kwargs\n        protocol: str,\n        protocol_version: Optional[str] = None,\n        description: Optional[str] = None,\n        tags: Optional[Sequence[Union[asyncapi.Tag, asyncapi.TagDict]]] = None,\n        # broker kwargs\n        apply_types: bool = True,\n        logger: Optional[logging.Logger] = access_logger,\n        log_level: int = logging.INFO,\n        log_fmt: Optional[str] = \"%(asctime)s %(levelname)s - %(message)s\",\n        dependencies: Sequence[Depends] = (),\n        middlewares: Optional[Sequence[Callable[[MsgType], BaseMiddleware]]] = None,\n        decoder: Optional[CustomDecoder[MsgType]] = None,\n        parser: Optional[CustomParser[MsgType]] = None,\n        security: Optional[BaseSecurity] = None,\n        **kwargs: Any,\n    ) -&gt; None:\n\"\"\"Initialize a broker.\n\n        Args:\n            url: The URL or list of URLs to connect to.\n            *args: Additional arguments.\n            protocol: The protocol to use for the connection.\n            protocol_version: The version of the protocol.\n            description: A description of the broker.\n            tags: Tags associated with the broker.\n            apply_types: Whether to apply types to messages.\n            logger: The logger to use.\n            log_level: The log level to use.\n            log_fmt: The log format to use.\n            dependencies: Dependencies of the broker.\n            middlewares: Middlewares to use.\n            decoder: Custom decoder for messages.\n            parser: Custom parser for messages.\n            **kwargs: Additional keyword arguments.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        super().__init__(\n            logger=logger,\n            log_level=log_level,\n            log_fmt=log_fmt,\n        )\n\n        self._connection = None\n        self._is_apply_types = apply_types\n        self.handlers = {}\n        self._publishers = {}\n        empty_middleware: Sequence[Callable[[MsgType], BaseMiddleware]] = ()\n        midd_args: Sequence[Callable[[MsgType], BaseMiddleware]] = (\n            middlewares or empty_middleware\n        )\n        self.middlewares = [CriticalLogMiddleware(logger), *midd_args]  # type: ignore\n        self.dependencies = dependencies\n\n        self._connection_args = args\n        self._connection_kwargs = kwargs\n\n        self._global_parser = parser\n        self._global_decoder = decoder\n\n        context.set_global(\"logger\", logger)\n        context.set_global(\"broker\", self)\n\n        self.started = False\n\n        # AsyncAPI information\n        self.url = url\n        self.protocol = protocol\n        self.protocol_version = protocol_version\n        self.description = description\n        self.tags = tags\n        self.security = security\n\n    def include_router(self, router: BrokerRouter[Any, MsgType]) -&gt; None:\n\"\"\"Includes a router in the current object.\n\n        Args:\n            router: The router to be included.\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        for r in router._handlers:\n            self.subscriber(*r.args, **r.kwargs)(r.call)\n\n        self._publishers.update(router._publishers)\n\n    def include_routers(self, *routers: BrokerRouter[Any, MsgType]) -&gt; None:\n\"\"\"Includes routers in the current object.\n\n        Args:\n            *routers: Variable length argument list of routers to include.\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        for r in routers:\n            self.include_router(r)\n\n    def _resolve_connection_kwargs(self, *args: Any, **kwargs: Any) -&gt; AnyDict:\n\"\"\"Resolve connection keyword arguments.\n\n        Args:\n            *args: Positional arguments passed to the function.\n            **kwargs: Keyword arguments passed to the function.\n\n        Returns:\n            A dictionary containing the resolved connection keyword arguments.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        arguments = get_function_positional_arguments(self.__init__)  # type: ignore\n        init_kwargs = {\n            **self._connection_kwargs,\n            **dict(zip(arguments, self._connection_args)),\n        }\n\n        connect_kwargs = {\n            **kwargs,\n            **dict(zip(arguments, args)),\n        }\n        return {**init_kwargs, **connect_kwargs}\n\n    def _wrap_handler(\n        self,\n        func: Union[\n            HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn],\n            Callable[P_HandlerParams, T_HandlerReturn],\n        ],\n        *,\n        retry: Union[bool, int] = False,\n        extra_dependencies: Sequence[Depends] = (),\n        _raw: bool = False,\n        _get_dependant: Optional[Any] = None,\n        **broker_log_context_kwargs: Any,\n    ) -&gt; Tuple[\n        HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn],\n        Union[\n            CallModel[P_HandlerParams, T_HandlerReturn],\n            CallModel[P_HandlerParams, Awaitable[T_HandlerReturn]],\n        ],\n    ]:\n\"\"\"Wrap a handler function.\n\n        Args:\n            func: The handler function to wrap.\n            retry: Whether to retry the handler function if it fails. Can be a boolean or an integer specifying the number of retries.\n            extra_dependencies: Additional dependencies for the handler function.\n            _raw: Whether to use the raw handler function.\n            _get_dependant: The dependant function to use.\n            **broker_log_context_kwargs: Additional keyword arguments for the broker log context.\n\n        Returns:\n            A tuple containing the wrapped handler function and the call model.\n\n        Raises:\n            NotImplementedError: If silent animals are not supported.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        build_dep = cast(\n            Callable[[Callable[F_Spec, F_Return]], CallModel[F_Spec, F_Return]],\n            _get_dependant or build_call_model,\n        )\n\n        if isinstance(func, HandlerCallWrapper):\n            handler_call, func = func, func._original_call\n            if handler_call._wrapped_call is not None:\n                return handler_call, build_dep(func)\n        else:\n            handler_call = HandlerCallWrapper(func)\n\n        f = to_async(func)\n\n        dependant = build_dep(f)\n\n        extra = [\n            build_dep(d.dependency)\n            for d in chain(extra_dependencies, self.dependencies)\n        ]\n\n        extend_dependencies(extra, dependant)\n\n        if getattr(dependant, \"flat_params\", None) is None:  # handle FastAPI Dependant\n            dependant = _patch_fastapi_dependant(dependant)\n\n        if self._is_apply_types is True:\n            apply_wrapper: _InjectWrapper[\n                P_HandlerParams, Awaitable[T_HandlerReturn]\n            ] = apply_types(None)\n            f = apply_wrapper(f, dependant)\n\n        decode_f = self._wrap_decode_message(\n            func=f,\n            _raw=_raw,\n            params=set(\n                chain(\n                    dependant.flat_params.keys(), *(d.flat_params.keys() for d in extra)\n                )\n            ),\n        )\n\n        process_f = self._process_message(\n            func=decode_f,\n            watcher=get_watcher(self.logger, retry),\n        )\n\n        if self.logger is not None:\n            process_f = self._log_execution(process_f, **broker_log_context_kwargs)\n\n        process_f = set_message_context(process_f)\n\n        handler_call.set_wrapped(process_f)\n        return handler_call, dependant\n\n    def _abc_start(self) -&gt; None:\n        self.started = True\n\n        for h in self.handlers.values():\n            h.global_middlewares = (*self.middlewares, *h.global_middlewares)\n\n        if self.logger is not None:\n            change_logger_handlers(self.logger, self.fmt)\n\n    def _abc_close(\n        self,\n        exc_type: Optional[Type[BaseException]] = None,\n        exc_val: Optional[BaseException] = None,\n        exec_tb: Optional[TracebackType] = None,\n    ) -&gt; None:\n\"\"\"Closes the ABC.\n\n        Args:\n            exc_type: The exception type\n            exc_val: The exception value\n            exec_tb: The traceback\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        self.started = False\n\n    def _abc__close(\n        self,\n        exc_type: Optional[Type[BaseException]] = None,\n        exc_val: Optional[BaseException] = None,\n        exec_tb: Optional[TracebackType] = None,\n    ) -&gt; None:\n\"\"\"Closes the connection.\n\n        Args:\n            exc_type: The type of the exception being handled (optional)\n            exc_val: The exception instance being handled (optional)\n            exec_tb: The traceback for the exception being handled (optional)\n\n        Returns:\n            None\n\n        Note:\n            This is an abstract method and must be implemented by subclasses.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        self._connection = None\n\n    @abstractmethod\n    def _process_message(\n        self,\n        func: Callable[[StreamMessage[MsgType]], Awaitable[T_HandlerReturn]],\n        watcher: BaseWatcher,\n    ) -&gt; Callable[[StreamMessage[MsgType]], Awaitable[WrappedReturn[T_HandlerReturn]],]:\n\"\"\"Processes a message using a given function and watcher.\n\n        Args:\n            func: A callable that takes a StreamMessage of type MsgType and returns an Awaitable of type T_HandlerReturn.\n            watcher: An instance of BaseWatcher.\n\n        Returns:\n            A callable that takes a StreamMessage of type MsgType and returns an Awaitable of type WrappedReturn[T_HandlerReturn].\n\n        Raises:\n            NotImplementedError: If the method is not implemented.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        raise NotImplementedError()\n\n    @abstractmethod\n    def subscriber(  # type: ignore[return]\n        self,\n        *broker_args: Any,\n        retry: Union[bool, int] = False,\n        dependencies: Sequence[Depends] = (),\n        decoder: Optional[CustomDecoder[MsgType]] = None,\n        parser: Optional[CustomParser[MsgType]] = None,\n        middlewares: Optional[\n            Sequence[\n                Callable[\n                    [StreamMessage[MsgType]],\n                    BaseMiddleware,\n                ]\n            ]\n        ] = None,\n        filter: Filter[StreamMessage[MsgType]] = lambda m: not m.processed,\n        _raw: bool = False,\n        _get_dependant: Optional[Any] = None,\n        **broker_kwargs: Any,\n    ) -&gt; Callable[\n        [\n            Union[\n                Callable[P_HandlerParams, T_HandlerReturn],\n                HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn],\n            ]\n        ],\n        HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn],\n    ]:\n\"\"\"This is a function decorator for subscribing to a message broker.\n\n        Args:\n            *broker_args: Positional arguments to be passed to the broker.\n            retry: Whether to retry the subscription if it fails. Can be a boolean or an integer specifying the number of retries.\n            dependencies: Sequence of dependencies to be injected into the handler function.\n            decoder: Custom decoder function to decode the message.\n            parser: Custom parser function to parse the decoded message.\n            middlewares: Sequence of middleware functions to be applied to the message.\n            filter: Filter function to filter the messages to be processed.\n            _raw: Whether to return the raw message instead of the processed message.\n            _get_dependant: Optional parameter to get the dependant object.\n            **broker_kwargs: Keyword arguments to be passed to the broker.\n\n        Returns:\n            A callable object that can be used as a decorator for a handler function.\n\n        Raises:\n            RuntimeWarning: If the broker is already running.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        if self.started:\n            warnings.warn(\n                \"You are trying to register `handler` with already running broker\\n\"  # noqa: E501\n                \"It has no effect until broker restarting.\",  # noqa: E501\n                category=RuntimeWarning,\n                stacklevel=1,\n            )\n\n    @abstractmethod\n    def publisher(\n        self,\n        key: Any,\n        publisher: BasePublisher[MsgType],\n    ) -&gt; BasePublisher[MsgType]:\n\"\"\"Publishes a publisher.\n\n        Args:\n            key: The key associated with the publisher.\n            publisher: The publisher to be published.\n\n        Returns:\n            The published publisher.\n\n        Raises:\n            NotImplementedError: If the method is not implemented.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        self._publishers[key] = publisher\n        return publisher\n\n    @abstractmethod\n    def _wrap_decode_message(\n        self,\n        func: Callable[..., Awaitable[T_HandlerReturn]],\n        params: Sized = (),\n        _raw: bool = False,\n    ) -&gt; Callable[[StreamMessage[MsgType]], Awaitable[T_HandlerReturn]]:\n\"\"\"Wrap a decoding message function.\n\n        Args:\n            func: The function to wrap.\n            params: The parameters to pass to the function.\n            _raw: Whether to return the raw message or not.\n\n        Returns:\n            The wrapped function.\n\n        Raises:\n            NotImplementedError: If the method is not implemented.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        raise NotImplementedError()\n\n    @abstractmethod\n    def _log_execution(\n        self,\n        func: Callable[\n            [StreamMessage[MsgType]],\n            Awaitable[WrappedReturn[T_HandlerReturn]],\n        ],\n        **broker_args: Any,\n    ) -&gt; Callable[[StreamMessage[MsgType]], Awaitable[WrappedReturn[T_HandlerReturn]],]:\n\"\"\"Log the execution of a function.\n\n        Args:\n            func: The function to be logged.\n            **broker_args: Additional arguments to be passed to the function.\n\n        Returns:\n            A decorated version of the function that logs its execution.\n\n        Raises:\n            NotImplementedError: If the function is not implemented.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        raise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/broker/core/abc/BrokerUsecase/#faststream.broker.core.abc.BrokerUsecase-attributes","title":"Attributes","text":""},{"location":"api/faststream/broker/core/abc/BrokerUsecase/#faststream.broker.core.abc.BrokerUsecase.dependencies","title":"dependencies  <code>instance-attribute</code>","text":"<pre><code>dependencies: Sequence[Depends] = dependencies\n</code></pre>"},{"location":"api/faststream/broker/core/abc/BrokerUsecase/#faststream.broker.core.abc.BrokerUsecase.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description = description\n</code></pre>"},{"location":"api/faststream/broker/core/abc/BrokerUsecase/#faststream.broker.core.abc.BrokerUsecase.handlers","title":"handlers  <code>instance-attribute</code>","text":"<pre><code>handlers: Dict[Any, BaseHandler[MsgType]] = {}\n</code></pre>"},{"location":"api/faststream/broker/core/abc/BrokerUsecase/#faststream.broker.core.abc.BrokerUsecase.log_level","title":"log_level  <code>instance-attribute</code>","text":"<pre><code>log_level: int\n</code></pre>"},{"location":"api/faststream/broker/core/abc/BrokerUsecase/#faststream.broker.core.abc.BrokerUsecase.logger","title":"logger  <code>instance-attribute</code>","text":"<pre><code>logger: Optional[logging.Logger]\n</code></pre>"},{"location":"api/faststream/broker/core/abc/BrokerUsecase/#faststream.broker.core.abc.BrokerUsecase.middlewares","title":"middlewares  <code>instance-attribute</code>","text":"<pre><code>middlewares: Sequence[Callable[[Any], BaseMiddleware]] = [\n    CriticalLogMiddleware(logger),\n    *midd_args,\n]\n</code></pre>"},{"location":"api/faststream/broker/core/abc/BrokerUsecase/#faststream.broker.core.abc.BrokerUsecase.protocol","title":"protocol  <code>instance-attribute</code>","text":"<pre><code>protocol = protocol\n</code></pre>"},{"location":"api/faststream/broker/core/abc/BrokerUsecase/#faststream.broker.core.abc.BrokerUsecase.protocol_version","title":"protocol_version  <code>instance-attribute</code>","text":"<pre><code>protocol_version = protocol_version\n</code></pre>"},{"location":"api/faststream/broker/core/abc/BrokerUsecase/#faststream.broker.core.abc.BrokerUsecase.security","title":"security  <code>instance-attribute</code>","text":"<pre><code>security = security\n</code></pre>"},{"location":"api/faststream/broker/core/abc/BrokerUsecase/#faststream.broker.core.abc.BrokerUsecase.started","title":"started  <code>instance-attribute</code>","text":"<pre><code>started: bool = False\n</code></pre>"},{"location":"api/faststream/broker/core/abc/BrokerUsecase/#faststream.broker.core.abc.BrokerUsecase.tags","title":"tags  <code>instance-attribute</code>","text":"<pre><code>tags = tags\n</code></pre>"},{"location":"api/faststream/broker/core/abc/BrokerUsecase/#faststream.broker.core.abc.BrokerUsecase.url","title":"url  <code>instance-attribute</code>","text":"<pre><code>url = url\n</code></pre>"},{"location":"api/faststream/broker/core/abc/BrokerUsecase/#faststream.broker.core.abc.BrokerUsecase-functions","title":"Functions","text":""},{"location":"api/faststream/broker/core/abc/BrokerUsecase/#faststream.broker.core.abc.BrokerUsecase.__init__","title":"__init__","text":"<pre><code>__init__(\n    url: Union[str, List[str]],\n    *args: Any,\n    protocol: str,\n    protocol_version: Optional[str] = None,\n    description: Optional[str] = None,\n    tags: Optional[\n        Sequence[Union[asyncapi.Tag, asyncapi.TagDict]]\n    ] = None,\n    apply_types: bool = True,\n    logger: Optional[logging.Logger] = access_logger,\n    log_level: int = logging.INFO,\n    log_fmt: Optional[\n        str\n    ] = \"%(asctime)s %(levelname)s - %(message)s\",\n    dependencies: Sequence[Depends] = (),\n    middlewares: Optional[\n        Sequence[Callable[[MsgType], BaseMiddleware]]\n    ] = None,\n    decoder: Optional[CustomDecoder[MsgType]] = None,\n    parser: Optional[CustomParser[MsgType]] = None,\n    security: Optional[BaseSecurity] = None,\n    **kwargs: Any\n) -&gt; None\n</code></pre> <p>Initialize a broker.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>Union[str, List[str]]</code> <p>The URL or list of URLs to connect to.</p> required <code>*args</code> <code>Any</code> <p>Additional arguments.</p> <code>()</code> <code>protocol</code> <code>str</code> <p>The protocol to use for the connection.</p> required <code>protocol_version</code> <code>Optional[str]</code> <p>The version of the protocol.</p> <code>None</code> <code>description</code> <code>Optional[str]</code> <p>A description of the broker.</p> <code>None</code> <code>tags</code> <code>Optional[Sequence[Union[Tag, TagDict]]]</code> <p>Tags associated with the broker.</p> <code>None</code> <code>apply_types</code> <code>bool</code> <p>Whether to apply types to messages.</p> <code>True</code> <code>logger</code> <code>Optional[Logger]</code> <p>The logger to use.</p> <code>access_logger</code> <code>log_level</code> <code>int</code> <p>The log level to use.</p> <code>INFO</code> <code>log_fmt</code> <code>Optional[str]</code> <p>The log format to use.</p> <code>'%(asctime)s %(levelname)s - %(message)s'</code> <code>dependencies</code> <code>Sequence[Depends]</code> <p>Dependencies of the broker.</p> <code>()</code> <code>middlewares</code> <code>Optional[Sequence[Callable[[MsgType], BaseMiddleware]]]</code> <p>Middlewares to use.</p> <code>None</code> <code>decoder</code> <code>Optional[CustomDecoder[MsgType]]</code> <p>Custom decoder for messages.</p> <code>None</code> <code>parser</code> <code>Optional[CustomParser[MsgType]]</code> <p>Custom parser for messages.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/core/abc.py</code> <pre><code>def __init__(\n    self,\n    url: Union[str, List[str]],\n    *args: Any,\n    # AsyncAPI kwargs\n    protocol: str,\n    protocol_version: Optional[str] = None,\n    description: Optional[str] = None,\n    tags: Optional[Sequence[Union[asyncapi.Tag, asyncapi.TagDict]]] = None,\n    # broker kwargs\n    apply_types: bool = True,\n    logger: Optional[logging.Logger] = access_logger,\n    log_level: int = logging.INFO,\n    log_fmt: Optional[str] = \"%(asctime)s %(levelname)s - %(message)s\",\n    dependencies: Sequence[Depends] = (),\n    middlewares: Optional[Sequence[Callable[[MsgType], BaseMiddleware]]] = None,\n    decoder: Optional[CustomDecoder[MsgType]] = None,\n    parser: Optional[CustomParser[MsgType]] = None,\n    security: Optional[BaseSecurity] = None,\n    **kwargs: Any,\n) -&gt; None:\n\"\"\"Initialize a broker.\n\n    Args:\n        url: The URL or list of URLs to connect to.\n        *args: Additional arguments.\n        protocol: The protocol to use for the connection.\n        protocol_version: The version of the protocol.\n        description: A description of the broker.\n        tags: Tags associated with the broker.\n        apply_types: Whether to apply types to messages.\n        logger: The logger to use.\n        log_level: The log level to use.\n        log_fmt: The log format to use.\n        dependencies: Dependencies of the broker.\n        middlewares: Middlewares to use.\n        decoder: Custom decoder for messages.\n        parser: Custom parser for messages.\n        **kwargs: Additional keyword arguments.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    super().__init__(\n        logger=logger,\n        log_level=log_level,\n        log_fmt=log_fmt,\n    )\n\n    self._connection = None\n    self._is_apply_types = apply_types\n    self.handlers = {}\n    self._publishers = {}\n    empty_middleware: Sequence[Callable[[MsgType], BaseMiddleware]] = ()\n    midd_args: Sequence[Callable[[MsgType], BaseMiddleware]] = (\n        middlewares or empty_middleware\n    )\n    self.middlewares = [CriticalLogMiddleware(logger), *midd_args]  # type: ignore\n    self.dependencies = dependencies\n\n    self._connection_args = args\n    self._connection_kwargs = kwargs\n\n    self._global_parser = parser\n    self._global_decoder = decoder\n\n    context.set_global(\"logger\", logger)\n    context.set_global(\"broker\", self)\n\n    self.started = False\n\n    # AsyncAPI information\n    self.url = url\n    self.protocol = protocol\n    self.protocol_version = protocol_version\n    self.description = description\n    self.tags = tags\n    self.security = security\n</code></pre>"},{"location":"api/faststream/broker/core/abc/BrokerUsecase/#faststream.broker.core.abc.BrokerUsecase.include_router","title":"include_router","text":"<pre><code>include_router(router: BrokerRouter[Any, MsgType]) -&gt; None\n</code></pre> <p>Includes a router in the current object.</p> <p>Parameters:</p> Name Type Description Default <code>router</code> <code>BrokerRouter[Any, MsgType]</code> <p>The router to be included.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/core/abc.py</code> <pre><code>def include_router(self, router: BrokerRouter[Any, MsgType]) -&gt; None:\n\"\"\"Includes a router in the current object.\n\n    Args:\n        router: The router to be included.\n\n    Returns:\n        None\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    for r in router._handlers:\n        self.subscriber(*r.args, **r.kwargs)(r.call)\n\n    self._publishers.update(router._publishers)\n</code></pre>"},{"location":"api/faststream/broker/core/abc/BrokerUsecase/#faststream.broker.core.abc.BrokerUsecase.include_routers","title":"include_routers","text":"<pre><code>include_routers(\n    *routers: BrokerRouter[Any, MsgType]\n) -&gt; None\n</code></pre> <p>Includes routers in the current object.</p> <p>Parameters:</p> Name Type Description Default <code>*routers</code> <code>BrokerRouter[Any, MsgType]</code> <p>Variable length argument list of routers to include.</p> <code>()</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/core/abc.py</code> <pre><code>def include_routers(self, *routers: BrokerRouter[Any, MsgType]) -&gt; None:\n\"\"\"Includes routers in the current object.\n\n    Args:\n        *routers: Variable length argument list of routers to include.\n\n    Returns:\n        None\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    for r in routers:\n        self.include_router(r)\n</code></pre>"},{"location":"api/faststream/broker/core/abc/BrokerUsecase/#faststream.broker.core.abc.BrokerUsecase.publisher","title":"publisher  <code>abstractmethod</code>","text":"<pre><code>publisher(\n    key: Any, publisher: BasePublisher[MsgType]\n) -&gt; BasePublisher[MsgType]\n</code></pre> <p>Publishes a publisher.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Any</code> <p>The key associated with the publisher.</p> required <code>publisher</code> <code>BasePublisher[MsgType]</code> <p>The publisher to be published.</p> required <p>Returns:</p> Type Description <code>BasePublisher[MsgType]</code> <p>The published publisher.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the method is not implemented.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/core/abc.py</code> <pre><code>@abstractmethod\ndef publisher(\n    self,\n    key: Any,\n    publisher: BasePublisher[MsgType],\n) -&gt; BasePublisher[MsgType]:\n\"\"\"Publishes a publisher.\n\n    Args:\n        key: The key associated with the publisher.\n        publisher: The publisher to be published.\n\n    Returns:\n        The published publisher.\n\n    Raises:\n        NotImplementedError: If the method is not implemented.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    self._publishers[key] = publisher\n    return publisher\n</code></pre>"},{"location":"api/faststream/broker/core/abc/BrokerUsecase/#faststream.broker.core.abc.BrokerUsecase.subscriber","title":"subscriber  <code>abstractmethod</code>","text":"<pre><code>subscriber(\n    *broker_args: Any,\n    retry: Union[bool, int] = False,\n    dependencies: Sequence[Depends] = (),\n    decoder: Optional[CustomDecoder[MsgType]] = None,\n    parser: Optional[CustomParser[MsgType]] = None,\n    middlewares: Optional[\n        Sequence[\n            Callable[\n                [StreamMessage[MsgType]], BaseMiddleware\n            ]\n        ]\n    ] = None,\n    filter: Filter[\n        StreamMessage[MsgType]\n    ] = lambda: not m.processed,\n    _raw: bool = False,\n    _get_dependant: Optional[Any] = None,\n    **broker_kwargs: Any\n) -&gt; Callable[\n    [\n        Union[\n            Callable[P_HandlerParams, T_HandlerReturn],\n            HandlerCallWrapper[\n                MsgType, P_HandlerParams, T_HandlerReturn\n            ],\n        ]\n    ],\n    HandlerCallWrapper[\n        MsgType, P_HandlerParams, T_HandlerReturn\n    ],\n]\n</code></pre> <p>This is a function decorator for subscribing to a message broker.</p> <p>Parameters:</p> Name Type Description Default <code>*broker_args</code> <code>Any</code> <p>Positional arguments to be passed to the broker.</p> <code>()</code> <code>retry</code> <code>Union[bool, int]</code> <p>Whether to retry the subscription if it fails. Can be a boolean or an integer specifying the number of retries.</p> <code>False</code> <code>dependencies</code> <code>Sequence[Depends]</code> <p>Sequence of dependencies to be injected into the handler function.</p> <code>()</code> <code>decoder</code> <code>Optional[CustomDecoder[MsgType]]</code> <p>Custom decoder function to decode the message.</p> <code>None</code> <code>parser</code> <code>Optional[CustomParser[MsgType]]</code> <p>Custom parser function to parse the decoded message.</p> <code>None</code> <code>middlewares</code> <code>Optional[Sequence[Callable[[StreamMessage[MsgType]], BaseMiddleware]]]</code> <p>Sequence of middleware functions to be applied to the message.</p> <code>None</code> <code>filter</code> <code>Filter[StreamMessage[MsgType]]</code> <p>Filter function to filter the messages to be processed.</p> <code>lambda : not processed</code> <code>_raw</code> <code>bool</code> <p>Whether to return the raw message instead of the processed message.</p> <code>False</code> <code>_get_dependant</code> <code>Optional[Any]</code> <p>Optional parameter to get the dependant object.</p> <code>None</code> <code>**broker_kwargs</code> <code>Any</code> <p>Keyword arguments to be passed to the broker.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Callable[[Union[Callable[P_HandlerParams, T_HandlerReturn], HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn]]], HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn]]</code> <p>A callable object that can be used as a decorator for a handler function.</p> <p>Raises:</p> Type Description <code>RuntimeWarning</code> <p>If the broker is already running.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/core/abc.py</code> <pre><code>@abstractmethod\ndef subscriber(  # type: ignore[return]\n    self,\n    *broker_args: Any,\n    retry: Union[bool, int] = False,\n    dependencies: Sequence[Depends] = (),\n    decoder: Optional[CustomDecoder[MsgType]] = None,\n    parser: Optional[CustomParser[MsgType]] = None,\n    middlewares: Optional[\n        Sequence[\n            Callable[\n                [StreamMessage[MsgType]],\n                BaseMiddleware,\n            ]\n        ]\n    ] = None,\n    filter: Filter[StreamMessage[MsgType]] = lambda m: not m.processed,\n    _raw: bool = False,\n    _get_dependant: Optional[Any] = None,\n    **broker_kwargs: Any,\n) -&gt; Callable[\n    [\n        Union[\n            Callable[P_HandlerParams, T_HandlerReturn],\n            HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn],\n        ]\n    ],\n    HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn],\n]:\n\"\"\"This is a function decorator for subscribing to a message broker.\n\n    Args:\n        *broker_args: Positional arguments to be passed to the broker.\n        retry: Whether to retry the subscription if it fails. Can be a boolean or an integer specifying the number of retries.\n        dependencies: Sequence of dependencies to be injected into the handler function.\n        decoder: Custom decoder function to decode the message.\n        parser: Custom parser function to parse the decoded message.\n        middlewares: Sequence of middleware functions to be applied to the message.\n        filter: Filter function to filter the messages to be processed.\n        _raw: Whether to return the raw message instead of the processed message.\n        _get_dependant: Optional parameter to get the dependant object.\n        **broker_kwargs: Keyword arguments to be passed to the broker.\n\n    Returns:\n        A callable object that can be used as a decorator for a handler function.\n\n    Raises:\n        RuntimeWarning: If the broker is already running.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    if self.started:\n        warnings.warn(\n            \"You are trying to register `handler` with already running broker\\n\"  # noqa: E501\n            \"It has no effect until broker restarting.\",  # noqa: E501\n            category=RuntimeWarning,\n            stacklevel=1,\n        )\n</code></pre>"},{"location":"api/faststream/broker/core/abc/extend_dependencies/","title":"extend_dependencies","text":""},{"location":"api/faststream/broker/core/abc/extend_dependencies/#faststream.broker.core.abc.extend_dependencies","title":"faststream.broker.core.abc.extend_dependencies","text":"<pre><code>extend_dependencies(\n    extra: Sequence[CallModel[Any, Any]],\n    dependant: CallModel[Any, Any],\n) -&gt; CallModel[Any, Any]\n</code></pre> <p>Extends the dependencies of a function or FastAPI dependency.</p> <p>Parameters:</p> Name Type Description Default <code>extra</code> <code>Sequence[CallModel[Any, Any]]</code> <p>Additional dependencies to be added.</p> required <code>dependant</code> <code>CallModel[Any, Any]</code> <p>The function or FastAPI dependency whose dependencies will be extended.</p> required <p>Returns:</p> Type Description <code>CallModel[Any, Any]</code> <p>The updated function or FastAPI dependency.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/core/abc.py</code> <pre><code>def extend_dependencies(\n    extra: Sequence[CallModel[Any, Any]], dependant: CallModel[Any, Any]\n) -&gt; CallModel[Any, Any]:\n\"\"\"Extends the dependencies of a function or FastAPI dependency.\n\n    Args:\n        extra: Additional dependencies to be added.\n        dependant: The function or FastAPI dependency whose dependencies will be extended.\n\n    Returns:\n        The updated function or FastAPI dependency.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    if isinstance(dependant, CallModel):\n        dependant.extra_dependencies = (*dependant.extra_dependencies, *extra)\n    else:  # FastAPI dependencies\n        dependant.dependencies.extend(extra)\n    return dependant\n</code></pre>"},{"location":"api/faststream/broker/core/asyncronous/BrokerAsyncUsecase/","title":"BrokerAsyncUsecase","text":""},{"location":"api/faststream/broker/core/asyncronous/BrokerAsyncUsecase/#faststream.broker.core.asyncronous.BrokerAsyncUsecase","title":"faststream.broker.core.asyncronous.BrokerAsyncUsecase","text":"<p>             Bases: <code>BrokerUsecase[MsgType, ConnectionType]</code></p> <p>A class representing a broker async usecase.</p> <p>Attributes:</p> Name Type Description <code>handlers</code> <p>A dictionary of handlers for different message types.</p> <code>middlewares</code> <p>A sequence of middleware functions.</p> <code>_global_parser</code> <p>An optional global parser for messages.</p> <code>_global_decoder</code> <p>An optional global decoder for messages.</p> <p>Methods:</p> Name Description <code>start</code> <p>Abstract method to start the broker async usecase.</p> <code>_connect</code> <p>Any) : Abstract method to connect to the broker.</p> <code>_close</code> <p>Optional[Type[BaseException]] = None, exc_val: Optional[BaseException] = None, exec_tb: Optional[TracebackType] = None) : Abstract method to close the connection to the broker.</p> <code>close</code> <p>Optional[Type[BaseException]] = None, exc_val: Optional[BaseException] = None, exec_tb: Optional[TracebackType] = None) : Close the connection to the broker.</p> <code>_process_message</code> <p>Callable[[StreamMessage[MsgType]], Awaitable[T_HandlerReturn]], watcher: BaseWatcher) : Abstract method to process a message.</p> <code>publish</code> <p>SendableMessage, *args: Any, reply_to: str = \"\", rpc: bool = False, rpc_timeout: Optional[float]</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/core/asyncronous.py</code> <pre><code>class BrokerAsyncUsecase(BrokerUsecase[MsgType, ConnectionType]):\n\"\"\"A class representing a broker async usecase.\n\n    Attributes:\n        handlers : A dictionary of handlers for different message types.\n        middlewares : A sequence of middleware functions.\n        _global_parser : An optional global parser for messages.\n        _global_decoder : An optional global decoder for messages.\n\n    Methods:\n        start() : Abstract method to start the broker async usecase.\n        _connect(**kwargs: Any) : Abstract method to connect to the broker.\n        _close(exc_type: Optional[Type[BaseException]] = None, exc_val: Optional[BaseException] = None, exec_tb: Optional[TracebackType] = None) : Abstract method to close the connection to the broker.\n        close(exc_type: Optional[Type[BaseException]] = None, exc_val: Optional[BaseException] = None, exec_tb: Optional[TracebackType] = None) : Close the connection to the broker.\n        _process_message(func: Callable[[StreamMessage[MsgType]], Awaitable[T_HandlerReturn]], watcher: BaseWatcher) : Abstract method to process a message.\n        publish(message: SendableMessage, *args: Any, reply_to: str = \"\", rpc: bool = False, rpc_timeout: Optional[float]\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    handlers: Dict[Any, AsyncHandler[MsgType]]  # type: ignore[assignment]\n    middlewares: Sequence[Callable[[MsgType], BaseMiddleware]]\n    _global_parser: Optional[AsyncCustomParser[MsgType]]\n    _global_decoder: Optional[AsyncCustomDecoder[MsgType]]\n\n    @abstractmethod\n    async def start(self) -&gt; None:\n        super()._abc_start()\n        for h in self.handlers.values():\n            for c, _, _, _, _, _ in h.calls:\n                c.event = anyio.Event()\n        await self.connect()\n\n    @abstractmethod\n    async def _connect(self, **kwargs: Any) -&gt; ConnectionType:\n\"\"\"Connect to a resource.\n\n        Args:\n            **kwargs: Additional keyword arguments for the connection.\n\n        Returns:\n            The connection object.\n\n        Raises:\n            NotImplementedError: If the method is not implemented.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        raise NotImplementedError()\n\n    @abstractmethod\n    async def _close(\n        self,\n        exc_type: Optional[Type[BaseException]] = None,\n        exc_val: Optional[BaseException] = None,\n        exec_tb: Optional[TracebackType] = None,\n    ) -&gt; None:\n\"\"\"Close the object.\n\n        Args:\n            exc_type: Optional. The type of the exception.\n            exc_val: Optional. The exception value.\n            exec_tb: Optional. The traceback of the exception.\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        super()._abc__close(exc_type, exc_val, exec_tb)\n\n    async def close(\n        self,\n        exc_type: Optional[Type[BaseException]] = None,\n        exc_val: Optional[BaseException] = None,\n        exec_tb: Optional[TracebackType] = None,\n    ) -&gt; None:\n\"\"\"Closes the object.\n\n        Args:\n            exc_type: The type of the exception being handled, if any.\n            exc_val: The exception instance being handled, if any.\n            exec_tb: The traceback of the exception being handled, if any.\n\n        Returns:\n            None\n\n        Raises:\n            NotImplementedError: If the method is not implemented.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        super()._abc_close(exc_type, exc_val, exec_tb)\n\n        for h in self.handlers.values():\n            await h.close()\n\n        if self._connection is not None:\n            await self._close(exc_type, exc_val, exec_tb)\n\n    @override\n    @abstractmethod\n    def _process_message(\n        self,\n        func: Callable[[StreamMessage[MsgType]], Awaitable[T_HandlerReturn]],\n        watcher: BaseWatcher,\n    ) -&gt; Callable[[StreamMessage[MsgType]], Awaitable[WrappedReturn[T_HandlerReturn]],]:\n\"\"\"Process a message.\n\n        Args:\n            func: A callable function that takes a StreamMessage and returns an Awaitable\n            watcher: An instance of BaseWatcher\n\n        Returns:\n            A callable function that takes a StreamMessage and returns an Awaitable\n\n        Raises:\n            NotImplementedError: If the method is not implemented\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        raise NotImplementedError()\n\n    @abstractmethod\n    async def publish(\n        self,\n        message: SendableMessage,\n        *args: Any,\n        reply_to: str = \"\",\n        rpc: bool = False,\n        rpc_timeout: Optional[float] = None,\n        raise_timeout: bool = False,\n        **kwargs: Any,\n    ) -&gt; Optional[SendableMessage]:\n\"\"\"Publish a message.\n\n        Args:\n            message: The message to be published.\n            *args: Additional arguments.\n            reply_to: The reply-to address for the message.\n            rpc: Whether the message is for RPC.\n            rpc_timeout: The timeout for RPC.\n            raise_timeout: Whether to raise an exception on timeout.\n            **kwargs: Additional keyword arguments.\n\n        Returns:\n            The published message.\n\n        Raises:\n            NotImplementedError: If the method is not implemented.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        raise NotImplementedError()\n\n    @override\n    @abstractmethod\n    def subscriber(  # type: ignore[override,return]\n        self,\n        *broker_args: Any,\n        retry: Union[bool, int] = False,\n        dependencies: Sequence[Depends] = (),\n        decoder: Optional[CustomDecoder[MsgType]] = None,\n        parser: Optional[CustomParser[MsgType]] = None,\n        middlewares: Optional[Sequence[Callable[[MsgType], BaseMiddleware]]] = None,\n        filter: Filter[StreamMessage[MsgType]] = default_filter,\n        _raw: bool = False,\n        _get_dependant: Optional[Any] = None,\n        **broker_kwargs: Any,\n    ) -&gt; Callable[\n        [\n            Union[\n                Callable[P_HandlerParams, T_HandlerReturn],\n                HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn],\n            ]\n        ],\n        HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn],\n    ]:\n\"\"\"A function decorator for subscribing to a message broker.\n\n        Args:\n            *broker_args: Positional arguments to be passed to the message broker.\n            retry: Whether to retry the subscription if it fails. Can be a boolean or an integer specifying the number of retries.\n            dependencies: Sequence of dependencies to be injected into the decorated function.\n            decoder: Custom decoder function for decoding the message.\n            parser: Custom parser function for parsing the decoded message.\n            middlewares: Sequence of middleware functions to be applied to the message.\n            filter: Filter function for filtering the messages to be processed.\n            _raw: Whether to return the raw message instead of the processed result.\n            _get_dependant: Optional argument to get the dependant object.\n\n        Returns:\n            A callable decorator that wraps the decorated function and handles the subscription.\n\n        Raises:\n            NotImplementedError: If silent animals are not supported.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        super().subscriber()\n\n    def __init__(\n        self,\n        *args: Any,\n        apply_types: bool = True,\n        logger: Optional[logging.Logger] = access_logger,\n        log_level: int = logging.INFO,\n        log_fmt: Optional[str] = \"%(asctime)s %(levelname)s - %(message)s\",\n        dependencies: Sequence[Depends] = (),\n        decoder: Optional[CustomDecoder[MsgType]] = None,\n        parser: Optional[CustomParser[MsgType]] = None,\n        middlewares: Optional[Sequence[Callable[[MsgType], BaseMiddleware]]] = None,\n        **kwargs: Any,\n    ) -&gt; None:\n\"\"\"Initialize the class.\n\n        Args:\n            *args: Variable length arguments\n            apply_types: Whether to apply types or not\n            logger: Logger object for logging\n            log_level: Log level for logging\n            log_fmt: Log format for logging\n            dependencies: Sequence of dependencies\n            decoder: Custom decoder object\n            parser: Custom parser object\n            middlewares: Sequence of middlewares\n            **kwargs: Keyword arguments\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        super().__init__(\n            *args,\n            apply_types=apply_types,\n            logger=logger,\n            log_level=log_level,\n            log_fmt=log_fmt,\n            dependencies=dependencies,\n            decoder=cast(\n                Optional[AsyncCustomDecoder[MsgType]],\n                to_async(decoder) if decoder else None,\n            ),\n            parser=cast(\n                Optional[AsyncCustomParser[MsgType]],\n                to_async(parser) if parser else None,\n            ),\n            middlewares=middlewares,\n            **kwargs,\n        )\n\n    async def connect(self, *args: Any, **kwargs: Any) -&gt; ConnectionType:\n\"\"\"Connect to a remote server.\n\n        Args:\n            *args: Variable length argument list.\n            **kwargs: Arbitrary keyword arguments.\n\n        Returns:\n            The connection object.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        if self._connection is None:\n            _kwargs = self._resolve_connection_kwargs(*args, **kwargs)\n            self._connection = await self._connect(**_kwargs)\n        return self._connection\n\n    async def __aenter__(self) -&gt; Self:\n        await self.connect()\n        return self\n\n    async def __aexit__(\n        self,\n        exc_type: Optional[Type[BaseException]],\n        exc_val: Optional[BaseException],\n        exec_tb: Optional[TracebackType],\n    ) -&gt; None:\n\"\"\"Exit the context manager.\n\n        Args:\n            exc_type: The type of the exception raised, if any.\n            exc_val: The exception raised, if any.\n            exec_tb: The traceback of the exception raised, if any.\n\n        Returns:\n            None\n\n        Overrides:\n            This method overrides the __aexit__ method of the base class.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        await self.close(exc_type, exc_val, exec_tb)\n\n    @override\n    def _wrap_decode_message(\n        self,\n        func: Callable[..., Awaitable[T_HandlerReturn]],\n        params: Sized = (),\n        _raw: bool = False,\n    ) -&gt; Callable[[StreamMessage[MsgType]], Awaitable[T_HandlerReturn]]:\n\"\"\"Wraps a function to decode a message and pass it as an argument to the wrapped function.\n\n        Args:\n            func: The function to be wrapped.\n            params: The parameters to be passed to the wrapped function.\n            _raw: Whether to return the raw message or not.\n\n        Returns:\n            The wrapped function.\n\n        Raises:\n            AssertionError: If the code reaches an unreachable state.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        params_ln = len(params)\n\n        @wraps(func)\n        async def decode_wrapper(message: StreamMessage[MsgType]) -&gt; T_HandlerReturn:\n\"\"\"A wrapper function to decode and handle a message.\n\n            Args:\n                message : The message to be decoded and handled\n\n            Returns:\n                The return value of the handler function\n\n            Raises:\n                AssertionError: If the code reaches an unreachable state\n            !!! note\n\n                The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n            \"\"\"\n            if _raw is True:\n                return await func(message)\n\n            msg = message.decoded_body\n            if params_ln &gt; 1:\n                if isinstance(msg, Mapping):\n                    return await func(**msg)\n                elif isinstance(msg, Sequence):\n                    return await func(*msg)\n            else:\n                return await func(msg)\n\n            raise AssertionError(\"unreachable\")\n\n        return decode_wrapper\n\n    @override\n    def _wrap_handler(\n        self,\n        func: Callable[P_HandlerParams, T_HandlerReturn],\n        *,\n        retry: Union[bool, int] = False,\n        extra_dependencies: Sequence[Depends] = (),\n        _raw: bool = False,\n        _get_dependant: Optional[Any] = None,\n        **broker_log_context_kwargs: Any,\n    ) -&gt; Tuple[\n        HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn],\n        CallModel[P_HandlerParams, T_HandlerReturn],\n    ]:\n\"\"\"Wrap a handler function.\n\n        Args:\n            func: The handler function to wrap.\n            retry: Whether to retry the handler function if it fails. Can be a boolean or an integer specifying the number of retries.\n            extra_dependencies: Additional dependencies to inject into the handler function.\n            _raw: Whether to return the raw response from the handler function.\n            _get_dependant: An optional object to use as the dependant for the handler function.\n            **broker_log_context_kwargs: Additional keyword arguments to pass to the broker log context.\n\n        Returns:\n            A tuple containing the wrapped handler function and the call model.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        return super()._wrap_handler(  # type: ignore[return-value]\n            func,\n            retry=retry,\n            extra_dependencies=extra_dependencies,\n            _raw=_raw,\n            _get_dependant=_get_dependant,\n            **broker_log_context_kwargs,\n        )\n\n    async def _execute_handler(\n        self,\n        func: Callable[[StreamMessage[MsgType]], Awaitable[T_HandlerReturn]],\n        message: StreamMessage[MsgType],\n    ) -&gt; T_HandlerReturn:\n\"\"\"Executes a handler function asynchronously.\n\n        Args:\n            func: The handler function to be executed.\n            message: The message to be passed to the handler function.\n\n        Returns:\n            The return value of the handler function.\n\n        Raises:\n            AckMessage: If the handler function raises an AckMessage exception.\n            NackMessage: If the handler function raises a NackMessage exception.\n            RejectMessage: If the handler function raises a RejectMessage exception.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        try:\n            return await func(message)\n        except AckMessage as e:\n            await message.ack()\n            raise e\n        except NackMessage as e:\n            await message.nack()\n            raise e\n        except RejectMessage as e:\n            await message.reject()\n            raise e\n\n    @override\n    def _log_execution(\n        self,\n        func: Callable[\n            [StreamMessage[MsgType]],\n            Awaitable[WrappedReturn[T_HandlerReturn]],\n        ],\n        **broker_args: Any,\n    ) -&gt; Callable[[StreamMessage[MsgType]], Awaitable[WrappedReturn[T_HandlerReturn]]]:\n\"\"\"Decorator to log the execution of a function.\n\n        Args:\n            func: The function to be decorated.\n\n        Returns:\n            The decorated function.\n\n        Raises:\n            SkipMessage: If the message should be skipped.\n\n        Note:\n            This decorator logs the execution of the function, including the received message and any exceptions that occur during execution.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n\n        @wraps(func)\n        async def log_wrapper(\n            message: StreamMessage[MsgType],\n        ) -&gt; WrappedReturn[T_HandlerReturn]:\n\"\"\"A wrapper function for logging.\n\n            Args:\n                message : The message to be logged.\n\n            Returns:\n                The wrapped return value.\n\n            Raises:\n                SkipMessage: If the message is to be skipped.\n                Exception: If an exception occurs during processing.\n            !!! note\n\n                The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n            \"\"\"\n            log_context = self._get_log_context(message=message, **broker_args)\n\n            with context.scope(\"log_context\", log_context):\n                self._log(\"Received\", extra=log_context)\n\n                try:\n                    r = await func(message)\n                except SkipMessage as e:\n                    self._log(\"Skipped\", extra=log_context)\n                    raise e\n                except Exception as e:\n                    self._log(f\"{type(e).__name__}: {e}\", logging.ERROR, exc_info=e)\n                    raise e\n                else:\n                    self._log(\"Processed\", extra=log_context)\n                    return r\n\n        return log_wrapper\n</code></pre>"},{"location":"api/faststream/broker/core/asyncronous/BrokerAsyncUsecase/#faststream.broker.core.asyncronous.BrokerAsyncUsecase-attributes","title":"Attributes","text":""},{"location":"api/faststream/broker/core/asyncronous/BrokerAsyncUsecase/#faststream.broker.core.asyncronous.BrokerAsyncUsecase.handlers","title":"handlers  <code>instance-attribute</code>","text":"<pre><code>handlers: Dict[Any, AsyncHandler[MsgType]]\n</code></pre>"},{"location":"api/faststream/broker/core/asyncronous/BrokerAsyncUsecase/#faststream.broker.core.asyncronous.BrokerAsyncUsecase.middlewares","title":"middlewares  <code>instance-attribute</code>","text":"<pre><code>middlewares: Sequence[Callable[[MsgType], BaseMiddleware]]\n</code></pre>"},{"location":"api/faststream/broker/core/asyncronous/BrokerAsyncUsecase/#faststream.broker.core.asyncronous.BrokerAsyncUsecase-functions","title":"Functions","text":""},{"location":"api/faststream/broker/core/asyncronous/BrokerAsyncUsecase/#faststream.broker.core.asyncronous.BrokerAsyncUsecase.__aenter__","title":"__aenter__  <code>async</code>","text":"<pre><code>__aenter__() -&gt; Self\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/core/asyncronous.py</code> <pre><code>async def __aenter__(self) -&gt; Self:\n    await self.connect()\n    return self\n</code></pre>"},{"location":"api/faststream/broker/core/asyncronous/BrokerAsyncUsecase/#faststream.broker.core.asyncronous.BrokerAsyncUsecase.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(\n    exc_type: Optional[Type[BaseException]],\n    exc_val: Optional[BaseException],\n    exec_tb: Optional[TracebackType],\n) -&gt; None\n</code></pre> <p>Exit the context manager.</p> <p>Parameters:</p> Name Type Description Default <code>exc_type</code> <code>Optional[Type[BaseException]]</code> <p>The type of the exception raised, if any.</p> required <code>exc_val</code> <code>Optional[BaseException]</code> <p>The exception raised, if any.</p> required <code>exec_tb</code> <code>Optional[TracebackType]</code> <p>The traceback of the exception raised, if any.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Overrides <p>This method overrides the aexit method of the base class.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/core/asyncronous.py</code> <pre><code>async def __aexit__(\n    self,\n    exc_type: Optional[Type[BaseException]],\n    exc_val: Optional[BaseException],\n    exec_tb: Optional[TracebackType],\n) -&gt; None:\n\"\"\"Exit the context manager.\n\n    Args:\n        exc_type: The type of the exception raised, if any.\n        exc_val: The exception raised, if any.\n        exec_tb: The traceback of the exception raised, if any.\n\n    Returns:\n        None\n\n    Overrides:\n        This method overrides the __aexit__ method of the base class.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    await self.close(exc_type, exc_val, exec_tb)\n</code></pre>"},{"location":"api/faststream/broker/core/asyncronous/BrokerAsyncUsecase/#faststream.broker.core.asyncronous.BrokerAsyncUsecase.__init__","title":"__init__","text":"<pre><code>__init__(\n    *args: Any,\n    apply_types: bool = True,\n    logger: Optional[logging.Logger] = access_logger,\n    log_level: int = logging.INFO,\n    log_fmt: Optional[\n        str\n    ] = \"%(asctime)s %(levelname)s - %(message)s\",\n    dependencies: Sequence[Depends] = (),\n    decoder: Optional[CustomDecoder[MsgType]] = None,\n    parser: Optional[CustomParser[MsgType]] = None,\n    middlewares: Optional[\n        Sequence[Callable[[MsgType], BaseMiddleware]]\n    ] = None,\n    **kwargs: Any\n) -&gt; None\n</code></pre> <p>Initialize the class.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Any</code> <p>Variable length arguments</p> <code>()</code> <code>apply_types</code> <code>bool</code> <p>Whether to apply types or not</p> <code>True</code> <code>logger</code> <code>Optional[Logger]</code> <p>Logger object for logging</p> <code>access_logger</code> <code>log_level</code> <code>int</code> <p>Log level for logging</p> <code>INFO</code> <code>log_fmt</code> <code>Optional[str]</code> <p>Log format for logging</p> <code>'%(asctime)s %(levelname)s - %(message)s'</code> <code>dependencies</code> <code>Sequence[Depends]</code> <p>Sequence of dependencies</p> <code>()</code> <code>decoder</code> <code>Optional[CustomDecoder[MsgType]]</code> <p>Custom decoder object</p> <code>None</code> <code>parser</code> <code>Optional[CustomParser[MsgType]]</code> <p>Custom parser object</p> <code>None</code> <code>middlewares</code> <code>Optional[Sequence[Callable[[MsgType], BaseMiddleware]]]</code> <p>Sequence of middlewares</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments</p> <code>{}</code> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/core/asyncronous.py</code> <pre><code>def __init__(\n    self,\n    *args: Any,\n    apply_types: bool = True,\n    logger: Optional[logging.Logger] = access_logger,\n    log_level: int = logging.INFO,\n    log_fmt: Optional[str] = \"%(asctime)s %(levelname)s - %(message)s\",\n    dependencies: Sequence[Depends] = (),\n    decoder: Optional[CustomDecoder[MsgType]] = None,\n    parser: Optional[CustomParser[MsgType]] = None,\n    middlewares: Optional[Sequence[Callable[[MsgType], BaseMiddleware]]] = None,\n    **kwargs: Any,\n) -&gt; None:\n\"\"\"Initialize the class.\n\n    Args:\n        *args: Variable length arguments\n        apply_types: Whether to apply types or not\n        logger: Logger object for logging\n        log_level: Log level for logging\n        log_fmt: Log format for logging\n        dependencies: Sequence of dependencies\n        decoder: Custom decoder object\n        parser: Custom parser object\n        middlewares: Sequence of middlewares\n        **kwargs: Keyword arguments\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    super().__init__(\n        *args,\n        apply_types=apply_types,\n        logger=logger,\n        log_level=log_level,\n        log_fmt=log_fmt,\n        dependencies=dependencies,\n        decoder=cast(\n            Optional[AsyncCustomDecoder[MsgType]],\n            to_async(decoder) if decoder else None,\n        ),\n        parser=cast(\n            Optional[AsyncCustomParser[MsgType]],\n            to_async(parser) if parser else None,\n        ),\n        middlewares=middlewares,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/faststream/broker/core/asyncronous/BrokerAsyncUsecase/#faststream.broker.core.asyncronous.BrokerAsyncUsecase.close","title":"close  <code>async</code>","text":"<pre><code>close(\n    exc_type: Optional[Type[BaseException]] = None,\n    exc_val: Optional[BaseException] = None,\n    exec_tb: Optional[TracebackType] = None,\n) -&gt; None\n</code></pre> <p>Closes the object.</p> <p>Parameters:</p> Name Type Description Default <code>exc_type</code> <code>Optional[Type[BaseException]]</code> <p>The type of the exception being handled, if any.</p> <code>None</code> <code>exc_val</code> <code>Optional[BaseException]</code> <p>The exception instance being handled, if any.</p> <code>None</code> <code>exec_tb</code> <code>Optional[TracebackType]</code> <p>The traceback of the exception being handled, if any.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the method is not implemented.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/core/asyncronous.py</code> <pre><code>async def close(\n    self,\n    exc_type: Optional[Type[BaseException]] = None,\n    exc_val: Optional[BaseException] = None,\n    exec_tb: Optional[TracebackType] = None,\n) -&gt; None:\n\"\"\"Closes the object.\n\n    Args:\n        exc_type: The type of the exception being handled, if any.\n        exc_val: The exception instance being handled, if any.\n        exec_tb: The traceback of the exception being handled, if any.\n\n    Returns:\n        None\n\n    Raises:\n        NotImplementedError: If the method is not implemented.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    super()._abc_close(exc_type, exc_val, exec_tb)\n\n    for h in self.handlers.values():\n        await h.close()\n\n    if self._connection is not None:\n        await self._close(exc_type, exc_val, exec_tb)\n</code></pre>"},{"location":"api/faststream/broker/core/asyncronous/BrokerAsyncUsecase/#faststream.broker.core.asyncronous.BrokerAsyncUsecase.connect","title":"connect  <code>async</code>","text":"<pre><code>connect(*args: Any, **kwargs: Any) -&gt; ConnectionType\n</code></pre> <p>Connect to a remote server.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Any</code> <p>Variable length argument list.</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Arbitrary keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>ConnectionType</code> <p>The connection object.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/core/asyncronous.py</code> <pre><code>async def connect(self, *args: Any, **kwargs: Any) -&gt; ConnectionType:\n\"\"\"Connect to a remote server.\n\n    Args:\n        *args: Variable length argument list.\n        **kwargs: Arbitrary keyword arguments.\n\n    Returns:\n        The connection object.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    if self._connection is None:\n        _kwargs = self._resolve_connection_kwargs(*args, **kwargs)\n        self._connection = await self._connect(**_kwargs)\n    return self._connection\n</code></pre>"},{"location":"api/faststream/broker/core/asyncronous/BrokerAsyncUsecase/#faststream.broker.core.asyncronous.BrokerAsyncUsecase.publish","title":"publish  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>publish(\n    message: SendableMessage,\n    *args: Any,\n    reply_to: str = \"\",\n    rpc: bool = False,\n    rpc_timeout: Optional[float] = None,\n    raise_timeout: bool = False,\n    **kwargs: Any\n) -&gt; Optional[SendableMessage]\n</code></pre> <p>Publish a message.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>SendableMessage</code> <p>The message to be published.</p> required <code>*args</code> <code>Any</code> <p>Additional arguments.</p> <code>()</code> <code>reply_to</code> <code>str</code> <p>The reply-to address for the message.</p> <code>''</code> <code>rpc</code> <code>bool</code> <p>Whether the message is for RPC.</p> <code>False</code> <code>rpc_timeout</code> <code>Optional[float]</code> <p>The timeout for RPC.</p> <code>None</code> <code>raise_timeout</code> <code>bool</code> <p>Whether to raise an exception on timeout.</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Optional[SendableMessage]</code> <p>The published message.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the method is not implemented.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/core/asyncronous.py</code> <pre><code>@abstractmethod\nasync def publish(\n    self,\n    message: SendableMessage,\n    *args: Any,\n    reply_to: str = \"\",\n    rpc: bool = False,\n    rpc_timeout: Optional[float] = None,\n    raise_timeout: bool = False,\n    **kwargs: Any,\n) -&gt; Optional[SendableMessage]:\n\"\"\"Publish a message.\n\n    Args:\n        message: The message to be published.\n        *args: Additional arguments.\n        reply_to: The reply-to address for the message.\n        rpc: Whether the message is for RPC.\n        rpc_timeout: The timeout for RPC.\n        raise_timeout: Whether to raise an exception on timeout.\n        **kwargs: Additional keyword arguments.\n\n    Returns:\n        The published message.\n\n    Raises:\n        NotImplementedError: If the method is not implemented.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/broker/core/asyncronous/BrokerAsyncUsecase/#faststream.broker.core.asyncronous.BrokerAsyncUsecase.start","title":"start  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>start() -&gt; None\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/core/asyncronous.py</code> <pre><code>@abstractmethod\nasync def start(self) -&gt; None:\n    super()._abc_start()\n    for h in self.handlers.values():\n        for c, _, _, _, _, _ in h.calls:\n            c.event = anyio.Event()\n    await self.connect()\n</code></pre>"},{"location":"api/faststream/broker/core/asyncronous/BrokerAsyncUsecase/#faststream.broker.core.asyncronous.BrokerAsyncUsecase.subscriber","title":"subscriber  <code>abstractmethod</code>","text":"<pre><code>subscriber(\n    *broker_args: Any,\n    retry: Union[bool, int] = False,\n    dependencies: Sequence[Depends] = (),\n    decoder: Optional[CustomDecoder[MsgType]] = None,\n    parser: Optional[CustomParser[MsgType]] = None,\n    middlewares: Optional[\n        Sequence[Callable[[MsgType], BaseMiddleware]]\n    ] = None,\n    filter: Filter[StreamMessage[MsgType]] = default_filter,\n    _raw: bool = False,\n    _get_dependant: Optional[Any] = None,\n    **broker_kwargs: Any\n) -&gt; Callable[\n    [\n        Union[\n            Callable[P_HandlerParams, T_HandlerReturn],\n            HandlerCallWrapper[\n                MsgType, P_HandlerParams, T_HandlerReturn\n            ],\n        ]\n    ],\n    HandlerCallWrapper[\n        MsgType, P_HandlerParams, T_HandlerReturn\n    ],\n]\n</code></pre> <p>A function decorator for subscribing to a message broker.</p> <p>Parameters:</p> Name Type Description Default <code>*broker_args</code> <code>Any</code> <p>Positional arguments to be passed to the message broker.</p> <code>()</code> <code>retry</code> <code>Union[bool, int]</code> <p>Whether to retry the subscription if it fails. Can be a boolean or an integer specifying the number of retries.</p> <code>False</code> <code>dependencies</code> <code>Sequence[Depends]</code> <p>Sequence of dependencies to be injected into the decorated function.</p> <code>()</code> <code>decoder</code> <code>Optional[CustomDecoder[MsgType]]</code> <p>Custom decoder function for decoding the message.</p> <code>None</code> <code>parser</code> <code>Optional[CustomParser[MsgType]]</code> <p>Custom parser function for parsing the decoded message.</p> <code>None</code> <code>middlewares</code> <code>Optional[Sequence[Callable[[MsgType], BaseMiddleware]]]</code> <p>Sequence of middleware functions to be applied to the message.</p> <code>None</code> <code>filter</code> <code>Filter[StreamMessage[MsgType]]</code> <p>Filter function for filtering the messages to be processed.</p> <code>default_filter</code> <code>_raw</code> <code>bool</code> <p>Whether to return the raw message instead of the processed result.</p> <code>False</code> <code>_get_dependant</code> <code>Optional[Any]</code> <p>Optional argument to get the dependant object.</p> <code>None</code> <p>Returns:</p> Type Description <code>Callable[[Union[Callable[P_HandlerParams, T_HandlerReturn], HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn]]], HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn]]</code> <p>A callable decorator that wraps the decorated function and handles the subscription.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If silent animals are not supported.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/core/asyncronous.py</code> <pre><code>@override\n@abstractmethod\ndef subscriber(  # type: ignore[override,return]\n    self,\n    *broker_args: Any,\n    retry: Union[bool, int] = False,\n    dependencies: Sequence[Depends] = (),\n    decoder: Optional[CustomDecoder[MsgType]] = None,\n    parser: Optional[CustomParser[MsgType]] = None,\n    middlewares: Optional[Sequence[Callable[[MsgType], BaseMiddleware]]] = None,\n    filter: Filter[StreamMessage[MsgType]] = default_filter,\n    _raw: bool = False,\n    _get_dependant: Optional[Any] = None,\n    **broker_kwargs: Any,\n) -&gt; Callable[\n    [\n        Union[\n            Callable[P_HandlerParams, T_HandlerReturn],\n            HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn],\n        ]\n    ],\n    HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn],\n]:\n\"\"\"A function decorator for subscribing to a message broker.\n\n    Args:\n        *broker_args: Positional arguments to be passed to the message broker.\n        retry: Whether to retry the subscription if it fails. Can be a boolean or an integer specifying the number of retries.\n        dependencies: Sequence of dependencies to be injected into the decorated function.\n        decoder: Custom decoder function for decoding the message.\n        parser: Custom parser function for parsing the decoded message.\n        middlewares: Sequence of middleware functions to be applied to the message.\n        filter: Filter function for filtering the messages to be processed.\n        _raw: Whether to return the raw message instead of the processed result.\n        _get_dependant: Optional argument to get the dependant object.\n\n    Returns:\n        A callable decorator that wraps the decorated function and handles the subscription.\n\n    Raises:\n        NotImplementedError: If silent animals are not supported.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    super().subscriber()\n</code></pre>"},{"location":"api/faststream/broker/core/asyncronous/default_filter/","title":"default_filter","text":""},{"location":"api/faststream/broker/core/asyncronous/default_filter/#faststream.broker.core.asyncronous.default_filter","title":"faststream.broker.core.asyncronous.default_filter  <code>async</code>","text":"<pre><code>default_filter(msg: StreamMessage[Any]) -&gt; bool\n</code></pre> <p>A function to filter stream messages.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <p>A stream message object</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the message has not been processed, False otherwise</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/core/asyncronous.py</code> <pre><code>async def default_filter(msg: StreamMessage[Any]) -&gt; bool:\n\"\"\"A function to filter stream messages.\n\n    Args:\n        msg : A stream message object\n\n    Returns:\n        True if the message has not been processed, False otherwise\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    return not msg.processed\n</code></pre>"},{"location":"api/faststream/broker/core/mixins/LoggingMixin/","title":"LoggingMixin","text":""},{"location":"api/faststream/broker/core/mixins/LoggingMixin/#faststream.broker.core.mixins.LoggingMixin","title":"faststream.broker.core.mixins.LoggingMixin","text":"<p>A mixin class for logging.</p> <p>Attributes:</p> Name Type Description <code>logger</code> <p>logger object used for logging</p> <code>log_level</code> <p>log level for logging</p> <code>_fmt</code> <p>format string for log messages</p> <p>Methods:</p> Name Description <code>fmt </code> <p>getter method for _fmt attribute</p> <code>_get_log_context </code> <p>returns a dictionary with log context information</p> <code>_log </code> <p>logs a message with optional log level, extra data, and exception info</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/core/mixins.py</code> <pre><code>class LoggingMixin:\n\"\"\"A mixin class for logging.\n\n    Attributes:\n        logger : logger object used for logging\n        log_level : log level for logging\n        _fmt : format string for log messages\n\n    Methods:\n        fmt : getter method for _fmt attribute\n        _get_log_context : returns a dictionary with log context information\n        _log : logs a message with optional log level, extra data, and exception info\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    def __init__(\n        self,\n        *args: Any,\n        logger: Optional[logging.Logger] = access_logger,\n        log_level: int = logging.INFO,\n        log_fmt: Optional[str] = \"%(asctime)s %(levelname)s - %(message)s\",\n        **kwargs: Any,\n    ) -&gt; None:\n\"\"\"Initialize the class.\n\n        Args:\n            *args: Variable length argument list\n            logger: Optional logger object\n            log_level: Log level (default: logging.INFO)\n            log_fmt: Log format (default: \"%(asctime)s %(levelname)s - %(message)s\")\n            **kwargs: Arbitrary keyword arguments\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        self.logger = logger\n        self.log_level = log_level\n        self._fmt = log_fmt\n\n    @property\n    def fmt(self) -&gt; str:  # pragma: no cover\n        return self._fmt or \"\"\n\n    def _get_log_context(\n        self,\n        message: Optional[StreamMessage[MsgType]],\n        **kwargs: str,\n    ) -&gt; AnyDict:\n\"\"\"Get the log context.\n\n        Args:\n            message: Optional stream message\n            **kwargs: Additional keyword arguments\n\n        Returns:\n            A dictionary containing the log context with the following keys:\n                - message_id: The first 10 characters of the message_id if message is not None, otherwise an empty string\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        return {\n            \"message_id\": message.message_id[:10] if message else \"\",\n        }\n\n    def _log(\n        self,\n        message: str,\n        log_level: Optional[int] = None,\n        extra: Optional[AnyDict] = None,\n        exc_info: Optional[Exception] = None,\n    ) -&gt; None:\n\"\"\"Logs a message.\n\n        Args:\n            message: The message to be logged.\n            log_level: The log level of the message. If not provided, the default log level of the logger will be used.\n            extra: Additional information to be logged along with the message. This should be a dictionary.\n            exc_info: An exception to be logged along with the message.\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        if self.logger is not None:\n            self.logger.log(\n                level=(log_level or self.log_level),\n                msg=message,\n                extra=extra,\n                exc_info=exc_info,\n            )\n</code></pre>"},{"location":"api/faststream/broker/core/mixins/LoggingMixin/#faststream.broker.core.mixins.LoggingMixin-attributes","title":"Attributes","text":""},{"location":"api/faststream/broker/core/mixins/LoggingMixin/#faststream.broker.core.mixins.LoggingMixin.fmt","title":"fmt  <code>property</code>","text":"<pre><code>fmt: str\n</code></pre>"},{"location":"api/faststream/broker/core/mixins/LoggingMixin/#faststream.broker.core.mixins.LoggingMixin.log_level","title":"log_level  <code>instance-attribute</code>","text":"<pre><code>log_level = log_level\n</code></pre>"},{"location":"api/faststream/broker/core/mixins/LoggingMixin/#faststream.broker.core.mixins.LoggingMixin.logger","title":"logger  <code>instance-attribute</code>","text":"<pre><code>logger = logger\n</code></pre>"},{"location":"api/faststream/broker/core/mixins/LoggingMixin/#faststream.broker.core.mixins.LoggingMixin-functions","title":"Functions","text":""},{"location":"api/faststream/broker/core/mixins/LoggingMixin/#faststream.broker.core.mixins.LoggingMixin.__init__","title":"__init__","text":"<pre><code>__init__(\n    *args: Any,\n    logger: Optional[logging.Logger] = access_logger,\n    log_level: int = logging.INFO,\n    log_fmt: Optional[\n        str\n    ] = \"%(asctime)s %(levelname)s - %(message)s\",\n    **kwargs: Any\n) -&gt; None\n</code></pre> <p>Initialize the class.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Any</code> <p>Variable length argument list</p> <code>()</code> <code>logger</code> <code>Optional[Logger]</code> <p>Optional logger object</p> <code>access_logger</code> <code>log_level</code> <code>int</code> <p>Log level (default: logging.INFO)</p> <code>INFO</code> <code>log_fmt</code> <code>Optional[str]</code> <p>Log format (default: \"%(asctime)s %(levelname)s - %(message)s\")</p> <code>'%(asctime)s %(levelname)s - %(message)s'</code> <code>**kwargs</code> <code>Any</code> <p>Arbitrary keyword arguments</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/core/mixins.py</code> <pre><code>def __init__(\n    self,\n    *args: Any,\n    logger: Optional[logging.Logger] = access_logger,\n    log_level: int = logging.INFO,\n    log_fmt: Optional[str] = \"%(asctime)s %(levelname)s - %(message)s\",\n    **kwargs: Any,\n) -&gt; None:\n\"\"\"Initialize the class.\n\n    Args:\n        *args: Variable length argument list\n        logger: Optional logger object\n        log_level: Log level (default: logging.INFO)\n        log_fmt: Log format (default: \"%(asctime)s %(levelname)s - %(message)s\")\n        **kwargs: Arbitrary keyword arguments\n\n    Returns:\n        None\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    self.logger = logger\n    self.log_level = log_level\n    self._fmt = log_fmt\n</code></pre>"},{"location":"api/faststream/broker/fastapi/route/StreamMessage/","title":"StreamMessage","text":""},{"location":"api/faststream/broker/fastapi/route/StreamMessage/#faststream.broker.fastapi.route.StreamMessage","title":"faststream.broker.fastapi.route.StreamMessage","text":"<p>             Bases: <code>Request</code></p> <p>A class to represent a stream message.</p> <p>Attributes:</p> Name Type Description <code>scope</code> <p>dictionary representing the scope of the message</p> <code>_cookies</code> <p>dictionary representing the cookies of the message</p> <code>_headers</code> <p>dictionary representing the headers of the message</p> <code>_body</code> <p>dictionary representing the body of the message</p> <code>_query_params</code> <p>dictionary representing the query parameters of the message</p> <p>Methods:</p> Name Description <code>__init__ </code> <p>initializes the StreamMessage object</p> <code>get_session </code> <p>returns a callable function that handles the session of the message</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/fastapi/route.py</code> <pre><code>class StreamMessage(Request):\n\"\"\"A class to represent a stream message.\n\n    Attributes:\n        scope : dictionary representing the scope of the message\n        _cookies : dictionary representing the cookies of the message\n        _headers : dictionary representing the headers of the message\n        _body : dictionary representing the body of the message\n        _query_params : dictionary representing the query parameters of the message\n\n    Methods:\n        __init__ : initializes the StreamMessage object\n        get_session : returns a callable function that handles the session of the message\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    scope: AnyDict\n    _cookies: AnyDict\n    _headers: AnyDict  # type: ignore\n    _body: AnyDict  # type: ignore\n    _query_params: AnyDict  # type: ignore\n\n    def __init__(\n        self,\n        body: Optional[AnyDict] = None,\n        headers: Optional[AnyDict] = None,\n    ):\n\"\"\"Initialize a class instance.\n\n        Args:\n            body: The body of the request as a dictionary. Default is None.\n            headers: The headers of the request as a dictionary. Default is None.\n\n        Attributes:\n            scope: A dictionary to store the scope of the request.\n            _cookies: A dictionary to store the cookies of the request.\n            _headers: A dictionary to store the headers of the request.\n            _body: A dictionary to store the body of the request.\n            _query_params: A dictionary to store the query parameters of the request.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        self.scope = {}\n        self._cookies = {}\n        self._headers = headers or {}\n        self._body = body or {}\n        self._query_params = self._body\n\n    @classmethod\n    def get_session(\n        cls,\n        dependant: Dependant,\n        dependency_overrides_provider: Optional[Any] = None,\n    ) -&gt; Callable[[NativeMessage[Any]], Awaitable[SendableMessage]]:\n\"\"\"Creates a session for handling requests.\n\n        Args:\n            dependant: The dependant object representing the session.\n            dependency_overrides_provider: Optional provider for dependency overrides.\n\n        Returns:\n            A callable that takes a native message and returns an awaitable sendable message.\n\n        Raises:\n            AssertionError: If the dependant call is not defined.\n\n        Note:\n            This function is used to create a session for handling requests. It takes a dependant object, which represents the session, and a dependency overrides provider, which allows for overriding dependencies. It returns a callable that takes a native message and returns an awaitable sendable message. The session is created based on the dependant object and the message passed to the callable. The session is then used to call the function obtained from the dependant object, and the result is returned.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        assert dependant.call  # nosec B101\n\n        func = get_app(dependant, dependency_overrides_provider)\n\n        dependencies_names = tuple(i.name for i in dependant.dependencies)\n\n        first_arg = next(\n            dropwhile(\n                lambda i: i in dependencies_names,\n                inspect.signature(dependant.call).parameters,\n            ),\n            None,\n        )\n\n        async def app(message: NativeMessage[Any]) -&gt; SendableMessage:\n\"\"\"An asynchronous function that processes an incoming message and returns a sendable message.\n\n            Args:\n                message : The incoming message to be processed\n\n            Returns:\n                The sendable message\n\n            Raises:\n                TypeError: If the body of the message is not a dictionary\n            !!! note\n\n                The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n            \"\"\"\n            body = message.decoded_body\n            if first_arg is not None:\n                if not isinstance(body, dict):  # pragma: no branch\n                    fastapi_body: AnyDict = {first_arg: body}\n                else:\n                    fastapi_body = body\n\n                session = cls(fastapi_body, message.headers)\n            else:\n                session = cls()\n            return await func(session)\n\n        return app\n</code></pre>"},{"location":"api/faststream/broker/fastapi/route/StreamMessage/#faststream.broker.fastapi.route.StreamMessage-attributes","title":"Attributes","text":""},{"location":"api/faststream/broker/fastapi/route/StreamMessage/#faststream.broker.fastapi.route.StreamMessage.scope","title":"scope  <code>instance-attribute</code>","text":"<pre><code>scope: AnyDict = {}\n</code></pre>"},{"location":"api/faststream/broker/fastapi/route/StreamMessage/#faststream.broker.fastapi.route.StreamMessage-functions","title":"Functions","text":""},{"location":"api/faststream/broker/fastapi/route/StreamMessage/#faststream.broker.fastapi.route.StreamMessage.__init__","title":"__init__","text":"<pre><code>__init__(\n    body: Optional[AnyDict] = None,\n    headers: Optional[AnyDict] = None,\n)\n</code></pre> <p>Initialize a class instance.</p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>Optional[AnyDict]</code> <p>The body of the request as a dictionary. Default is None.</p> <code>None</code> <code>headers</code> <code>Optional[AnyDict]</code> <p>The headers of the request as a dictionary. Default is None.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>scope</code> <p>A dictionary to store the scope of the request.</p> <code>_cookies</code> <p>A dictionary to store the cookies of the request.</p> <code>_headers</code> <p>A dictionary to store the headers of the request.</p> <code>_body</code> <p>A dictionary to store the body of the request.</p> <code>_query_params</code> <p>A dictionary to store the query parameters of the request.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/fastapi/route.py</code> <pre><code>def __init__(\n    self,\n    body: Optional[AnyDict] = None,\n    headers: Optional[AnyDict] = None,\n):\n\"\"\"Initialize a class instance.\n\n    Args:\n        body: The body of the request as a dictionary. Default is None.\n        headers: The headers of the request as a dictionary. Default is None.\n\n    Attributes:\n        scope: A dictionary to store the scope of the request.\n        _cookies: A dictionary to store the cookies of the request.\n        _headers: A dictionary to store the headers of the request.\n        _body: A dictionary to store the body of the request.\n        _query_params: A dictionary to store the query parameters of the request.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    self.scope = {}\n    self._cookies = {}\n    self._headers = headers or {}\n    self._body = body or {}\n    self._query_params = self._body\n</code></pre>"},{"location":"api/faststream/broker/fastapi/route/StreamMessage/#faststream.broker.fastapi.route.StreamMessage.get_session","title":"get_session  <code>classmethod</code>","text":"<pre><code>get_session(\n    dependant: Dependant,\n    dependency_overrides_provider: Optional[Any] = None,\n) -&gt; Callable[\n    [NativeMessage[Any]], Awaitable[SendableMessage]\n]\n</code></pre> <p>Creates a session for handling requests.</p> <p>Parameters:</p> Name Type Description Default <code>dependant</code> <code>Dependant</code> <p>The dependant object representing the session.</p> required <code>dependency_overrides_provider</code> <code>Optional[Any]</code> <p>Optional provider for dependency overrides.</p> <code>None</code> <p>Returns:</p> Type Description <code>Callable[[StreamMessage[Any]], Awaitable[SendableMessage]]</code> <p>A callable that takes a native message and returns an awaitable sendable message.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If the dependant call is not defined.</p> Note <p>This function is used to create a session for handling requests. It takes a dependant object, which represents the session, and a dependency overrides provider, which allows for overriding dependencies. It returns a callable that takes a native message and returns an awaitable sendable message. The session is created based on the dependant object and the message passed to the callable. The session is then used to call the function obtained from the dependant object, and the result is returned.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/fastapi/route.py</code> <pre><code>@classmethod\ndef get_session(\n    cls,\n    dependant: Dependant,\n    dependency_overrides_provider: Optional[Any] = None,\n) -&gt; Callable[[NativeMessage[Any]], Awaitable[SendableMessage]]:\n\"\"\"Creates a session for handling requests.\n\n    Args:\n        dependant: The dependant object representing the session.\n        dependency_overrides_provider: Optional provider for dependency overrides.\n\n    Returns:\n        A callable that takes a native message and returns an awaitable sendable message.\n\n    Raises:\n        AssertionError: If the dependant call is not defined.\n\n    Note:\n        This function is used to create a session for handling requests. It takes a dependant object, which represents the session, and a dependency overrides provider, which allows for overriding dependencies. It returns a callable that takes a native message and returns an awaitable sendable message. The session is created based on the dependant object and the message passed to the callable. The session is then used to call the function obtained from the dependant object, and the result is returned.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    assert dependant.call  # nosec B101\n\n    func = get_app(dependant, dependency_overrides_provider)\n\n    dependencies_names = tuple(i.name for i in dependant.dependencies)\n\n    first_arg = next(\n        dropwhile(\n            lambda i: i in dependencies_names,\n            inspect.signature(dependant.call).parameters,\n        ),\n        None,\n    )\n\n    async def app(message: NativeMessage[Any]) -&gt; SendableMessage:\n\"\"\"An asynchronous function that processes an incoming message and returns a sendable message.\n\n        Args:\n            message : The incoming message to be processed\n\n        Returns:\n            The sendable message\n\n        Raises:\n            TypeError: If the body of the message is not a dictionary\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        body = message.decoded_body\n        if first_arg is not None:\n            if not isinstance(body, dict):  # pragma: no branch\n                fastapi_body: AnyDict = {first_arg: body}\n            else:\n                fastapi_body = body\n\n            session = cls(fastapi_body, message.headers)\n        else:\n            session = cls()\n        return await func(session)\n\n    return app\n</code></pre>"},{"location":"api/faststream/broker/fastapi/route/StreamRoute/","title":"StreamRoute","text":""},{"location":"api/faststream/broker/fastapi/route/StreamRoute/#faststream.broker.fastapi.route.StreamRoute","title":"faststream.broker.fastapi.route.StreamRoute","text":"<p>             Bases: <code>BaseRoute</code>, <code>Generic[MsgType, P_HandlerParams, T_HandlerReturn]</code></p> <p>A class representing a stream route.</p> <p>Attributes:</p> Name Type Description <code>handler</code> <p>HandlerCallWrapper object representing the handler for the route</p> <code>path</code> <p>path of the route</p> <code>broker</code> <p>BrokerAsyncUsecase object representing the broker for the route</p> <code>dependant</code> <p>Dependable object representing the dependencies for the route</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/fastapi/route.py</code> <pre><code>class StreamRoute(BaseRoute, Generic[MsgType, P_HandlerParams, T_HandlerReturn]):\n\"\"\"A class representing a stream route.\n\n    Attributes:\n        handler : HandlerCallWrapper object representing the handler for the route\n        path : path of the route\n        broker : BrokerAsyncUsecase object representing the broker for the route\n        dependant : Dependable object representing the dependencies for the route\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    handler: HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn]\n\n    def __init__(\n        self,\n        path: Union[NameRequired, str],\n        *extra: Union[NameRequired, str],\n        endpoint: Union[\n            Callable[P_HandlerParams, T_HandlerReturn],\n            HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn],\n        ],\n        broker: BrokerAsyncUsecase[MsgType, Any],\n        dependencies: Sequence[params.Depends] = (),\n        dependency_overrides_provider: Optional[Any] = None,\n        **handle_kwargs: Any,\n    ) -&gt; None:\n\"\"\"Initialize a class instance.\n\n        Args:\n            path: The path of the instance.\n            *extra: Additional arguments.\n            endpoint: The endpoint of the instance.\n            broker: The broker of the instance.\n            dependencies: The dependencies of the instance.\n            dependency_overrides_provider: The provider for dependency overrides.\n            **handle_kwargs: Additional keyword arguments.\n\n        Returns:\n            None.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        self.path = path\n        self.broker = broker\n\n        path_name = (path if isinstance(path, str) else path.name) or \"\"\n\n        if isinstance(endpoint, HandlerCallWrapper):\n            orig_call = endpoint._original_call\n        else:\n            orig_call = endpoint\n\n        dependant = get_dependant(\n            path=path_name,\n            call=orig_call,\n        )\n        for depends in dependencies[::-1]:\n            dependant.dependencies.insert(\n                0,\n                get_parameterless_sub_dependant(depends=depends, path=path_name),\n            )\n        self.dependant = dependant\n\n        call = wraps(orig_call)(\n            StreamMessage.get_session(\n                dependant,\n                dependency_overrides_provider,\n            )\n        )\n\n        if isinstance(endpoint, HandlerCallWrapper):\n            endpoint._original_call = call\n            handler = endpoint\n\n        else:\n            handler = call\n\n        self.handler = broker.subscriber(\n            path,\n            *extra,\n            _raw=True,\n            _get_dependant=lambda call: dependant,\n            **handle_kwargs,\n        )(\n            handler  # type: ignore[arg-type]\n        )\n</code></pre>"},{"location":"api/faststream/broker/fastapi/route/StreamRoute/#faststream.broker.fastapi.route.StreamRoute-attributes","title":"Attributes","text":""},{"location":"api/faststream/broker/fastapi/route/StreamRoute/#faststream.broker.fastapi.route.StreamRoute.broker","title":"broker  <code>instance-attribute</code>","text":"<pre><code>broker = broker\n</code></pre>"},{"location":"api/faststream/broker/fastapi/route/StreamRoute/#faststream.broker.fastapi.route.StreamRoute.dependant","title":"dependant  <code>instance-attribute</code>","text":"<pre><code>dependant = dependant\n</code></pre>"},{"location":"api/faststream/broker/fastapi/route/StreamRoute/#faststream.broker.fastapi.route.StreamRoute.handler","title":"handler  <code>instance-attribute</code>","text":"<pre><code>handler: HandlerCallWrapper[\n    MsgType, P_HandlerParams, T_HandlerReturn\n] = broker.subscriber(\n    path,\n    *extra,\n    _raw=True,\n    _get_dependant=lambda: dependant,\n    **handle_kwargs\n)(\n    handler\n)\n</code></pre>"},{"location":"api/faststream/broker/fastapi/route/StreamRoute/#faststream.broker.fastapi.route.StreamRoute.path","title":"path  <code>instance-attribute</code>","text":"<pre><code>path = path\n</code></pre>"},{"location":"api/faststream/broker/fastapi/route/StreamRoute/#faststream.broker.fastapi.route.StreamRoute-functions","title":"Functions","text":""},{"location":"api/faststream/broker/fastapi/route/StreamRoute/#faststream.broker.fastapi.route.StreamRoute.__init__","title":"__init__","text":"<pre><code>__init__(\n    path: Union[NameRequired, str],\n    *extra: Union[NameRequired, str],\n    endpoint: Union[\n        Callable[P_HandlerParams, T_HandlerReturn],\n        HandlerCallWrapper[\n            MsgType, P_HandlerParams, T_HandlerReturn\n        ],\n    ],\n    broker: BrokerAsyncUsecase[MsgType, Any],\n    dependencies: Sequence[params.Depends] = (),\n    dependency_overrides_provider: Optional[Any] = None,\n    **handle_kwargs: Any\n) -&gt; None\n</code></pre> <p>Initialize a class instance.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[NameRequired, str]</code> <p>The path of the instance.</p> required <code>*extra</code> <code>Union[NameRequired, str]</code> <p>Additional arguments.</p> <code>()</code> <code>endpoint</code> <code>Union[Callable[P_HandlerParams, T_HandlerReturn], HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn]]</code> <p>The endpoint of the instance.</p> required <code>broker</code> <code>BrokerAsyncUsecase[MsgType, Any]</code> <p>The broker of the instance.</p> required <code>dependencies</code> <code>Sequence[Depends]</code> <p>The dependencies of the instance.</p> <code>()</code> <code>dependency_overrides_provider</code> <code>Optional[Any]</code> <p>The provider for dependency overrides.</p> <code>None</code> <code>**handle_kwargs</code> <code>Any</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>None.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/fastapi/route.py</code> <pre><code>def __init__(\n    self,\n    path: Union[NameRequired, str],\n    *extra: Union[NameRequired, str],\n    endpoint: Union[\n        Callable[P_HandlerParams, T_HandlerReturn],\n        HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn],\n    ],\n    broker: BrokerAsyncUsecase[MsgType, Any],\n    dependencies: Sequence[params.Depends] = (),\n    dependency_overrides_provider: Optional[Any] = None,\n    **handle_kwargs: Any,\n) -&gt; None:\n\"\"\"Initialize a class instance.\n\n    Args:\n        path: The path of the instance.\n        *extra: Additional arguments.\n        endpoint: The endpoint of the instance.\n        broker: The broker of the instance.\n        dependencies: The dependencies of the instance.\n        dependency_overrides_provider: The provider for dependency overrides.\n        **handle_kwargs: Additional keyword arguments.\n\n    Returns:\n        None.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    self.path = path\n    self.broker = broker\n\n    path_name = (path if isinstance(path, str) else path.name) or \"\"\n\n    if isinstance(endpoint, HandlerCallWrapper):\n        orig_call = endpoint._original_call\n    else:\n        orig_call = endpoint\n\n    dependant = get_dependant(\n        path=path_name,\n        call=orig_call,\n    )\n    for depends in dependencies[::-1]:\n        dependant.dependencies.insert(\n            0,\n            get_parameterless_sub_dependant(depends=depends, path=path_name),\n        )\n    self.dependant = dependant\n\n    call = wraps(orig_call)(\n        StreamMessage.get_session(\n            dependant,\n            dependency_overrides_provider,\n        )\n    )\n\n    if isinstance(endpoint, HandlerCallWrapper):\n        endpoint._original_call = call\n        handler = endpoint\n\n    else:\n        handler = call\n\n    self.handler = broker.subscriber(\n        path,\n        *extra,\n        _raw=True,\n        _get_dependant=lambda call: dependant,\n        **handle_kwargs,\n    )(\n        handler  # type: ignore[arg-type]\n    )\n</code></pre>"},{"location":"api/faststream/broker/fastapi/route/get_app/","title":"get_app","text":""},{"location":"api/faststream/broker/fastapi/route/get_app/#faststream.broker.fastapi.route.get_app","title":"faststream.broker.fastapi.route.get_app","text":"<pre><code>get_app(\n    dependant: Dependant,\n    dependency_overrides_provider: Optional[Any] = None,\n) -&gt; Callable[\n    [StreamMessage], Coroutine[Any, Any, SendableMessage]\n]\n</code></pre> <p>Creates a FastAPI application.</p> <p>Parameters:</p> Name Type Description Default <code>dependant</code> <code>Dependant</code> <p>The dependant object that defines the endpoint function and its dependencies.</p> required <code>dependency_overrides_provider</code> <code>Optional[Any]</code> <p>Optional provider for dependency overrides.</p> <code>None</code> <p>Returns:</p> Type Description <code>Callable[[StreamMessage], Coroutine[Any, Any, SendableMessage]]</code> <p>The FastAPI application as a callable that takes a StreamMessage object as input and returns a SendableMessage coroutine.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If the code reaches an unreachable state.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/fastapi/route.py</code> <pre><code>def get_app(\n    dependant: Dependant,\n    dependency_overrides_provider: Optional[Any] = None,\n) -&gt; Callable[[StreamMessage], Coroutine[Any, Any, SendableMessage]]:\n\"\"\"Creates a FastAPI application.\n\n    Args:\n        dependant: The dependant object that defines the endpoint function and its dependencies.\n        dependency_overrides_provider: Optional provider for dependency overrides.\n\n    Returns:\n        The FastAPI application as a callable that takes a StreamMessage object as input and returns a SendableMessage coroutine.\n\n    Raises:\n        AssertionError: If the code reaches an unreachable state.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    async def app(request: StreamMessage) -&gt; SendableMessage:\n\"\"\"Handle an HTTP request and return a response.\n\n        Args:\n            request: The incoming HTTP request.\n\n        Returns:\n            The response to be sent back to the client.\n\n        Raises:\n            AssertionError: If the code reaches an unreachable point.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        async with AsyncExitStack() as stack:\n            request.scope[\"fastapi_astack\"] = stack\n\n            solved_result = await solve_dependencies(\n                request=request,\n                body=request._body,\n                dependant=dependant,\n                dependency_overrides_provider=dependency_overrides_provider,\n            )\n\n            values, errors, _, _2, _3 = solved_result\n            if errors:\n                raise_fastapi_validation_error(errors, request._body)\n\n            return cast(\n                SendableMessage,\n                await run_endpoint_function(\n                    dependant=dependant,\n                    values=values,\n                    is_coroutine=asyncio.iscoroutinefunction(dependant.call),\n                ),\n            )\n\n        raise AssertionError(\"unreachable\")\n\n    return app\n</code></pre>"},{"location":"api/faststream/broker/fastapi/router/StreamRouter/","title":"StreamRouter","text":""},{"location":"api/faststream/broker/fastapi/router/StreamRouter/#faststream.broker.fastapi.router.StreamRouter","title":"faststream.broker.fastapi.router.StreamRouter","text":"<p>             Bases: <code>APIRouter</code>, <code>Generic[MsgType]</code></p> <p>A class to route streams.</p> <p>Attributes:</p> Name Type Description <code>broker_class</code> <p>type of the broker</p> <code>broker</code> <p>instance of the broker</p> <code>docs_router</code> <p>optional APIRouter for documentation</p> <code>_after_startup_hooks</code> <p>list of functions to be executed after startup</p> <code>schema</code> <p>optional schema</p> <code>title</code> <p>title of the router</p> <code>description</code> <p>description of the router</p> <code>version</code> <p>version of the router</p> <code>license</code> <p>optional license information</p> <code>contact</code> <p>optional contact information</p> <p>Methods:</p> Name Description <code>__init__ </code> <p>initialize the StreamRouter</p> <code>add_api_mq_route </code> <p>add a route for API and message queue</p> <code>subscriber </code> <p>decorator to define a subscriber</p> <code>wrap_lifespan </code> <p>wrap the lifespan of the router</p> <code>after_startup </code> <p>decorator to define a function to be executed after startup</p> <code>publisher </code> <p>create a publisher for the broker</p> <code>asyncapi_router </code> <p>create an APIRouter for AsyncAPI documentation</p> <code>include_router </code> <p>include another router in the StreamRouter</p> <code>_setup_log_context </code> <p>setup log context for the broker</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/fastapi/router.py</code> <pre><code>class StreamRouter(APIRouter, Generic[MsgType]):\n\"\"\"A class to route streams.\n\n    Attributes:\n        broker_class : type of the broker\n        broker : instance of the broker\n        docs_router : optional APIRouter for documentation\n        _after_startup_hooks : list of functions to be executed after startup\n        schema : optional schema\n\n        title : title of the router\n        description : description of the router\n        version : version of the router\n        license : optional license information\n        contact : optional contact information\n\n    Methods:\n        __init__ : initialize the StreamRouter\n        add_api_mq_route : add a route for API and message queue\n        subscriber : decorator to define a subscriber\n        wrap_lifespan : wrap the lifespan of the router\n        after_startup : decorator to define a function to be executed after startup\n        publisher : create a publisher for the broker\n        asyncapi_router : create an APIRouter for AsyncAPI documentation\n        include_router : include another router in the StreamRouter\n        _setup_log_context : setup log context for the broker\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    broker_class: Type[BrokerAsyncUsecase[MsgType, Any]]\n    broker: BrokerAsyncUsecase[MsgType, Any]\n    docs_router: Optional[APIRouter]\n    _after_startup_hooks: List[\n        Callable[[AppType], Awaitable[Optional[Mapping[str, Any]]]]\n    ]\n    schema: Optional[Schema]\n\n    title: str\n    description: str\n    version: str\n    license: Optional[AnyDict]\n    contact: Optional[AnyDict]\n\n    def __init__(\n        self,\n        *connection_args: Tuple[Any, ...],\n        prefix: str = \"\",\n        tags: Optional[List[Union[str, Enum]]] = None,\n        dependencies: Optional[Sequence[params.Depends]] = None,\n        default_response_class: Type[Response] = Default(JSONResponse),\n        responses: Optional[Dict[Union[int, str], AnyDict]] = None,\n        callbacks: Optional[List[routing.BaseRoute]] = None,\n        routes: Optional[List[routing.BaseRoute]] = None,\n        redirect_slashes: bool = True,\n        default: Optional[ASGIApp] = None,\n        dependency_overrides_provider: Optional[Any] = None,\n        route_class: Type[APIRoute] = APIRoute,\n        on_startup: Optional[Sequence[Callable[[], Any]]] = None,\n        on_shutdown: Optional[Sequence[Callable[[], Any]]] = None,\n        deprecated: Optional[bool] = None,\n        include_in_schema: bool = True,\n        setup_state: bool = True,\n        lifespan: Optional[Lifespan[Any]] = None,\n        generate_unique_id_function: Callable[[APIRoute], str] = Default(\n            generate_unique_id\n        ),\n        # AsyncAPI information\n        asyncapi_tags: Optional[Sequence[Union[asyncapi.Tag, asyncapi.TagDict]]] = None,\n        schema_url: Optional[str] = \"/asyncapi\",\n        **connection_kwars: Any,\n    ) -&gt; None:\n\"\"\"Initialize an instance of a class.\n\n        Args:\n            *connection_args: Variable length arguments for the connection\n            prefix: Prefix for the class\n            tags: Optional list of tags for the class\n            dependencies: Optional sequence of dependencies for the class\n            default_response_class: Default response class for the class\n            responses: Optional dictionary of responses for the class\n            callbacks: Optional list of callbacks for the class\n            routes: Optional list of routes for the class\n            redirect_slashes: Boolean value indicating whether to redirect slashes\n            default: Optional default value for the class\n            dependency_overrides_provider: Optional provider for dependency overrides\n            route_class: Route class for the class\n            on_startup: Optional sequence of functions to run on startup\n            on_shutdown: Optional sequence of functions to run on shutdown\n            deprecated: Optional boolean value indicating whether the class is deprecated\n            include_in_schema: Boolean value indicating whether to include the class in the schema\n            setup_state: Boolean value indicating whether to setup state\n            lifespan: Optional lifespan for the class\n            generate_unique_id_function: Function to generate unique ID for the class\n            asyncapi_tags: Optional sequence of asyncapi tags for the class schema\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        assert (  # nosec B101\n            self.broker_class\n        ), \"You should specify `broker_class` at your implementation\"\n\n        self.broker = self.broker_class(\n            *connection_args,\n            apply_types=False,\n            tags=asyncapi_tags,\n            **connection_kwars,\n        )\n\n        self.setup_state = setup_state\n\n        # AsyncAPI information\n        # Empty\n        self.terms_of_service = None\n        self.identifier = None\n        self.asyncapi_tags = None\n        self.external_docs = None\n        # parse from FastAPI app on startup\n        self.title = \"\"\n        self.version = \"\"\n        self.description = \"\"\n        self.license = None\n        self.contact = None\n\n        self.schema = None\n\n        super().__init__(\n            prefix=prefix,\n            tags=tags,\n            dependencies=dependencies,\n            default_response_class=default_response_class,\n            responses=responses,\n            callbacks=callbacks,\n            routes=routes,\n            redirect_slashes=redirect_slashes,\n            default=default,\n            dependency_overrides_provider=dependency_overrides_provider,\n            route_class=route_class,\n            deprecated=deprecated,\n            include_in_schema=include_in_schema,\n            generate_unique_id_function=generate_unique_id_function,\n            lifespan=self.wrap_lifespan(lifespan),\n            on_startup=on_startup,\n            on_shutdown=on_shutdown,\n        )\n\n        self.docs_router = self.asyncapi_router(schema_url)\n\n        self._after_startup_hooks = []\n\n    def add_api_mq_route(\n        self,\n        path: Union[NameRequired, str],\n        *extra: Union[NameRequired, str],\n        endpoint: Callable[P_HandlerParams, T_HandlerReturn],\n        dependencies: Sequence[params.Depends],\n        **broker_kwargs: Any,\n    ) -&gt; HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn]:\n\"\"\"Add an API message queue route.\n\n        Args:\n            path: The path of the route.\n            *extra: Additional path segments.\n            endpoint: The endpoint function to be called for this route.\n            dependencies: The dependencies required by the endpoint function.\n            **broker_kwargs: Additional keyword arguments to be passed to the broker.\n\n        Returns:\n            The handler call wrapper for the route.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        route: StreamRoute[MsgType, P_HandlerParams, T_HandlerReturn] = StreamRoute(\n            path,\n            *extra,\n            endpoint=endpoint,\n            dependencies=dependencies,\n            dependency_overrides_provider=self.dependency_overrides_provider,\n            broker=self.broker,\n            **broker_kwargs,\n        )\n        self.routes.append(route)\n        return route.handler\n\n    def subscriber(\n        self,\n        path: Union[str, NameRequired],\n        *extra: Union[NameRequired, str],\n        dependencies: Optional[Sequence[params.Depends]] = None,\n        **broker_kwargs: Any,\n    ) -&gt; Callable[\n        [Callable[P_HandlerParams, T_HandlerReturn]],\n        HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn],\n    ]:\n\"\"\"A function decorator for subscribing to a message queue.\n\n        Args:\n            path : The path to subscribe to. Can be a string or a `NameRequired` object.\n            *extra : Additional path segments. Can be a `NameRequired` object or a string.\n            dependencies : Optional sequence of dependencies.\n            **broker_kwargs : Additional keyword arguments for the broker.\n\n        Returns:\n            A callable decorator that adds the decorated function as an endpoint for the specified path.\n\n        Raises:\n            NotImplementedError: If silent animals are not supported.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        current_dependencies = self.dependencies.copy()\n        if dependencies:\n            current_dependencies.extend(dependencies)\n\n        def decorator(\n            func: Callable[P_HandlerParams, T_HandlerReturn],\n        ) -&gt; HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn]:\n\"\"\"A decorator function.\n\n            Args:\n                func: The function to be decorated.\n\n            Returns:\n                The decorated function.\n            !!! note\n\n                The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n            \"\"\"\n            return self.add_api_mq_route(\n                path,\n                *extra,\n                endpoint=func,\n                dependencies=current_dependencies,\n                **broker_kwargs,\n            )\n\n        return decorator\n\n    def wrap_lifespan(self, lifespan: Optional[Lifespan[Any]] = None) -&gt; Lifespan[Any]:\n\"\"\"Wrap the lifespan of the application.\n\n        Args:\n            lifespan: Optional lifespan object.\n\n        Returns:\n            The wrapped lifespan object.\n\n        Raises:\n            NotImplementedError: If silent animals are not supported.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        if lifespan is not None:\n            lifespan_context = lifespan\n        else:\n            lifespan_context = _DefaultLifespan(self)\n\n        @asynccontextmanager\n        async def start_broker_lifespan(\n            app: FastAPI,\n        ) -&gt; AsyncIterator[Mapping[str, Any]]:\n\"\"\"Starts the lifespan of a broker.\n\n            Args:\n                app (FastAPI): The FastAPI application.\n\n            Yields:\n                AsyncIterator[Mapping[str, Any]]: A mapping of context information during the lifespan of the broker.\n\n            Raises:\n                NotImplementedError: If silent animals are not supported.\n            !!! note\n\n                The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n            \"\"\"\n            from faststream.asyncapi.generate import get_app_schema\n\n            self.title = app.title\n            self.description = app.description\n            self.version = app.version\n            self.contact = app.contact\n            self.license = app.license_info\n\n            self.schema = get_app_schema(self)\n            if self.docs_router:\n                app.include_router(self.docs_router)\n\n            async with lifespan_context(app) as maybe_context:\n                if maybe_context is None:\n                    context: AnyDict = {}\n                else:\n                    context = dict(maybe_context)\n\n                context.update({\"broker\": self.broker})\n                await self.broker.start()\n\n                for h in self._after_startup_hooks:\n                    h_context = await h(app)\n                    if h_context:  # pragma: no branch\n                        context.update(h_context)\n\n                try:\n                    if self.setup_state:\n                        yield context\n                    else:\n                        # NOTE: old asgi compatibility\n                        yield  # type: ignore\n\n                finally:\n                    await self.broker.close()\n\n        return start_broker_lifespan\n\n    @overload\n    def after_startup(\n        self,\n        func: Callable[[AppType], Mapping[str, Any]],\n    ) -&gt; Callable[[AppType], Mapping[str, Any]]:\n\"\"\"A function decorator to be used for executing a function after startup.\n\n        Args:\n            func: A function that takes an `AppType` argument and returns a mapping of strings to any type.\n\n        Returns:\n            A decorated function that takes an `AppType` argument and returns a mapping of strings to any type.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        ...\n\n    @overload\n    def after_startup(\n        self,\n        func: Callable[[AppType], Awaitable[Mapping[str, Any]]],\n    ) -&gt; Callable[[AppType], Awaitable[Mapping[str, Any]]]:\n\"\"\"A function decorator to be used for running a function after the startup of an application.\n\n        Args:\n            func: The function to be decorated. It should take an argument of type AppType and return an awaitable mapping of strings to any type.\n\n        Returns:\n            The decorated function.\n\n        Note:\n            This function can be used as a decorator for other functions.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        ...\n\n    @overload\n    def after_startup(\n        self,\n        func: Callable[[AppType], None],\n    ) -&gt; Callable[[AppType], None]:\n\"\"\"A function decorator to be used for running a function after the startup of an application.\n\n        Args:\n            func: The function to be executed after startup.\n\n        Returns:\n            A decorated function that will be executed after startup.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        ...\n\n    @overload\n    def after_startup(\n        self,\n        func: Callable[[AppType], Awaitable[None]],\n    ) -&gt; Callable[[AppType], Awaitable[None]]:\n\"\"\"Decorator to register a function to be executed after the application startup.\n\n        Args:\n            func: A callable that takes an `AppType` argument and returns an awaitable `None`.\n\n        Returns:\n            A decorated function that takes an `AppType` argument and returns an awaitable `None`.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        ...\n\n    def after_startup(\n        self,\n        func: Union[\n            Callable[[AppType], Mapping[str, Any]],\n            Callable[[AppType], Awaitable[Mapping[str, Any]]],\n            Callable[[AppType], None],\n            Callable[[AppType], Awaitable[None]],\n        ],\n    ) -&gt; Union[\n        Callable[[AppType], Mapping[str, Any]],\n        Callable[[AppType], Awaitable[Mapping[str, Any]]],\n        Callable[[AppType], None],\n        Callable[[AppType], Awaitable[None]],\n    ]:\n\"\"\"Register a function to be executed after startup.\n\n        Args:\n            func: A function to be executed after startup. It can take an `AppType` argument and return a mapping of strings to any values, or it can take an `AppType` argument and return an awaitable that resolves to a mapping of strings to any values, or it can take an `AppType` argument and return nothing, or it can take an `AppType` argument and return an awaitable that resolves to nothing.\n\n        Returns:\n            The registered function.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        self._after_startup_hooks.append(to_async(func))  # type: ignore\n        return func\n\n    def publisher(\n        self,\n        queue: Union[NameRequired, str],\n        *publisher_args: Any,\n        **publisher_kwargs: Any,\n    ) -&gt; BasePublisher[MsgType]:\n\"\"\"Publishes messages to a queue.\n\n        Args:\n            queue: The queue to publish the messages to. Can be either a `NameRequired` object or a string.\n            *publisher_args: Additional arguments to be passed to the publisher.\n            **publisher_kwargs: Additional keyword arguments to be passed to the publisher.\n\n        Returns:\n            An instance of `BasePublisher` that can be used to publish messages to the specified queue.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        return self.broker.publisher(\n            queue,\n            *publisher_args,\n            **publisher_kwargs,\n        )\n\n    def asyncapi_router(self, schema_url: Optional[str]) -&gt; Optional[APIRouter]:\n\"\"\"Creates an API router for serving AsyncAPI documentation.\n\n        Args:\n            schema_url: The URL where the AsyncAPI schema will be served.\n\n        Returns:\n            An instance of APIRouter if include_in_schema and schema_url are both True, otherwise returns None.\n\n        Raises:\n            AssertionError: If self.schema is not set.\n\n        Notes:\n            This function defines three nested functions: download_app_json_schema, download_app_yaml_schema, and serve_asyncapi_schema. These functions are used to handle different routes for serving the AsyncAPI schema and documentation.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        if not self.include_in_schema or not schema_url:\n            return None\n\n        def download_app_json_schema() -&gt; Response:\n            assert (  # nosec B101\n                self.schema\n            ), \"You need to run application lifespan at first\"\n\n            return Response(\n                content=json.dumps(self.schema.to_jsonable(), indent=4),\n                headers={\"Content-Type\": \"application/octet-stream\"},\n            )\n\n        def download_app_yaml_schema() -&gt; Response:\n            assert (  # nosec B101\n                self.schema\n            ), \"You need to run application lifespan at first\"\n\n            return Response(\n                content=self.schema.to_yaml(),\n                headers={\n                    \"Content-Type\": \"application/octet-stream\",\n                },\n            )\n\n        def serve_asyncapi_schema(\n            sidebar: bool = True,\n            info: bool = True,\n            servers: bool = True,\n            operations: bool = True,\n            messages: bool = True,\n            schemas: bool = True,\n            errors: bool = True,\n            expandMessageExamples: bool = True,\n        ) -&gt; HTMLResponse:\n\"\"\"Serve the AsyncAPI schema as an HTML response.\n\n            Args:\n                sidebar (bool, optional): Whether to include the sidebar in the HTML. Defaults to True.\n                info (bool, optional): Whether to include the info section in the HTML. Defaults to True.\n                servers (bool, optional): Whether to include the servers section in the HTML. Defaults to True.\n                operations (bool, optional): Whether to include the operations section in the HTML. Defaults to True.\n                messages (bool, optional): Whether to include the messages section in the HTML. Defaults to True.\n                schemas (bool, optional): Whether to include the schemas section in the HTML. Defaults to True.\n                errors (bool, optional): Whether to include the errors section in the HTML. Defaults to True.\n                expandMessageExamples (bool, optional): Whether to expand message examples in the HTML. Defaults to True.\n\n            Returns:\n                HTMLResponse: The HTML response containing the AsyncAPI schema.\n\n            Raises:\n                AssertionError: If the schema is not available.\n            !!! note\n\n                The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n            \"\"\"\n            assert (  # nosec B101\n                self.schema\n            ), \"You need to run application lifespan at first\"\n\n            return HTMLResponse(\n                content=get_asyncapi_html(\n                    self.schema,\n                    sidebar=sidebar,\n                    info=info,\n                    servers=servers,\n                    operations=operations,\n                    messages=messages,\n                    schemas=schemas,\n                    errors=errors,\n                    expand_message_examples=expandMessageExamples,\n                    title=self.schema.info.title,\n                )\n            )\n\n        docs_router = APIRouter(\n            prefix=self.prefix,\n            tags=[\"asyncapi\"],\n            redirect_slashes=self.redirect_slashes,\n            default=self.default,\n            deprecated=self.deprecated,\n        )\n        docs_router.get(schema_url)(serve_asyncapi_schema)\n        docs_router.get(f\"{schema_url}.json\")(download_app_json_schema)\n        docs_router.get(f\"{schema_url}.yaml\")(download_app_yaml_schema)\n        return docs_router\n\n    def include_router(\n        self,\n        router: \"APIRouter\",\n        *,\n        prefix: str = \"\",\n        tags: Optional[List[Union[str, Enum]]] = None,\n        dependencies: Optional[Sequence[params.Depends]] = None,\n        default_response_class: Type[Response] = Default(JSONResponse),\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        callbacks: Optional[List[BaseRoute]] = None,\n        deprecated: Optional[bool] = None,\n        include_in_schema: bool = True,\n        generate_unique_id_function: Callable[[APIRoute], str] = Default(\n            generate_unique_id\n        ),\n    ) -&gt; None:\n\"\"\"Includes a router in the API.\n\n        Args:\n            router (APIRouter): The router to include.\n            prefix (str, optional): The prefix to prepend to all paths defined in the router. Defaults to \"\".\n            tags (List[Union[str, Enum]], optional): The tags to assign to all paths defined in the router. Defaults to None.\n            dependencies (Sequence[params.Depends], optional): The dependencies to apply to all paths defined in the router. Defaults to None.\n            default_response_class (Type[Response], optional): The default response class to use for all paths defined in the router. Defaults to Default(JSONResponse).\n            responses (Dict[Union[int, str], Dict[str, Any]], optional): The responses to define for all paths defined in the router. Defaults to None.\n            callbacks (List[BaseRoute], optional): The callbacks to apply to all paths defined in the router. Defaults to None.\n            deprecated (bool, optional): Whether the router is deprecated. Defaults to None.\n            include_in_schema (bool, optional): Whether to include the router in the API schema. Defaults to True.\n            generate_unique_id_function (Callable[[APIRoute], str], optional): The function to generate unique IDs for\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        if isinstance(router, StreamRouter):\n            self._setup_log_context(self.broker, router.broker)\n            self.broker.handlers.update(router.broker.handlers)\n            self.broker._publishers.update(router.broker._publishers)\n\n        super().include_router(\n            router=router,\n            prefix=prefix,\n            tags=tags,\n            dependencies=dependencies,\n            default_response_class=default_response_class,\n            responses=responses,\n            callbacks=callbacks,\n            deprecated=deprecated,\n            include_in_schema=include_in_schema,\n            generate_unique_id_function=generate_unique_id_function,\n        )\n\n    @staticmethod\n    @abstractmethod\n    def _setup_log_context(\n        main_broker: BrokerAsyncUsecase[MsgType, Any],\n        including_broker: BrokerAsyncUsecase[MsgType, Any],\n    ) -&gt; None:\n\"\"\"Set up log context.\n\n        Args:\n            main_broker: The main broker.\n            including_broker: The including broker.\n\n        Returns:\n            None\n\n        Raises:\n            NotImplementedError: If the function is not implemented.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        raise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/broker/fastapi/router/StreamRouter/#faststream.broker.fastapi.router.StreamRouter-attributes","title":"Attributes","text":""},{"location":"api/faststream/broker/fastapi/router/StreamRouter/#faststream.broker.fastapi.router.StreamRouter.asyncapi_tags","title":"asyncapi_tags  <code>instance-attribute</code>","text":"<pre><code>asyncapi_tags = None\n</code></pre>"},{"location":"api/faststream/broker/fastapi/router/StreamRouter/#faststream.broker.fastapi.router.StreamRouter.broker","title":"broker  <code>instance-attribute</code>","text":"<pre><code>broker: BrokerAsyncUsecase[\n    MsgType, Any\n] = self.broker_class(\n    *connection_args,\n    apply_types=False,\n    tags=asyncapi_tags,\n    **connection_kwars\n)\n</code></pre>"},{"location":"api/faststream/broker/fastapi/router/StreamRouter/#faststream.broker.fastapi.router.StreamRouter.broker_class","title":"broker_class  <code>instance-attribute</code>","text":"<pre><code>broker_class: Type[BrokerAsyncUsecase[MsgType, Any]]\n</code></pre>"},{"location":"api/faststream/broker/fastapi/router/StreamRouter/#faststream.broker.fastapi.router.StreamRouter.contact","title":"contact  <code>instance-attribute</code>","text":"<pre><code>contact: Optional[AnyDict] = None\n</code></pre>"},{"location":"api/faststream/broker/fastapi/router/StreamRouter/#faststream.broker.fastapi.router.StreamRouter.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description: str = ''\n</code></pre>"},{"location":"api/faststream/broker/fastapi/router/StreamRouter/#faststream.broker.fastapi.router.StreamRouter.docs_router","title":"docs_router  <code>instance-attribute</code>","text":"<pre><code>docs_router: Optional[APIRouter] = self.asyncapi_router(\n    schema_url\n)\n</code></pre>"},{"location":"api/faststream/broker/fastapi/router/StreamRouter/#faststream.broker.fastapi.router.StreamRouter.external_docs","title":"external_docs  <code>instance-attribute</code>","text":"<pre><code>external_docs = None\n</code></pre>"},{"location":"api/faststream/broker/fastapi/router/StreamRouter/#faststream.broker.fastapi.router.StreamRouter.identifier","title":"identifier  <code>instance-attribute</code>","text":"<pre><code>identifier = None\n</code></pre>"},{"location":"api/faststream/broker/fastapi/router/StreamRouter/#faststream.broker.fastapi.router.StreamRouter.license","title":"license  <code>instance-attribute</code>","text":"<pre><code>license: Optional[AnyDict] = None\n</code></pre>"},{"location":"api/faststream/broker/fastapi/router/StreamRouter/#faststream.broker.fastapi.router.StreamRouter.schema","title":"schema  <code>instance-attribute</code>","text":"<pre><code>schema: Optional[Schema] = None\n</code></pre>"},{"location":"api/faststream/broker/fastapi/router/StreamRouter/#faststream.broker.fastapi.router.StreamRouter.setup_state","title":"setup_state  <code>instance-attribute</code>","text":"<pre><code>setup_state = setup_state\n</code></pre>"},{"location":"api/faststream/broker/fastapi/router/StreamRouter/#faststream.broker.fastapi.router.StreamRouter.terms_of_service","title":"terms_of_service  <code>instance-attribute</code>","text":"<pre><code>terms_of_service = None\n</code></pre>"},{"location":"api/faststream/broker/fastapi/router/StreamRouter/#faststream.broker.fastapi.router.StreamRouter.title","title":"title  <code>instance-attribute</code>","text":"<pre><code>title: str = ''\n</code></pre>"},{"location":"api/faststream/broker/fastapi/router/StreamRouter/#faststream.broker.fastapi.router.StreamRouter.version","title":"version  <code>instance-attribute</code>","text":"<pre><code>version: str = ''\n</code></pre>"},{"location":"api/faststream/broker/fastapi/router/StreamRouter/#faststream.broker.fastapi.router.StreamRouter-functions","title":"Functions","text":""},{"location":"api/faststream/broker/fastapi/router/StreamRouter/#faststream.broker.fastapi.router.StreamRouter.__init__","title":"__init__","text":"<pre><code>__init__(\n    *connection_args: Tuple[Any, ...],\n    prefix: str = \"\",\n    tags: Optional[List[Union[str, Enum]]] = None,\n    dependencies: Optional[Sequence[params.Depends]] = None,\n    default_response_class: Type[Response] = Default(\n        JSONResponse\n    ),\n    responses: Optional[\n        Dict[Union[int, str], AnyDict]\n    ] = None,\n    callbacks: Optional[List[routing.BaseRoute]] = None,\n    routes: Optional[List[routing.BaseRoute]] = None,\n    redirect_slashes: bool = True,\n    default: Optional[ASGIApp] = None,\n    dependency_overrides_provider: Optional[Any] = None,\n    route_class: Type[APIRoute] = APIRoute,\n    on_startup: Optional[\n        Sequence[Callable[[], Any]]\n    ] = None,\n    on_shutdown: Optional[\n        Sequence[Callable[[], Any]]\n    ] = None,\n    deprecated: Optional[bool] = None,\n    include_in_schema: bool = True,\n    setup_state: bool = True,\n    lifespan: Optional[Lifespan[Any]] = None,\n    generate_unique_id_function: Callable[\n        [APIRoute], str\n    ] = Default(generate_unique_id),\n    asyncapi_tags: Optional[\n        Sequence[Union[asyncapi.Tag, asyncapi.TagDict]]\n    ] = None,\n    schema_url: Optional[str] = \"/asyncapi\",\n    **connection_kwars: Any\n) -&gt; None\n</code></pre> <p>Initialize an instance of a class.</p> <p>Parameters:</p> Name Type Description Default <code>*connection_args</code> <code>Tuple[Any, ...]</code> <p>Variable length arguments for the connection</p> <code>()</code> <code>prefix</code> <code>str</code> <p>Prefix for the class</p> <code>''</code> <code>tags</code> <code>Optional[List[Union[str, Enum]]]</code> <p>Optional list of tags for the class</p> <code>None</code> <code>dependencies</code> <code>Optional[Sequence[Depends]]</code> <p>Optional sequence of dependencies for the class</p> <code>None</code> <code>default_response_class</code> <code>Type[Response]</code> <p>Default response class for the class</p> <code>Default(JSONResponse)</code> <code>responses</code> <code>Optional[Dict[Union[int, str], AnyDict]]</code> <p>Optional dictionary of responses for the class</p> <code>None</code> <code>callbacks</code> <code>Optional[List[BaseRoute]]</code> <p>Optional list of callbacks for the class</p> <code>None</code> <code>routes</code> <code>Optional[List[BaseRoute]]</code> <p>Optional list of routes for the class</p> <code>None</code> <code>redirect_slashes</code> <code>bool</code> <p>Boolean value indicating whether to redirect slashes</p> <code>True</code> <code>default</code> <code>Optional[ASGIApp]</code> <p>Optional default value for the class</p> <code>None</code> <code>dependency_overrides_provider</code> <code>Optional[Any]</code> <p>Optional provider for dependency overrides</p> <code>None</code> <code>route_class</code> <code>Type[APIRoute]</code> <p>Route class for the class</p> <code>APIRoute</code> <code>on_startup</code> <code>Optional[Sequence[Callable[[], Any]]]</code> <p>Optional sequence of functions to run on startup</p> <code>None</code> <code>on_shutdown</code> <code>Optional[Sequence[Callable[[], Any]]]</code> <p>Optional sequence of functions to run on shutdown</p> <code>None</code> <code>deprecated</code> <code>Optional[bool]</code> <p>Optional boolean value indicating whether the class is deprecated</p> <code>None</code> <code>include_in_schema</code> <code>bool</code> <p>Boolean value indicating whether to include the class in the schema</p> <code>True</code> <code>setup_state</code> <code>bool</code> <p>Boolean value indicating whether to setup state</p> <code>True</code> <code>lifespan</code> <code>Optional[Lifespan[Any]]</code> <p>Optional lifespan for the class</p> <code>None</code> <code>generate_unique_id_function</code> <code>Callable[[APIRoute], str]</code> <p>Function to generate unique ID for the class</p> <code>Default(generate_unique_id)</code> <code>asyncapi_tags</code> <code>Optional[Sequence[Union[Tag, TagDict]]]</code> <p>Optional sequence of asyncapi tags for the class schema</p> <code>None</code> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/fastapi/router.py</code> <pre><code>def __init__(\n    self,\n    *connection_args: Tuple[Any, ...],\n    prefix: str = \"\",\n    tags: Optional[List[Union[str, Enum]]] = None,\n    dependencies: Optional[Sequence[params.Depends]] = None,\n    default_response_class: Type[Response] = Default(JSONResponse),\n    responses: Optional[Dict[Union[int, str], AnyDict]] = None,\n    callbacks: Optional[List[routing.BaseRoute]] = None,\n    routes: Optional[List[routing.BaseRoute]] = None,\n    redirect_slashes: bool = True,\n    default: Optional[ASGIApp] = None,\n    dependency_overrides_provider: Optional[Any] = None,\n    route_class: Type[APIRoute] = APIRoute,\n    on_startup: Optional[Sequence[Callable[[], Any]]] = None,\n    on_shutdown: Optional[Sequence[Callable[[], Any]]] = None,\n    deprecated: Optional[bool] = None,\n    include_in_schema: bool = True,\n    setup_state: bool = True,\n    lifespan: Optional[Lifespan[Any]] = None,\n    generate_unique_id_function: Callable[[APIRoute], str] = Default(\n        generate_unique_id\n    ),\n    # AsyncAPI information\n    asyncapi_tags: Optional[Sequence[Union[asyncapi.Tag, asyncapi.TagDict]]] = None,\n    schema_url: Optional[str] = \"/asyncapi\",\n    **connection_kwars: Any,\n) -&gt; None:\n\"\"\"Initialize an instance of a class.\n\n    Args:\n        *connection_args: Variable length arguments for the connection\n        prefix: Prefix for the class\n        tags: Optional list of tags for the class\n        dependencies: Optional sequence of dependencies for the class\n        default_response_class: Default response class for the class\n        responses: Optional dictionary of responses for the class\n        callbacks: Optional list of callbacks for the class\n        routes: Optional list of routes for the class\n        redirect_slashes: Boolean value indicating whether to redirect slashes\n        default: Optional default value for the class\n        dependency_overrides_provider: Optional provider for dependency overrides\n        route_class: Route class for the class\n        on_startup: Optional sequence of functions to run on startup\n        on_shutdown: Optional sequence of functions to run on shutdown\n        deprecated: Optional boolean value indicating whether the class is deprecated\n        include_in_schema: Boolean value indicating whether to include the class in the schema\n        setup_state: Boolean value indicating whether to setup state\n        lifespan: Optional lifespan for the class\n        generate_unique_id_function: Function to generate unique ID for the class\n        asyncapi_tags: Optional sequence of asyncapi tags for the class schema\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    assert (  # nosec B101\n        self.broker_class\n    ), \"You should specify `broker_class` at your implementation\"\n\n    self.broker = self.broker_class(\n        *connection_args,\n        apply_types=False,\n        tags=asyncapi_tags,\n        **connection_kwars,\n    )\n\n    self.setup_state = setup_state\n\n    # AsyncAPI information\n    # Empty\n    self.terms_of_service = None\n    self.identifier = None\n    self.asyncapi_tags = None\n    self.external_docs = None\n    # parse from FastAPI app on startup\n    self.title = \"\"\n    self.version = \"\"\n    self.description = \"\"\n    self.license = None\n    self.contact = None\n\n    self.schema = None\n\n    super().__init__(\n        prefix=prefix,\n        tags=tags,\n        dependencies=dependencies,\n        default_response_class=default_response_class,\n        responses=responses,\n        callbacks=callbacks,\n        routes=routes,\n        redirect_slashes=redirect_slashes,\n        default=default,\n        dependency_overrides_provider=dependency_overrides_provider,\n        route_class=route_class,\n        deprecated=deprecated,\n        include_in_schema=include_in_schema,\n        generate_unique_id_function=generate_unique_id_function,\n        lifespan=self.wrap_lifespan(lifespan),\n        on_startup=on_startup,\n        on_shutdown=on_shutdown,\n    )\n\n    self.docs_router = self.asyncapi_router(schema_url)\n\n    self._after_startup_hooks = []\n</code></pre>"},{"location":"api/faststream/broker/fastapi/router/StreamRouter/#faststream.broker.fastapi.router.StreamRouter.add_api_mq_route","title":"add_api_mq_route","text":"<pre><code>add_api_mq_route(\n    path: Union[NameRequired, str],\n    *extra: Union[NameRequired, str],\n    endpoint: Callable[P_HandlerParams, T_HandlerReturn],\n    dependencies: Sequence[params.Depends],\n    **broker_kwargs: Any\n) -&gt; HandlerCallWrapper[\n    MsgType, P_HandlerParams, T_HandlerReturn\n]\n</code></pre> <p>Add an API message queue route.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[NameRequired, str]</code> <p>The path of the route.</p> required <code>*extra</code> <code>Union[NameRequired, str]</code> <p>Additional path segments.</p> <code>()</code> <code>endpoint</code> <code>Callable[P_HandlerParams, T_HandlerReturn]</code> <p>The endpoint function to be called for this route.</p> required <code>dependencies</code> <code>Sequence[Depends]</code> <p>The dependencies required by the endpoint function.</p> required <code>**broker_kwargs</code> <code>Any</code> <p>Additional keyword arguments to be passed to the broker.</p> <code>{}</code> <p>Returns:</p> Type Description <code>HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn]</code> <p>The handler call wrapper for the route.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/fastapi/router.py</code> <pre><code>def add_api_mq_route(\n    self,\n    path: Union[NameRequired, str],\n    *extra: Union[NameRequired, str],\n    endpoint: Callable[P_HandlerParams, T_HandlerReturn],\n    dependencies: Sequence[params.Depends],\n    **broker_kwargs: Any,\n) -&gt; HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn]:\n\"\"\"Add an API message queue route.\n\n    Args:\n        path: The path of the route.\n        *extra: Additional path segments.\n        endpoint: The endpoint function to be called for this route.\n        dependencies: The dependencies required by the endpoint function.\n        **broker_kwargs: Additional keyword arguments to be passed to the broker.\n\n    Returns:\n        The handler call wrapper for the route.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    route: StreamRoute[MsgType, P_HandlerParams, T_HandlerReturn] = StreamRoute(\n        path,\n        *extra,\n        endpoint=endpoint,\n        dependencies=dependencies,\n        dependency_overrides_provider=self.dependency_overrides_provider,\n        broker=self.broker,\n        **broker_kwargs,\n    )\n    self.routes.append(route)\n    return route.handler\n</code></pre>"},{"location":"api/faststream/broker/fastapi/router/StreamRouter/#faststream.broker.fastapi.router.StreamRouter.after_startup","title":"after_startup","text":"<pre><code>after_startup(\n    func: Union[\n        Callable[[AppType], Mapping[str, Any]],\n        Callable[[AppType], Awaitable[Mapping[str, Any]]],\n        Callable[[AppType], None],\n        Callable[[AppType], Awaitable[None]],\n    ]\n) -&gt; Union[\n    Callable[[AppType], Mapping[str, Any]],\n    Callable[[AppType], Awaitable[Mapping[str, Any]]],\n    Callable[[AppType], None],\n    Callable[[AppType], Awaitable[None]],\n]\n</code></pre> <p>Register a function to be executed after startup.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Union[Callable[[AppType], Mapping[str, Any]], Callable[[AppType], Awaitable[Mapping[str, Any]]], Callable[[AppType], None], Callable[[AppType], Awaitable[None]]]</code> <p>A function to be executed after startup. It can take an <code>AppType</code> argument and return a mapping of strings to any values, or it can take an <code>AppType</code> argument and return an awaitable that resolves to a mapping of strings to any values, or it can take an <code>AppType</code> argument and return nothing, or it can take an <code>AppType</code> argument and return an awaitable that resolves to nothing.</p> required <p>Returns:</p> Type Description <code>Union[Callable[[AppType], Mapping[str, Any]], Callable[[AppType], Awaitable[Mapping[str, Any]]], Callable[[AppType], None], Callable[[AppType], Awaitable[None]]]</code> <p>The registered function.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/fastapi/router.py</code> <pre><code>def after_startup(\n    self,\n    func: Union[\n        Callable[[AppType], Mapping[str, Any]],\n        Callable[[AppType], Awaitable[Mapping[str, Any]]],\n        Callable[[AppType], None],\n        Callable[[AppType], Awaitable[None]],\n    ],\n) -&gt; Union[\n    Callable[[AppType], Mapping[str, Any]],\n    Callable[[AppType], Awaitable[Mapping[str, Any]]],\n    Callable[[AppType], None],\n    Callable[[AppType], Awaitable[None]],\n]:\n\"\"\"Register a function to be executed after startup.\n\n    Args:\n        func: A function to be executed after startup. It can take an `AppType` argument and return a mapping of strings to any values, or it can take an `AppType` argument and return an awaitable that resolves to a mapping of strings to any values, or it can take an `AppType` argument and return nothing, or it can take an `AppType` argument and return an awaitable that resolves to nothing.\n\n    Returns:\n        The registered function.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    self._after_startup_hooks.append(to_async(func))  # type: ignore\n    return func\n</code></pre>"},{"location":"api/faststream/broker/fastapi/router/StreamRouter/#faststream.broker.fastapi.router.StreamRouter.asyncapi_router","title":"asyncapi_router","text":"<pre><code>asyncapi_router(\n    schema_url: Optional[str],\n) -&gt; Optional[APIRouter]\n</code></pre> <p>Creates an API router for serving AsyncAPI documentation.</p> <p>Parameters:</p> Name Type Description Default <code>schema_url</code> <code>Optional[str]</code> <p>The URL where the AsyncAPI schema will be served.</p> required <p>Returns:</p> Type Description <code>Optional[APIRouter]</code> <p>An instance of APIRouter if include_in_schema and schema_url are both True, otherwise returns None.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If self.schema is not set.</p> Notes <p>This function defines three nested functions: download_app_json_schema, download_app_yaml_schema, and serve_asyncapi_schema. These functions are used to handle different routes for serving the AsyncAPI schema and documentation.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/fastapi/router.py</code> <pre><code>def asyncapi_router(self, schema_url: Optional[str]) -&gt; Optional[APIRouter]:\n\"\"\"Creates an API router for serving AsyncAPI documentation.\n\n    Args:\n        schema_url: The URL where the AsyncAPI schema will be served.\n\n    Returns:\n        An instance of APIRouter if include_in_schema and schema_url are both True, otherwise returns None.\n\n    Raises:\n        AssertionError: If self.schema is not set.\n\n    Notes:\n        This function defines three nested functions: download_app_json_schema, download_app_yaml_schema, and serve_asyncapi_schema. These functions are used to handle different routes for serving the AsyncAPI schema and documentation.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    if not self.include_in_schema or not schema_url:\n        return None\n\n    def download_app_json_schema() -&gt; Response:\n        assert (  # nosec B101\n            self.schema\n        ), \"You need to run application lifespan at first\"\n\n        return Response(\n            content=json.dumps(self.schema.to_jsonable(), indent=4),\n            headers={\"Content-Type\": \"application/octet-stream\"},\n        )\n\n    def download_app_yaml_schema() -&gt; Response:\n        assert (  # nosec B101\n            self.schema\n        ), \"You need to run application lifespan at first\"\n\n        return Response(\n            content=self.schema.to_yaml(),\n            headers={\n                \"Content-Type\": \"application/octet-stream\",\n            },\n        )\n\n    def serve_asyncapi_schema(\n        sidebar: bool = True,\n        info: bool = True,\n        servers: bool = True,\n        operations: bool = True,\n        messages: bool = True,\n        schemas: bool = True,\n        errors: bool = True,\n        expandMessageExamples: bool = True,\n    ) -&gt; HTMLResponse:\n\"\"\"Serve the AsyncAPI schema as an HTML response.\n\n        Args:\n            sidebar (bool, optional): Whether to include the sidebar in the HTML. Defaults to True.\n            info (bool, optional): Whether to include the info section in the HTML. Defaults to True.\n            servers (bool, optional): Whether to include the servers section in the HTML. Defaults to True.\n            operations (bool, optional): Whether to include the operations section in the HTML. Defaults to True.\n            messages (bool, optional): Whether to include the messages section in the HTML. Defaults to True.\n            schemas (bool, optional): Whether to include the schemas section in the HTML. Defaults to True.\n            errors (bool, optional): Whether to include the errors section in the HTML. Defaults to True.\n            expandMessageExamples (bool, optional): Whether to expand message examples in the HTML. Defaults to True.\n\n        Returns:\n            HTMLResponse: The HTML response containing the AsyncAPI schema.\n\n        Raises:\n            AssertionError: If the schema is not available.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        assert (  # nosec B101\n            self.schema\n        ), \"You need to run application lifespan at first\"\n\n        return HTMLResponse(\n            content=get_asyncapi_html(\n                self.schema,\n                sidebar=sidebar,\n                info=info,\n                servers=servers,\n                operations=operations,\n                messages=messages,\n                schemas=schemas,\n                errors=errors,\n                expand_message_examples=expandMessageExamples,\n                title=self.schema.info.title,\n            )\n        )\n\n    docs_router = APIRouter(\n        prefix=self.prefix,\n        tags=[\"asyncapi\"],\n        redirect_slashes=self.redirect_slashes,\n        default=self.default,\n        deprecated=self.deprecated,\n    )\n    docs_router.get(schema_url)(serve_asyncapi_schema)\n    docs_router.get(f\"{schema_url}.json\")(download_app_json_schema)\n    docs_router.get(f\"{schema_url}.yaml\")(download_app_yaml_schema)\n    return docs_router\n</code></pre>"},{"location":"api/faststream/broker/fastapi/router/StreamRouter/#faststream.broker.fastapi.router.StreamRouter.include_router","title":"include_router","text":"<pre><code>include_router(\n    router: APIRouter,\n    *,\n    prefix: str = \"\",\n    tags: Optional[List[Union[str, Enum]]] = None,\n    dependencies: Optional[Sequence[params.Depends]] = None,\n    default_response_class: Type[Response] = Default(\n        JSONResponse\n    ),\n    responses: Optional[\n        Dict[Union[int, str], Dict[str, Any]]\n    ] = None,\n    callbacks: Optional[List[BaseRoute]] = None,\n    deprecated: Optional[bool] = None,\n    include_in_schema: bool = True,\n    generate_unique_id_function: Callable[\n        [APIRoute], str\n    ] = Default(generate_unique_id)\n) -&gt; None\n</code></pre> <p>Includes a router in the API.</p> <p>Parameters:</p> Name Type Description Default <code>router</code> <code>APIRouter</code> <p>The router to include.</p> required <code>prefix</code> <code>str</code> <p>The prefix to prepend to all paths defined in the router. Defaults to \"\".</p> <code>''</code> <code>tags</code> <code>List[Union[str, Enum]]</code> <p>The tags to assign to all paths defined in the router. Defaults to None.</p> <code>None</code> <code>dependencies</code> <code>Sequence[Depends]</code> <p>The dependencies to apply to all paths defined in the router. Defaults to None.</p> <code>None</code> <code>default_response_class</code> <code>Type[Response]</code> <p>The default response class to use for all paths defined in the router. Defaults to Default(JSONResponse).</p> <code>Default(JSONResponse)</code> <code>responses</code> <code>Dict[Union[int, str], Dict[str, Any]]</code> <p>The responses to define for all paths defined in the router. Defaults to None.</p> <code>None</code> <code>callbacks</code> <code>List[BaseRoute]</code> <p>The callbacks to apply to all paths defined in the router. Defaults to None.</p> <code>None</code> <code>deprecated</code> <code>bool</code> <p>Whether the router is deprecated. Defaults to None.</p> <code>None</code> <code>include_in_schema</code> <code>bool</code> <p>Whether to include the router in the API schema. Defaults to True.</p> <code>True</code> <code>generate_unique_id_function</code> <code>Callable[[APIRoute], str]</code> <p>The function to generate unique IDs for</p> <code>Default(generate_unique_id)</code> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/fastapi/router.py</code> <pre><code>def include_router(\n    self,\n    router: \"APIRouter\",\n    *,\n    prefix: str = \"\",\n    tags: Optional[List[Union[str, Enum]]] = None,\n    dependencies: Optional[Sequence[params.Depends]] = None,\n    default_response_class: Type[Response] = Default(JSONResponse),\n    responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n    callbacks: Optional[List[BaseRoute]] = None,\n    deprecated: Optional[bool] = None,\n    include_in_schema: bool = True,\n    generate_unique_id_function: Callable[[APIRoute], str] = Default(\n        generate_unique_id\n    ),\n) -&gt; None:\n\"\"\"Includes a router in the API.\n\n    Args:\n        router (APIRouter): The router to include.\n        prefix (str, optional): The prefix to prepend to all paths defined in the router. Defaults to \"\".\n        tags (List[Union[str, Enum]], optional): The tags to assign to all paths defined in the router. Defaults to None.\n        dependencies (Sequence[params.Depends], optional): The dependencies to apply to all paths defined in the router. Defaults to None.\n        default_response_class (Type[Response], optional): The default response class to use for all paths defined in the router. Defaults to Default(JSONResponse).\n        responses (Dict[Union[int, str], Dict[str, Any]], optional): The responses to define for all paths defined in the router. Defaults to None.\n        callbacks (List[BaseRoute], optional): The callbacks to apply to all paths defined in the router. Defaults to None.\n        deprecated (bool, optional): Whether the router is deprecated. Defaults to None.\n        include_in_schema (bool, optional): Whether to include the router in the API schema. Defaults to True.\n        generate_unique_id_function (Callable[[APIRoute], str], optional): The function to generate unique IDs for\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    if isinstance(router, StreamRouter):\n        self._setup_log_context(self.broker, router.broker)\n        self.broker.handlers.update(router.broker.handlers)\n        self.broker._publishers.update(router.broker._publishers)\n\n    super().include_router(\n        router=router,\n        prefix=prefix,\n        tags=tags,\n        dependencies=dependencies,\n        default_response_class=default_response_class,\n        responses=responses,\n        callbacks=callbacks,\n        deprecated=deprecated,\n        include_in_schema=include_in_schema,\n        generate_unique_id_function=generate_unique_id_function,\n    )\n</code></pre>"},{"location":"api/faststream/broker/fastapi/router/StreamRouter/#faststream.broker.fastapi.router.StreamRouter.publisher","title":"publisher","text":"<pre><code>publisher(\n    queue: Union[NameRequired, str],\n    *publisher_args: Any,\n    **publisher_kwargs: Any\n) -&gt; BasePublisher[MsgType]\n</code></pre> <p>Publishes messages to a queue.</p> <p>Parameters:</p> Name Type Description Default <code>queue</code> <code>Union[NameRequired, str]</code> <p>The queue to publish the messages to. Can be either a <code>NameRequired</code> object or a string.</p> required <code>*publisher_args</code> <code>Any</code> <p>Additional arguments to be passed to the publisher.</p> <code>()</code> <code>**publisher_kwargs</code> <code>Any</code> <p>Additional keyword arguments to be passed to the publisher.</p> <code>{}</code> <p>Returns:</p> Type Description <code>BasePublisher[MsgType]</code> <p>An instance of <code>BasePublisher</code> that can be used to publish messages to the specified queue.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/fastapi/router.py</code> <pre><code>def publisher(\n    self,\n    queue: Union[NameRequired, str],\n    *publisher_args: Any,\n    **publisher_kwargs: Any,\n) -&gt; BasePublisher[MsgType]:\n\"\"\"Publishes messages to a queue.\n\n    Args:\n        queue: The queue to publish the messages to. Can be either a `NameRequired` object or a string.\n        *publisher_args: Additional arguments to be passed to the publisher.\n        **publisher_kwargs: Additional keyword arguments to be passed to the publisher.\n\n    Returns:\n        An instance of `BasePublisher` that can be used to publish messages to the specified queue.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    return self.broker.publisher(\n        queue,\n        *publisher_args,\n        **publisher_kwargs,\n    )\n</code></pre>"},{"location":"api/faststream/broker/fastapi/router/StreamRouter/#faststream.broker.fastapi.router.StreamRouter.subscriber","title":"subscriber","text":"<pre><code>subscriber(\n    path: Union[str, NameRequired],\n    *extra: Union[NameRequired, str],\n    dependencies: Optional[Sequence[params.Depends]] = None,\n    **broker_kwargs: Any\n) -&gt; Callable[\n    [Callable[P_HandlerParams, T_HandlerReturn]],\n    HandlerCallWrapper[\n        MsgType, P_HandlerParams, T_HandlerReturn\n    ],\n]\n</code></pre> <p>A function decorator for subscribing to a message queue.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <p>The path to subscribe to. Can be a string or a <code>NameRequired</code> object.</p> required <code>*extra</code> <p>Additional path segments. Can be a <code>NameRequired</code> object or a string.</p> <code>()</code> <code>dependencies</code> <p>Optional sequence of dependencies.</p> <code>None</code> <code>**broker_kwargs</code> <p>Additional keyword arguments for the broker.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Callable[[Callable[P_HandlerParams, T_HandlerReturn]], HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn]]</code> <p>A callable decorator that adds the decorated function as an endpoint for the specified path.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If silent animals are not supported.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/fastapi/router.py</code> <pre><code>def subscriber(\n    self,\n    path: Union[str, NameRequired],\n    *extra: Union[NameRequired, str],\n    dependencies: Optional[Sequence[params.Depends]] = None,\n    **broker_kwargs: Any,\n) -&gt; Callable[\n    [Callable[P_HandlerParams, T_HandlerReturn]],\n    HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn],\n]:\n\"\"\"A function decorator for subscribing to a message queue.\n\n    Args:\n        path : The path to subscribe to. Can be a string or a `NameRequired` object.\n        *extra : Additional path segments. Can be a `NameRequired` object or a string.\n        dependencies : Optional sequence of dependencies.\n        **broker_kwargs : Additional keyword arguments for the broker.\n\n    Returns:\n        A callable decorator that adds the decorated function as an endpoint for the specified path.\n\n    Raises:\n        NotImplementedError: If silent animals are not supported.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    current_dependencies = self.dependencies.copy()\n    if dependencies:\n        current_dependencies.extend(dependencies)\n\n    def decorator(\n        func: Callable[P_HandlerParams, T_HandlerReturn],\n    ) -&gt; HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn]:\n\"\"\"A decorator function.\n\n        Args:\n            func: The function to be decorated.\n\n        Returns:\n            The decorated function.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        return self.add_api_mq_route(\n            path,\n            *extra,\n            endpoint=func,\n            dependencies=current_dependencies,\n            **broker_kwargs,\n        )\n\n    return decorator\n</code></pre>"},{"location":"api/faststream/broker/fastapi/router/StreamRouter/#faststream.broker.fastapi.router.StreamRouter.wrap_lifespan","title":"wrap_lifespan","text":"<pre><code>wrap_lifespan(\n    lifespan: Optional[Lifespan[Any]] = None,\n) -&gt; Lifespan[Any]\n</code></pre> <p>Wrap the lifespan of the application.</p> <p>Parameters:</p> Name Type Description Default <code>lifespan</code> <code>Optional[Lifespan[Any]]</code> <p>Optional lifespan object.</p> <code>None</code> <p>Returns:</p> Type Description <code>Lifespan[Any]</code> <p>The wrapped lifespan object.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If silent animals are not supported.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/fastapi/router.py</code> <pre><code>def wrap_lifespan(self, lifespan: Optional[Lifespan[Any]] = None) -&gt; Lifespan[Any]:\n\"\"\"Wrap the lifespan of the application.\n\n    Args:\n        lifespan: Optional lifespan object.\n\n    Returns:\n        The wrapped lifespan object.\n\n    Raises:\n        NotImplementedError: If silent animals are not supported.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    if lifespan is not None:\n        lifespan_context = lifespan\n    else:\n        lifespan_context = _DefaultLifespan(self)\n\n    @asynccontextmanager\n    async def start_broker_lifespan(\n        app: FastAPI,\n    ) -&gt; AsyncIterator[Mapping[str, Any]]:\n\"\"\"Starts the lifespan of a broker.\n\n        Args:\n            app (FastAPI): The FastAPI application.\n\n        Yields:\n            AsyncIterator[Mapping[str, Any]]: A mapping of context information during the lifespan of the broker.\n\n        Raises:\n            NotImplementedError: If silent animals are not supported.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        from faststream.asyncapi.generate import get_app_schema\n\n        self.title = app.title\n        self.description = app.description\n        self.version = app.version\n        self.contact = app.contact\n        self.license = app.license_info\n\n        self.schema = get_app_schema(self)\n        if self.docs_router:\n            app.include_router(self.docs_router)\n\n        async with lifespan_context(app) as maybe_context:\n            if maybe_context is None:\n                context: AnyDict = {}\n            else:\n                context = dict(maybe_context)\n\n            context.update({\"broker\": self.broker})\n            await self.broker.start()\n\n            for h in self._after_startup_hooks:\n                h_context = await h(app)\n                if h_context:  # pragma: no branch\n                    context.update(h_context)\n\n            try:\n                if self.setup_state:\n                    yield context\n                else:\n                    # NOTE: old asgi compatibility\n                    yield  # type: ignore\n\n            finally:\n                await self.broker.close()\n\n    return start_broker_lifespan\n</code></pre>"},{"location":"api/faststream/broker/handler/AsyncHandler/","title":"AsyncHandler","text":""},{"location":"api/faststream/broker/handler/AsyncHandler/#faststream.broker.handler.AsyncHandler","title":"faststream.broker.handler.AsyncHandler","text":"<p>             Bases: <code>BaseHandler[MsgType]</code></p> <p>A class representing an asynchronous handler.</p> <p>Attributes:</p> Name Type Description <code>calls</code> <p>a list of tuples containing the following information: - handler : the handler function - filter : a callable that filters the stream message - parser : an async parser for the message - decoder : an async decoder for the message - middlewares : a sequence of middlewares - dependant : a call model for the handler</p> <p>Methods:</p> Name Description <code>add_call </code> <p>adds a new call to the list of calls</p> <code>consume </code> <p>consumes a message and returns a sendable message</p> <code>start </code> <p>starts the handler</p> <code>close </code> <p>closes the handler</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/handler.py</code> <pre><code>class AsyncHandler(BaseHandler[MsgType]):\n\"\"\"A class representing an asynchronous handler.\n\n    Attributes:\n        calls : a list of tuples containing the following information:\n            - handler : the handler function\n            - filter : a callable that filters the stream message\n            - parser : an async parser for the message\n            - decoder : an async decoder for the message\n            - middlewares : a sequence of middlewares\n            - dependant : a call model for the handler\n\n    Methods:\n        add_call : adds a new call to the list of calls\n        consume : consumes a message and returns a sendable message\n        start : starts the handler\n        close : closes the handler\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    calls: List[\n        Tuple[\n            HandlerCallWrapper[MsgType, Any, SendableMessage],  # handler\n            Callable[[StreamMessage[MsgType]], Awaitable[bool]],  # filter\n            AsyncParser[MsgType],  # parser\n            AsyncDecoder[MsgType],  # decoder\n            Sequence[Callable[[Any], BaseMiddleware]],  # middlewares\n            CallModel[Any, SendableMessage],  # dependant\n        ]\n    ]\n\n    def add_call(\n        self,\n        *,\n        handler: HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn],\n        parser: CustomParser[MsgType],\n        decoder: CustomDecoder[MsgType],\n        dependant: CallModel[P_HandlerParams, T_HandlerReturn],\n        filter: Filter[StreamMessage[MsgType]],\n        middlewares: Optional[Sequence[Callable[[Any], BaseMiddleware]]],\n    ) -&gt; None:\n\"\"\"Adds a call to the handler.\n\n        Args:\n            handler: The handler call wrapper.\n            parser: The custom parser.\n            decoder: The custom decoder.\n            dependant: The call model.\n            filter: The filter for stream messages.\n            middlewares: Optional sequence of middlewares.\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        self.calls.append(\n            (  # type: ignore[arg-type]\n                handler,\n                to_async(filter),\n                to_async(parser) if parser else None,\n                to_async(decoder) if decoder else None,\n                middlewares or (),\n                dependant,\n            )\n        )\n\n    @override\n    async def consume(self, msg: MsgType) -&gt; SendableMessage:  # type: ignore[override]\n\"\"\"Consume a message asynchronously.\n\n        Args:\n            msg: The message to be consumed.\n\n        Returns:\n            The sendable message.\n\n        Raises:\n            StopConsume: If the consumption needs to be stopped.\n\n        Raises:\n            Exception: If an error occurs during consumption.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        result: Optional[WrappedReturn[SendableMessage]] = None\n        result_msg: SendableMessage = None\n\n        async with AsyncExitStack() as stack:\n            gl_middlewares: List[BaseMiddleware] = []\n\n            for m in self.global_middlewares:\n                gl_middlewares.append(await stack.enter_async_context(m(msg)))\n\n            processed = False\n            for handler, filter_, parser, decoder, middlewares, _ in self.calls:\n                local_middlewares: List[BaseMiddleware] = []\n                for local_m in middlewares:\n                    local_middlewares.append(\n                        await stack.enter_async_context(local_m(msg))\n                    )\n\n                all_middlewares = gl_middlewares + local_middlewares\n\n                # TODO: add parser &amp; decoder cashes\n                message = await parser(msg)\n                message.decoded_body = await decoder(message)\n                message.processed = processed\n\n                if await filter_(message):\n                    assert (  # nosec B101\n                        not processed\n                    ), \"You can't proccess a message with multiple consumers\"\n\n                    try:\n                        async with AsyncExitStack() as consume_stack:\n                            for m_consume in all_middlewares:\n                                message.decoded_body = (\n                                    await consume_stack.enter_async_context(\n                                        m_consume.consume_scope(message.decoded_body)\n                                    )\n                                )\n\n                            result = await cast(\n                                Awaitable[Optional[WrappedReturn[SendableMessage]]],\n                                handler.call_wrapped(message),\n                            )\n\n                        if result is not None:\n                            result_msg, pub_response = result\n\n                            # TODO: suppress all publishing errors and raise them after all publishers will be tried\n                            for publisher in (pub_response, *handler._publishers):\n                                if publisher is not None:\n                                    async with AsyncExitStack() as pub_stack:\n                                        result_to_send = result_msg\n\n                                        for m_pub in all_middlewares:\n                                            result_to_send = (\n                                                await pub_stack.enter_async_context(\n                                                    m_pub.publish_scope(result_msg)\n                                                )\n                                            )\n\n                                        await publisher.publish(\n                                            message=result_to_send,\n                                            correlation_id=message.correlation_id,\n                                        )\n\n                    except StopConsume:\n                        await self.close()\n                        return None\n\n                    except Exception as e:\n                        if self.is_test:\n                            raise e\n                        else:\n                            return None\n\n                    else:\n                        message.processed = processed = True\n                        if IS_OPTIMIZED:  # pragma: no cover\n                            break\n\n            assert processed, \"You have to consume message\"  # nosec B101\n\n        return result_msg\n\n    @abstractmethod\n    async def start(self) -&gt; None:\n        raise NotImplementedError()\n\n    @abstractmethod\n    async def close(self) -&gt; None:\n        raise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/broker/handler/AsyncHandler/#faststream.broker.handler.AsyncHandler-attributes","title":"Attributes","text":""},{"location":"api/faststream/broker/handler/AsyncHandler/#faststream.broker.handler.AsyncHandler.calls","title":"calls  <code>instance-attribute</code>","text":"<pre><code>calls: List[\n    Tuple[\n        HandlerCallWrapper[MsgType, Any, SendableMessage],\n        Callable[[StreamMessage[MsgType]], Awaitable[bool]],\n        AsyncParser[MsgType],\n        AsyncDecoder[MsgType],\n        Sequence[Callable[[Any], BaseMiddleware]],\n        CallModel[Any, SendableMessage],\n    ]\n]\n</code></pre>"},{"location":"api/faststream/broker/handler/AsyncHandler/#faststream.broker.handler.AsyncHandler-functions","title":"Functions","text":""},{"location":"api/faststream/broker/handler/AsyncHandler/#faststream.broker.handler.AsyncHandler.add_call","title":"add_call","text":"<pre><code>add_call(\n    *,\n    handler: HandlerCallWrapper[\n        MsgType, P_HandlerParams, T_HandlerReturn\n    ],\n    parser: CustomParser[MsgType],\n    decoder: CustomDecoder[MsgType],\n    dependant: CallModel[P_HandlerParams, T_HandlerReturn],\n    filter: Filter[StreamMessage[MsgType]],\n    middlewares: Optional[\n        Sequence[Callable[[Any], BaseMiddleware]]\n    ]\n) -&gt; None\n</code></pre> <p>Adds a call to the handler.</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn]</code> <p>The handler call wrapper.</p> required <code>parser</code> <code>CustomParser[MsgType]</code> <p>The custom parser.</p> required <code>decoder</code> <code>CustomDecoder[MsgType]</code> <p>The custom decoder.</p> required <code>dependant</code> <code>CallModel[P_HandlerParams, T_HandlerReturn]</code> <p>The call model.</p> required <code>filter</code> <code>Filter[StreamMessage[MsgType]]</code> <p>The filter for stream messages.</p> required <code>middlewares</code> <code>Optional[Sequence[Callable[[Any], BaseMiddleware]]]</code> <p>Optional sequence of middlewares.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/handler.py</code> <pre><code>def add_call(\n    self,\n    *,\n    handler: HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn],\n    parser: CustomParser[MsgType],\n    decoder: CustomDecoder[MsgType],\n    dependant: CallModel[P_HandlerParams, T_HandlerReturn],\n    filter: Filter[StreamMessage[MsgType]],\n    middlewares: Optional[Sequence[Callable[[Any], BaseMiddleware]]],\n) -&gt; None:\n\"\"\"Adds a call to the handler.\n\n    Args:\n        handler: The handler call wrapper.\n        parser: The custom parser.\n        decoder: The custom decoder.\n        dependant: The call model.\n        filter: The filter for stream messages.\n        middlewares: Optional sequence of middlewares.\n\n    Returns:\n        None\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    self.calls.append(\n        (  # type: ignore[arg-type]\n            handler,\n            to_async(filter),\n            to_async(parser) if parser else None,\n            to_async(decoder) if decoder else None,\n            middlewares or (),\n            dependant,\n        )\n    )\n</code></pre>"},{"location":"api/faststream/broker/handler/AsyncHandler/#faststream.broker.handler.AsyncHandler.close","title":"close  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>close() -&gt; None\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/handler.py</code> <pre><code>@abstractmethod\nasync def close(self) -&gt; None:\n    raise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/broker/handler/AsyncHandler/#faststream.broker.handler.AsyncHandler.consume","title":"consume  <code>async</code>","text":"<pre><code>consume(msg: MsgType) -&gt; SendableMessage\n</code></pre> <p>Consume a message asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>MsgType</code> <p>The message to be consumed.</p> required <p>Returns:</p> Type Description <code>SendableMessage</code> <p>The sendable message.</p> <p>Raises:</p> Type Description <code>StopConsume</code> <p>If the consumption needs to be stopped.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If an error occurs during consumption.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/handler.py</code> <pre><code>@override\nasync def consume(self, msg: MsgType) -&gt; SendableMessage:  # type: ignore[override]\n\"\"\"Consume a message asynchronously.\n\n    Args:\n        msg: The message to be consumed.\n\n    Returns:\n        The sendable message.\n\n    Raises:\n        StopConsume: If the consumption needs to be stopped.\n\n    Raises:\n        Exception: If an error occurs during consumption.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    result: Optional[WrappedReturn[SendableMessage]] = None\n    result_msg: SendableMessage = None\n\n    async with AsyncExitStack() as stack:\n        gl_middlewares: List[BaseMiddleware] = []\n\n        for m in self.global_middlewares:\n            gl_middlewares.append(await stack.enter_async_context(m(msg)))\n\n        processed = False\n        for handler, filter_, parser, decoder, middlewares, _ in self.calls:\n            local_middlewares: List[BaseMiddleware] = []\n            for local_m in middlewares:\n                local_middlewares.append(\n                    await stack.enter_async_context(local_m(msg))\n                )\n\n            all_middlewares = gl_middlewares + local_middlewares\n\n            # TODO: add parser &amp; decoder cashes\n            message = await parser(msg)\n            message.decoded_body = await decoder(message)\n            message.processed = processed\n\n            if await filter_(message):\n                assert (  # nosec B101\n                    not processed\n                ), \"You can't proccess a message with multiple consumers\"\n\n                try:\n                    async with AsyncExitStack() as consume_stack:\n                        for m_consume in all_middlewares:\n                            message.decoded_body = (\n                                await consume_stack.enter_async_context(\n                                    m_consume.consume_scope(message.decoded_body)\n                                )\n                            )\n\n                        result = await cast(\n                            Awaitable[Optional[WrappedReturn[SendableMessage]]],\n                            handler.call_wrapped(message),\n                        )\n\n                    if result is not None:\n                        result_msg, pub_response = result\n\n                        # TODO: suppress all publishing errors and raise them after all publishers will be tried\n                        for publisher in (pub_response, *handler._publishers):\n                            if publisher is not None:\n                                async with AsyncExitStack() as pub_stack:\n                                    result_to_send = result_msg\n\n                                    for m_pub in all_middlewares:\n                                        result_to_send = (\n                                            await pub_stack.enter_async_context(\n                                                m_pub.publish_scope(result_msg)\n                                            )\n                                        )\n\n                                    await publisher.publish(\n                                        message=result_to_send,\n                                        correlation_id=message.correlation_id,\n                                    )\n\n                except StopConsume:\n                    await self.close()\n                    return None\n\n                except Exception as e:\n                    if self.is_test:\n                        raise e\n                    else:\n                        return None\n\n                else:\n                    message.processed = processed = True\n                    if IS_OPTIMIZED:  # pragma: no cover\n                        break\n\n        assert processed, \"You have to consume message\"  # nosec B101\n\n    return result_msg\n</code></pre>"},{"location":"api/faststream/broker/handler/AsyncHandler/#faststream.broker.handler.AsyncHandler.start","title":"start  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>start() -&gt; None\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/handler.py</code> <pre><code>@abstractmethod\nasync def start(self) -&gt; None:\n    raise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/broker/handler/BaseHandler/","title":"BaseHandler","text":""},{"location":"api/faststream/broker/handler/BaseHandler/#faststream.broker.handler.BaseHandler","title":"faststream.broker.handler.BaseHandler","text":"<p>             Bases: <code>AsyncAPIOperation</code>, <code>Generic[MsgType]</code></p> <p>A base handler class for asynchronous API operations.</p> <p>Attributes:</p> Name Type Description <code>calls</code> <p>List of tuples representing handler calls, filters, parsers, decoders, middlewares, and dependants.</p> <code>global_middlewares</code> <p>Sequence of global middlewares.</p> <code>is_test</code> <p>Boolean indicating if the handler is in test mode.</p> <p>Methods:</p> Name Description <code>__init__ </code> <p>Initializes the BaseHandler object.</p> <code>set_test </code> <p>Sets the handler to test mode.</p> <code>name </code> <p>Returns the name of the handler.</p> <code>call_name </code> <p>Returns the name of the handler call.</p> <code>description </code> <p>Returns the description of the handler.</p> <code>consume </code> <p>Abstract method to consume a message.</p> <p>Note: This class inherits from AsyncAPIOperation and is a generic class with type parameter MsgType.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/handler.py</code> <pre><code>class BaseHandler(AsyncAPIOperation, Generic[MsgType]):\n\"\"\"A base handler class for asynchronous API operations.\n\n    Attributes:\n        calls : List of tuples representing handler calls, filters, parsers, decoders, middlewares, and dependants.\n        global_middlewares : Sequence of global middlewares.\n        is_test : Boolean indicating if the handler is in test mode.\n\n    Methods:\n        __init__ : Initializes the BaseHandler object.\n        set_test : Sets the handler to test mode.\n        name : Returns the name of the handler.\n        call_name : Returns the name of the handler call.\n        description : Returns the description of the handler.\n        consume : Abstract method to consume a message.\n\n    Note: This class inherits from AsyncAPIOperation and is a generic class with type parameter MsgType.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    calls: Union[\n        List[\n            Tuple[\n                HandlerCallWrapper[MsgType, Any, SendableMessage],  # handler\n                Callable[[StreamMessage[MsgType]], bool],  # filter\n                SyncParser[MsgType],  # parser\n                SyncDecoder[MsgType],  # decoder\n                Sequence[Callable[[Any], BaseMiddleware]],  # middlewares\n                CallModel[Any, SendableMessage],  # dependant\n            ]\n        ],\n        List[\n            Tuple[\n                HandlerCallWrapper[MsgType, Any, SendableMessage],  # handler\n                Callable[[StreamMessage[MsgType]], Awaitable[bool]],  # filter\n                AsyncParser[MsgType],  # parser\n                AsyncDecoder[MsgType],  # decoder\n                Sequence[Callable[[Any], BaseMiddleware]],  # middlewares\n                CallModel[Any, SendableMessage],  # dependant\n            ]\n        ],\n    ]\n\n    global_middlewares: Sequence[Callable[[Any], BaseMiddleware]]\n    is_test: bool\n\n    def __init__(\n        self,\n        *,\n        description: Optional[str] = None,\n        title: Optional[str] = None,\n    ):\n\"\"\"Initialize a new instance of the class.\n\n        Args:\n            description: Optional description of the instance.\n            title: Optional title of the instance.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        self.calls = []  # type: ignore[assignment]\n        self.global_middlewares = []\n        # AsyncAPI information\n        self._description = description\n        self._title = title\n        self.is_test = False\n\n    def set_test(self) -&gt; None:\n        self.is_test = True\n\n    @override\n    @property\n    def name(self) -&gt; Union[str, bool]:  # type: ignore[override]\n        if self._title:\n            return self._title\n\n        if not self.calls:  # pragma: no cover\n            return False\n\n        else:\n            return True\n\n    @property\n    def call_name(self) -&gt; str:\n        caller = self.calls[0][0]._original_call\n        name = getattr(caller, \"__name__\", str(caller))\n        return to_camelcase(name)\n\n    @property\n    def description(self) -&gt; Optional[str]:\n        if not self.calls:  # pragma: no cover\n            description = None\n\n        else:\n            caller = self.calls[0][0]._original_call\n            description = getattr(caller, \"__doc__\", None)\n\n        return self._description or description\n\n    @abstractmethod\n    def consume(self, msg: MsgType) -&gt; SendableMessage:\n\"\"\"Consume a message.\n\n        Args:\n            msg: The message to be consumed.\n\n        Returns:\n            The sendable message.\n\n        Raises:\n            NotImplementedError: If the method is not implemented.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        raise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/broker/handler/BaseHandler/#faststream.broker.handler.BaseHandler-attributes","title":"Attributes","text":""},{"location":"api/faststream/broker/handler/BaseHandler/#faststream.broker.handler.BaseHandler.call_name","title":"call_name  <code>property</code>","text":"<pre><code>call_name: str\n</code></pre>"},{"location":"api/faststream/broker/handler/BaseHandler/#faststream.broker.handler.BaseHandler.calls","title":"calls  <code>instance-attribute</code>","text":"<pre><code>calls: Union[\n    List[\n        Tuple[\n            HandlerCallWrapper[\n                MsgType, Any, SendableMessage\n            ],\n            Callable[[StreamMessage[MsgType]], bool],\n            SyncParser[MsgType],\n            SyncDecoder[MsgType],\n            Sequence[Callable[[Any], BaseMiddleware]],\n            CallModel[Any, SendableMessage],\n        ]\n    ],\n    List[\n        Tuple[\n            HandlerCallWrapper[\n                MsgType, Any, SendableMessage\n            ],\n            Callable[\n                [StreamMessage[MsgType]], Awaitable[bool]\n            ],\n            AsyncParser[MsgType],\n            AsyncDecoder[MsgType],\n            Sequence[Callable[[Any], BaseMiddleware]],\n            CallModel[Any, SendableMessage],\n        ]\n    ],\n] = []\n</code></pre>"},{"location":"api/faststream/broker/handler/BaseHandler/#faststream.broker.handler.BaseHandler.description","title":"description  <code>property</code>","text":"<pre><code>description: Optional[str]\n</code></pre>"},{"location":"api/faststream/broker/handler/BaseHandler/#faststream.broker.handler.BaseHandler.global_middlewares","title":"global_middlewares  <code>instance-attribute</code>","text":"<pre><code>global_middlewares: Sequence[\n    Callable[[Any], BaseMiddleware]\n] = []\n</code></pre>"},{"location":"api/faststream/broker/handler/BaseHandler/#faststream.broker.handler.BaseHandler.is_test","title":"is_test  <code>instance-attribute</code>","text":"<pre><code>is_test: bool = False\n</code></pre>"},{"location":"api/faststream/broker/handler/BaseHandler/#faststream.broker.handler.BaseHandler.name","title":"name  <code>property</code>","text":"<pre><code>name: Union[str, bool]\n</code></pre>"},{"location":"api/faststream/broker/handler/BaseHandler/#faststream.broker.handler.BaseHandler-functions","title":"Functions","text":""},{"location":"api/faststream/broker/handler/BaseHandler/#faststream.broker.handler.BaseHandler.__init__","title":"__init__","text":"<pre><code>__init__(\n    *,\n    description: Optional[str] = None,\n    title: Optional[str] = None\n)\n</code></pre> <p>Initialize a new instance of the class.</p> <p>Parameters:</p> Name Type Description Default <code>description</code> <code>Optional[str]</code> <p>Optional description of the instance.</p> <code>None</code> <code>title</code> <code>Optional[str]</code> <p>Optional title of the instance.</p> <code>None</code> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/handler.py</code> <pre><code>def __init__(\n    self,\n    *,\n    description: Optional[str] = None,\n    title: Optional[str] = None,\n):\n\"\"\"Initialize a new instance of the class.\n\n    Args:\n        description: Optional description of the instance.\n        title: Optional title of the instance.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    self.calls = []  # type: ignore[assignment]\n    self.global_middlewares = []\n    # AsyncAPI information\n    self._description = description\n    self._title = title\n    self.is_test = False\n</code></pre>"},{"location":"api/faststream/broker/handler/BaseHandler/#faststream.broker.handler.BaseHandler.consume","title":"consume  <code>abstractmethod</code>","text":"<pre><code>consume(msg: MsgType) -&gt; SendableMessage\n</code></pre> <p>Consume a message.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>MsgType</code> <p>The message to be consumed.</p> required <p>Returns:</p> Type Description <code>SendableMessage</code> <p>The sendable message.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the method is not implemented.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/handler.py</code> <pre><code>@abstractmethod\ndef consume(self, msg: MsgType) -&gt; SendableMessage:\n\"\"\"Consume a message.\n\n    Args:\n        msg: The message to be consumed.\n\n    Returns:\n        The sendable message.\n\n    Raises:\n        NotImplementedError: If the method is not implemented.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/broker/handler/BaseHandler/#faststream.broker.handler.BaseHandler.set_test","title":"set_test","text":"<pre><code>set_test() -&gt; None\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/handler.py</code> <pre><code>def set_test(self) -&gt; None:\n    self.is_test = True\n</code></pre>"},{"location":"api/faststream/broker/message/ABCStreamMessage/","title":"ABCStreamMessage","text":""},{"location":"api/faststream/broker/message/ABCStreamMessage/#faststream.broker.message.ABCStreamMessage","title":"faststream.broker.message.ABCStreamMessage  <code>dataclass</code>","text":"<p>             Bases: <code>Generic[Msg]</code></p> <p>A generic class to represent a stream message.</p> <p>Attributes:</p> Name Type Description <code>raw_message</code> <p>the raw message</p> <code>body</code> <p>the body of the message, can be bytes or any other type</p> <code>decoded_body</code> <p>the decoded message body, if applicable</p> <code>content_type</code> <p>the content type of the message</p> <code>reply_to</code> <p>the reply-to address of the message</p> <code>headers</code> <p>additional headers of the message</p> <code>message_id</code> <p>the unique identifier of the message</p> <code>correlation_id</code> <p>the correlation identifier of the message</p> <code>processed</code> <p>a flag indicating whether the message has been processed or not</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/message.py</code> <pre><code>@dataclass\nclass ABCStreamMessage(Generic[Msg]):\n\"\"\"A generic class to represent a stream message.\n\n    Attributes:\n        raw_message : the raw message\n        body : the body of the message, can be bytes or any other type\n        decoded_body : the decoded message body, if applicable\n        content_type : the content type of the message\n        reply_to : the reply-to address of the message\n        headers : additional headers of the message\n        message_id : the unique identifier of the message\n        correlation_id : the correlation identifier of the message\n        processed : a flag indicating whether the message has been processed or not\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    raw_message: Msg\n\n    body: Union[bytes, Any]\n    decoded_body: Optional[DecodedMessage] = None\n\n    content_type: Optional[str] = None\n    reply_to: str = \"\"\n    headers: AnyDict = field(default_factory=dict)\n    message_id: str = field(default_factory=lambda: str(uuid4()))  # pragma: no cover\n    correlation_id: str = field(\n        default_factory=lambda: str(uuid4())\n    )  # pragma: no cover\n\n    processed: bool = False\n</code></pre>"},{"location":"api/faststream/broker/message/ABCStreamMessage/#faststream.broker.message.ABCStreamMessage-attributes","title":"Attributes","text":""},{"location":"api/faststream/broker/message/ABCStreamMessage/#faststream.broker.message.ABCStreamMessage.body","title":"body  <code>instance-attribute</code>","text":"<pre><code>body: Union[bytes, Any]\n</code></pre>"},{"location":"api/faststream/broker/message/ABCStreamMessage/#faststream.broker.message.ABCStreamMessage.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>content_type: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/broker/message/ABCStreamMessage/#faststream.broker.message.ABCStreamMessage.correlation_id","title":"correlation_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>correlation_id: str = field(\n    default_factory=lambda: str(uuid4())\n)\n</code></pre>"},{"location":"api/faststream/broker/message/ABCStreamMessage/#faststream.broker.message.ABCStreamMessage.decoded_body","title":"decoded_body  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>decoded_body: Optional[DecodedMessage] = None\n</code></pre>"},{"location":"api/faststream/broker/message/ABCStreamMessage/#faststream.broker.message.ABCStreamMessage.headers","title":"headers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>headers: AnyDict = field(default_factory=dict)\n</code></pre>"},{"location":"api/faststream/broker/message/ABCStreamMessage/#faststream.broker.message.ABCStreamMessage.message_id","title":"message_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>message_id: str = field(\n    default_factory=lambda: str(uuid4())\n)\n</code></pre>"},{"location":"api/faststream/broker/message/ABCStreamMessage/#faststream.broker.message.ABCStreamMessage.processed","title":"processed  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>processed: bool = False\n</code></pre>"},{"location":"api/faststream/broker/message/ABCStreamMessage/#faststream.broker.message.ABCStreamMessage.raw_message","title":"raw_message  <code>instance-attribute</code>","text":"<pre><code>raw_message: Msg\n</code></pre>"},{"location":"api/faststream/broker/message/ABCStreamMessage/#faststream.broker.message.ABCStreamMessage.reply_to","title":"reply_to  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>reply_to: str = ''\n</code></pre>"},{"location":"api/faststream/broker/message/StreamMessage/","title":"StreamMessage","text":""},{"location":"api/faststream/broker/message/StreamMessage/#faststream.broker.message.StreamMessage","title":"faststream.broker.message.StreamMessage","text":"<p>             Bases: <code>ABCStreamMessage[Msg]</code></p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/message.py</code> <pre><code>class StreamMessage(ABCStreamMessage[Msg]):\n    @abstractmethod\n    async def ack(self, **kwargs: Any) -&gt; None:\n\"\"\"Acknowledge method.\n\n        Args:\n            **kwargs: Additional keyword arguments\n\n        Raises:\n            NotImplementedError: If the method is not implemented.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        raise NotImplementedError()\n\n    @abstractmethod\n    async def nack(self, **kwargs: Any) -&gt; None:\n\"\"\"A function to handle a nack.\n\n        Args:\n            **kwargs: Additional arguments\n\n        Returns:\n            None\n\n        Raises:\n            NotImplementedError: If the function is not implemented.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        raise NotImplementedError()\n\n    @abstractmethod\n    async def reject(self, **kwargs: Any) -&gt; None:\n\"\"\"Rejects the operation.\n\n        Args:\n            **kwargs: Additional keyword arguments\n\n        Returns:\n            None\n\n        Raises:\n            NotImplementedError: Always raises NotImplementedError\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        raise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/broker/message/StreamMessage/#faststream.broker.message.StreamMessage-functions","title":"Functions","text":""},{"location":"api/faststream/broker/message/StreamMessage/#faststream.broker.message.StreamMessage.ack","title":"ack  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>ack(**kwargs: Any) -&gt; None\n</code></pre> <p>Acknowledge method.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments</p> <code>{}</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the method is not implemented.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/message.py</code> <pre><code>@abstractmethod\nasync def ack(self, **kwargs: Any) -&gt; None:\n\"\"\"Acknowledge method.\n\n    Args:\n        **kwargs: Additional keyword arguments\n\n    Raises:\n        NotImplementedError: If the method is not implemented.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/broker/message/StreamMessage/#faststream.broker.message.StreamMessage.nack","title":"nack  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>nack(**kwargs: Any) -&gt; None\n</code></pre> <p>A function to handle a nack.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Additional arguments</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the function is not implemented.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/message.py</code> <pre><code>@abstractmethod\nasync def nack(self, **kwargs: Any) -&gt; None:\n\"\"\"A function to handle a nack.\n\n    Args:\n        **kwargs: Additional arguments\n\n    Returns:\n        None\n\n    Raises:\n        NotImplementedError: If the function is not implemented.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/broker/message/StreamMessage/#faststream.broker.message.StreamMessage.reject","title":"reject  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>reject(**kwargs: Any) -&gt; None\n</code></pre> <p>Rejects the operation.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Always raises NotImplementedError</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/message.py</code> <pre><code>@abstractmethod\nasync def reject(self, **kwargs: Any) -&gt; None:\n\"\"\"Rejects the operation.\n\n    Args:\n        **kwargs: Additional keyword arguments\n\n    Returns:\n        None\n\n    Raises:\n        NotImplementedError: Always raises NotImplementedError\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/broker/message/SyncStreamMessage/","title":"SyncStreamMessage","text":""},{"location":"api/faststream/broker/message/SyncStreamMessage/#faststream.broker.message.SyncStreamMessage","title":"faststream.broker.message.SyncStreamMessage","text":"<p>             Bases: <code>ABCStreamMessage[Msg]</code></p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/message.py</code> <pre><code>class SyncStreamMessage(ABCStreamMessage[Msg]):\n    @abstractmethod\n    def ack(self, **kwargs: Any) -&gt; None:\n        raise NotImplementedError()\n\n    @abstractmethod\n    def nack(self, **kwargs: Any) -&gt; None:\n\"\"\"A function to raise a NotImplementedError.\n\n        Args:\n            kwargs: Additional keyword arguments\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        raise NotImplementedError()\n\n    @abstractmethod\n    def reject(self, **kwargs: Any) -&gt; None:\n\"\"\"Reject function.\n\n        Args:\n            **kwargs: Arbitrary keyword arguments\n\n        Returns:\n            None\n\n        Raises:\n            NotImplementedError: Always raises NotImplementedError\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        raise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/broker/message/SyncStreamMessage/#faststream.broker.message.SyncStreamMessage-functions","title":"Functions","text":""},{"location":"api/faststream/broker/message/SyncStreamMessage/#faststream.broker.message.SyncStreamMessage.ack","title":"ack  <code>abstractmethod</code>","text":"<pre><code>ack(**kwargs: Any) -&gt; None\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/message.py</code> <pre><code>@abstractmethod\ndef ack(self, **kwargs: Any) -&gt; None:\n    raise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/broker/message/SyncStreamMessage/#faststream.broker.message.SyncStreamMessage.nack","title":"nack  <code>abstractmethod</code>","text":"<pre><code>nack(**kwargs: Any) -&gt; None\n</code></pre> <p>A function to raise a NotImplementedError.</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>Any</code> <p>Additional keyword arguments</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/message.py</code> <pre><code>@abstractmethod\ndef nack(self, **kwargs: Any) -&gt; None:\n\"\"\"A function to raise a NotImplementedError.\n\n    Args:\n        kwargs: Additional keyword arguments\n\n    Returns:\n        None\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/broker/message/SyncStreamMessage/#faststream.broker.message.SyncStreamMessage.reject","title":"reject  <code>abstractmethod</code>","text":"<pre><code>reject(**kwargs: Any) -&gt; None\n</code></pre> <p>Reject function.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Arbitrary keyword arguments</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Always raises NotImplementedError</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/message.py</code> <pre><code>@abstractmethod\ndef reject(self, **kwargs: Any) -&gt; None:\n\"\"\"Reject function.\n\n    Args:\n        **kwargs: Arbitrary keyword arguments\n\n    Returns:\n        None\n\n    Raises:\n        NotImplementedError: Always raises NotImplementedError\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/broker/middlewares/BaseMiddleware/","title":"BaseMiddleware","text":""},{"location":"api/faststream/broker/middlewares/BaseMiddleware/#faststream.broker.middlewares.BaseMiddleware","title":"faststream.broker.middlewares.BaseMiddleware","text":"<p>A base middleware class.</p> <p>Attributes:</p> Name Type Description <code>msg</code> <p>Any - a message</p> <p>Methods:</p> Name Description <code>on_receive</code> <p>Called when a message is received.</p> <code>after_processed</code> <p>Optional[Type[BaseException]] = None, exc_val: Optional[BaseException] = None, exec_tb: Optional[TracebackType] = None) -&gt; Optional[bool]: Called after processing a message.</p> <code>__aenter__</code> <p>Called when entering a context.</p> <code>__aexit__</code> <p>Optional[Type[BaseException]] = None, exc_val: Optional[BaseException] = None, exec_tb: Optional[TracebackType] = None) -&gt; Optional[bool]: Called when exiting a context.</p> <code>on_consume</code> <p>DecodedMessage) -&gt; DecodedMessage: Called before consuming a message.</p> <code>after_consume</code> <p>Optional[Exception]) -&gt; None: Called after consuming a message.</p> <code>consume_scope</code> <p>DecodedMessage) -&gt; AsyncIterator[DecodedMessage]: Context manager for consuming a message.</p> <code>on_publish</code> <p>SendableMessage) -&gt; SendableMessage: Called before publishing a message.</p> <code>after_publish</code> <p>Optional[Exception]) -&gt; None: Asynchronous function to handle the after publish event.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/middlewares.py</code> <pre><code>class BaseMiddleware:\n\"\"\"A base middleware class.\n\n    Attributes:\n        msg: Any - a message\n\n    Methods:\n        on_receive() -&gt; None:\n            Called when a message is received.\n\n        after_processed(exc_type: Optional[Type[BaseException]] = None, exc_val: Optional[BaseException] = None, exec_tb: Optional[TracebackType] = None) -&gt; Optional[bool]:\n            Called after processing a message.\n\n        __aenter__() -&gt; Self:\n            Called when entering a context.\n\n        __aexit__(exc_type: Optional[Type[BaseException]] = None, exc_val: Optional[BaseException] = None, exec_tb: Optional[TracebackType] = None) -&gt; Optional[bool]:\n            Called when exiting a context.\n\n        on_consume(msg: DecodedMessage) -&gt; DecodedMessage:\n            Called before consuming a message.\n\n        after_consume(err: Optional[Exception]) -&gt; None:\n            Called after consuming a message.\n\n        consume_scope(msg: DecodedMessage) -&gt; AsyncIterator[DecodedMessage]:\n            Context manager for consuming a message.\n\n        on_publish(msg: SendableMessage) -&gt; SendableMessage:\n            Called before publishing a message.\n\n        after_publish(err: Optional[Exception]) -&gt; None:\n            Asynchronous function to handle the after publish event.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    def __init__(self, msg: Any) -&gt; None:\n\"\"\"Initialize the class.\n\n        Args:\n            msg: Any message to be stored.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        self.msg = msg\n\n    async def on_receive(self) -&gt; None:\n        pass\n\n    async def after_processed(\n        self,\n        exc_type: Optional[Type[BaseException]] = None,\n        exc_val: Optional[BaseException] = None,\n        exec_tb: Optional[TracebackType] = None,\n    ) -&gt; Optional[bool]:\n\"\"\"Asynchronously called after processing.\n\n        Args:\n            exc_type: Optional exception type\n            exc_val: Optional exception value\n            exec_tb: Optional traceback\n\n        Returns:\n            Optional boolean value indicating whether the processing was successful or not.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        return False\n\n    async def __aenter__(self) -&gt; Self:\n        await self.on_receive()\n        return self\n\n    async def __aexit__(\n        self,\n        exc_type: Optional[Type[BaseException]] = None,\n        exc_val: Optional[BaseException] = None,\n        exec_tb: Optional[TracebackType] = None,\n    ) -&gt; Optional[bool]:\n\"\"\"Exit the asynchronous context manager.\n\n        Args:\n            exc_type: The type of the exception raised, if any.\n            exc_val: The exception instance raised, if any.\n            exec_tb: The traceback for the exception raised, if any.\n\n        Returns:\n            A boolean indicating whether the exception was handled or not.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        return await self.after_processed(exc_type, exc_val, exec_tb)\n\n    async def on_consume(self, msg: DecodedMessage) -&gt; DecodedMessage:\n\"\"\"Asynchronously consumes a message.\n\n        Args:\n            msg: The message to be consumed.\n\n        Returns:\n            The consumed message.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        return msg\n\n    async def after_consume(self, err: Optional[Exception]) -&gt; None:\n\"\"\"A function to handle the result of consuming a resource asynchronously.\n\n        Args:\n            err : Optional exception that occurred during consumption\n\n        Raises:\n            err : If an exception occurred during consumption\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        if err is not None:\n            raise err\n\n    @asynccontextmanager\n    async def consume_scope(self, msg: DecodedMessage) -&gt; AsyncIterator[DecodedMessage]:\n\"\"\"Asynchronously consumes a message and returns an asynchronous iterator of decoded messages.\n\n        Args:\n            msg: The decoded message to consume.\n\n        Yields:\n            An asynchronous iterator of decoded messages.\n\n        Returns:\n            An asynchronous iterator of decoded messages.\n\n        Raises:\n            Exception: If an error occurs while consuming the message.\n\n        AsyncIterator:\n            An asynchronous iterator that yields decoded messages.\n\n        Note:\n            This function is an async function.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        err: Optional[Exception]\n        try:\n            yield await self.on_consume(msg)\n        except Exception as e:\n            err = e\n        else:\n            err = None\n        await self.after_consume(err)\n\n    async def on_publish(self, msg: SendableMessage) -&gt; SendableMessage:\n\"\"\"Asynchronously handle a publish event.\n\n        Args:\n            msg: The message to be published.\n\n        Returns:\n            The published message.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        return msg\n\n    async def after_publish(self, err: Optional[Exception]) -&gt; None:\n\"\"\"Asynchronous function to handle the after publish event.\n\n        Args:\n            err: Optional exception that occurred during the publish\n\n        Returns:\n            None\n\n        Raises:\n            Exception: If an error occurred during the publish\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        if err is not None:\n            raise err\n\n    @asynccontextmanager\n    async def publish_scope(\n        self, msg: SendableMessage\n    ) -&gt; AsyncIterator[SendableMessage]:\n\"\"\"Publish a message and return an async iterator.\n\n        Args:\n            msg: The message to be published.\n\n        Yields:\n            A sendable message.\n\n        Returns:\n            An async iterator of sendable messages.\n\n        Raises:\n            Exception: If an error occurs during publishing.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        err: Optional[Exception]\n        try:\n            yield await self.on_publish(msg)\n        except Exception as e:\n            err = e\n        else:\n            err = None\n        await self.after_publish(err)\n</code></pre>"},{"location":"api/faststream/broker/middlewares/BaseMiddleware/#faststream.broker.middlewares.BaseMiddleware-attributes","title":"Attributes","text":""},{"location":"api/faststream/broker/middlewares/BaseMiddleware/#faststream.broker.middlewares.BaseMiddleware.msg","title":"msg  <code>instance-attribute</code>","text":"<pre><code>msg = msg\n</code></pre>"},{"location":"api/faststream/broker/middlewares/BaseMiddleware/#faststream.broker.middlewares.BaseMiddleware-functions","title":"Functions","text":""},{"location":"api/faststream/broker/middlewares/BaseMiddleware/#faststream.broker.middlewares.BaseMiddleware.__aenter__","title":"__aenter__  <code>async</code>","text":"<pre><code>__aenter__() -&gt; Self\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/middlewares.py</code> <pre><code>async def __aenter__(self) -&gt; Self:\n    await self.on_receive()\n    return self\n</code></pre>"},{"location":"api/faststream/broker/middlewares/BaseMiddleware/#faststream.broker.middlewares.BaseMiddleware.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(\n    exc_type: Optional[Type[BaseException]] = None,\n    exc_val: Optional[BaseException] = None,\n    exec_tb: Optional[TracebackType] = None,\n) -&gt; Optional[bool]\n</code></pre> <p>Exit the asynchronous context manager.</p> <p>Parameters:</p> Name Type Description Default <code>exc_type</code> <code>Optional[Type[BaseException]]</code> <p>The type of the exception raised, if any.</p> <code>None</code> <code>exc_val</code> <code>Optional[BaseException]</code> <p>The exception instance raised, if any.</p> <code>None</code> <code>exec_tb</code> <code>Optional[TracebackType]</code> <p>The traceback for the exception raised, if any.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[bool]</code> <p>A boolean indicating whether the exception was handled or not.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/middlewares.py</code> <pre><code>async def __aexit__(\n    self,\n    exc_type: Optional[Type[BaseException]] = None,\n    exc_val: Optional[BaseException] = None,\n    exec_tb: Optional[TracebackType] = None,\n) -&gt; Optional[bool]:\n\"\"\"Exit the asynchronous context manager.\n\n    Args:\n        exc_type: The type of the exception raised, if any.\n        exc_val: The exception instance raised, if any.\n        exec_tb: The traceback for the exception raised, if any.\n\n    Returns:\n        A boolean indicating whether the exception was handled or not.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    return await self.after_processed(exc_type, exc_val, exec_tb)\n</code></pre>"},{"location":"api/faststream/broker/middlewares/BaseMiddleware/#faststream.broker.middlewares.BaseMiddleware.__init__","title":"__init__","text":"<pre><code>__init__(msg: Any) -&gt; None\n</code></pre> <p>Initialize the class.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>Any</code> <p>Any message to be stored.</p> required <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/middlewares.py</code> <pre><code>def __init__(self, msg: Any) -&gt; None:\n\"\"\"Initialize the class.\n\n    Args:\n        msg: Any message to be stored.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    self.msg = msg\n</code></pre>"},{"location":"api/faststream/broker/middlewares/BaseMiddleware/#faststream.broker.middlewares.BaseMiddleware.after_consume","title":"after_consume  <code>async</code>","text":"<pre><code>after_consume(err: Optional[Exception]) -&gt; None\n</code></pre> <p>A function to handle the result of consuming a resource asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>err</code> <p>Optional exception that occurred during consumption</p> required <p>Raises:</p> Type Description <code>err</code> <p>If an exception occurred during consumption</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/middlewares.py</code> <pre><code>async def after_consume(self, err: Optional[Exception]) -&gt; None:\n\"\"\"A function to handle the result of consuming a resource asynchronously.\n\n    Args:\n        err : Optional exception that occurred during consumption\n\n    Raises:\n        err : If an exception occurred during consumption\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    if err is not None:\n        raise err\n</code></pre>"},{"location":"api/faststream/broker/middlewares/BaseMiddleware/#faststream.broker.middlewares.BaseMiddleware.after_processed","title":"after_processed  <code>async</code>","text":"<pre><code>after_processed(\n    exc_type: Optional[Type[BaseException]] = None,\n    exc_val: Optional[BaseException] = None,\n    exec_tb: Optional[TracebackType] = None,\n) -&gt; Optional[bool]\n</code></pre> <p>Asynchronously called after processing.</p> <p>Parameters:</p> Name Type Description Default <code>exc_type</code> <code>Optional[Type[BaseException]]</code> <p>Optional exception type</p> <code>None</code> <code>exc_val</code> <code>Optional[BaseException]</code> <p>Optional exception value</p> <code>None</code> <code>exec_tb</code> <code>Optional[TracebackType]</code> <p>Optional traceback</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[bool]</code> <p>Optional boolean value indicating whether the processing was successful or not.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/middlewares.py</code> <pre><code>async def after_processed(\n    self,\n    exc_type: Optional[Type[BaseException]] = None,\n    exc_val: Optional[BaseException] = None,\n    exec_tb: Optional[TracebackType] = None,\n) -&gt; Optional[bool]:\n\"\"\"Asynchronously called after processing.\n\n    Args:\n        exc_type: Optional exception type\n        exc_val: Optional exception value\n        exec_tb: Optional traceback\n\n    Returns:\n        Optional boolean value indicating whether the processing was successful or not.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    return False\n</code></pre>"},{"location":"api/faststream/broker/middlewares/BaseMiddleware/#faststream.broker.middlewares.BaseMiddleware.after_publish","title":"after_publish  <code>async</code>","text":"<pre><code>after_publish(err: Optional[Exception]) -&gt; None\n</code></pre> <p>Asynchronous function to handle the after publish event.</p> <p>Parameters:</p> Name Type Description Default <code>err</code> <code>Optional[Exception]</code> <p>Optional exception that occurred during the publish</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If an error occurred during the publish</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/middlewares.py</code> <pre><code>async def after_publish(self, err: Optional[Exception]) -&gt; None:\n\"\"\"Asynchronous function to handle the after publish event.\n\n    Args:\n        err: Optional exception that occurred during the publish\n\n    Returns:\n        None\n\n    Raises:\n        Exception: If an error occurred during the publish\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    if err is not None:\n        raise err\n</code></pre>"},{"location":"api/faststream/broker/middlewares/BaseMiddleware/#faststream.broker.middlewares.BaseMiddleware.consume_scope","title":"consume_scope  <code>async</code>","text":"<pre><code>consume_scope(\n    msg: DecodedMessage,\n) -&gt; AsyncIterator[DecodedMessage]\n</code></pre> <p>Asynchronously consumes a message and returns an asynchronous iterator of decoded messages.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>DecodedMessage</code> <p>The decoded message to consume.</p> required <p>Yields:</p> Type Description <code>AsyncIterator[DecodedMessage]</code> <p>An asynchronous iterator of decoded messages.</p> <p>Returns:</p> Type Description <code>AsyncIterator[DecodedMessage]</code> <p>An asynchronous iterator of decoded messages.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If an error occurs while consuming the message.</p> AsyncIterator <p>An asynchronous iterator that yields decoded messages.</p> Note <p>This function is an async function.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/middlewares.py</code> <pre><code>@asynccontextmanager\nasync def consume_scope(self, msg: DecodedMessage) -&gt; AsyncIterator[DecodedMessage]:\n\"\"\"Asynchronously consumes a message and returns an asynchronous iterator of decoded messages.\n\n    Args:\n        msg: The decoded message to consume.\n\n    Yields:\n        An asynchronous iterator of decoded messages.\n\n    Returns:\n        An asynchronous iterator of decoded messages.\n\n    Raises:\n        Exception: If an error occurs while consuming the message.\n\n    AsyncIterator:\n        An asynchronous iterator that yields decoded messages.\n\n    Note:\n        This function is an async function.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    err: Optional[Exception]\n    try:\n        yield await self.on_consume(msg)\n    except Exception as e:\n        err = e\n    else:\n        err = None\n    await self.after_consume(err)\n</code></pre>"},{"location":"api/faststream/broker/middlewares/BaseMiddleware/#faststream.broker.middlewares.BaseMiddleware.on_consume","title":"on_consume  <code>async</code>","text":"<pre><code>on_consume(msg: DecodedMessage) -&gt; DecodedMessage\n</code></pre> <p>Asynchronously consumes a message.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>DecodedMessage</code> <p>The message to be consumed.</p> required <p>Returns:</p> Type Description <code>DecodedMessage</code> <p>The consumed message.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/middlewares.py</code> <pre><code>async def on_consume(self, msg: DecodedMessage) -&gt; DecodedMessage:\n\"\"\"Asynchronously consumes a message.\n\n    Args:\n        msg: The message to be consumed.\n\n    Returns:\n        The consumed message.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    return msg\n</code></pre>"},{"location":"api/faststream/broker/middlewares/BaseMiddleware/#faststream.broker.middlewares.BaseMiddleware.on_publish","title":"on_publish  <code>async</code>","text":"<pre><code>on_publish(msg: SendableMessage) -&gt; SendableMessage\n</code></pre> <p>Asynchronously handle a publish event.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>SendableMessage</code> <p>The message to be published.</p> required <p>Returns:</p> Type Description <code>SendableMessage</code> <p>The published message.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/middlewares.py</code> <pre><code>async def on_publish(self, msg: SendableMessage) -&gt; SendableMessage:\n\"\"\"Asynchronously handle a publish event.\n\n    Args:\n        msg: The message to be published.\n\n    Returns:\n        The published message.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    return msg\n</code></pre>"},{"location":"api/faststream/broker/middlewares/BaseMiddleware/#faststream.broker.middlewares.BaseMiddleware.on_receive","title":"on_receive  <code>async</code>","text":"<pre><code>on_receive() -&gt; None\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/middlewares.py</code> <pre><code>async def on_receive(self) -&gt; None:\n    pass\n</code></pre>"},{"location":"api/faststream/broker/middlewares/BaseMiddleware/#faststream.broker.middlewares.BaseMiddleware.publish_scope","title":"publish_scope  <code>async</code>","text":"<pre><code>publish_scope(\n    msg: SendableMessage,\n) -&gt; AsyncIterator[SendableMessage]\n</code></pre> <p>Publish a message and return an async iterator.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>SendableMessage</code> <p>The message to be published.</p> required <p>Yields:</p> Type Description <code>AsyncIterator[SendableMessage]</code> <p>A sendable message.</p> <p>Returns:</p> Type Description <code>AsyncIterator[SendableMessage]</code> <p>An async iterator of sendable messages.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If an error occurs during publishing.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/middlewares.py</code> <pre><code>@asynccontextmanager\nasync def publish_scope(\n    self, msg: SendableMessage\n) -&gt; AsyncIterator[SendableMessage]:\n\"\"\"Publish a message and return an async iterator.\n\n    Args:\n        msg: The message to be published.\n\n    Yields:\n        A sendable message.\n\n    Returns:\n        An async iterator of sendable messages.\n\n    Raises:\n        Exception: If an error occurs during publishing.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    err: Optional[Exception]\n    try:\n        yield await self.on_publish(msg)\n    except Exception as e:\n        err = e\n    else:\n        err = None\n    await self.after_publish(err)\n</code></pre>"},{"location":"api/faststream/broker/middlewares/CriticalLogMiddleware/","title":"CriticalLogMiddleware","text":""},{"location":"api/faststream/broker/middlewares/CriticalLogMiddleware/#faststream.broker.middlewares.CriticalLogMiddleware","title":"faststream.broker.middlewares.CriticalLogMiddleware","text":"<p>             Bases: <code>BaseMiddleware</code></p> <p>A middleware class for logging critical errors.</p> <p>Parameters:</p> Name Type Description Default <code>logger</code> <code>Logger</code> <p>The logger object to use for logging</p> required <p>Methods:</p> Name Description <code>__call__</code> <p>Any) -&gt; Self: Returns the middleware instance</p> <code>after_processed</code> <p>Optional[Type[BaseException]] = None, exc_val: Optional[BaseException] = None, exec_tb: Optional[TracebackType] = None) -&gt; bool: Logs critical errors if they occur and returns True</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/middlewares.py</code> <pre><code>class CriticalLogMiddleware(BaseMiddleware):\n\"\"\"A middleware class for logging critical errors.\n\n    Args:\n        logger: The logger object to use for logging\n\n    Methods:\n        __call__(msg: Any) -&gt; Self: Returns the middleware instance\n        after_processed(exc_type: Optional[Type[BaseException]] = None, exc_val: Optional[BaseException] = None, exec_tb: Optional[TracebackType] = None) -&gt; bool: Logs critical errors if they occur and returns True\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    def __init__(self, logger: logging.Logger) -&gt; None:\n\"\"\"Initialize the class.\n\n        Args:\n            logger: an instance of the logging.Logger class\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        self.logger = logger\n\n    def __call__(self, msg: Any) -&gt; Self:\n\"\"\"Call the object with a message.\n\n        Args:\n            msg: Any message to be passed to the object.\n\n        Returns:\n            The object itself.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        return self\n\n    async def after_processed(\n        self,\n        exc_type: Optional[Type[BaseException]] = None,\n        exc_val: Optional[BaseException] = None,\n        exec_tb: Optional[TracebackType] = None,\n    ) -&gt; bool:\n\"\"\"Asynchronously called after processing.\n\n        Args:\n            exc_type (Optional[Type[BaseException]]): Type of the exception raised during processing.\n            exc_val (Optional[BaseException]): Value of the exception raised during processing.\n            exec_tb (Optional[TracebackType]): Traceback of the exception raised during processing.\n\n        Returns:\n            bool: True if the method is successfully executed.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        if exc_type and exc_val:\n            self.logger.critical(f\"{exc_type.__name__}: {exc_val}\", exc_info=exc_val)\n        return True\n</code></pre>"},{"location":"api/faststream/broker/middlewares/CriticalLogMiddleware/#faststream.broker.middlewares.CriticalLogMiddleware-attributes","title":"Attributes","text":""},{"location":"api/faststream/broker/middlewares/CriticalLogMiddleware/#faststream.broker.middlewares.CriticalLogMiddleware.logger","title":"logger  <code>instance-attribute</code>","text":"<pre><code>logger = logger\n</code></pre>"},{"location":"api/faststream/broker/middlewares/CriticalLogMiddleware/#faststream.broker.middlewares.CriticalLogMiddleware-functions","title":"Functions","text":""},{"location":"api/faststream/broker/middlewares/CriticalLogMiddleware/#faststream.broker.middlewares.CriticalLogMiddleware.__call__","title":"__call__","text":"<pre><code>__call__(msg: Any) -&gt; Self\n</code></pre> <p>Call the object with a message.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>Any</code> <p>Any message to be passed to the object.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>The object itself.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/middlewares.py</code> <pre><code>def __call__(self, msg: Any) -&gt; Self:\n\"\"\"Call the object with a message.\n\n    Args:\n        msg: Any message to be passed to the object.\n\n    Returns:\n        The object itself.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    return self\n</code></pre>"},{"location":"api/faststream/broker/middlewares/CriticalLogMiddleware/#faststream.broker.middlewares.CriticalLogMiddleware.__init__","title":"__init__","text":"<pre><code>__init__(logger: logging.Logger) -&gt; None\n</code></pre> <p>Initialize the class.</p> <p>Parameters:</p> Name Type Description Default <code>logger</code> <code>Logger</code> <p>an instance of the logging.Logger class</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/middlewares.py</code> <pre><code>def __init__(self, logger: logging.Logger) -&gt; None:\n\"\"\"Initialize the class.\n\n    Args:\n        logger: an instance of the logging.Logger class\n\n    Returns:\n        None\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    self.logger = logger\n</code></pre>"},{"location":"api/faststream/broker/middlewares/CriticalLogMiddleware/#faststream.broker.middlewares.CriticalLogMiddleware.after_processed","title":"after_processed  <code>async</code>","text":"<pre><code>after_processed(\n    exc_type: Optional[Type[BaseException]] = None,\n    exc_val: Optional[BaseException] = None,\n    exec_tb: Optional[TracebackType] = None,\n) -&gt; bool\n</code></pre> <p>Asynchronously called after processing.</p> <p>Parameters:</p> Name Type Description Default <code>exc_type</code> <code>Optional[Type[BaseException]]</code> <p>Type of the exception raised during processing.</p> <code>None</code> <code>exc_val</code> <code>Optional[BaseException]</code> <p>Value of the exception raised during processing.</p> <code>None</code> <code>exec_tb</code> <code>Optional[TracebackType]</code> <p>Traceback of the exception raised during processing.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the method is successfully executed.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/middlewares.py</code> <pre><code>async def after_processed(\n    self,\n    exc_type: Optional[Type[BaseException]] = None,\n    exc_val: Optional[BaseException] = None,\n    exec_tb: Optional[TracebackType] = None,\n) -&gt; bool:\n\"\"\"Asynchronously called after processing.\n\n    Args:\n        exc_type (Optional[Type[BaseException]]): Type of the exception raised during processing.\n        exc_val (Optional[BaseException]): Value of the exception raised during processing.\n        exec_tb (Optional[TracebackType]): Traceback of the exception raised during processing.\n\n    Returns:\n        bool: True if the method is successfully executed.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    if exc_type and exc_val:\n        self.logger.critical(f\"{exc_type.__name__}: {exc_val}\", exc_info=exc_val)\n    return True\n</code></pre>"},{"location":"api/faststream/broker/parsers/decode_message/","title":"decode_message","text":""},{"location":"api/faststream/broker/parsers/decode_message/#faststream.broker.parsers.decode_message","title":"faststream.broker.parsers.decode_message","text":"<pre><code>decode_message(\n    message: StreamMessage[Any],\n) -&gt; DecodedMessage\n</code></pre> <p>Decodes a message.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>StreamMessage[Any]</code> <p>The message to decode.</p> required <p>Returns:</p> Type Description <code>DecodedMessage</code> <p>The decoded message.</p> <p>Raises:</p> Type Description <code>JSONDecodeError</code> <p>If the message body cannot be decoded as JSON.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/parsers.py</code> <pre><code>def decode_message(message: StreamMessage[Any]) -&gt; DecodedMessage:\n\"\"\"Decodes a message.\n\n    Args:\n        message: The message to decode.\n\n    Returns:\n        The decoded message.\n\n    Raises:\n        JSONDecodeError: If the message body cannot be decoded as JSON.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    body = message.body\n    m: DecodedMessage = body\n\n    if message.content_type:\n        if ContentTypes.text.value in message.content_type:\n            m = body.decode()\n        elif ContentTypes.json.value in message.content_type:  # pragma: no branch\n            m = json.loads(body)\n\n    else:\n        with suppress(json.JSONDecodeError):\n            m = json.loads(body)\n\n    return m\n</code></pre>"},{"location":"api/faststream/broker/parsers/encode_message/","title":"encode_message","text":""},{"location":"api/faststream/broker/parsers/encode_message/#faststream.broker.parsers.encode_message","title":"faststream.broker.parsers.encode_message","text":"<pre><code>encode_message(\n    msg: SendableMessage,\n) -&gt; Tuple[bytes, Optional[ContentType]]\n</code></pre> <p>Encodes a message.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>SendableMessage</code> <p>The message to be encoded.</p> required <p>Returns:</p> Type Description <code>Tuple[bytes, Optional[ContentType]]</code> <p>A tuple containing the encoded message as bytes and the content type of the message.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/parsers.py</code> <pre><code>def encode_message(msg: SendableMessage) -&gt; Tuple[bytes, Optional[ContentType]]:\n\"\"\"Encodes a message.\n\n    Args:\n        msg: The message to be encoded.\n\n    Returns:\n        A tuple containing the encoded message as bytes and the content type of the message.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    if msg is None:\n        return b\"\", None\n\n    if isinstance(msg, bytes):\n        return msg, None\n\n    if isinstance(msg, str):\n        return msg.encode(), ContentTypes.text.value\n\n    return (\n        dump_json(msg).encode(),\n        ContentTypes.json.value,\n    )\n</code></pre>"},{"location":"api/faststream/broker/parsers/resolve_custom_func/","title":"resolve_custom_func","text":""},{"location":"api/faststream/broker/parsers/resolve_custom_func/#faststream.broker.parsers.resolve_custom_func","title":"faststream.broker.parsers.resolve_custom_func","text":"<pre><code>resolve_custom_func(\n    custom_func: Optional[\n        Union[CustomDecoder[MsgType], CustomParser[MsgType]]\n    ],\n    default_func: Union[Decoder[MsgType], Parser[MsgType]],\n) -&gt; Union[Decoder[MsgType], Parser[MsgType]]\n</code></pre> <p>Resolve a custom function.</p> <p>Parameters:</p> Name Type Description Default <code>custom_func</code> <code>Optional[Union[CustomDecoder[MsgType], CustomParser[MsgType]]]</code> <p>Optional custom function of type CustomDecoder or CustomParser.</p> required <code>default_func</code> <code>Union[Decoder[MsgType], Parser[MsgType]]</code> <p>Default function of type Decoder or Parser.</p> required <p>Returns:</p> Type Description <code>Union[Decoder[MsgType], Parser[MsgType]]</code> <p>The resolved function of type Decoder or Parser.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/parsers.py</code> <pre><code>def resolve_custom_func(\n    custom_func: Optional[Union[CustomDecoder[MsgType], CustomParser[MsgType]]],\n    default_func: Union[Decoder[MsgType], Parser[MsgType]],\n) -&gt; Union[Decoder[MsgType], Parser[MsgType]]:\n\"\"\"Resolve a custom function.\n\n    Args:\n        custom_func: Optional custom function of type CustomDecoder or CustomParser.\n        default_func: Default function of type Decoder or Parser.\n\n    Returns:\n        The resolved function of type Decoder or Parser.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    if custom_func is None:\n        return default_func\n\n    original_params = inspect.signature(custom_func).parameters\n    if len(original_params) == 1:\n        return cast(Union[Decoder[MsgType], Parser[MsgType]], custom_func)\n\n    else:\n        name = tuple(original_params.items())[1][0]\n        return partial(custom_func, **{name: default_func})  # type: ignore\n</code></pre>"},{"location":"api/faststream/broker/publisher/BasePublisher/","title":"BasePublisher","text":""},{"location":"api/faststream/broker/publisher/BasePublisher/#faststream.broker.publisher.BasePublisher","title":"faststream.broker.publisher.BasePublisher  <code>dataclass</code>","text":"<p>             Bases: <code>AsyncAPIOperation</code>, <code>Generic[MsgType]</code></p> <p>A base class for publishers in an asynchronous API.</p> <p>Attributes:</p> Name Type Description <code>title</code> <p>optional title of the publisher</p> <code>_description</code> <p>optional description of the publisher</p> <code>_fake_handler</code> <p>boolean indicating if a fake handler is used</p> <code>calls</code> <p>list of callable objects</p> <code>mock</code> <p>MagicMock object for mocking purposes</p> <p>Methods:</p> Name Description <code>description</code> <p>returns the description of the publisher</p> <code>__call__</code> <p>decorator to register a function as a handler for the publisher</p> <code>publish</code> <p>publishes a message with optional correlation ID</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>if the publish method is not implemented.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/publisher.py</code> <pre><code>@dataclass\nclass BasePublisher(AsyncAPIOperation, Generic[MsgType]):\n\"\"\"A base class for publishers in an asynchronous API.\n\n    Attributes:\n        title : optional title of the publisher\n        _description : optional description of the publisher\n        _fake_handler : boolean indicating if a fake handler is used\n        calls : list of callable objects\n        mock : MagicMock object for mocking purposes\n\n    Methods:\n        description() : returns the description of the publisher\n        __call__(func) : decorator to register a function as a handler for the publisher\n        publish(message, correlation_id, **kwargs) : publishes a message with optional correlation ID\n\n    Raises:\n        NotImplementedError: if the publish method is not implemented.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    title: Optional[str] = field(default=None)\n    _description: Optional[str] = field(default=None)\n    _fake_handler: bool = field(default=False)\n\n    calls: List[Callable[..., Any]] = field(\n        init=False, default_factory=list, repr=False\n    )\n    mock: MagicMock = field(init=False, default_factory=MagicMock, repr=False)\n\n    @property\n    def description(self) -&gt; Optional[str]:\n        return self._description\n\n    def __call__(\n        self,\n        func: Callable[P_HandlerParams, T_HandlerReturn],\n    ) -&gt; HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn]:\n\"\"\"This is a Python function.\n\n        Args:\n            func: A callable object that takes `P_HandlerParams` as input and returns `T_HandlerReturn`.\n\n        Returns:\n            An instance of `HandlerCallWrapper` class.\n\n        Raises:\n            TypeError: If `func` is not callable.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        handler_call: HandlerCallWrapper[\n            MsgType, P_HandlerParams, T_HandlerReturn\n        ] = HandlerCallWrapper(func)\n        handler_call._publishers.append(self)\n        self.calls.append(handler_call._original_call)\n        return handler_call\n\n    @abstractmethod\n    async def publish(\n        self,\n        message: SendableMessage,\n        correlation_id: Optional[str] = None,\n        **kwargs: Any,\n    ) -&gt; Optional[SendableMessage]:\n\"\"\"Publish a message.\n\n        Args:\n            message: The message to be published.\n            correlation_id: Optional correlation ID for the message.\n            **kwargs: Additional keyword arguments.\n\n        Returns:\n            The published message.\n\n        Raises:\n            NotImplementedError: If the method is not implemented.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        raise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/broker/publisher/BasePublisher/#faststream.broker.publisher.BasePublisher-attributes","title":"Attributes","text":""},{"location":"api/faststream/broker/publisher/BasePublisher/#faststream.broker.publisher.BasePublisher.calls","title":"calls  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>calls: List[Callable[..., Any]] = field(\n    init=False, default_factory=list, repr=False\n)\n</code></pre>"},{"location":"api/faststream/broker/publisher/BasePublisher/#faststream.broker.publisher.BasePublisher.description","title":"description  <code>property</code>","text":"<pre><code>description: Optional[str]\n</code></pre>"},{"location":"api/faststream/broker/publisher/BasePublisher/#faststream.broker.publisher.BasePublisher.mock","title":"mock  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mock: MagicMock = field(\n    init=False, default_factory=MagicMock, repr=False\n)\n</code></pre>"},{"location":"api/faststream/broker/publisher/BasePublisher/#faststream.broker.publisher.BasePublisher.title","title":"title  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>title: Optional[str] = field(default=None)\n</code></pre>"},{"location":"api/faststream/broker/publisher/BasePublisher/#faststream.broker.publisher.BasePublisher-functions","title":"Functions","text":""},{"location":"api/faststream/broker/publisher/BasePublisher/#faststream.broker.publisher.BasePublisher.__call__","title":"__call__","text":"<pre><code>__call__(\n    func: Callable[P_HandlerParams, T_HandlerReturn]\n) -&gt; HandlerCallWrapper[\n    MsgType, P_HandlerParams, T_HandlerReturn\n]\n</code></pre> <p>This is a Python function.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[P_HandlerParams, T_HandlerReturn]</code> <p>A callable object that takes <code>P_HandlerParams</code> as input and returns <code>T_HandlerReturn</code>.</p> required <p>Returns:</p> Type Description <code>HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn]</code> <p>An instance of <code>HandlerCallWrapper</code> class.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>func</code> is not callable.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/publisher.py</code> <pre><code>def __call__(\n    self,\n    func: Callable[P_HandlerParams, T_HandlerReturn],\n) -&gt; HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn]:\n\"\"\"This is a Python function.\n\n    Args:\n        func: A callable object that takes `P_HandlerParams` as input and returns `T_HandlerReturn`.\n\n    Returns:\n        An instance of `HandlerCallWrapper` class.\n\n    Raises:\n        TypeError: If `func` is not callable.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    handler_call: HandlerCallWrapper[\n        MsgType, P_HandlerParams, T_HandlerReturn\n    ] = HandlerCallWrapper(func)\n    handler_call._publishers.append(self)\n    self.calls.append(handler_call._original_call)\n    return handler_call\n</code></pre>"},{"location":"api/faststream/broker/publisher/BasePublisher/#faststream.broker.publisher.BasePublisher.publish","title":"publish  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>publish(\n    message: SendableMessage,\n    correlation_id: Optional[str] = None,\n    **kwargs: Any\n) -&gt; Optional[SendableMessage]\n</code></pre> <p>Publish a message.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>SendableMessage</code> <p>The message to be published.</p> required <code>correlation_id</code> <code>Optional[str]</code> <p>Optional correlation ID for the message.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Optional[SendableMessage]</code> <p>The published message.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the method is not implemented.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/publisher.py</code> <pre><code>@abstractmethod\nasync def publish(\n    self,\n    message: SendableMessage,\n    correlation_id: Optional[str] = None,\n    **kwargs: Any,\n) -&gt; Optional[SendableMessage]:\n\"\"\"Publish a message.\n\n    Args:\n        message: The message to be published.\n        correlation_id: Optional correlation ID for the message.\n        **kwargs: Additional keyword arguments.\n\n    Returns:\n        The published message.\n\n    Raises:\n        NotImplementedError: If the method is not implemented.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/broker/push_back_watcher/BaseWatcher/","title":"BaseWatcher","text":""},{"location":"api/faststream/broker/push_back_watcher/BaseWatcher/#faststream.broker.push_back_watcher.BaseWatcher","title":"faststream.broker.push_back_watcher.BaseWatcher","text":"<p>             Bases: <code>ABC</code></p> <p>A base class for a watcher.</p> <p>Attributes:</p> Name Type Description <code>max_tries</code> <p>maximum number of tries allowed</p> <p>Parameters:</p> Name Type Description Default <code>max_tries</code> <p>maximum number of tries allowed (default=0)</p> <code>0</code> <code>logger</code> <p>logger object (optional)</p> <code>None</code> <p>Methods:</p> Name Description <code>add </code> <p>add a message to the watcher</p> <code>is_max </code> <p>check if the maximum number of tries has been reached for a message</p> <code>remove </code> <p>remove a message from the watcher</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/push_back_watcher.py</code> <pre><code>class BaseWatcher(ABC):\n\"\"\"A base class for a watcher.\n\n    Attributes:\n        max_tries : maximum number of tries allowed\n\n    Args:\n        max_tries : maximum number of tries allowed (default=0)\n        logger : logger object (optional)\n\n    Methods:\n        add : add a message to the watcher\n        is_max : check if the maximum number of tries has been reached for a message\n        remove : remove a message from the watcher\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    max_tries: int\n\n    def __init__(\n        self,\n        max_tries: int = 0,\n        logger: Optional[Logger] = None,\n    ):\n\"\"\"Initialize the class.\n\n        Args:\n            max_tries: Maximum number of tries allowed\n            logger: Optional logger object\n\n        Raises:\n            NotImplementedError: If the method is not implemented in the subclass.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        self.logger = logger\n        self.max_tries = max_tries\n\n    @abstractmethod\n    def add(self, message_id: str) -&gt; None:\n\"\"\"Add a message.\n\n        Args:\n            message_id: ID of the message to be added\n\n        Returns:\n            None\n\n        Raises:\n            NotImplementedError: If the method is not implemented\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        raise NotImplementedError()\n\n    @abstractmethod\n    def is_max(self, message_id: str) -&gt; bool:\n\"\"\"Check if the given message ID is the maximum.\n\n        Args:\n            message_id: The ID of the message to check.\n\n        Returns:\n            True if the given message ID is the maximum, False otherwise.\n\n        Raises:\n            NotImplementedError: This method is meant to be overridden by subclasses.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        raise NotImplementedError()\n\n    @abstractmethod\n    def remove(self, message_id: str) -&gt; None:\n\"\"\"Remove a message.\n\n        Args:\n            message_id: ID of the message to be removed\n\n        Returns:\n            None\n\n        Raises:\n            NotImplementedError: If the method is not implemented\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        raise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/broker/push_back_watcher/BaseWatcher/#faststream.broker.push_back_watcher.BaseWatcher-attributes","title":"Attributes","text":""},{"location":"api/faststream/broker/push_back_watcher/BaseWatcher/#faststream.broker.push_back_watcher.BaseWatcher.logger","title":"logger  <code>instance-attribute</code>","text":"<pre><code>logger = logger\n</code></pre>"},{"location":"api/faststream/broker/push_back_watcher/BaseWatcher/#faststream.broker.push_back_watcher.BaseWatcher.max_tries","title":"max_tries  <code>instance-attribute</code>","text":"<pre><code>max_tries: int = max_tries\n</code></pre>"},{"location":"api/faststream/broker/push_back_watcher/BaseWatcher/#faststream.broker.push_back_watcher.BaseWatcher-functions","title":"Functions","text":""},{"location":"api/faststream/broker/push_back_watcher/BaseWatcher/#faststream.broker.push_back_watcher.BaseWatcher.__init__","title":"__init__","text":"<pre><code>__init__(\n    max_tries: int = 0, logger: Optional[Logger] = None\n)\n</code></pre> <p>Initialize the class.</p> <p>Parameters:</p> Name Type Description Default <code>max_tries</code> <code>int</code> <p>Maximum number of tries allowed</p> <code>0</code> <code>logger</code> <code>Optional[Logger]</code> <p>Optional logger object</p> <code>None</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the method is not implemented in the subclass.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/push_back_watcher.py</code> <pre><code>def __init__(\n    self,\n    max_tries: int = 0,\n    logger: Optional[Logger] = None,\n):\n\"\"\"Initialize the class.\n\n    Args:\n        max_tries: Maximum number of tries allowed\n        logger: Optional logger object\n\n    Raises:\n        NotImplementedError: If the method is not implemented in the subclass.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    self.logger = logger\n    self.max_tries = max_tries\n</code></pre>"},{"location":"api/faststream/broker/push_back_watcher/BaseWatcher/#faststream.broker.push_back_watcher.BaseWatcher.add","title":"add  <code>abstractmethod</code>","text":"<pre><code>add(message_id: str) -&gt; None\n</code></pre> <p>Add a message.</p> <p>Parameters:</p> Name Type Description Default <code>message_id</code> <code>str</code> <p>ID of the message to be added</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the method is not implemented</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/push_back_watcher.py</code> <pre><code>@abstractmethod\ndef add(self, message_id: str) -&gt; None:\n\"\"\"Add a message.\n\n    Args:\n        message_id: ID of the message to be added\n\n    Returns:\n        None\n\n    Raises:\n        NotImplementedError: If the method is not implemented\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/broker/push_back_watcher/BaseWatcher/#faststream.broker.push_back_watcher.BaseWatcher.is_max","title":"is_max  <code>abstractmethod</code>","text":"<pre><code>is_max(message_id: str) -&gt; bool\n</code></pre> <p>Check if the given message ID is the maximum.</p> <p>Parameters:</p> Name Type Description Default <code>message_id</code> <code>str</code> <p>The ID of the message to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the given message ID is the maximum, False otherwise.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>This method is meant to be overridden by subclasses.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/push_back_watcher.py</code> <pre><code>@abstractmethod\ndef is_max(self, message_id: str) -&gt; bool:\n\"\"\"Check if the given message ID is the maximum.\n\n    Args:\n        message_id: The ID of the message to check.\n\n    Returns:\n        True if the given message ID is the maximum, False otherwise.\n\n    Raises:\n        NotImplementedError: This method is meant to be overridden by subclasses.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/broker/push_back_watcher/BaseWatcher/#faststream.broker.push_back_watcher.BaseWatcher.remove","title":"remove  <code>abstractmethod</code>","text":"<pre><code>remove(message_id: str) -&gt; None\n</code></pre> <p>Remove a message.</p> <p>Parameters:</p> Name Type Description Default <code>message_id</code> <code>str</code> <p>ID of the message to be removed</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the method is not implemented</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/push_back_watcher.py</code> <pre><code>@abstractmethod\ndef remove(self, message_id: str) -&gt; None:\n\"\"\"Remove a message.\n\n    Args:\n        message_id: ID of the message to be removed\n\n    Returns:\n        None\n\n    Raises:\n        NotImplementedError: If the method is not implemented\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/broker/push_back_watcher/CounterWatcher/","title":"CounterWatcher","text":""},{"location":"api/faststream/broker/push_back_watcher/CounterWatcher/#faststream.broker.push_back_watcher.CounterWatcher","title":"faststream.broker.push_back_watcher.CounterWatcher","text":"<p>             Bases: <code>BaseWatcher</code></p> <p>A class to watch and track the count of messages.</p> <p>Attributes:</p> Name Type Description <code>memory</code> <p>CounterType[str] - a counter to store the count of each message</p> <p>Parameters:</p> Name Type Description Default <code>max_tries</code> <p>int - maximum number of tries allowed</p> <code>3</code> <code>logger</code> <p>Optional[Logger] - logger object for logging messages</p> <code>None</code> <p>Methods:</p> Name Description <code>__init__</code> <p>int = 3, logger: Optional[Logger] = None) - initializes the CounterWatcher object</p> <code>add</code> <p>str) -&gt; None - adds a message to the counter</p> <code>is_max</code> <p>str) -&gt; bool - checks if the count of a message has reached the maximum tries</p> <code>remove</code> <p>str) -&gt; None - removes a message from the counter</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/push_back_watcher.py</code> <pre><code>class CounterWatcher(BaseWatcher):\n\"\"\"A class to watch and track the count of messages.\n\n    Attributes:\n        memory : CounterType[str] - a counter to store the count of each message\n\n    Args:\n        max_tries : int - maximum number of tries allowed\n        logger : Optional[Logger] - logger object for logging messages\n\n    Methods:\n        __init__(self, max_tries: int = 3, logger: Optional[Logger] = None) - initializes the CounterWatcher object\n        add(self, message_id: str) -&gt; None - adds a message to the counter\n        is_max(self, message_id: str) -&gt; bool - checks if the count of a message has reached the maximum tries\n        remove(self, message: str) -&gt; None - removes a message from the counter\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    memory: CounterType[str]\n\n    def __init__(\n        self,\n        max_tries: int = 3,\n        logger: Optional[Logger] = None,\n    ):\n\"\"\"Initialize the class.\n\n        Args:\n            max_tries (int): maximum number of tries\n            logger (Optional[Logger]): logger object (default: None)\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        super().__init__(logger=logger, max_tries=max_tries)\n        self.memory = Counter()\n\n    def add(self, message_id: str) -&gt; None:\n\"\"\"Increments the count of a message in the memory.\n\n        Args:\n            message_id: The ID of the message to be incremented.\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        self.memory[message_id] += 1\n\n    def is_max(self, message_id: str) -&gt; bool:\n\"\"\"Check if the number of tries for a message has exceeded the maximum allowed tries.\n\n        Args:\n            message_id: The ID of the message\n\n        Returns:\n            True if the number of tries has exceeded the maximum allowed tries, False otherwise\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        is_max = self.memory[message_id] &gt; self.max_tries\n        if self.logger is not None:\n            if is_max:\n                self.logger.error(f\"Already retried {self.max_tries} times. Skipped.\")\n            else:\n                self.logger.error(\"Error is occured. Pushing back to queue.\")\n        return is_max\n\n    def remove(self, message: str) -&gt; None:\n\"\"\"Remove a message from memory.\n\n        Args:\n            message: The message to be removed.\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        self.memory[message] = 0\n        self.memory += Counter()\n</code></pre>"},{"location":"api/faststream/broker/push_back_watcher/CounterWatcher/#faststream.broker.push_back_watcher.CounterWatcher-attributes","title":"Attributes","text":""},{"location":"api/faststream/broker/push_back_watcher/CounterWatcher/#faststream.broker.push_back_watcher.CounterWatcher.memory","title":"memory  <code>instance-attribute</code>","text":"<pre><code>memory: CounterType[str] = Counter()\n</code></pre>"},{"location":"api/faststream/broker/push_back_watcher/CounterWatcher/#faststream.broker.push_back_watcher.CounterWatcher-functions","title":"Functions","text":""},{"location":"api/faststream/broker/push_back_watcher/CounterWatcher/#faststream.broker.push_back_watcher.CounterWatcher.__init__","title":"__init__","text":"<pre><code>__init__(\n    max_tries: int = 3, logger: Optional[Logger] = None\n)\n</code></pre> <p>Initialize the class.</p> <p>Parameters:</p> Name Type Description Default <code>max_tries</code> <code>int</code> <p>maximum number of tries</p> <code>3</code> <code>logger</code> <code>Optional[Logger]</code> <p>logger object (default: None)</p> <code>None</code> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/push_back_watcher.py</code> <pre><code>def __init__(\n    self,\n    max_tries: int = 3,\n    logger: Optional[Logger] = None,\n):\n\"\"\"Initialize the class.\n\n    Args:\n        max_tries (int): maximum number of tries\n        logger (Optional[Logger]): logger object (default: None)\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    super().__init__(logger=logger, max_tries=max_tries)\n    self.memory = Counter()\n</code></pre>"},{"location":"api/faststream/broker/push_back_watcher/CounterWatcher/#faststream.broker.push_back_watcher.CounterWatcher.add","title":"add","text":"<pre><code>add(message_id: str) -&gt; None\n</code></pre> <p>Increments the count of a message in the memory.</p> <p>Parameters:</p> Name Type Description Default <code>message_id</code> <code>str</code> <p>The ID of the message to be incremented.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/push_back_watcher.py</code> <pre><code>def add(self, message_id: str) -&gt; None:\n\"\"\"Increments the count of a message in the memory.\n\n    Args:\n        message_id: The ID of the message to be incremented.\n\n    Returns:\n        None\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    self.memory[message_id] += 1\n</code></pre>"},{"location":"api/faststream/broker/push_back_watcher/CounterWatcher/#faststream.broker.push_back_watcher.CounterWatcher.is_max","title":"is_max","text":"<pre><code>is_max(message_id: str) -&gt; bool\n</code></pre> <p>Check if the number of tries for a message has exceeded the maximum allowed tries.</p> <p>Parameters:</p> Name Type Description Default <code>message_id</code> <code>str</code> <p>The ID of the message</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the number of tries has exceeded the maximum allowed tries, False otherwise</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/push_back_watcher.py</code> <pre><code>def is_max(self, message_id: str) -&gt; bool:\n\"\"\"Check if the number of tries for a message has exceeded the maximum allowed tries.\n\n    Args:\n        message_id: The ID of the message\n\n    Returns:\n        True if the number of tries has exceeded the maximum allowed tries, False otherwise\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    is_max = self.memory[message_id] &gt; self.max_tries\n    if self.logger is not None:\n        if is_max:\n            self.logger.error(f\"Already retried {self.max_tries} times. Skipped.\")\n        else:\n            self.logger.error(\"Error is occured. Pushing back to queue.\")\n    return is_max\n</code></pre>"},{"location":"api/faststream/broker/push_back_watcher/CounterWatcher/#faststream.broker.push_back_watcher.CounterWatcher.remove","title":"remove","text":"<pre><code>remove(message: str) -&gt; None\n</code></pre> <p>Remove a message from memory.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The message to be removed.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/push_back_watcher.py</code> <pre><code>def remove(self, message: str) -&gt; None:\n\"\"\"Remove a message from memory.\n\n    Args:\n        message: The message to be removed.\n\n    Returns:\n        None\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    self.memory[message] = 0\n    self.memory += Counter()\n</code></pre>"},{"location":"api/faststream/broker/push_back_watcher/EndlessWatcher/","title":"EndlessWatcher","text":""},{"location":"api/faststream/broker/push_back_watcher/EndlessWatcher/#faststream.broker.push_back_watcher.EndlessWatcher","title":"faststream.broker.push_back_watcher.EndlessWatcher","text":"<p>             Bases: <code>BaseWatcher</code></p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/push_back_watcher.py</code> <pre><code>class EndlessWatcher(BaseWatcher):\n    def add(self, message_id: str) -&gt; None:\n\"\"\"Add a message to the list.\n\n        Args:\n            message_id: ID of the message to be added\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        pass\n\n    def is_max(self, message_id: str) -&gt; bool:\n\"\"\"Check if a message is the maximum.\n\n        Args:\n            message_id: ID of the message to check\n\n        Returns:\n            True if the message is the maximum, False otherwise\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        return False\n\n    def remove(self, message_id: str) -&gt; None:\n\"\"\"Remove a message.\n\n        Args:\n            message_id: The ID of the message to be removed.\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/faststream/broker/push_back_watcher/EndlessWatcher/#faststream.broker.push_back_watcher.EndlessWatcher-functions","title":"Functions","text":""},{"location":"api/faststream/broker/push_back_watcher/EndlessWatcher/#faststream.broker.push_back_watcher.EndlessWatcher.add","title":"add","text":"<pre><code>add(message_id: str) -&gt; None\n</code></pre> <p>Add a message to the list.</p> <p>Parameters:</p> Name Type Description Default <code>message_id</code> <code>str</code> <p>ID of the message to be added</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/push_back_watcher.py</code> <pre><code>def add(self, message_id: str) -&gt; None:\n\"\"\"Add a message to the list.\n\n    Args:\n        message_id: ID of the message to be added\n\n    Returns:\n        None\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/faststream/broker/push_back_watcher/EndlessWatcher/#faststream.broker.push_back_watcher.EndlessWatcher.is_max","title":"is_max","text":"<pre><code>is_max(message_id: str) -&gt; bool\n</code></pre> <p>Check if a message is the maximum.</p> <p>Parameters:</p> Name Type Description Default <code>message_id</code> <code>str</code> <p>ID of the message to check</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the message is the maximum, False otherwise</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/push_back_watcher.py</code> <pre><code>def is_max(self, message_id: str) -&gt; bool:\n\"\"\"Check if a message is the maximum.\n\n    Args:\n        message_id: ID of the message to check\n\n    Returns:\n        True if the message is the maximum, False otherwise\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    return False\n</code></pre>"},{"location":"api/faststream/broker/push_back_watcher/EndlessWatcher/#faststream.broker.push_back_watcher.EndlessWatcher.remove","title":"remove","text":"<pre><code>remove(message_id: str) -&gt; None\n</code></pre> <p>Remove a message.</p> <p>Parameters:</p> Name Type Description Default <code>message_id</code> <code>str</code> <p>The ID of the message to be removed.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/push_back_watcher.py</code> <pre><code>def remove(self, message_id: str) -&gt; None:\n\"\"\"Remove a message.\n\n    Args:\n        message_id: The ID of the message to be removed.\n\n    Returns:\n        None\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/faststream/broker/push_back_watcher/OneTryWatcher/","title":"OneTryWatcher","text":""},{"location":"api/faststream/broker/push_back_watcher/OneTryWatcher/#faststream.broker.push_back_watcher.OneTryWatcher","title":"faststream.broker.push_back_watcher.OneTryWatcher","text":"<p>             Bases: <code>BaseWatcher</code></p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/push_back_watcher.py</code> <pre><code>class OneTryWatcher(BaseWatcher):\n    def add(self, message_id: str) -&gt; None:\n\"\"\"Add a message.\n\n        Args:\n            message_id: ID of the message to be added\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        pass\n\n    def is_max(self, message_id: str) -&gt; bool:\n\"\"\"Check if the given message ID is the maximum.\n\n        Args:\n            message_id: The ID of the message to check.\n\n        Returns:\n            True if the given message ID is the maximum, False otherwise.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        return True\n\n    def remove(self, message_id: str) -&gt; None:\n\"\"\"Remove a message.\n\n        Args:\n            message_id: ID of the message to be removed\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/faststream/broker/push_back_watcher/OneTryWatcher/#faststream.broker.push_back_watcher.OneTryWatcher-functions","title":"Functions","text":""},{"location":"api/faststream/broker/push_back_watcher/OneTryWatcher/#faststream.broker.push_back_watcher.OneTryWatcher.add","title":"add","text":"<pre><code>add(message_id: str) -&gt; None\n</code></pre> <p>Add a message.</p> <p>Parameters:</p> Name Type Description Default <code>message_id</code> <code>str</code> <p>ID of the message to be added</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/push_back_watcher.py</code> <pre><code>def add(self, message_id: str) -&gt; None:\n\"\"\"Add a message.\n\n    Args:\n        message_id: ID of the message to be added\n\n    Returns:\n        None\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/faststream/broker/push_back_watcher/OneTryWatcher/#faststream.broker.push_back_watcher.OneTryWatcher.is_max","title":"is_max","text":"<pre><code>is_max(message_id: str) -&gt; bool\n</code></pre> <p>Check if the given message ID is the maximum.</p> <p>Parameters:</p> Name Type Description Default <code>message_id</code> <code>str</code> <p>The ID of the message to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the given message ID is the maximum, False otherwise.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/push_back_watcher.py</code> <pre><code>def is_max(self, message_id: str) -&gt; bool:\n\"\"\"Check if the given message ID is the maximum.\n\n    Args:\n        message_id: The ID of the message to check.\n\n    Returns:\n        True if the given message ID is the maximum, False otherwise.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    return True\n</code></pre>"},{"location":"api/faststream/broker/push_back_watcher/OneTryWatcher/#faststream.broker.push_back_watcher.OneTryWatcher.remove","title":"remove","text":"<pre><code>remove(message_id: str) -&gt; None\n</code></pre> <p>Remove a message.</p> <p>Parameters:</p> Name Type Description Default <code>message_id</code> <code>str</code> <p>ID of the message to be removed</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/push_back_watcher.py</code> <pre><code>def remove(self, message_id: str) -&gt; None:\n\"\"\"Remove a message.\n\n    Args:\n        message_id: ID of the message to be removed\n\n    Returns:\n        None\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/faststream/broker/push_back_watcher/WatcherContext/","title":"WatcherContext","text":""},{"location":"api/faststream/broker/push_back_watcher/WatcherContext/#faststream.broker.push_back_watcher.WatcherContext","title":"faststream.broker.push_back_watcher.WatcherContext","text":"<p>A class representing a context for a watcher.</p> <p>Attributes:</p> Name Type Description <code>watcher</code> <p>the watcher object</p> <code>message</code> <p>the message being watched</p> <code>extra_ack_args</code> <p>additional arguments for acknowledging the message</p> <p>Methods:</p> Name Description <code>__aenter__ </code> <p>called when entering the context</p> <code>__aexit__ </code> <p>called when exiting the context</p> <code>__ack </code> <p>acknowledges the message</p> <code>__nack </code> <p>negatively acknowledges the message</p> <code>__reject </code> <p>rejects the message</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/push_back_watcher.py</code> <pre><code>class WatcherContext:\n\"\"\"A class representing a context for a watcher.\n\n    Attributes:\n        watcher : the watcher object\n        message : the message being watched\n        extra_ack_args : additional arguments for acknowledging the message\n\n    Methods:\n        __aenter__ : called when entering the context\n        __aexit__ : called when exiting the context\n        __ack : acknowledges the message\n        __nack : negatively acknowledges the message\n        __reject : rejects the message\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    def __init__(\n        self,\n        watcher: BaseWatcher,\n        message: Union[SyncStreamMessage[MsgType], StreamMessage[MsgType]],\n        **extra_ack_args: Any,\n    ):\n\"\"\"Initialize a new instance of the class.\n\n        Args:\n            watcher: An instance of BaseWatcher.\n            message: An instance of SyncStreamMessage or StreamMessage.\n            **extra_ack_args: Additional arguments for acknowledgement.\n\n        Attributes:\n            watcher: An instance of BaseWatcher.\n            message: An instance of SyncStreamMessage or StreamMessage.\n            extra_ack_args: Additional arguments for acknowledgement.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        self.watcher = watcher\n        self.message = message\n        self.extra_ack_args = extra_ack_args or {}\n\n    async def __aenter__(self) -&gt; None:\n        self.watcher.add(self.message.message_id)\n\n    async def __aexit__(\n        self,\n        exc_type: Optional[Type[BaseException]],\n        exc_val: Optional[BaseException],\n        exc_tb: Optional[TracebackType],\n    ) -&gt; bool:\n\"\"\"Exit the asynchronous context manager.\n\n        Args:\n            exc_type: The type of the exception raised, if any.\n            exc_val: The exception instance raised, if any.\n            exc_tb: The traceback for the exception raised, if any.\n\n        Returns:\n            A boolean indicating whether the exit was successful or not.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        if not exc_type:\n            await self.__ack()\n\n        elif isinstance(exc_val, SkipMessage):\n            self.watcher.remove(self.message.message_id)\n\n        elif isinstance(exc_val, HandlerException):\n            if isinstance(exc_val, AckMessage):\n                await self.__ack()\n            elif isinstance(exc_val, NackMessage):\n                await self.__nack()\n            elif isinstance(exc_val, RejectMessage):\n                await self.__reject()\n            return True\n\n        elif self.watcher.is_max(self.message.message_id):\n            await self.__reject()\n\n        else:\n            await self.__nack()\n\n        return False\n\n    async def __ack(self) -&gt; None:\n        await call_or_await(self.message.ack, **self.extra_ack_args)\n        self.watcher.remove(self.message.message_id)\n\n    async def __nack(self) -&gt; None:\n        await call_or_await(self.message.nack, **self.extra_ack_args)\n\n    async def __reject(self) -&gt; None:\n        await call_or_await(self.message.reject, **self.extra_ack_args)\n        self.watcher.remove(self.message.message_id)\n</code></pre>"},{"location":"api/faststream/broker/push_back_watcher/WatcherContext/#faststream.broker.push_back_watcher.WatcherContext-attributes","title":"Attributes","text":""},{"location":"api/faststream/broker/push_back_watcher/WatcherContext/#faststream.broker.push_back_watcher.WatcherContext.extra_ack_args","title":"extra_ack_args  <code>instance-attribute</code>","text":"<pre><code>extra_ack_args = extra_ack_args or {}\n</code></pre>"},{"location":"api/faststream/broker/push_back_watcher/WatcherContext/#faststream.broker.push_back_watcher.WatcherContext.message","title":"message  <code>instance-attribute</code>","text":"<pre><code>message = message\n</code></pre>"},{"location":"api/faststream/broker/push_back_watcher/WatcherContext/#faststream.broker.push_back_watcher.WatcherContext.watcher","title":"watcher  <code>instance-attribute</code>","text":"<pre><code>watcher = watcher\n</code></pre>"},{"location":"api/faststream/broker/push_back_watcher/WatcherContext/#faststream.broker.push_back_watcher.WatcherContext-functions","title":"Functions","text":""},{"location":"api/faststream/broker/push_back_watcher/WatcherContext/#faststream.broker.push_back_watcher.WatcherContext.__ack","title":"__ack  <code>async</code>","text":"<pre><code>__ack() -&gt; None\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/push_back_watcher.py</code> <pre><code>async def __ack(self) -&gt; None:\n    await call_or_await(self.message.ack, **self.extra_ack_args)\n    self.watcher.remove(self.message.message_id)\n</code></pre>"},{"location":"api/faststream/broker/push_back_watcher/WatcherContext/#faststream.broker.push_back_watcher.WatcherContext.__aenter__","title":"__aenter__  <code>async</code>","text":"<pre><code>__aenter__() -&gt; None\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/push_back_watcher.py</code> <pre><code>async def __aenter__(self) -&gt; None:\n    self.watcher.add(self.message.message_id)\n</code></pre>"},{"location":"api/faststream/broker/push_back_watcher/WatcherContext/#faststream.broker.push_back_watcher.WatcherContext.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(\n    exc_type: Optional[Type[BaseException]],\n    exc_val: Optional[BaseException],\n    exc_tb: Optional[TracebackType],\n) -&gt; bool\n</code></pre> <p>Exit the asynchronous context manager.</p> <p>Parameters:</p> Name Type Description Default <code>exc_type</code> <code>Optional[Type[BaseException]]</code> <p>The type of the exception raised, if any.</p> required <code>exc_val</code> <code>Optional[BaseException]</code> <p>The exception instance raised, if any.</p> required <code>exc_tb</code> <code>Optional[TracebackType]</code> <p>The traceback for the exception raised, if any.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>A boolean indicating whether the exit was successful or not.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/push_back_watcher.py</code> <pre><code>async def __aexit__(\n    self,\n    exc_type: Optional[Type[BaseException]],\n    exc_val: Optional[BaseException],\n    exc_tb: Optional[TracebackType],\n) -&gt; bool:\n\"\"\"Exit the asynchronous context manager.\n\n    Args:\n        exc_type: The type of the exception raised, if any.\n        exc_val: The exception instance raised, if any.\n        exc_tb: The traceback for the exception raised, if any.\n\n    Returns:\n        A boolean indicating whether the exit was successful or not.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    if not exc_type:\n        await self.__ack()\n\n    elif isinstance(exc_val, SkipMessage):\n        self.watcher.remove(self.message.message_id)\n\n    elif isinstance(exc_val, HandlerException):\n        if isinstance(exc_val, AckMessage):\n            await self.__ack()\n        elif isinstance(exc_val, NackMessage):\n            await self.__nack()\n        elif isinstance(exc_val, RejectMessage):\n            await self.__reject()\n        return True\n\n    elif self.watcher.is_max(self.message.message_id):\n        await self.__reject()\n\n    else:\n        await self.__nack()\n\n    return False\n</code></pre>"},{"location":"api/faststream/broker/push_back_watcher/WatcherContext/#faststream.broker.push_back_watcher.WatcherContext.__init__","title":"__init__","text":"<pre><code>__init__(\n    watcher: BaseWatcher,\n    message: Union[\n        SyncStreamMessage[MsgType], StreamMessage[MsgType]\n    ],\n    **extra_ack_args: Any\n)\n</code></pre> <p>Initialize a new instance of the class.</p> <p>Parameters:</p> Name Type Description Default <code>watcher</code> <code>BaseWatcher</code> <p>An instance of BaseWatcher.</p> required <code>message</code> <code>Union[SyncStreamMessage[MsgType], StreamMessage[MsgType]]</code> <p>An instance of SyncStreamMessage or StreamMessage.</p> required <code>**extra_ack_args</code> <code>Any</code> <p>Additional arguments for acknowledgement.</p> <code>{}</code> <p>Attributes:</p> Name Type Description <code>watcher</code> <p>An instance of BaseWatcher.</p> <code>message</code> <p>An instance of SyncStreamMessage or StreamMessage.</p> <code>extra_ack_args</code> <p>Additional arguments for acknowledgement.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/push_back_watcher.py</code> <pre><code>def __init__(\n    self,\n    watcher: BaseWatcher,\n    message: Union[SyncStreamMessage[MsgType], StreamMessage[MsgType]],\n    **extra_ack_args: Any,\n):\n\"\"\"Initialize a new instance of the class.\n\n    Args:\n        watcher: An instance of BaseWatcher.\n        message: An instance of SyncStreamMessage or StreamMessage.\n        **extra_ack_args: Additional arguments for acknowledgement.\n\n    Attributes:\n        watcher: An instance of BaseWatcher.\n        message: An instance of SyncStreamMessage or StreamMessage.\n        extra_ack_args: Additional arguments for acknowledgement.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    self.watcher = watcher\n    self.message = message\n    self.extra_ack_args = extra_ack_args or {}\n</code></pre>"},{"location":"api/faststream/broker/push_back_watcher/WatcherContext/#faststream.broker.push_back_watcher.WatcherContext.__nack","title":"__nack  <code>async</code>","text":"<pre><code>__nack() -&gt; None\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/push_back_watcher.py</code> <pre><code>async def __nack(self) -&gt; None:\n    await call_or_await(self.message.nack, **self.extra_ack_args)\n</code></pre>"},{"location":"api/faststream/broker/push_back_watcher/WatcherContext/#faststream.broker.push_back_watcher.WatcherContext.__reject","title":"__reject  <code>async</code>","text":"<pre><code>__reject() -&gt; None\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/push_back_watcher.py</code> <pre><code>async def __reject(self) -&gt; None:\n    await call_or_await(self.message.reject, **self.extra_ack_args)\n    self.watcher.remove(self.message.message_id)\n</code></pre>"},{"location":"api/faststream/broker/router/BrokerRoute/","title":"BrokerRoute","text":""},{"location":"api/faststream/broker/router/BrokerRoute/#faststream.broker.router.BrokerRoute","title":"faststream.broker.router.BrokerRoute","text":"<p>             Bases: <code>Generic[MsgType, T_HandlerReturn]</code></p> <p>A generic class to represent a broker route.</p> <p>Attributes:</p> Name Type Description <code>call</code> <p>callable object representing the route</p> <code>args</code> <p>tuple of arguments for the route</p> <code>kwargs</code> <p>dictionary of keyword arguments for the route</p> <p>Parameters:</p> Name Type Description Default <code>call</code> <p>callable object representing the route</p> required <code>*args</code> <p>variable length arguments for the route</p> <code>()</code> <code>**kwargs</code> <p>variable length keyword arguments for the route</p> <code>{}</code> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/router.py</code> <pre><code>class BrokerRoute(Generic[MsgType, T_HandlerReturn]):\n\"\"\"A generic class to represent a broker route.\n\n    Attributes:\n        call : callable object representing the route\n        args : tuple of arguments for the route\n        kwargs : dictionary of keyword arguments for the route\n\n    Args:\n        call : callable object representing the route\n        *args : variable length arguments for the route\n        **kwargs : variable length keyword arguments for the route\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    call: Callable[..., T_HandlerReturn]\n    args: Tuple[Any, ...]\n    kwargs: AnyDict\n\n    def __init__(\n        self,\n        call: Callable[..., T_HandlerReturn],\n        *args: Any,\n        **kwargs: Any,\n    ):\n\"\"\"Initialize a callable object with arguments and keyword arguments.\n\n        Args:\n            call: A callable object.\n            *args: Positional arguments to be passed to the callable object.\n            **kwargs: Keyword arguments to be passed to the callable object.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        self.call = call\n        self.args = args\n        self.kwargs = kwargs\n</code></pre>"},{"location":"api/faststream/broker/router/BrokerRoute/#faststream.broker.router.BrokerRoute-attributes","title":"Attributes","text":""},{"location":"api/faststream/broker/router/BrokerRoute/#faststream.broker.router.BrokerRoute.args","title":"args  <code>instance-attribute</code>","text":"<pre><code>args: Tuple[Any, ...] = args\n</code></pre>"},{"location":"api/faststream/broker/router/BrokerRoute/#faststream.broker.router.BrokerRoute.call","title":"call  <code>instance-attribute</code>","text":"<pre><code>call: Callable[..., T_HandlerReturn] = call\n</code></pre>"},{"location":"api/faststream/broker/router/BrokerRoute/#faststream.broker.router.BrokerRoute.kwargs","title":"kwargs  <code>instance-attribute</code>","text":"<pre><code>kwargs: AnyDict = kwargs\n</code></pre>"},{"location":"api/faststream/broker/router/BrokerRoute/#faststream.broker.router.BrokerRoute-functions","title":"Functions","text":""},{"location":"api/faststream/broker/router/BrokerRoute/#faststream.broker.router.BrokerRoute.__init__","title":"__init__","text":"<pre><code>__init__(\n    call: Callable[..., T_HandlerReturn],\n    *args: Any,\n    **kwargs: Any\n)\n</code></pre> <p>Initialize a callable object with arguments and keyword arguments.</p> <p>Parameters:</p> Name Type Description Default <code>call</code> <code>Callable[..., T_HandlerReturn]</code> <p>A callable object.</p> required <code>*args</code> <code>Any</code> <p>Positional arguments to be passed to the callable object.</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments to be passed to the callable object.</p> <code>{}</code> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/router.py</code> <pre><code>def __init__(\n    self,\n    call: Callable[..., T_HandlerReturn],\n    *args: Any,\n    **kwargs: Any,\n):\n\"\"\"Initialize a callable object with arguments and keyword arguments.\n\n    Args:\n        call: A callable object.\n        *args: Positional arguments to be passed to the callable object.\n        **kwargs: Keyword arguments to be passed to the callable object.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    self.call = call\n    self.args = args\n    self.kwargs = kwargs\n</code></pre>"},{"location":"api/faststream/broker/router/BrokerRouter/","title":"BrokerRouter","text":""},{"location":"api/faststream/broker/router/BrokerRouter/#faststream.broker.router.BrokerRouter","title":"faststream.broker.router.BrokerRouter","text":"<p>             Bases: <code>Generic[PublisherKeyType, MsgType]</code></p> <p>A generic class representing a broker router.</p> <p>Attributes:</p> Name Type Description <code>prefix</code> <p>prefix for the router</p> <code>_handlers</code> <p>list of broker routes</p> <code>_publishers</code> <p>dictionary of publishers</p> <p>Methods:</p> Name Description <code>_get_publisher_key </code> <p>abstract method to get the publisher key</p> <code>_update_publisher_prefix </code> <p>abstract method to update the publisher prefix</p> <code>__init__ </code> <p>constructor method</p> <code>subscriber </code> <p>abstract method to define a subscriber</p> <code>_wrap_subscriber </code> <p>method to wrap a subscriber function</p> <code>publisher </code> <p>abstract method to define a publisher</p> <code>include_router </code> <p>method to include a router</p> <code>include_routers </code> <p>method to include multiple routers</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/router.py</code> <pre><code>class BrokerRouter(Generic[PublisherKeyType, MsgType]):\n\"\"\"A generic class representing a broker router.\n\n    Attributes:\n        prefix : prefix for the router\n        _handlers : list of broker routes\n        _publishers : dictionary of publishers\n\n    Methods:\n        _get_publisher_key : abstract method to get the publisher key\n        _update_publisher_prefix : abstract method to update the publisher prefix\n        __init__ : constructor method\n        subscriber : abstract method to define a subscriber\n        _wrap_subscriber : method to wrap a subscriber function\n        publisher : abstract method to define a publisher\n        include_router : method to include a router\n        include_routers : method to include multiple routers\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    prefix: str\n    _handlers: List[BrokerRoute[MsgType, Any]]\n    _publishers: Dict[PublisherKeyType, BasePublisher[MsgType]]\n\n    @staticmethod\n    @abstractmethod\n    def _get_publisher_key(publisher: BasePublisher[MsgType]) -&gt; PublisherKeyType:\n\"\"\"This is a Python function.\n\n        _get_publisher_key function:\n\n        Args:\n            publisher: An instance of BasePublisher class.\n\n        Returns:\n            The publisher key.\n\n        Raises:\n            NotImplementedError: This function is not implemented.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        raise NotImplementedError()\n\n    @staticmethod\n    @abstractmethod\n    def _update_publisher_prefix(\n        prefix: str,\n        publisher: BasePublisher[MsgType],\n    ) -&gt; BasePublisher[MsgType]:\n\"\"\"Updates the publisher prefix.\n\n        Args:\n            prefix: The new prefix to be set.\n            publisher: The publisher to update.\n\n        Returns:\n            The updated publisher.\n\n        Raises:\n            NotImplementedError: If the function is not implemented.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        raise NotImplementedError()\n\n    def __init__(\n        self,\n        prefix: str = \"\",\n        handlers: Sequence[BrokerRoute[MsgType, SendableMessage]] = (),\n        dependencies: Sequence[Depends] = (),\n        middlewares: Optional[\n            Sequence[\n                Callable[\n                    [StreamMessage[MsgType]],\n                    AsyncContextManager[None],\n                ]\n            ]\n        ] = None,\n        parser: Optional[CustomParser[MsgType]] = None,\n        decoder: Optional[CustomDecoder[MsgType]] = None,\n    ):\n\"\"\"Initialize a class object.\n\n        Args:\n            prefix (str): Prefix for the object.\n            handlers (Sequence[BrokerRoute[MsgType, SendableMessage]]): Handlers for the object.\n            dependencies (Sequence[Depends]): Dependencies for the object.\n            middlewares (Optional[Sequence[Callable[[StreamMessage[MsgType]], AsyncContextManager[None]]]]): Middlewares for the object.\n            parser (Optional[CustomParser[MsgType]]): Parser for the object.\n            decoder (Optional[CustomDecoder[MsgType]]): Decoder for the object.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        self.prefix = prefix\n        self._handlers = list(handlers)\n        self._publishers = {}\n        self._dependencies = dependencies\n        self._middlewares = middlewares\n        self._parser = parser\n        self._decoder = decoder\n\n    @abstractmethod\n    def subscriber(\n        self,\n        subj: str,\n        *args: Any,\n        dependencies: Sequence[Depends] = (),\n        middlewares: Optional[\n            Sequence[\n                Callable[\n                    [StreamMessage[MsgType]],\n                    AsyncContextManager[None],\n                ]\n            ]\n        ] = None,\n        parser: Optional[CustomParser[MsgType]] = None,\n        decoder: Optional[CustomDecoder[MsgType]] = None,\n        **kwargs: Any,\n    ) -&gt; Callable[\n        [Callable[P_HandlerParams, T_HandlerReturn]],\n        HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn],\n    ]:\n\"\"\"A function to subscribe to a subject.\n\n        Args:\n            subj : subject to subscribe to\n            *args : additional arguments\n            dependencies : sequence of dependencies\n            middlewares : optional sequence of middlewares\n            parser : optional custom parser\n            decoder : optional custom decoder\n            **kwargs : additional keyword arguments\n\n        Returns:\n            A callable handler function\n\n        Raises:\n            NotImplementedError: If the function is not implemented\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        raise NotImplementedError()\n\n    def _wrap_subscriber(\n        self,\n        *args: Any,\n        dependencies: Sequence[Depends] = (),\n        middlewares: Optional[\n            Sequence[\n                Callable[\n                    [StreamMessage[MsgType]],\n                    AsyncContextManager[None],\n                ]\n            ]\n        ] = None,\n        parser: Optional[CustomParser[MsgType]] = None,\n        decoder: Optional[CustomDecoder[MsgType]] = None,\n        **kwargs: Any,\n    ) -&gt; Callable[\n        [Callable[P_HandlerParams, T_HandlerReturn]],\n        HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn],\n    ]:\n\"\"\"This is a function named `_wrap_subscriber` that returns a callable object. It is used as a decorator for another function.\n\n        Args:\n            *args: Variable length arguments\n            dependencies: Sequence of dependencies\n            middlewares: Optional sequence of middlewares\n            parser: Optional custom parser\n            decoder: Optional custom decoder\n            **kwargs: Variable length keyword arguments\n\n        Returns:\n            A callable object that wraps the decorated function\n\n        This function is decorated with `@abstractmethod`, indicating that it is an abstract method and must be implemented by any subclass.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n\n        def router_subscriber_wrapper(\n            func: Callable[P_HandlerParams, T_HandlerReturn]\n        ) -&gt; HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn]:\n\"\"\"Wraps a function with a router subscriber.\n\n            Args:\n                func: The function to be wrapped.\n\n            Returns:\n                The wrapped function.\n            !!! note\n\n                The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n            \"\"\"\n            wrapped_func: HandlerCallWrapper[\n                MsgType, P_HandlerParams, T_HandlerReturn\n            ] = HandlerCallWrapper(func)\n            route: BrokerRoute[MsgType, T_HandlerReturn] = BrokerRoute(\n                wrapped_func,\n                *args,\n                dependencies=(*self._dependencies, *dependencies),\n                middlewares=(*(self._middlewares or ()), *(middlewares or ())) or None,\n                parser=parser or self._parser,\n                decoder=decoder or self._decoder,\n                **kwargs,\n            )\n            self._handlers.append(route)\n            return wrapped_func\n\n        return router_subscriber_wrapper\n\n    @abstractmethod\n    def publisher(\n        self,\n        subj: str,\n        *args: Any,\n        **kwargs: Any,\n    ) -&gt; BasePublisher[MsgType]:\n\"\"\"Publishes a message.\n\n        Args:\n            subj: Subject of the message\n            *args: Additional arguments\n            **kwargs: Additional keyword arguments\n\n        Returns:\n            The published message\n\n        Raises:\n            NotImplementedError: If the method is not implemented\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        raise NotImplementedError()\n\n    def include_router(self, router: \"BrokerRouter[PublisherKeyType, MsgType]\") -&gt; None:\n\"\"\"Includes a router in the current object.\n\n        Args:\n            router: The router to be included.\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        for h in router._handlers:\n            self.subscriber(*h.args, **h.kwargs)(h.call)\n\n        for p in router._publishers.values():\n            p = self._update_publisher_prefix(self.prefix, p)\n            key = self._get_publisher_key(p)\n            self._publishers[key] = self._publishers.get(key, p)\n\n    def include_routers(\n        self, *routers: \"BrokerRouter[PublisherKeyType, MsgType]\"\n    ) -&gt; None:\n\"\"\"Includes routers in the object.\n\n        Args:\n            *routers: Variable length argument list of routers to include.\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        for r in routers:\n            self.include_router(r)\n</code></pre>"},{"location":"api/faststream/broker/router/BrokerRouter/#faststream.broker.router.BrokerRouter-attributes","title":"Attributes","text":""},{"location":"api/faststream/broker/router/BrokerRouter/#faststream.broker.router.BrokerRouter.prefix","title":"prefix  <code>instance-attribute</code>","text":"<pre><code>prefix: str = prefix\n</code></pre>"},{"location":"api/faststream/broker/router/BrokerRouter/#faststream.broker.router.BrokerRouter-functions","title":"Functions","text":""},{"location":"api/faststream/broker/router/BrokerRouter/#faststream.broker.router.BrokerRouter.__init__","title":"__init__","text":"<pre><code>__init__(\n    prefix: str = \"\",\n    handlers: Sequence[\n        BrokerRoute[MsgType, SendableMessage]\n    ] = (),\n    dependencies: Sequence[Depends] = (),\n    middlewares: Optional[\n        Sequence[\n            Callable[\n                [StreamMessage[MsgType]],\n                AsyncContextManager[None],\n            ]\n        ]\n    ] = None,\n    parser: Optional[CustomParser[MsgType]] = None,\n    decoder: Optional[CustomDecoder[MsgType]] = None,\n)\n</code></pre> <p>Initialize a class object.</p> <p>Parameters:</p> Name Type Description Default <code>prefix</code> <code>str</code> <p>Prefix for the object.</p> <code>''</code> <code>handlers</code> <code>Sequence[BrokerRoute[MsgType, SendableMessage]]</code> <p>Handlers for the object.</p> <code>()</code> <code>dependencies</code> <code>Sequence[Depends]</code> <p>Dependencies for the object.</p> <code>()</code> <code>middlewares</code> <code>Optional[Sequence[Callable[[StreamMessage[MsgType]], AsyncContextManager[None]]]]</code> <p>Middlewares for the object.</p> <code>None</code> <code>parser</code> <code>Optional[CustomParser[MsgType]]</code> <p>Parser for the object.</p> <code>None</code> <code>decoder</code> <code>Optional[CustomDecoder[MsgType]]</code> <p>Decoder for the object.</p> <code>None</code> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/router.py</code> <pre><code>def __init__(\n    self,\n    prefix: str = \"\",\n    handlers: Sequence[BrokerRoute[MsgType, SendableMessage]] = (),\n    dependencies: Sequence[Depends] = (),\n    middlewares: Optional[\n        Sequence[\n            Callable[\n                [StreamMessage[MsgType]],\n                AsyncContextManager[None],\n            ]\n        ]\n    ] = None,\n    parser: Optional[CustomParser[MsgType]] = None,\n    decoder: Optional[CustomDecoder[MsgType]] = None,\n):\n\"\"\"Initialize a class object.\n\n    Args:\n        prefix (str): Prefix for the object.\n        handlers (Sequence[BrokerRoute[MsgType, SendableMessage]]): Handlers for the object.\n        dependencies (Sequence[Depends]): Dependencies for the object.\n        middlewares (Optional[Sequence[Callable[[StreamMessage[MsgType]], AsyncContextManager[None]]]]): Middlewares for the object.\n        parser (Optional[CustomParser[MsgType]]): Parser for the object.\n        decoder (Optional[CustomDecoder[MsgType]]): Decoder for the object.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    self.prefix = prefix\n    self._handlers = list(handlers)\n    self._publishers = {}\n    self._dependencies = dependencies\n    self._middlewares = middlewares\n    self._parser = parser\n    self._decoder = decoder\n</code></pre>"},{"location":"api/faststream/broker/router/BrokerRouter/#faststream.broker.router.BrokerRouter.include_router","title":"include_router","text":"<pre><code>include_router(\n    router: BrokerRouter[PublisherKeyType, MsgType]\n) -&gt; None\n</code></pre> <p>Includes a router in the current object.</p> <p>Parameters:</p> Name Type Description Default <code>router</code> <code>BrokerRouter[PublisherKeyType, MsgType]</code> <p>The router to be included.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/router.py</code> <pre><code>def include_router(self, router: \"BrokerRouter[PublisherKeyType, MsgType]\") -&gt; None:\n\"\"\"Includes a router in the current object.\n\n    Args:\n        router: The router to be included.\n\n    Returns:\n        None\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    for h in router._handlers:\n        self.subscriber(*h.args, **h.kwargs)(h.call)\n\n    for p in router._publishers.values():\n        p = self._update_publisher_prefix(self.prefix, p)\n        key = self._get_publisher_key(p)\n        self._publishers[key] = self._publishers.get(key, p)\n</code></pre>"},{"location":"api/faststream/broker/router/BrokerRouter/#faststream.broker.router.BrokerRouter.include_routers","title":"include_routers","text":"<pre><code>include_routers(\n    *routers: BrokerRouter[PublisherKeyType, MsgType]\n) -&gt; None\n</code></pre> <p>Includes routers in the object.</p> <p>Parameters:</p> Name Type Description Default <code>*routers</code> <code>BrokerRouter[PublisherKeyType, MsgType]</code> <p>Variable length argument list of routers to include.</p> <code>()</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/router.py</code> <pre><code>def include_routers(\n    self, *routers: \"BrokerRouter[PublisherKeyType, MsgType]\"\n) -&gt; None:\n\"\"\"Includes routers in the object.\n\n    Args:\n        *routers: Variable length argument list of routers to include.\n\n    Returns:\n        None\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    for r in routers:\n        self.include_router(r)\n</code></pre>"},{"location":"api/faststream/broker/router/BrokerRouter/#faststream.broker.router.BrokerRouter.publisher","title":"publisher  <code>abstractmethod</code>","text":"<pre><code>publisher(\n    subj: str, *args: Any, **kwargs: Any\n) -&gt; BasePublisher[MsgType]\n</code></pre> <p>Publishes a message.</p> <p>Parameters:</p> Name Type Description Default <code>subj</code> <code>str</code> <p>Subject of the message</p> required <code>*args</code> <code>Any</code> <p>Additional arguments</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments</p> <code>{}</code> <p>Returns:</p> Type Description <code>BasePublisher[MsgType]</code> <p>The published message</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the method is not implemented</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/router.py</code> <pre><code>@abstractmethod\ndef publisher(\n    self,\n    subj: str,\n    *args: Any,\n    **kwargs: Any,\n) -&gt; BasePublisher[MsgType]:\n\"\"\"Publishes a message.\n\n    Args:\n        subj: Subject of the message\n        *args: Additional arguments\n        **kwargs: Additional keyword arguments\n\n    Returns:\n        The published message\n\n    Raises:\n        NotImplementedError: If the method is not implemented\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/broker/router/BrokerRouter/#faststream.broker.router.BrokerRouter.subscriber","title":"subscriber  <code>abstractmethod</code>","text":"<pre><code>subscriber(\n    subj: str,\n    *args: Any,\n    dependencies: Sequence[Depends] = (),\n    middlewares: Optional[\n        Sequence[\n            Callable[\n                [StreamMessage[MsgType]],\n                AsyncContextManager[None],\n            ]\n        ]\n    ] = None,\n    parser: Optional[CustomParser[MsgType]] = None,\n    decoder: Optional[CustomDecoder[MsgType]] = None,\n    **kwargs: Any\n) -&gt; Callable[\n    [Callable[P_HandlerParams, T_HandlerReturn]],\n    HandlerCallWrapper[\n        MsgType, P_HandlerParams, T_HandlerReturn\n    ],\n]\n</code></pre> <p>A function to subscribe to a subject.</p> <p>Parameters:</p> Name Type Description Default <code>subj</code> <p>subject to subscribe to</p> required <code>*args</code> <p>additional arguments</p> <code>()</code> <code>dependencies</code> <p>sequence of dependencies</p> <code>()</code> <code>middlewares</code> <p>optional sequence of middlewares</p> <code>None</code> <code>parser</code> <p>optional custom parser</p> <code>None</code> <code>decoder</code> <p>optional custom decoder</p> <code>None</code> <code>**kwargs</code> <p>additional keyword arguments</p> <code>{}</code> <p>Returns:</p> Type Description <code>Callable[[Callable[P_HandlerParams, T_HandlerReturn]], HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn]]</code> <p>A callable handler function</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the function is not implemented</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/router.py</code> <pre><code>@abstractmethod\ndef subscriber(\n    self,\n    subj: str,\n    *args: Any,\n    dependencies: Sequence[Depends] = (),\n    middlewares: Optional[\n        Sequence[\n            Callable[\n                [StreamMessage[MsgType]],\n                AsyncContextManager[None],\n            ]\n        ]\n    ] = None,\n    parser: Optional[CustomParser[MsgType]] = None,\n    decoder: Optional[CustomDecoder[MsgType]] = None,\n    **kwargs: Any,\n) -&gt; Callable[\n    [Callable[P_HandlerParams, T_HandlerReturn]],\n    HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn],\n]:\n\"\"\"A function to subscribe to a subject.\n\n    Args:\n        subj : subject to subscribe to\n        *args : additional arguments\n        dependencies : sequence of dependencies\n        middlewares : optional sequence of middlewares\n        parser : optional custom parser\n        decoder : optional custom decoder\n        **kwargs : additional keyword arguments\n\n    Returns:\n        A callable handler function\n\n    Raises:\n        NotImplementedError: If the function is not implemented\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/broker/schemas/NameRequired/","title":"NameRequired","text":""},{"location":"api/faststream/broker/schemas/NameRequired/#faststream.broker.schemas.NameRequired","title":"faststream.broker.schemas.NameRequired","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent a required name.</p> <p>Attributes:</p> Name Type Description <code>name</code> <p>optional name</p> <p>Methods:</p> Name Description <code>__eq__</code> <p>object) -&gt; bool: Check if the given value is equal to the current instance.</p> <code>__init__</code> <p>str, **kwargs: Any): Initialize the NameRequired instance.</p> <code>validate</code> <p>Type[NameRequiredCls], value: Union[str, NameRequiredCls]) -&gt; NameRequiredCls: Validate the given value and return a NameRequiredCls instance.</p> <code>validate</code> <p>Type[NameRequiredCls], value: None) -&gt; None: Validate the given value and return None.</p> <code>validate</code> <p>Type[NameRequiredCls], value: Union[str, NameRequiredCls, None]) -&gt; Optional[NameRequiredCls]: Validate the given value and return an optional NameRequiredCls instance.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/schemas.py</code> <pre><code>class NameRequired(BaseModel):\n\"\"\"A class to represent a required name.\n\n    Attributes:\n        name : optional name\n\n    Methods:\n        __eq__(self, __value: object) -&gt; bool: Check if the given value is equal to the current instance.\n        __init__(self, name: str, **kwargs: Any): Initialize the NameRequired instance.\n        validate(cls: Type[NameRequiredCls], value: Union[str, NameRequiredCls]) -&gt; NameRequiredCls: Validate the given value and return a NameRequiredCls instance.\n        validate(cls: Type[NameRequiredCls], value: None) -&gt; None: Validate the given value and return None.\n        validate(cls: Type[NameRequiredCls], value: Union[str, NameRequiredCls, None]) -&gt; Optional[NameRequiredCls]: Validate the given value and return an optional NameRequiredCls instance.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    name: Optional[str] = Field(...)\n\n    def __eq__(self, __value: object) -&gt; bool:\n\"\"\"Compares the current object with another object for equality.\n\n        Args:\n            __value: The object to compare with.\n\n        Returns:\n            True if the objects are equal, False otherwise.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        if __value is None:\n            return False\n\n        if not isinstance(__value, NameRequired):  # pragma: no cover\n            return NotImplemented\n\n        return self.name == __value.name\n\n    def __init__(self, name: str, **kwargs: Any) -&gt; None:\n\"\"\"This is a Python function.\n\n        Args:\n            name (str): The name of the object.\n            **kwargs (Any): Additional keyword arguments.\n\n        Returns:\n            None.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        super().__init__(name=name, **kwargs)\n\n    @overload\n    @classmethod\n    def validate(\n        cls: Type[NameRequiredCls], value: Union[str, NameRequiredCls]\n    ) -&gt; NameRequiredCls:\n\"\"\"Validates a value.\n\n        Args:\n            value: The value to validate.\n\n        Returns:\n            The validated value.\n\n        Raises:\n            TypeError: If the value is not of the expected type.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        ...\n\n    @overload\n    @classmethod\n    def validate(cls: Type[NameRequiredCls], value: None) -&gt; None:\n\"\"\"Validate a value.\n\n        Args:\n            value: The value to be validated\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        ...\n\n    @classmethod\n    def validate(\n        cls: Type[NameRequiredCls], value: Union[str, NameRequiredCls, None]\n    ) -&gt; Optional[NameRequiredCls]:\n\"\"\"Validates a value.\n\n        Args:\n            value: The value to be validated.\n\n        Returns:\n            The validated value.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        if value is not None:\n            if isinstance(value, str):\n                value = cls(value)\n        return value\n</code></pre>"},{"location":"api/faststream/broker/schemas/NameRequired/#faststream.broker.schemas.NameRequired-attributes","title":"Attributes","text":""},{"location":"api/faststream/broker/schemas/NameRequired/#faststream.broker.schemas.NameRequired.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: Optional[str] = Field(...)\n</code></pre>"},{"location":"api/faststream/broker/schemas/NameRequired/#faststream.broker.schemas.NameRequired-functions","title":"Functions","text":""},{"location":"api/faststream/broker/schemas/NameRequired/#faststream.broker.schemas.NameRequired.__eq__","title":"__eq__","text":"<pre><code>__eq__(__value: object) -&gt; bool\n</code></pre> <p>Compares the current object with another object for equality.</p> <p>Parameters:</p> Name Type Description Default <code>__value</code> <code>object</code> <p>The object to compare with.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the objects are equal, False otherwise.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/schemas.py</code> <pre><code>def __eq__(self, __value: object) -&gt; bool:\n\"\"\"Compares the current object with another object for equality.\n\n    Args:\n        __value: The object to compare with.\n\n    Returns:\n        True if the objects are equal, False otherwise.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    if __value is None:\n        return False\n\n    if not isinstance(__value, NameRequired):  # pragma: no cover\n        return NotImplemented\n\n    return self.name == __value.name\n</code></pre>"},{"location":"api/faststream/broker/schemas/NameRequired/#faststream.broker.schemas.NameRequired.__init__","title":"__init__","text":"<pre><code>__init__(name: str, **kwargs: Any) -&gt; None\n</code></pre> <p>This is a Python function.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the object.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>None.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/schemas.py</code> <pre><code>def __init__(self, name: str, **kwargs: Any) -&gt; None:\n\"\"\"This is a Python function.\n\n    Args:\n        name (str): The name of the object.\n        **kwargs (Any): Additional keyword arguments.\n\n    Returns:\n        None.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    super().__init__(name=name, **kwargs)\n</code></pre>"},{"location":"api/faststream/broker/schemas/NameRequired/#faststream.broker.schemas.NameRequired.validate","title":"validate  <code>classmethod</code>","text":"<pre><code>validate(\n    value: Union[str, NameRequiredCls, None]\n) -&gt; Optional[NameRequiredCls]\n</code></pre> <p>Validates a value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Union[str, NameRequiredCls, None]</code> <p>The value to be validated.</p> required <p>Returns:</p> Type Description <code>Optional[NameRequiredCls]</code> <p>The validated value.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/schemas.py</code> <pre><code>@classmethod\ndef validate(\n    cls: Type[NameRequiredCls], value: Union[str, NameRequiredCls, None]\n) -&gt; Optional[NameRequiredCls]:\n\"\"\"Validates a value.\n\n    Args:\n        value: The value to be validated.\n\n    Returns:\n        The validated value.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    if value is not None:\n        if isinstance(value, str):\n            value = cls(value)\n    return value\n</code></pre>"},{"location":"api/faststream/broker/schemas/RawDecoced/","title":"RawDecoced","text":""},{"location":"api/faststream/broker/schemas/RawDecoced/#faststream.broker.schemas.RawDecoced","title":"faststream.broker.schemas.RawDecoced","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent a raw decoded message.</p> <p>Attributes:</p> Name Type Description <code>message</code> <p>the decoded message, which can be either a JSON object or a string</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/schemas.py</code> <pre><code>class RawDecoced(BaseModel):\n\"\"\"A class to represent a raw decoded message.\n\n    Attributes:\n        message : the decoded message, which can be either a JSON object or a string\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    message: Union[Json[Any], str]\n</code></pre>"},{"location":"api/faststream/broker/schemas/RawDecoced/#faststream.broker.schemas.RawDecoced-attributes","title":"Attributes","text":""},{"location":"api/faststream/broker/schemas/RawDecoced/#faststream.broker.schemas.RawDecoced.message","title":"message  <code>instance-attribute</code>","text":"<pre><code>message: Union[Json[Any], str]\n</code></pre>"},{"location":"api/faststream/broker/security/BaseSecurity/","title":"BaseSecurity","text":""},{"location":"api/faststream/broker/security/BaseSecurity/#faststream.broker.security.BaseSecurity","title":"faststream.broker.security.BaseSecurity","text":"<p>Base class for defining security configurations.</p> <p>This class provides a base for defining security configurations for communication with a broker. It allows setting SSL encryption and provides methods to retrieve security requirements and schemas.</p> <p>Parameters:</p> Name Type Description Default <code>ssl_context</code> <code>Optional[SSLContext]</code> <p>An SSLContext object for SSL encryption. If None, SSL encryption is disabled.</p> <code>None</code> <code>use_ssl</code> <code>Optional[bool]</code> <p>A boolean indicating whether to use SSL encryption. Defaults to True.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>use_ssl</code> <code>bool</code> <p>A boolean indicating whether SSL encryption is enabled.</p> <code>ssl_context</code> <code>Optional[SSLContext]</code> <p>An SSLContext object for SSL encryption. None if SSL is not used.</p> <p>Methods:</p> Name Description <code>get_requirement</code> <p>Get the security requirements in the form of a list of dictionaries.</p> <code>get_schema</code> <p>Get the security schema as a dictionary.</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/security.py</code> <pre><code>class BaseSecurity:\n\"\"\"\n    Base class for defining security configurations.\n\n    This class provides a base for defining security configurations for communication with a broker. It allows setting\n    SSL encryption and provides methods to retrieve security requirements and schemas.\n\n    Args:\n        ssl_context (Optional[SSLContext]): An SSLContext object for SSL encryption. If None, SSL encryption is disabled.\n        use_ssl (Optional[bool]): A boolean indicating whether to use SSL encryption. Defaults to True.\n\n    Attributes:\n        use_ssl (bool): A boolean indicating whether SSL encryption is enabled.\n        ssl_context (Optional[SSLContext]): An SSLContext object for SSL encryption. None if SSL is not used.\n\n    Methods:\n        get_requirement(self) -&gt; List[Dict[str, Any]]:\n            Get the security requirements in the form of a list of dictionaries.\n\n        get_schema(self) -&gt; Dict[str, Dict[str, str]]:\n            Get the security schema as a dictionary.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        ssl_context: Optional[SSLContext] = None,\n        use_ssl: Optional[bool] = None,\n    ):\n        if use_ssl is None:\n            use_ssl = True\n\n        if use_ssl and ssl_context is None:\n            raise RuntimeError(ssl_not_set_error_msg)\n\n        self.use_ssl = use_ssl\n        self.ssl_context = ssl_context\n\n    def get_requirement(self) -&gt; List[Dict[str, Any]]:\n\"\"\"\n        Get the security requirements.\n\n        Returns:\n            List[Dict[str, Any]]: A list of dictionaries representing security requirements.\n        \"\"\"\n        return []\n\n    def get_schema(self) -&gt; Dict[str, Dict[str, str]]:\n\"\"\"\n        Get the security schema.\n\n        Returns:\n            Dict[str, Dict[str, str]]: A dictionary representing the security schema.\n        \"\"\"\n        return {}\n</code></pre>"},{"location":"api/faststream/broker/security/BaseSecurity/#faststream.broker.security.BaseSecurity-attributes","title":"Attributes","text":""},{"location":"api/faststream/broker/security/BaseSecurity/#faststream.broker.security.BaseSecurity.ssl_context","title":"ssl_context  <code>instance-attribute</code>","text":"<pre><code>ssl_context = ssl_context\n</code></pre>"},{"location":"api/faststream/broker/security/BaseSecurity/#faststream.broker.security.BaseSecurity.use_ssl","title":"use_ssl  <code>instance-attribute</code>","text":"<pre><code>use_ssl = use_ssl\n</code></pre>"},{"location":"api/faststream/broker/security/BaseSecurity/#faststream.broker.security.BaseSecurity-functions","title":"Functions","text":""},{"location":"api/faststream/broker/security/BaseSecurity/#faststream.broker.security.BaseSecurity.__init__","title":"__init__","text":"<pre><code>__init__(\n    ssl_context: Optional[SSLContext] = None,\n    use_ssl: Optional[bool] = None,\n)\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/security.py</code> <pre><code>def __init__(\n    self,\n    ssl_context: Optional[SSLContext] = None,\n    use_ssl: Optional[bool] = None,\n):\n    if use_ssl is None:\n        use_ssl = True\n\n    if use_ssl and ssl_context is None:\n        raise RuntimeError(ssl_not_set_error_msg)\n\n    self.use_ssl = use_ssl\n    self.ssl_context = ssl_context\n</code></pre>"},{"location":"api/faststream/broker/security/BaseSecurity/#faststream.broker.security.BaseSecurity.get_requirement","title":"get_requirement","text":"<pre><code>get_requirement() -&gt; List[Dict[str, Any]]\n</code></pre> <p>Get the security requirements.</p> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List[Dict[str, Any]]: A list of dictionaries representing security requirements.</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/security.py</code> <pre><code>def get_requirement(self) -&gt; List[Dict[str, Any]]:\n\"\"\"\n    Get the security requirements.\n\n    Returns:\n        List[Dict[str, Any]]: A list of dictionaries representing security requirements.\n    \"\"\"\n    return []\n</code></pre>"},{"location":"api/faststream/broker/security/BaseSecurity/#faststream.broker.security.BaseSecurity.get_schema","title":"get_schema","text":"<pre><code>get_schema() -&gt; Dict[str, Dict[str, str]]\n</code></pre> <p>Get the security schema.</p> <p>Returns:</p> Type Description <code>Dict[str, Dict[str, str]]</code> <p>Dict[str, Dict[str, str]]: A dictionary representing the security schema.</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/security.py</code> <pre><code>def get_schema(self) -&gt; Dict[str, Dict[str, str]]:\n\"\"\"\n    Get the security schema.\n\n    Returns:\n        Dict[str, Dict[str, str]]: A dictionary representing the security schema.\n    \"\"\"\n    return {}\n</code></pre>"},{"location":"api/faststream/broker/security/SASLPlaintext/","title":"SASLPlaintext","text":""},{"location":"api/faststream/broker/security/SASLPlaintext/#faststream.broker.security.SASLPlaintext","title":"faststream.broker.security.SASLPlaintext","text":"<p>             Bases: <code>BaseSecurity</code></p> <p>Security configuration for SASL/PLAINTEXT authentication.</p> <p>This class defines security configuration for SASL/PLAINTEXT authentication, which includes a username and password.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>The username for authentication.</p> required <code>password</code> <code>str</code> <p>The password for authentication.</p> required <code>ssl_context</code> <code>Optional[SSLContext]</code> <p>An SSLContext object for SSL encryption. If None, SSL encryption is disabled.</p> <code>None</code> <code>use_ssl</code> <code>Optional[bool]</code> <p>A boolean indicating whether to use SSL encryption. Defaults to True.</p> <code>None</code> <p>Methods:</p> Name Description <code>get_requirement</code> <p>Get the security requirements for SASL/PLAINTEXT authentication.</p> <code>get_schema</code> <p>Get the security schema for SASL/PLAINTEXT authentication.</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/security.py</code> <pre><code>class SASLPlaintext(BaseSecurity):\n\"\"\"\n    Security configuration for SASL/PLAINTEXT authentication.\n\n    This class defines security configuration for SASL/PLAINTEXT authentication, which includes a username and password.\n\n    Args:\n        username (str): The username for authentication.\n        password (str): The password for authentication.\n        ssl_context (Optional[SSLContext]): An SSLContext object for SSL encryption. If None, SSL encryption is disabled.\n        use_ssl (Optional[bool]): A boolean indicating whether to use SSL encryption. Defaults to True.\n\n    Methods:\n        get_requirement(self) -&gt; List[Dict[str, Any]]:\n            Get the security requirements for SASL/PLAINTEXT authentication.\n\n        get_schema(self) -&gt; Dict[str, Dict[str, str]]:\n            Get the security schema for SASL/PLAINTEXT authentication.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        username: str,\n        password: str,\n        ssl_context: Optional[SSLContext] = None,\n        use_ssl: Optional[bool] = None,\n    ):\n        super().__init__(ssl_context, use_ssl)\n        self.username = username\n        self.password = password\n\n    def get_requirement(self) -&gt; List[Dict[str, Any]]:\n\"\"\"\n        Get the security requirements for SASL/PLAINTEXT authentication.\n\n        Returns:\n            List[Dict[str, Any]]: A list of dictionaries representing security requirements.\n        \"\"\"\n        return [{\"user-password\": []}]\n\n    def get_schema(self) -&gt; Dict[str, Dict[str, str]]:\n\"\"\"\n        Get the security schema for SASL/PLAINTEXT authentication.\n\n        Returns:\n            Dict[str, Dict[str, str]]: A dictionary representing the security schema.\n        \"\"\"\n        return {\"user-password\": {\"type\": \"userPassword\"}}\n</code></pre>"},{"location":"api/faststream/broker/security/SASLPlaintext/#faststream.broker.security.SASLPlaintext-attributes","title":"Attributes","text":""},{"location":"api/faststream/broker/security/SASLPlaintext/#faststream.broker.security.SASLPlaintext.password","title":"password  <code>instance-attribute</code>","text":"<pre><code>password = password\n</code></pre>"},{"location":"api/faststream/broker/security/SASLPlaintext/#faststream.broker.security.SASLPlaintext.username","title":"username  <code>instance-attribute</code>","text":"<pre><code>username = username\n</code></pre>"},{"location":"api/faststream/broker/security/SASLPlaintext/#faststream.broker.security.SASLPlaintext-functions","title":"Functions","text":""},{"location":"api/faststream/broker/security/SASLPlaintext/#faststream.broker.security.SASLPlaintext.__init__","title":"__init__","text":"<pre><code>__init__(\n    username: str,\n    password: str,\n    ssl_context: Optional[SSLContext] = None,\n    use_ssl: Optional[bool] = None,\n)\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/security.py</code> <pre><code>def __init__(\n    self,\n    username: str,\n    password: str,\n    ssl_context: Optional[SSLContext] = None,\n    use_ssl: Optional[bool] = None,\n):\n    super().__init__(ssl_context, use_ssl)\n    self.username = username\n    self.password = password\n</code></pre>"},{"location":"api/faststream/broker/security/SASLPlaintext/#faststream.broker.security.SASLPlaintext.get_requirement","title":"get_requirement","text":"<pre><code>get_requirement() -&gt; List[Dict[str, Any]]\n</code></pre> <p>Get the security requirements for SASL/PLAINTEXT authentication.</p> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List[Dict[str, Any]]: A list of dictionaries representing security requirements.</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/security.py</code> <pre><code>def get_requirement(self) -&gt; List[Dict[str, Any]]:\n\"\"\"\n    Get the security requirements for SASL/PLAINTEXT authentication.\n\n    Returns:\n        List[Dict[str, Any]]: A list of dictionaries representing security requirements.\n    \"\"\"\n    return [{\"user-password\": []}]\n</code></pre>"},{"location":"api/faststream/broker/security/SASLPlaintext/#faststream.broker.security.SASLPlaintext.get_schema","title":"get_schema","text":"<pre><code>get_schema() -&gt; Dict[str, Dict[str, str]]\n</code></pre> <p>Get the security schema for SASL/PLAINTEXT authentication.</p> <p>Returns:</p> Type Description <code>Dict[str, Dict[str, str]]</code> <p>Dict[str, Dict[str, str]]: A dictionary representing the security schema.</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/security.py</code> <pre><code>def get_schema(self) -&gt; Dict[str, Dict[str, str]]:\n\"\"\"\n    Get the security schema for SASL/PLAINTEXT authentication.\n\n    Returns:\n        Dict[str, Dict[str, str]]: A dictionary representing the security schema.\n    \"\"\"\n    return {\"user-password\": {\"type\": \"userPassword\"}}\n</code></pre>"},{"location":"api/faststream/broker/security/SASLScram256/","title":"SASLScram256","text":""},{"location":"api/faststream/broker/security/SASLScram256/#faststream.broker.security.SASLScram256","title":"faststream.broker.security.SASLScram256","text":"<p>             Bases: <code>BaseSecurity</code></p> <p>Security configuration for SASL/SCRAM-SHA-256 authentication.</p> <p>This class defines security configuration for SASL/SCRAM-SHA-256 authentication, which includes a username and password.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>The username for authentication.</p> required <code>password</code> <code>str</code> <p>The password for authentication.</p> required <code>ssl_context</code> <code>Optional[SSLContext]</code> <p>An SSLContext object for SSL encryption. If None, SSL encryption is disabled.</p> <code>None</code> <code>use_ssl</code> <code>Optional[bool]</code> <p>A boolean indicating whether to use SSL encryption. Defaults to True.</p> <code>None</code> <p>Methods:</p> Name Description <code>get_requirement</code> <p>Get the security requirements for SASL/SCRAM-SHA-256 authentication.</p> <code>get_schema</code> <p>Get the security schema for SASL/SCRAM-SHA-256 authentication.</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/security.py</code> <pre><code>class SASLScram256(BaseSecurity):\n\"\"\"\n    Security configuration for SASL/SCRAM-SHA-256 authentication.\n\n    This class defines security configuration for SASL/SCRAM-SHA-256 authentication, which includes a username and password.\n\n    Args:\n        username (str): The username for authentication.\n        password (str): The password for authentication.\n        ssl_context (Optional[SSLContext]): An SSLContext object for SSL encryption. If None, SSL encryption is disabled.\n        use_ssl (Optional[bool]): A boolean indicating whether to use SSL encryption. Defaults to True.\n\n    Methods:\n        get_requirement(self) -&gt; List[Dict[str, Any]]:\n            Get the security requirements for SASL/SCRAM-SHA-256 authentication.\n\n        get_schema(self) -&gt; Dict[str, Dict[str, str]]:\n            Get the security schema for SASL/SCRAM-SHA-256 authentication.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        username: str,\n        password: str,\n        ssl_context: Optional[SSLContext] = None,\n        use_ssl: Optional[bool] = None,\n    ):\n        super().__init__(ssl_context, use_ssl)\n        self.username = username\n        self.password = password\n\n    def get_requirement(self) -&gt; List[Dict[str, Any]]:\n\"\"\"\n        Get the security requirements for SASL/SCRAM-SHA-256 authentication.\n\n        Returns:\n            List[Dict[str, Any]]: A list of dictionaries representing security requirements.\n        \"\"\"\n        return [{\"scram256\": []}]\n\n    def get_schema(self) -&gt; Dict[str, Dict[str, str]]:\n\"\"\"\n        Get the security schema for SASL/SCRAM-SHA-256 authentication.\n\n        Returns:\n            Dict[str, Dict[str, str]]: A dictionary representing the security schema.\n        \"\"\"\n        return {\"scram256\": {\"type\": \"scramSha256\"}}\n</code></pre>"},{"location":"api/faststream/broker/security/SASLScram256/#faststream.broker.security.SASLScram256-attributes","title":"Attributes","text":""},{"location":"api/faststream/broker/security/SASLScram256/#faststream.broker.security.SASLScram256.password","title":"password  <code>instance-attribute</code>","text":"<pre><code>password = password\n</code></pre>"},{"location":"api/faststream/broker/security/SASLScram256/#faststream.broker.security.SASLScram256.username","title":"username  <code>instance-attribute</code>","text":"<pre><code>username = username\n</code></pre>"},{"location":"api/faststream/broker/security/SASLScram256/#faststream.broker.security.SASLScram256-functions","title":"Functions","text":""},{"location":"api/faststream/broker/security/SASLScram256/#faststream.broker.security.SASLScram256.__init__","title":"__init__","text":"<pre><code>__init__(\n    username: str,\n    password: str,\n    ssl_context: Optional[SSLContext] = None,\n    use_ssl: Optional[bool] = None,\n)\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/security.py</code> <pre><code>def __init__(\n    self,\n    username: str,\n    password: str,\n    ssl_context: Optional[SSLContext] = None,\n    use_ssl: Optional[bool] = None,\n):\n    super().__init__(ssl_context, use_ssl)\n    self.username = username\n    self.password = password\n</code></pre>"},{"location":"api/faststream/broker/security/SASLScram256/#faststream.broker.security.SASLScram256.get_requirement","title":"get_requirement","text":"<pre><code>get_requirement() -&gt; List[Dict[str, Any]]\n</code></pre> <p>Get the security requirements for SASL/SCRAM-SHA-256 authentication.</p> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List[Dict[str, Any]]: A list of dictionaries representing security requirements.</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/security.py</code> <pre><code>def get_requirement(self) -&gt; List[Dict[str, Any]]:\n\"\"\"\n    Get the security requirements for SASL/SCRAM-SHA-256 authentication.\n\n    Returns:\n        List[Dict[str, Any]]: A list of dictionaries representing security requirements.\n    \"\"\"\n    return [{\"scram256\": []}]\n</code></pre>"},{"location":"api/faststream/broker/security/SASLScram256/#faststream.broker.security.SASLScram256.get_schema","title":"get_schema","text":"<pre><code>get_schema() -&gt; Dict[str, Dict[str, str]]\n</code></pre> <p>Get the security schema for SASL/SCRAM-SHA-256 authentication.</p> <p>Returns:</p> Type Description <code>Dict[str, Dict[str, str]]</code> <p>Dict[str, Dict[str, str]]: A dictionary representing the security schema.</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/security.py</code> <pre><code>def get_schema(self) -&gt; Dict[str, Dict[str, str]]:\n\"\"\"\n    Get the security schema for SASL/SCRAM-SHA-256 authentication.\n\n    Returns:\n        Dict[str, Dict[str, str]]: A dictionary representing the security schema.\n    \"\"\"\n    return {\"scram256\": {\"type\": \"scramSha256\"}}\n</code></pre>"},{"location":"api/faststream/broker/security/SASLScram512/","title":"SASLScram512","text":""},{"location":"api/faststream/broker/security/SASLScram512/#faststream.broker.security.SASLScram512","title":"faststream.broker.security.SASLScram512","text":"<p>             Bases: <code>BaseSecurity</code></p> <p>Security configuration for SASL/SCRAM-SHA-512 authentication.</p> <p>This class defines security configuration for SASL/SCRAM-SHA-512 authentication, which includes a username and password.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>The username for authentication.</p> required <code>password</code> <code>str</code> <p>The password for authentication.</p> required <code>ssl_context</code> <code>Optional[SSLContext]</code> <p>An SSLContext object for SSL encryption. If None, SSL encryption is disabled.</p> <code>None</code> <code>use_ssl</code> <code>Optional[bool]</code> <p>A boolean indicating whether to use SSL encryption. Defaults to True.</p> <code>None</code> <p>Methods:</p> Name Description <code>get_requirement</code> <p>Get the security requirements for SASL/SCRAM-SHA-512 authentication.</p> <code>get_schema</code> <p>Get the security schema for SASL/SCRAM-SHA-512 authentication.</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/security.py</code> <pre><code>class SASLScram512(BaseSecurity):\n\"\"\"\n    Security configuration for SASL/SCRAM-SHA-512 authentication.\n\n    This class defines security configuration for SASL/SCRAM-SHA-512 authentication, which includes a username and password.\n\n    Args:\n        username (str): The username for authentication.\n        password (str): The password for authentication.\n        ssl_context (Optional[SSLContext]): An SSLContext object for SSL encryption. If None, SSL encryption is disabled.\n        use_ssl (Optional[bool]): A boolean indicating whether to use SSL encryption. Defaults to True.\n\n    Methods:\n        get_requirement(self) -&gt; List[Dict[str, Any]]:\n            Get the security requirements for SASL/SCRAM-SHA-512 authentication.\n\n        get_schema(self) -&gt; Dict[str, Dict[str, str]]:\n            Get the security schema for SASL/SCRAM-SHA-512 authentication.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        username: str,\n        password: str,\n        ssl_context: Optional[SSLContext] = None,\n        use_ssl: Optional[bool] = None,\n    ):\n        super().__init__(ssl_context, use_ssl)\n        self.username = username\n        self.password = password\n\n    def get_requirement(self) -&gt; List[Dict[str, Any]]:\n\"\"\"\n        Get the security requirements for SASL/SCRAM-SHA-512 authentication.\n\n        Returns:\n            List[Dict[str, Any]]: A list of dictionaries representing security requirements.\n        \"\"\"\n        return [{\"scram512\": []}]\n\n    def get_schema(self) -&gt; Dict[str, Dict[str, str]]:\n\"\"\"\n        Get the security schema for SASL/SCRAM-SHA-512 authentication.\n\n        Returns:\n            Dict[str, Dict[str, str]]: A dictionary representing the security schema.\n        \"\"\"\n        return {\"scram512\": {\"type\": \"scramSha512\"}}\n</code></pre>"},{"location":"api/faststream/broker/security/SASLScram512/#faststream.broker.security.SASLScram512-attributes","title":"Attributes","text":""},{"location":"api/faststream/broker/security/SASLScram512/#faststream.broker.security.SASLScram512.password","title":"password  <code>instance-attribute</code>","text":"<pre><code>password = password\n</code></pre>"},{"location":"api/faststream/broker/security/SASLScram512/#faststream.broker.security.SASLScram512.username","title":"username  <code>instance-attribute</code>","text":"<pre><code>username = username\n</code></pre>"},{"location":"api/faststream/broker/security/SASLScram512/#faststream.broker.security.SASLScram512-functions","title":"Functions","text":""},{"location":"api/faststream/broker/security/SASLScram512/#faststream.broker.security.SASLScram512.__init__","title":"__init__","text":"<pre><code>__init__(\n    username: str,\n    password: str,\n    ssl_context: Optional[SSLContext] = None,\n    use_ssl: Optional[bool] = None,\n)\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/security.py</code> <pre><code>def __init__(\n    self,\n    username: str,\n    password: str,\n    ssl_context: Optional[SSLContext] = None,\n    use_ssl: Optional[bool] = None,\n):\n    super().__init__(ssl_context, use_ssl)\n    self.username = username\n    self.password = password\n</code></pre>"},{"location":"api/faststream/broker/security/SASLScram512/#faststream.broker.security.SASLScram512.get_requirement","title":"get_requirement","text":"<pre><code>get_requirement() -&gt; List[Dict[str, Any]]\n</code></pre> <p>Get the security requirements for SASL/SCRAM-SHA-512 authentication.</p> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List[Dict[str, Any]]: A list of dictionaries representing security requirements.</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/security.py</code> <pre><code>def get_requirement(self) -&gt; List[Dict[str, Any]]:\n\"\"\"\n    Get the security requirements for SASL/SCRAM-SHA-512 authentication.\n\n    Returns:\n        List[Dict[str, Any]]: A list of dictionaries representing security requirements.\n    \"\"\"\n    return [{\"scram512\": []}]\n</code></pre>"},{"location":"api/faststream/broker/security/SASLScram512/#faststream.broker.security.SASLScram512.get_schema","title":"get_schema","text":"<pre><code>get_schema() -&gt; Dict[str, Dict[str, str]]\n</code></pre> <p>Get the security schema for SASL/SCRAM-SHA-512 authentication.</p> <p>Returns:</p> Type Description <code>Dict[str, Dict[str, str]]</code> <p>Dict[str, Dict[str, str]]: A dictionary representing the security schema.</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/security.py</code> <pre><code>def get_schema(self) -&gt; Dict[str, Dict[str, str]]:\n\"\"\"\n    Get the security schema for SASL/SCRAM-SHA-512 authentication.\n\n    Returns:\n        Dict[str, Dict[str, str]]: A dictionary representing the security schema.\n    \"\"\"\n    return {\"scram512\": {\"type\": \"scramSha512\"}}\n</code></pre>"},{"location":"api/faststream/broker/test/TestApp/","title":"TestApp","text":""},{"location":"api/faststream/broker/test/TestApp/#faststream.broker.test.TestApp","title":"faststream.broker.test.TestApp","text":"<p>A class to represent a test application.</p> <p>Attributes:</p> Name Type Description <code>app</code> <p>an instance of FastStream</p> <code>_extra_options</code> <p>optional dictionary of additional options</p> <code>_event</code> <p>an instance of anyio.Event</p> <code>_task</code> <p>an instance of TaskGroup</p> <p>Methods:</p> Name Description <code>__init__ </code> <p>initializes the TestApp object</p> <code>__aenter__ </code> <p>enters the asynchronous context and starts the FastStream application</p> <code>__aexit__ </code> <p>exits the asynchronous context and stops the FastStream application</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/test.py</code> <pre><code>class TestApp:\n    # make sure pytest doesn't try to collect this class as a test class\n\"\"\"A class to represent a test application.\n\n    Attributes:\n        app : an instance of FastStream\n        _extra_options : optional dictionary of additional options\n        _event : an instance of anyio.Event\n        _task : an instance of TaskGroup\n\n    Methods:\n        __init__ : initializes the TestApp object\n        __aenter__ : enters the asynchronous context and starts the FastStream application\n        __aexit__ : exits the asynchronous context and stops the FastStream application\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    __test__ = False\n    app: FastStream\n    _extra_options: Optional[Dict[str, SettingField]]\n    _event: anyio.Event\n    _task: TaskGroup\n\n    def __init__(\n        self,\n        app: FastStream,\n        run_extra_options: Optional[Dict[str, SettingField]] = None,\n    ) -&gt; None:\n\"\"\"Initialize a class instance.\n\n        Args:\n            app: An instance of the FastStream class.\n            run_extra_options: Optional dictionary of extra options for running the application.\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        self.app = app\n        self._extra_options = run_extra_options\n\n    async def __aenter__(self) -&gt; FastStream:\n        self.app._stop_event = self._event = anyio.Event()\n        await self.app._start(run_extra_options=self._extra_options)\n        self._task = tg = anyio.create_task_group()\n        await tg.__aenter__()\n        tg.start_soon(self.app._stop)\n        return self.app\n\n    async def __aexit__(\n        self,\n        exc_type: Optional[Type[BaseException]] = None,\n        exc_val: Optional[BaseException] = None,\n        exec_tb: Optional[TracebackType] = None,\n    ) -&gt; None:\n\"\"\"Exit the asynchronous context manager.\n\n        Args:\n            exc_type: The type of the exception raised, if any.\n            exc_val: The exception instance raised, if any.\n            exec_tb: The traceback for the exception raised, if any.\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        self._event.set()\n        await self._task.__aexit__(exc_type, exc_val, exec_tb)\n</code></pre>"},{"location":"api/faststream/broker/test/TestApp/#faststream.broker.test.TestApp-attributes","title":"Attributes","text":""},{"location":"api/faststream/broker/test/TestApp/#faststream.broker.test.TestApp.__test__","title":"__test__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__test__ = False\n</code></pre>"},{"location":"api/faststream/broker/test/TestApp/#faststream.broker.test.TestApp.app","title":"app  <code>instance-attribute</code>","text":"<pre><code>app: FastStream = app\n</code></pre>"},{"location":"api/faststream/broker/test/TestApp/#faststream.broker.test.TestApp-functions","title":"Functions","text":""},{"location":"api/faststream/broker/test/TestApp/#faststream.broker.test.TestApp.__aenter__","title":"__aenter__  <code>async</code>","text":"<pre><code>__aenter__() -&gt; FastStream\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/test.py</code> <pre><code>async def __aenter__(self) -&gt; FastStream:\n    self.app._stop_event = self._event = anyio.Event()\n    await self.app._start(run_extra_options=self._extra_options)\n    self._task = tg = anyio.create_task_group()\n    await tg.__aenter__()\n    tg.start_soon(self.app._stop)\n    return self.app\n</code></pre>"},{"location":"api/faststream/broker/test/TestApp/#faststream.broker.test.TestApp.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(\n    exc_type: Optional[Type[BaseException]] = None,\n    exc_val: Optional[BaseException] = None,\n    exec_tb: Optional[TracebackType] = None,\n) -&gt; None\n</code></pre> <p>Exit the asynchronous context manager.</p> <p>Parameters:</p> Name Type Description Default <code>exc_type</code> <code>Optional[Type[BaseException]]</code> <p>The type of the exception raised, if any.</p> <code>None</code> <code>exc_val</code> <code>Optional[BaseException]</code> <p>The exception instance raised, if any.</p> <code>None</code> <code>exec_tb</code> <code>Optional[TracebackType]</code> <p>The traceback for the exception raised, if any.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/test.py</code> <pre><code>async def __aexit__(\n    self,\n    exc_type: Optional[Type[BaseException]] = None,\n    exc_val: Optional[BaseException] = None,\n    exec_tb: Optional[TracebackType] = None,\n) -&gt; None:\n\"\"\"Exit the asynchronous context manager.\n\n    Args:\n        exc_type: The type of the exception raised, if any.\n        exc_val: The exception instance raised, if any.\n        exec_tb: The traceback for the exception raised, if any.\n\n    Returns:\n        None\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    self._event.set()\n    await self._task.__aexit__(exc_type, exc_val, exec_tb)\n</code></pre>"},{"location":"api/faststream/broker/test/TestApp/#faststream.broker.test.TestApp.__init__","title":"__init__","text":"<pre><code>__init__(\n    app: FastStream,\n    run_extra_options: Optional[\n        Dict[str, SettingField]\n    ] = None,\n) -&gt; None\n</code></pre> <p>Initialize a class instance.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>FastStream</code> <p>An instance of the FastStream class.</p> required <code>run_extra_options</code> <code>Optional[Dict[str, SettingField]]</code> <p>Optional dictionary of extra options for running the application.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/test.py</code> <pre><code>def __init__(\n    self,\n    app: FastStream,\n    run_extra_options: Optional[Dict[str, SettingField]] = None,\n) -&gt; None:\n\"\"\"Initialize a class instance.\n\n    Args:\n        app: An instance of the FastStream class.\n        run_extra_options: Optional dictionary of extra options for running the application.\n\n    Returns:\n        None\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    self.app = app\n    self._extra_options = run_extra_options\n</code></pre>"},{"location":"api/faststream/broker/test/call_handler/","title":"call_handler","text":""},{"location":"api/faststream/broker/test/call_handler/#faststream.broker.test.call_handler","title":"faststream.broker.test.call_handler  <code>async</code>","text":"<pre><code>call_handler(\n    handler: AsyncHandler[Any],\n    message: Any,\n    rpc: bool = False,\n    rpc_timeout: Optional[float] = 30.0,\n    raise_timeout: bool = False,\n) -&gt; Optional[SendableMessage]\n</code></pre> <p>Asynchronously call a handler function.</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>AsyncHandler[Any]</code> <p>The handler function to be called.</p> required <code>message</code> <code>Any</code> <p>The message to be passed to the handler function.</p> required <code>rpc</code> <code>bool</code> <p>Whether the call is a remote procedure call (RPC).</p> <code>False</code> <code>rpc_timeout</code> <code>Optional[float]</code> <p>The timeout for the RPC, in seconds.</p> <code>30.0</code> <code>raise_timeout</code> <code>bool</code> <p>Whether to raise a timeout error if the RPC times out.</p> <code>False</code> <p>Returns:</p> Type Description <code>Optional[SendableMessage]</code> <p>The result of the handler function if <code>rpc</code> is True, otherwise None.</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If the RPC times out and <code>raise_timeout</code> is True.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/test.py</code> <pre><code>async def call_handler(\n    handler: AsyncHandler[Any],\n    message: Any,\n    rpc: bool = False,\n    rpc_timeout: Optional[float] = 30.0,\n    raise_timeout: bool = False,\n) -&gt; Optional[SendableMessage]:\n\"\"\"Asynchronously call a handler function.\n\n    Args:\n        handler: The handler function to be called.\n        message: The message to be passed to the handler function.\n        rpc: Whether the call is a remote procedure call (RPC).\n        rpc_timeout: The timeout for the RPC, in seconds.\n        raise_timeout: Whether to raise a timeout error if the RPC times out.\n\n    Returns:\n        The result of the handler function if `rpc` is True, otherwise None.\n\n    Raises:\n        TimeoutError: If the RPC times out and `raise_timeout` is True.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    scope: Callable[[Optional[float]], ContextManager[CancelScope]]\n    if raise_timeout:\n        scope = anyio.fail_after\n    else:\n        scope = anyio.move_on_after\n\n    with scope(rpc_timeout):\n        result = await handler.consume(message)\n\n        if rpc is True:\n            return result\n\n    return None\n</code></pre>"},{"location":"api/faststream/broker/test/patch_broker_calls/","title":"patch_broker_calls","text":""},{"location":"api/faststream/broker/test/patch_broker_calls/#faststream.broker.test.patch_broker_calls","title":"faststream.broker.test.patch_broker_calls","text":"<pre><code>patch_broker_calls(broker: BrokerUsecase[Any, Any]) -&gt; None\n</code></pre> <p>Patch broker calls.</p> <p>Parameters:</p> Name Type Description Default <code>broker</code> <code>BrokerUsecase[Any, Any]</code> <p>The broker to patch.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/test.py</code> <pre><code>def patch_broker_calls(broker: BrokerUsecase[Any, Any]) -&gt; None:\n\"\"\"Patch broker calls.\n\n    Args:\n        broker: The broker to patch.\n\n    Returns:\n        None.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    for handler in broker.handlers.values():\n        for f, _, _, _, _, _ in handler.calls:\n            f.event = anyio.Event()\n        handler.set_test()\n</code></pre>"},{"location":"api/faststream/broker/types/AsyncPublisherProtocol/","title":"AsyncPublisherProtocol","text":""},{"location":"api/faststream/broker/types/AsyncPublisherProtocol/#faststream.broker.types.AsyncPublisherProtocol","title":"faststream.broker.types.AsyncPublisherProtocol","text":"<p>             Bases: <code>Protocol</code></p> <p>A protocol for an asynchronous publisher.</p> <p>Methods:</p> Name Description <code>publish</code> <p>SendableMessage, correlation_id: Optional[str] = None, **kwargs: Any) -&gt; Optional[SendableMessage]: Publishes a message asynchronously.</p> <p>Args:     message: The message to be published.     correlation_id: The correlation ID for the message (optional).     **kwargs: Additional keyword arguments.</p> <p>Returns:     The published message (optional).</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/types.py</code> <pre><code>class AsyncPublisherProtocol(Protocol):\n\"\"\"A protocol for an asynchronous publisher.\n\n    Methods:\n        publish(message: SendableMessage, correlation_id: Optional[str] = None, **kwargs: Any) -&gt; Optional[SendableMessage]:\n            Publishes a message asynchronously.\n\n            Args:\n                message: The message to be published.\n                correlation_id: The correlation ID for the message (optional).\n                **kwargs: Additional keyword arguments.\n\n            Returns:\n                The published message (optional).\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    async def publish(\n        self,\n        message: SendableMessage,\n        correlation_id: Optional[str] = None,\n        **kwargs: Any,\n    ) -&gt; Optional[SendableMessage]:\n\"\"\"Publishes a message.\n\n        Args:\n            message: The message to be published.\n            correlation_id: Optional correlation ID for the message.\n            **kwargs: Additional keyword arguments.\n\n        Returns:\n            The published message, or None if the message was not published.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        ...\n</code></pre>"},{"location":"api/faststream/broker/types/AsyncPublisherProtocol/#faststream.broker.types.AsyncPublisherProtocol-functions","title":"Functions","text":""},{"location":"api/faststream/broker/types/AsyncPublisherProtocol/#faststream.broker.types.AsyncPublisherProtocol.publish","title":"publish  <code>async</code>","text":"<pre><code>publish(\n    message: SendableMessage,\n    correlation_id: Optional[str] = None,\n    **kwargs: Any\n) -&gt; Optional[SendableMessage]\n</code></pre> <p>Publishes a message.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>SendableMessage</code> <p>The message to be published.</p> required <code>correlation_id</code> <code>Optional[str]</code> <p>Optional correlation ID for the message.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Optional[SendableMessage]</code> <p>The published message, or None if the message was not published.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/types.py</code> <pre><code>async def publish(\n    self,\n    message: SendableMessage,\n    correlation_id: Optional[str] = None,\n    **kwargs: Any,\n) -&gt; Optional[SendableMessage]:\n\"\"\"Publishes a message.\n\n    Args:\n        message: The message to be published.\n        correlation_id: Optional correlation ID for the message.\n        **kwargs: Additional keyword arguments.\n\n    Returns:\n        The published message, or None if the message was not published.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/faststream/broker/utils/change_logger_handlers/","title":"change_logger_handlers","text":""},{"location":"api/faststream/broker/utils/change_logger_handlers/#faststream.broker.utils.change_logger_handlers","title":"faststream.broker.utils.change_logger_handlers","text":"<pre><code>change_logger_handlers(\n    logger: logging.Logger, fmt: str\n) -&gt; None\n</code></pre> <p>Change the formatter of the logger handlers.</p> <p>Parameters:</p> Name Type Description Default <code>logger</code> <code>Logger</code> <p>The logger object.</p> required <code>fmt</code> <code>str</code> <p>The format string for the formatter.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/utils.py</code> <pre><code>def change_logger_handlers(logger: logging.Logger, fmt: str) -&gt; None:\n\"\"\"Change the formatter of the logger handlers.\n\n    Args:\n        logger (logging.Logger): The logger object.\n        fmt (str): The format string for the formatter.\n\n    Returns:\n        None\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    for handler in logger.handlers:\n        formatter = handler.formatter\n        if formatter is not None:\n            use_colors = getattr(formatter, \"use_colors\", None)\n            if use_colors is not None:\n                kwargs = {\"use_colors\": use_colors}\n            else:\n                kwargs = {}\n            handler.setFormatter(type(formatter)(fmt, **kwargs))\n</code></pre>"},{"location":"api/faststream/broker/utils/get_watcher/","title":"get_watcher","text":""},{"location":"api/faststream/broker/utils/get_watcher/#faststream.broker.utils.get_watcher","title":"faststream.broker.utils.get_watcher","text":"<pre><code>get_watcher(\n    logger: Optional[logging.Logger],\n    try_number: Union[bool, int] = True,\n) -&gt; BaseWatcher\n</code></pre> <p>Get a watcher object based on the provided parameters.</p> <p>Parameters:</p> Name Type Description Default <code>logger</code> <code>Optional[Logger]</code> <p>Optional logger object for logging messages.</p> required <code>try_number</code> <code>Union[bool, int]</code> <p>Optional parameter to specify the type of watcher. - If set to True, an EndlessWatcher object will be returned. - If set to False, a OneTryWatcher object will be returned. - If set to an integer, a CounterWatcher object with the specified maximum number of tries will be returned.</p> <code>True</code> <p>Returns:</p> Type Description <code>BaseWatcher</code> <p>A watcher object based on the provided parameters.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/utils.py</code> <pre><code>def get_watcher(\n    logger: Optional[logging.Logger],\n    try_number: Union[bool, int] = True,\n) -&gt; BaseWatcher:\n\"\"\"Get a watcher object based on the provided parameters.\n\n    Args:\n        logger: Optional logger object for logging messages.\n        try_number: Optional parameter to specify the type of watcher.\n            - If set to True, an EndlessWatcher object will be returned.\n            - If set to False, a OneTryWatcher object will be returned.\n            - If set to an integer, a CounterWatcher object with the specified maximum number of tries will be returned.\n\n    Returns:\n        A watcher object based on the provided parameters.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    watcher: Optional[BaseWatcher]\n    if try_number is True:\n        watcher = EndlessWatcher()\n    elif try_number is False:\n        watcher = OneTryWatcher()\n    else:\n        watcher = CounterWatcher(logger=logger, max_tries=try_number)\n    return watcher\n</code></pre>"},{"location":"api/faststream/broker/utils/set_message_context/","title":"set_message_context","text":""},{"location":"api/faststream/broker/utils/set_message_context/#faststream.broker.utils.set_message_context","title":"faststream.broker.utils.set_message_context","text":"<pre><code>set_message_context(\n    func: Callable[\n        [StreamMessage[MsgType]],\n        Awaitable[WrappedReturn[T_HandlerReturn]],\n    ]\n) -&gt; Callable[\n    [StreamMessage[MsgType]],\n    Awaitable[WrappedReturn[T_HandlerReturn]],\n]\n</code></pre> <p>Sets the message context for a function.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[StreamMessage[MsgType]], Awaitable[WrappedReturn[T_HandlerReturn]]]</code> <p>The function to set the message context for.</p> required <p>Returns:</p> Type Description <code>Callable[[StreamMessage[MsgType]], Awaitable[WrappedReturn[T_HandlerReturn]]]</code> <p>The function with the message context set.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/utils.py</code> <pre><code>def set_message_context(\n    func: Callable[\n        [StreamMessage[MsgType]],\n        Awaitable[WrappedReturn[T_HandlerReturn]],\n    ],\n) -&gt; Callable[[StreamMessage[MsgType]], Awaitable[WrappedReturn[T_HandlerReturn]]]:\n\"\"\"Sets the message context for a function.\n\n    Args:\n        func: The function to set the message context for.\n\n    Returns:\n        The function with the message context set.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    @wraps(func)\n    async def set_message_wrapper(\n        message: StreamMessage[MsgType],\n    ) -&gt; WrappedReturn[T_HandlerReturn]:\n\"\"\"Wraps a function that handles a stream message.\n\n        Args:\n            message: The stream message to be handled.\n\n        Returns:\n            The wrapped return value of the handler function.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        with context.scope(\"message\", message):\n            return await func(message)\n\n    return set_message_wrapper\n</code></pre>"},{"location":"api/faststream/broker/wrapper/FakePublisher/","title":"FakePublisher","text":""},{"location":"api/faststream/broker/wrapper/FakePublisher/#faststream.broker.wrapper.FakePublisher","title":"faststream.broker.wrapper.FakePublisher","text":"<p>A class to represent a fake publisher.</p> <p>Attributes:</p> Name Type Description <code>method</code> <p>a callable method that takes arguments and returns an awaitable sendable message</p> <p>Methods:</p> Name Description <code>publish </code> <p>asynchronously publishes a message with optional correlation ID and additional keyword arguments</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/wrapper.py</code> <pre><code>class FakePublisher:\n\"\"\"A class to represent a fake publisher.\n\n    Attributes:\n        method : a callable method that takes arguments and returns an awaitable sendable message\n\n    Methods:\n        publish : asynchronously publishes a message with optional correlation ID and additional keyword arguments\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    def __init__(self, method: Callable[..., Awaitable[SendableMessage]]) -&gt; None:\n\"\"\"Initialize an object.\n\n        Args:\n            method: A callable that takes any number of arguments and returns an awaitable sendable message.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        self.method = method\n\n    async def publish(\n        self,\n        message: SendableMessage,\n        correlation_id: Optional[str] = None,\n        **kwargs: Any,\n    ) -&gt; Optional[SendableMessage]:\n\"\"\"Publish a message.\n\n        Args:\n            message: The message to be published.\n            correlation_id: Optional correlation ID for the message.\n            **kwargs: Additional keyword arguments.\n\n        Returns:\n            The published message.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        return await self.method(message, correlation_id=correlation_id, **kwargs)\n</code></pre>"},{"location":"api/faststream/broker/wrapper/FakePublisher/#faststream.broker.wrapper.FakePublisher-attributes","title":"Attributes","text":""},{"location":"api/faststream/broker/wrapper/FakePublisher/#faststream.broker.wrapper.FakePublisher.method","title":"method  <code>instance-attribute</code>","text":"<pre><code>method = method\n</code></pre>"},{"location":"api/faststream/broker/wrapper/FakePublisher/#faststream.broker.wrapper.FakePublisher-functions","title":"Functions","text":""},{"location":"api/faststream/broker/wrapper/FakePublisher/#faststream.broker.wrapper.FakePublisher.__init__","title":"__init__","text":"<pre><code>__init__(\n    method: Callable[..., Awaitable[SendableMessage]]\n) -&gt; None\n</code></pre> <p>Initialize an object.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>Callable[..., Awaitable[SendableMessage]]</code> <p>A callable that takes any number of arguments and returns an awaitable sendable message.</p> required <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/wrapper.py</code> <pre><code>def __init__(self, method: Callable[..., Awaitable[SendableMessage]]) -&gt; None:\n\"\"\"Initialize an object.\n\n    Args:\n        method: A callable that takes any number of arguments and returns an awaitable sendable message.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    self.method = method\n</code></pre>"},{"location":"api/faststream/broker/wrapper/FakePublisher/#faststream.broker.wrapper.FakePublisher.publish","title":"publish  <code>async</code>","text":"<pre><code>publish(\n    message: SendableMessage,\n    correlation_id: Optional[str] = None,\n    **kwargs: Any\n) -&gt; Optional[SendableMessage]\n</code></pre> <p>Publish a message.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>SendableMessage</code> <p>The message to be published.</p> required <code>correlation_id</code> <code>Optional[str]</code> <p>Optional correlation ID for the message.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Optional[SendableMessage]</code> <p>The published message.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/wrapper.py</code> <pre><code>async def publish(\n    self,\n    message: SendableMessage,\n    correlation_id: Optional[str] = None,\n    **kwargs: Any,\n) -&gt; Optional[SendableMessage]:\n\"\"\"Publish a message.\n\n    Args:\n        message: The message to be published.\n        correlation_id: Optional correlation ID for the message.\n        **kwargs: Additional keyword arguments.\n\n    Returns:\n        The published message.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    return await self.method(message, correlation_id=correlation_id, **kwargs)\n</code></pre>"},{"location":"api/faststream/broker/wrapper/HandlerCallWrapper/","title":"HandlerCallWrapper","text":""},{"location":"api/faststream/broker/wrapper/HandlerCallWrapper/#faststream.broker.wrapper.HandlerCallWrapper","title":"faststream.broker.wrapper.HandlerCallWrapper","text":"<p>             Bases: <code>Generic[MsgType, P_HandlerParams, T_HandlerReturn]</code></p> <p>A generic class to wrap handler calls.</p> <p>Attributes:</p> Name Type Description <code>mock</code> <p>MagicMock object used for mocking</p> <code>event</code> <p>an anyio.Event object used for synchronization</p> <code>_wrapped_call</code> <p>WrappedHandlerCall object representing the wrapped handler call</p> <code>_original_call</code> <p>original handler call</p> <code>_publishers</code> <p>list of AsyncPublisherProtocol objects</p> <p>Methods:</p> Name Description <code>__new__ </code> <p>Create a new instance of the class</p> <code>__init__ </code> <p>Initialize the instance</p> <code>__call__ </code> <p>Call the wrapped handler</p> <code>set_wrapped </code> <p>Set the wrapped handler call</p> <code>call_wrapped </code> <p>Call the wrapped handler</p> <code>wait_call </code> <p>Wait for the handler call to complete</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/wrapper.py</code> <pre><code>class HandlerCallWrapper(Generic[MsgType, P_HandlerParams, T_HandlerReturn]):\n\"\"\"A generic class to wrap handler calls.\n\n    Attributes:\n        mock : MagicMock object used for mocking\n        event : an anyio.Event object used for synchronization\n\n        _wrapped_call : WrappedHandlerCall object representing the wrapped handler call\n        _original_call : original handler call\n        _publishers : list of AsyncPublisherProtocol objects\n\n    Methods:\n        __new__ : Create a new instance of the class\n        __init__ : Initialize the instance\n        __call__ : Call the wrapped handler\n        set_wrapped : Set the wrapped handler call\n        call_wrapped : Call the wrapped handler\n        wait_call : Wait for the handler call to complete\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    mock: MagicMock\n    event: Optional[anyio.Event]\n\n    _wrapped_call: Optional[WrappedHandlerCall[MsgType, T_HandlerReturn]]\n    _original_call: Callable[P_HandlerParams, T_HandlerReturn]\n    _publishers: List[AsyncPublisherProtocol]\n\n    def __new__(\n        cls,\n        call: Union[\n            \"HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn]\",\n            Callable[P_HandlerParams, T_HandlerReturn],\n        ],\n    ) -&gt; Self:\n\"\"\"Create a new instance of the class.\n\n        Args:\n            call: An instance of \"HandlerCallWrapper\" or a callable object\n\n        Returns:\n            An instance of the class\n\n        Note:\n            If the \"call\" argument is already an instance of the class, it is returned as is. Otherwise, a new instance of the class is created using the superclass's __new__ method.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        if isinstance(call, cls):\n            return call\n        else:\n            return super().__new__(cls)\n\n    def __init__(\n        self,\n        call: Callable[P_HandlerParams, T_HandlerReturn],\n    ):\n\"\"\"Initialize a handler.\n\n        Args:\n            call: A callable object that represents the handler function.\n\n        Attributes:\n            _original_call: The original handler function.\n            _wrapped_call: The wrapped handler function.\n            _publishers: A list of publishers.\n            mock: A MagicMock object.\n            event: The event associated with the handler.\n            __name__: The name of the handler function.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        if not isinstance(call, HandlerCallWrapper):\n            self._original_call = call\n            self._wrapped_call = None\n            self._publishers = []\n            self.mock = MagicMock()\n            self.event = None\n            self.__name__ = getattr(self._original_call, \"__name__\", \"undefined\")\n\n    def __call__(\n        self,\n        *args: P_HandlerParams.args,\n        **kwargs: P_HandlerParams.kwargs,\n    ) -&gt; T_HandlerReturn:\n\"\"\"Calls the object as a function.\n\n        Args:\n            *args: Positional arguments to be passed to the function.\n            **kwargs: Keyword arguments to be passed to the function.\n\n        Returns:\n            The return value of the function.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        self.mock(*args, **kwargs)\n        if self.event is not None:\n            self.event.set()\n        return self._original_call(*args, **kwargs)\n\n    def set_wrapped(\n        self, wrapped: WrappedHandlerCall[MsgType, T_HandlerReturn]\n    ) -&gt; None:\n\"\"\"Set the wrapped handler call.\n\n        Args:\n            wrapped: The wrapped handler call to set\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        self._wrapped_call = wrapped\n\n    def call_wrapped(\n        self,\n        message: StreamMessage[MsgType],\n    ) -&gt; Union[\n        Optional[WrappedReturn[T_HandlerReturn]],\n        Awaitable[Optional[WrappedReturn[T_HandlerReturn]]],\n    ]:\n\"\"\"Calls the wrapped function with the given message.\n\n        Args:\n            message: The message to be passed to the wrapped function.\n\n        Returns:\n            The result of the wrapped function call.\n\n        Raises:\n            AssertionError: If `set_wrapped` has not been called before calling this function.\n            AssertionError: If the broker has not been started before calling this function.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        assert self._wrapped_call, \"You should use `set_wrapped` first\"  # nosec B101\n        assert self.event, \"You should start the broker first\"  # nosec B101\n        self.mock(message.decoded_body)\n        self.event.set()\n        return self._wrapped_call(message)\n\n    async def wait_call(self, timeout: Optional[float] = None) -&gt; None:\n\"\"\"Waits for a call with an optional timeout.\n\n        Args:\n            timeout: Optional timeout in seconds\n\n        Raises:\n            AssertionError: If the broker is not started\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        assert self.event, \"You should start the broker first\"  # nosec B101\n        with anyio.fail_after(timeout):\n            await self.event.wait()\n</code></pre>"},{"location":"api/faststream/broker/wrapper/HandlerCallWrapper/#faststream.broker.wrapper.HandlerCallWrapper-attributes","title":"Attributes","text":""},{"location":"api/faststream/broker/wrapper/HandlerCallWrapper/#faststream.broker.wrapper.HandlerCallWrapper.__name__","title":"__name__  <code>instance-attribute</code>","text":"<pre><code>__name__ = getattr(\n    self._original_call, \"__name__\", \"undefined\"\n)\n</code></pre>"},{"location":"api/faststream/broker/wrapper/HandlerCallWrapper/#faststream.broker.wrapper.HandlerCallWrapper.event","title":"event  <code>instance-attribute</code>","text":"<pre><code>event: Optional[anyio.Event]\n</code></pre>"},{"location":"api/faststream/broker/wrapper/HandlerCallWrapper/#faststream.broker.wrapper.HandlerCallWrapper.mock","title":"mock  <code>instance-attribute</code>","text":"<pre><code>mock: MagicMock\n</code></pre>"},{"location":"api/faststream/broker/wrapper/HandlerCallWrapper/#faststream.broker.wrapper.HandlerCallWrapper-functions","title":"Functions","text":""},{"location":"api/faststream/broker/wrapper/HandlerCallWrapper/#faststream.broker.wrapper.HandlerCallWrapper.__call__","title":"__call__","text":"<pre><code>__call__(\n    *args: P_HandlerParams.args,\n    **kwargs: P_HandlerParams.kwargs\n) -&gt; T_HandlerReturn\n</code></pre> <p>Calls the object as a function.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>args</code> <p>Positional arguments to be passed to the function.</p> <code>()</code> <code>**kwargs</code> <code>kwargs</code> <p>Keyword arguments to be passed to the function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>T_HandlerReturn</code> <p>The return value of the function.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/wrapper.py</code> <pre><code>def __call__(\n    self,\n    *args: P_HandlerParams.args,\n    **kwargs: P_HandlerParams.kwargs,\n) -&gt; T_HandlerReturn:\n\"\"\"Calls the object as a function.\n\n    Args:\n        *args: Positional arguments to be passed to the function.\n        **kwargs: Keyword arguments to be passed to the function.\n\n    Returns:\n        The return value of the function.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    self.mock(*args, **kwargs)\n    if self.event is not None:\n        self.event.set()\n    return self._original_call(*args, **kwargs)\n</code></pre>"},{"location":"api/faststream/broker/wrapper/HandlerCallWrapper/#faststream.broker.wrapper.HandlerCallWrapper.__init__","title":"__init__","text":"<pre><code>__init__(call: Callable[P_HandlerParams, T_HandlerReturn])\n</code></pre> <p>Initialize a handler.</p> <p>Parameters:</p> Name Type Description Default <code>call</code> <code>Callable[P_HandlerParams, T_HandlerReturn]</code> <p>A callable object that represents the handler function.</p> required <p>Attributes:</p> Name Type Description <code>_original_call</code> <p>The original handler function.</p> <code>_wrapped_call</code> <p>The wrapped handler function.</p> <code>_publishers</code> <p>A list of publishers.</p> <code>mock</code> <p>A MagicMock object.</p> <code>event</code> <p>The event associated with the handler.</p> <code>__name__</code> <p>The name of the handler function.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/wrapper.py</code> <pre><code>def __init__(\n    self,\n    call: Callable[P_HandlerParams, T_HandlerReturn],\n):\n\"\"\"Initialize a handler.\n\n    Args:\n        call: A callable object that represents the handler function.\n\n    Attributes:\n        _original_call: The original handler function.\n        _wrapped_call: The wrapped handler function.\n        _publishers: A list of publishers.\n        mock: A MagicMock object.\n        event: The event associated with the handler.\n        __name__: The name of the handler function.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    if not isinstance(call, HandlerCallWrapper):\n        self._original_call = call\n        self._wrapped_call = None\n        self._publishers = []\n        self.mock = MagicMock()\n        self.event = None\n        self.__name__ = getattr(self._original_call, \"__name__\", \"undefined\")\n</code></pre>"},{"location":"api/faststream/broker/wrapper/HandlerCallWrapper/#faststream.broker.wrapper.HandlerCallWrapper.__new__","title":"__new__","text":"<pre><code>__new__(\n    call: Union[\n        HandlerCallWrapper[\n            MsgType, P_HandlerParams, T_HandlerReturn\n        ],\n        Callable[P_HandlerParams, T_HandlerReturn],\n    ]\n) -&gt; Self\n</code></pre> <p>Create a new instance of the class.</p> <p>Parameters:</p> Name Type Description Default <code>call</code> <code>Union[HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn], Callable[P_HandlerParams, T_HandlerReturn]]</code> <p>An instance of \"HandlerCallWrapper\" or a callable object</p> required <p>Returns:</p> Type Description <code>Self</code> <p>An instance of the class</p> Note <p>If the \"call\" argument is already an instance of the class, it is returned as is. Otherwise, a new instance of the class is created using the superclass's new method.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/wrapper.py</code> <pre><code>def __new__(\n    cls,\n    call: Union[\n        \"HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn]\",\n        Callable[P_HandlerParams, T_HandlerReturn],\n    ],\n) -&gt; Self:\n\"\"\"Create a new instance of the class.\n\n    Args:\n        call: An instance of \"HandlerCallWrapper\" or a callable object\n\n    Returns:\n        An instance of the class\n\n    Note:\n        If the \"call\" argument is already an instance of the class, it is returned as is. Otherwise, a new instance of the class is created using the superclass's __new__ method.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    if isinstance(call, cls):\n        return call\n    else:\n        return super().__new__(cls)\n</code></pre>"},{"location":"api/faststream/broker/wrapper/HandlerCallWrapper/#faststream.broker.wrapper.HandlerCallWrapper.call_wrapped","title":"call_wrapped","text":"<pre><code>call_wrapped(\n    message: StreamMessage[MsgType],\n) -&gt; Union[\n    Optional[WrappedReturn[T_HandlerReturn]],\n    Awaitable[Optional[WrappedReturn[T_HandlerReturn]]],\n]\n</code></pre> <p>Calls the wrapped function with the given message.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>StreamMessage[MsgType]</code> <p>The message to be passed to the wrapped function.</p> required <p>Returns:</p> Type Description <code>Union[Optional[WrappedReturn[T_HandlerReturn]], Awaitable[Optional[WrappedReturn[T_HandlerReturn]]]]</code> <p>The result of the wrapped function call.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If <code>set_wrapped</code> has not been called before calling this function.</p> <code>AssertionError</code> <p>If the broker has not been started before calling this function.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/wrapper.py</code> <pre><code>def call_wrapped(\n    self,\n    message: StreamMessage[MsgType],\n) -&gt; Union[\n    Optional[WrappedReturn[T_HandlerReturn]],\n    Awaitable[Optional[WrappedReturn[T_HandlerReturn]]],\n]:\n\"\"\"Calls the wrapped function with the given message.\n\n    Args:\n        message: The message to be passed to the wrapped function.\n\n    Returns:\n        The result of the wrapped function call.\n\n    Raises:\n        AssertionError: If `set_wrapped` has not been called before calling this function.\n        AssertionError: If the broker has not been started before calling this function.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    assert self._wrapped_call, \"You should use `set_wrapped` first\"  # nosec B101\n    assert self.event, \"You should start the broker first\"  # nosec B101\n    self.mock(message.decoded_body)\n    self.event.set()\n    return self._wrapped_call(message)\n</code></pre>"},{"location":"api/faststream/broker/wrapper/HandlerCallWrapper/#faststream.broker.wrapper.HandlerCallWrapper.set_wrapped","title":"set_wrapped","text":"<pre><code>set_wrapped(\n    wrapped: WrappedHandlerCall[MsgType, T_HandlerReturn]\n) -&gt; None\n</code></pre> <p>Set the wrapped handler call.</p> <p>Parameters:</p> Name Type Description Default <code>wrapped</code> <code>WrappedHandlerCall[MsgType, T_HandlerReturn]</code> <p>The wrapped handler call to set</p> required <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/wrapper.py</code> <pre><code>def set_wrapped(\n    self, wrapped: WrappedHandlerCall[MsgType, T_HandlerReturn]\n) -&gt; None:\n\"\"\"Set the wrapped handler call.\n\n    Args:\n        wrapped: The wrapped handler call to set\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    self._wrapped_call = wrapped\n</code></pre>"},{"location":"api/faststream/broker/wrapper/HandlerCallWrapper/#faststream.broker.wrapper.HandlerCallWrapper.wait_call","title":"wait_call  <code>async</code>","text":"<pre><code>wait_call(timeout: Optional[float] = None) -&gt; None\n</code></pre> <p>Waits for a call with an optional timeout.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>Optional[float]</code> <p>Optional timeout in seconds</p> <code>None</code> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If the broker is not started</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/wrapper.py</code> <pre><code>async def wait_call(self, timeout: Optional[float] = None) -&gt; None:\n\"\"\"Waits for a call with an optional timeout.\n\n    Args:\n        timeout: Optional timeout in seconds\n\n    Raises:\n        AssertionError: If the broker is not started\n\n    Returns:\n        None\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    assert self.event, \"You should start the broker first\"  # nosec B101\n    with anyio.fail_after(timeout):\n        await self.event.wait()\n</code></pre>"},{"location":"api/faststream/cli/docs/app/gen/","title":"gen","text":""},{"location":"api/faststream/cli/docs/app/gen/#faststream.cli.docs.app.gen","title":"faststream.cli.docs.app.gen","text":"<pre><code>gen(\n    app: str = typer.Argument(\n        ...,\n        help=\"[python_module:FastStream] - path to your application\",\n    ),\n    yaml: bool = typer.Option(\n        False,\n        \"--yaml\",\n        is_flag=True,\n        help=\"generate `asyncapi.yaml` schema\",\n    ),\n    out: Optional[str] = typer.Option(\n        None, help=\"output filename\"\n    ),\n) -&gt; None\n</code></pre> <p>Generate project AsyncAPI schema</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/cli/docs/app.py</code> <pre><code>@docs_app.command(name=\"gen\")\ndef gen(\n    app: str = typer.Argument(\n        ...,\n        help=\"[python_module:FastStream] - path to your application\",\n    ),\n    yaml: bool = typer.Option(\n        False,\n        \"--yaml\",\n        is_flag=True,\n        help=\"generate `asyncapi.yaml` schema\",\n    ),\n    out: Optional[str] = typer.Option(\n        None,\n        help=\"output filename\",\n    ),\n) -&gt; None:\n\"\"\"Generate project AsyncAPI schema\"\"\"\n    if \":\" in app:\n        module, app = get_app_path(app)\n        sys.path.insert(0, str(module.parent))\n        app_obj = try_import_app(module, app)\n        raw_schema = get_app_schema(app_obj)\n\n    else:\n        schema_filepath = Path.cwd() / app\n        raw_schema = model_parse(Schema, schema_filepath.read_text())\n\n    if yaml:\n        try:\n            schema = raw_schema.to_yaml()\n        except ImportError as e:  # pragma: no cover\n            typer.echo(INSTALL_YAML, err=True)\n            raise typer.Exit(1) from e\n\n        name = out or \"asyncapi.yaml\"\n\n        with open(name, \"w\") as f:\n            f.write(schema)\n\n    else:\n        schema = raw_schema.to_jsonable()\n        name = out or \"asyncapi.json\"\n\n        with open(name, \"w\") as f:\n            json.dump(schema, f, indent=2)\n\n    typer.echo(f\"Your project AsyncAPI scheme was placed to `{name}`\")\n</code></pre>"},{"location":"api/faststream/cli/docs/app/serve/","title":"serve","text":""},{"location":"api/faststream/cli/docs/app/serve/#faststream.cli.docs.app.serve","title":"faststream.cli.docs.app.serve","text":"<pre><code>serve(\n    app: str = typer.Argument(\n        ...,\n        help=\"[python_module:FastStream] or [asyncapi.yaml/.json] - path to your application or documentation\",\n    ),\n    host: str = typer.Option(\n        \"localhost\", help=\"documentation hosting address\"\n    ),\n    port: int = typer.Option(\n        8000, help=\"documentation hosting port\"\n    ),\n) -&gt; None\n</code></pre> <p>Serve project AsyncAPI schema</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/cli/docs/app.py</code> <pre><code>@docs_app.command(name=\"serve\")\ndef serve(\n    app: str = typer.Argument(\n        ...,\n        help=\"[python_module:FastStream] or [asyncapi.yaml/.json] - path to your application or documentation\",\n    ),\n    host: str = typer.Option(\n        \"localhost\",\n        help=\"documentation hosting address\",\n    ),\n    port: int = typer.Option(\n        8000,\n        help=\"documentation hosting port\",\n    ),\n) -&gt; None:\n\"\"\"Serve project AsyncAPI schema\"\"\"\n    if \":\" in app:\n        module, app = get_app_path(app)\n        sys.path.insert(0, str(module.parent))\n        app_obj = try_import_app(module, app)\n        raw_schema = get_app_schema(app_obj)\n\n    else:\n        schema_filepath = Path.cwd() / app\n        if schema_filepath.suffix == \".json\":\n            data = schema_filepath.read_text()\n\n        elif schema_filepath.suffix == \".yaml\" or schema_filepath.suffix == \".yml\":\n            try:\n                import yaml\n            except ImportError as e:  # pragma: no cover\n                typer.echo(INSTALL_YAML, err=True)\n                raise typer.Exit(1) from e\n\n            with schema_filepath.open(\"r\") as f:\n                schema = yaml.safe_load(f)\n\n            data = json.dumps(schema)\n        else:\n            raise ValueError(\n                f\"Unknown extension given - {app}; Please provide app in format [python_module:FastStream] or [asyncapi.yaml/.json] - path to your application or documentation\"\n            )\n\n        raw_schema = model_parse(Schema, data)\n\n    serve_app(\n        schema=raw_schema,\n        host=host,\n        port=port,\n    )\n</code></pre>"},{"location":"api/faststream/cli/main/main/","title":"main","text":""},{"location":"api/faststream/cli/main/main/#faststream.cli.main.main","title":"faststream.cli.main.main","text":"<pre><code>main(\n    version: Optional[bool] = typer.Option(\n        False,\n        \"-v\",\n        \"--version\",\n        callback=version_callback,\n        is_eager=True,\n        help=\"Show current platform, python and FastStream version\",\n    )\n) -&gt; None\n</code></pre> <p>Generate, run and manage FastStream apps to greater development experience</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/cli/main.py</code> <pre><code>@cli.callback()\ndef main(\n    version: Optional[bool] = typer.Option(\n        False,\n        \"-v\",\n        \"--version\",\n        callback=version_callback,\n        is_eager=True,\n        help=\"Show current platform, python and FastStream version\",\n    )\n) -&gt; None:\n\"\"\"\n    Generate, run and manage FastStream apps to greater development experience\n    \"\"\"\n</code></pre>"},{"location":"api/faststream/cli/main/run/","title":"run","text":""},{"location":"api/faststream/cli/main/run/#faststream.cli.main.run","title":"faststream.cli.main.run","text":"<pre><code>run(\n    ctx: typer.Context,\n    app: str = typer.Argument(\n        ...,\n        help=\"[python_module:FastStream] - path to your application\",\n    ),\n    workers: int = typer.Option(\n        1,\n        show_default=False,\n        help=\"Run [workers] applications with process spawning\",\n    ),\n    log_level: LogLevels = typer.Option(\n        LogLevels.info,\n        case_sensitive=False,\n        show_default=False,\n        help=\"[INFO] default\",\n    ),\n    reload: bool = typer.Option(\n        False,\n        \"--reload\",\n        is_flag=True,\n        help=\"Restart app at directory files changes\",\n    ),\n    app_dir: str = typer.Option(\n        \".\",\n        \"--app-dir\",\n        help=\"Look for APP in the specified directory, by adding this to the PYTHONPATH. Defaults to the current working directory.\",\n    ),\n) -&gt; None\n</code></pre> <p>Run [MODULE:APP] FastStream application</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/cli/main.py</code> <pre><code>@cli.command(\n    context_settings={\"allow_extra_args\": True, \"ignore_unknown_options\": True}\n)\ndef run(\n    ctx: typer.Context,\n    app: str = typer.Argument(\n        ...,\n        help=\"[python_module:FastStream] - path to your application\",\n    ),\n    workers: int = typer.Option(\n        1,\n        show_default=False,\n        help=\"Run [workers] applications with process spawning\",\n    ),\n    log_level: LogLevels = typer.Option(\n        LogLevels.info,\n        case_sensitive=False,\n        show_default=False,\n        help=\"[INFO] default\",\n    ),\n    reload: bool = typer.Option(\n        False,\n        \"--reload\",\n        is_flag=True,\n        help=\"Restart app at directory files changes\",\n    ),\n    app_dir: str = typer.Option(\n        \".\",\n        \"--app-dir\",\n        help=(\n            \"Look for APP in the specified directory, by adding this to the PYTHONPATH.\"\n            \" Defaults to the current working directory.\"\n        ),\n    ),\n) -&gt; None:\n\"\"\"Run [MODULE:APP] FastStream application\"\"\"\n    app, extra = parse_cli_args(app, *ctx.args)\n    casted_log_level = get_log_level(log_level)\n\n    module, app = get_app_path(app)\n\n    if app_dir:\n        sys.path.insert(0, app_dir)\n\n    args = (module, app, extra, casted_log_level)\n\n    if reload and workers &gt; 1:\n        raise ValueError(\"You can't use reload option with multiprocessing\")\n\n    if reload is True:\n        from faststream.cli.supervisors.watchfiles import WatchReloader\n\n        WatchReloader(target=_run, args=args, reload_dirs=(str(module.parent),)).run()\n\n    elif workers &gt; 1:\n        from faststream.cli.supervisors.multiprocess import Multiprocess\n\n        Multiprocess(target=_run, args=(*args, logging.DEBUG), workers=workers).run()\n\n    else:\n        _run(module=module, app=app, extra_options=extra, log_level=casted_log_level)\n</code></pre>"},{"location":"api/faststream/cli/main/version_callback/","title":"version_callback","text":""},{"location":"api/faststream/cli/main/version_callback/#faststream.cli.main.version_callback","title":"faststream.cli.main.version_callback","text":"<pre><code>version_callback(version: bool) -&gt; None\n</code></pre> <p>Callback function for displaying version information.</p> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>bool</code> <p>If True, display version information</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/cli/main.py</code> <pre><code>def version_callback(version: bool) -&gt; None:\n\"\"\"Callback function for displaying version information.\n\n    Args:\n        version: If True, display version information\n\n    Returns:\n        None\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    if version is True:\n        import platform\n\n        typer.echo(\n            \"Running FastStream %s with %s %s on %s\"\n            % (\n                __version__,\n                platform.python_implementation(),\n                platform.python_version(),\n                platform.system(),\n            )\n        )\n\n        raise typer.Exit()\n</code></pre>"},{"location":"api/faststream/cli/supervisors/basereload/BaseReload/","title":"BaseReload","text":""},{"location":"api/faststream/cli/supervisors/basereload/BaseReload/#faststream.cli.supervisors.basereload.BaseReload","title":"faststream.cli.supervisors.basereload.BaseReload","text":"<p>A base class for implementing a reloader process.</p> <p>Attributes:</p> Name Type Description <code>_process</code> <p>The spawned process</p> <code>_target</code> <p>The target callable function</p> <code>_args</code> <p>The arguments to be passed to the target function</p> <code>reload_delay</code> <p>The delay between reloads</p> <code>should_exit</code> <p>A threading event to signal the reloader to exit</p> <code>pid</code> <p>The process ID of the reloader</p> <code>reloader_name</code> <p>The name of the reloader</p> <p>Methods:</p> Name Description <code>__init__</code> <p>DecoratedCallable, args: Tuple[Any, ...], reload_delay: Optional[float] = 0.5) -&gt; None: Initializes the BaseReload object.</p> <code>run</code> <p>Runs the reloader process.</p> <code>startup</code> <p>Performs startup operations for the reloader process.</p> <code>restart</code> <p>Restarts the process.</p> <code>shutdown</code> <p>Shuts down the reloader process.</p> <code>_stop_process</code> <p>Stops the spawned process.</p> <code>_start_process</code> <p>Starts the spawned process.</p> <code>should_restart</code> <p>Determines whether the process should be restarted.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/cli/supervisors/basereload.py</code> <pre><code>class BaseReload:\n\"\"\"A base class for implementing a reloader process.\n\n    Attributes:\n        _process : The spawned process\n        _target : The target callable function\n        _args : The arguments to be passed to the target function\n        reload_delay : The delay between reloads\n        should_exit : A threading event to signal the reloader to exit\n        pid : The process ID of the reloader\n        reloader_name : The name of the reloader\n\n    Methods:\n        __init__(self, target: DecoratedCallable, args: Tuple[Any, ...], reload_delay: Optional[float] = 0.5) -&gt; None:\n            Initializes the BaseReload object.\n\n        run(self) -&gt; None:\n            Runs the reloader process.\n\n        startup(self) -&gt; None:\n            Performs startup operations for the reloader process.\n\n        restart(self) -&gt; None:\n            Restarts the process.\n\n        shutdown(self) -&gt; None:\n            Shuts down the reloader process.\n\n        _stop_process(self) -&gt; None:\n            Stops the spawned process.\n\n        _start_process(self) -&gt; SpawnProcess:\n            Starts the spawned process.\n\n        should_restart(self) -&gt; bool:\n            Determines whether the process should be restarted.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    _process: SpawnProcess\n    _target: DecoratedCallable\n    _args: Tuple[Any, ...]\n\n    reload_delay: Optional[float]\n    should_exit: threading.Event\n    pid: int\n    reloader_name: str = \"\"\n\n    def __init__(\n        self,\n        target: DecoratedCallable,\n        args: Tuple[Any, ...],\n        reload_delay: Optional[float] = 0.5,\n    ) -&gt; None:\n\"\"\"Initialize a class instance.\n\n        Args:\n            target: The target callable object\n            args: Tuple of arguments to be passed to the target callable\n            reload_delay: Optional delay in seconds before reloading the target callable (default is 0.5 seconds)\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        self._target = target\n        self._args = args\n\n        self.should_exit = threading.Event()\n        self.pid = os.getpid()\n        self.reload_delay = reload_delay\n\n        set_exit(lambda *_: self.should_exit.set())\n\n    def run(self) -&gt; None:\n        self.startup()\n        while not self.should_exit.wait(self.reload_delay):\n            if self.should_restart():  # pragma: no branch\n                self.restart()\n        self.shutdown()\n\n    def startup(self) -&gt; None:\n        logger.info(f\"Started reloader process [{self.pid}] using {self.reloader_name}\")\n        self._process = self._start_process()\n\n    def restart(self) -&gt; None:\n        self._stop_process()\n        logger.info(\"Process successfully reloaded\")\n        self._process = self._start_process()\n\n    def shutdown(self) -&gt; None:\n        self._stop_process()\n        logger.info(f\"Stopping reloader process [{self.pid}]\")\n\n    def _stop_process(self) -&gt; None:\n        self._process.terminate()\n        self._process.join()\n\n    def _start_process(self) -&gt; SpawnProcess:\n        process = get_subprocess(target=self._target, args=self._args)\n        process.start()\n        return process\n\n    def should_restart(self) -&gt; bool:\n        raise NotImplementedError(\"Reload strategies should override should_restart()\")\n</code></pre>"},{"location":"api/faststream/cli/supervisors/basereload/BaseReload/#faststream.cli.supervisors.basereload.BaseReload-attributes","title":"Attributes","text":""},{"location":"api/faststream/cli/supervisors/basereload/BaseReload/#faststream.cli.supervisors.basereload.BaseReload.pid","title":"pid  <code>instance-attribute</code>","text":"<pre><code>pid: int = os.getpid()\n</code></pre>"},{"location":"api/faststream/cli/supervisors/basereload/BaseReload/#faststream.cli.supervisors.basereload.BaseReload.reload_delay","title":"reload_delay  <code>instance-attribute</code>","text":"<pre><code>reload_delay: Optional[float] = reload_delay\n</code></pre>"},{"location":"api/faststream/cli/supervisors/basereload/BaseReload/#faststream.cli.supervisors.basereload.BaseReload.reloader_name","title":"reloader_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>reloader_name: str = ''\n</code></pre>"},{"location":"api/faststream/cli/supervisors/basereload/BaseReload/#faststream.cli.supervisors.basereload.BaseReload.should_exit","title":"should_exit  <code>instance-attribute</code>","text":"<pre><code>should_exit: threading.Event = threading.Event()\n</code></pre>"},{"location":"api/faststream/cli/supervisors/basereload/BaseReload/#faststream.cli.supervisors.basereload.BaseReload-functions","title":"Functions","text":""},{"location":"api/faststream/cli/supervisors/basereload/BaseReload/#faststream.cli.supervisors.basereload.BaseReload.__init__","title":"__init__","text":"<pre><code>__init__(\n    target: DecoratedCallable,\n    args: Tuple[Any, ...],\n    reload_delay: Optional[float] = 0.5,\n) -&gt; None\n</code></pre> <p>Initialize a class instance.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>DecoratedCallable</code> <p>The target callable object</p> required <code>args</code> <code>Tuple[Any, ...]</code> <p>Tuple of arguments to be passed to the target callable</p> required <code>reload_delay</code> <code>Optional[float]</code> <p>Optional delay in seconds before reloading the target callable (default is 0.5 seconds)</p> <code>0.5</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/cli/supervisors/basereload.py</code> <pre><code>def __init__(\n    self,\n    target: DecoratedCallable,\n    args: Tuple[Any, ...],\n    reload_delay: Optional[float] = 0.5,\n) -&gt; None:\n\"\"\"Initialize a class instance.\n\n    Args:\n        target: The target callable object\n        args: Tuple of arguments to be passed to the target callable\n        reload_delay: Optional delay in seconds before reloading the target callable (default is 0.5 seconds)\n\n    Returns:\n        None\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    self._target = target\n    self._args = args\n\n    self.should_exit = threading.Event()\n    self.pid = os.getpid()\n    self.reload_delay = reload_delay\n\n    set_exit(lambda *_: self.should_exit.set())\n</code></pre>"},{"location":"api/faststream/cli/supervisors/basereload/BaseReload/#faststream.cli.supervisors.basereload.BaseReload.restart","title":"restart","text":"<pre><code>restart() -&gt; None\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/cli/supervisors/basereload.py</code> <pre><code>def restart(self) -&gt; None:\n    self._stop_process()\n    logger.info(\"Process successfully reloaded\")\n    self._process = self._start_process()\n</code></pre>"},{"location":"api/faststream/cli/supervisors/basereload/BaseReload/#faststream.cli.supervisors.basereload.BaseReload.run","title":"run","text":"<pre><code>run() -&gt; None\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/cli/supervisors/basereload.py</code> <pre><code>def run(self) -&gt; None:\n    self.startup()\n    while not self.should_exit.wait(self.reload_delay):\n        if self.should_restart():  # pragma: no branch\n            self.restart()\n    self.shutdown()\n</code></pre>"},{"location":"api/faststream/cli/supervisors/basereload/BaseReload/#faststream.cli.supervisors.basereload.BaseReload.should_restart","title":"should_restart","text":"<pre><code>should_restart() -&gt; bool\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/cli/supervisors/basereload.py</code> <pre><code>def should_restart(self) -&gt; bool:\n    raise NotImplementedError(\"Reload strategies should override should_restart()\")\n</code></pre>"},{"location":"api/faststream/cli/supervisors/basereload/BaseReload/#faststream.cli.supervisors.basereload.BaseReload.shutdown","title":"shutdown","text":"<pre><code>shutdown() -&gt; None\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/cli/supervisors/basereload.py</code> <pre><code>def shutdown(self) -&gt; None:\n    self._stop_process()\n    logger.info(f\"Stopping reloader process [{self.pid}]\")\n</code></pre>"},{"location":"api/faststream/cli/supervisors/basereload/BaseReload/#faststream.cli.supervisors.basereload.BaseReload.startup","title":"startup","text":"<pre><code>startup() -&gt; None\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/cli/supervisors/basereload.py</code> <pre><code>def startup(self) -&gt; None:\n    logger.info(f\"Started reloader process [{self.pid}] using {self.reloader_name}\")\n    self._process = self._start_process()\n</code></pre>"},{"location":"api/faststream/cli/supervisors/multiprocess/Multiprocess/","title":"Multiprocess","text":""},{"location":"api/faststream/cli/supervisors/multiprocess/Multiprocess/#faststream.cli.supervisors.multiprocess.Multiprocess","title":"faststream.cli.supervisors.multiprocess.Multiprocess","text":"<p>             Bases: <code>BaseReload</code></p> <p>A class to represent a multiprocess.</p> <p>Attributes:</p> Name Type Description <code>target</code> <p>the target function to be executed by each process</p> <code>args</code> <p>arguments to be passed to the target function</p> <code>workers</code> <p>number of worker processes</p> <p>Methods:</p> Name Description <code>startup </code> <p>starts the parent process and creates worker processes</p> <code>shutdown </code> <p>terminates and joins all worker processes, and stops the parent process</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/cli/supervisors/multiprocess.py</code> <pre><code>class Multiprocess(BaseReload):\n\"\"\"A class to represent a multiprocess.\n\n    Attributes:\n        target : the target function to be executed by each process\n        args : arguments to be passed to the target function\n        workers : number of worker processes\n\n    Methods:\n        startup : starts the parent process and creates worker processes\n        shutdown : terminates and joins all worker processes, and stops the parent process\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    def __init__(\n        self,\n        target: DecoratedCallable,\n        args: Tuple[Any, ...],\n        workers: int,\n    ) -&gt; None:\n\"\"\"Initialize a new instance of the class.\n\n        Args:\n            target: The target callable object to be executed.\n            args: The arguments to be passed to the target callable.\n            workers: The number of workers to be used.\n\n        Returns:\n            None.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        super().__init__(target, args, None)\n\n        self.workers = workers\n        self.processes: List[SpawnProcess] = []\n\n    def startup(self) -&gt; None:\n        logger.info(f\"Started parent process [{self.pid}]\")\n\n        for _ in range(self.workers):\n            process = self._start_process()\n            logger.info(f\"Started child process [{process.pid}]\")\n            self.processes.append(process)\n\n    def shutdown(self) -&gt; None:\n        for process in self.processes:\n            process.terminate()\n            logger.info(f\"Stopping child process [{process.pid}]\")\n            process.join()\n\n        logger.info(f\"Stopping parent process [{self.pid}]\")\n</code></pre>"},{"location":"api/faststream/cli/supervisors/multiprocess/Multiprocess/#faststream.cli.supervisors.multiprocess.Multiprocess-attributes","title":"Attributes","text":""},{"location":"api/faststream/cli/supervisors/multiprocess/Multiprocess/#faststream.cli.supervisors.multiprocess.Multiprocess.processes","title":"processes  <code>instance-attribute</code>","text":"<pre><code>processes: List[SpawnProcess] = []\n</code></pre>"},{"location":"api/faststream/cli/supervisors/multiprocess/Multiprocess/#faststream.cli.supervisors.multiprocess.Multiprocess.workers","title":"workers  <code>instance-attribute</code>","text":"<pre><code>workers = workers\n</code></pre>"},{"location":"api/faststream/cli/supervisors/multiprocess/Multiprocess/#faststream.cli.supervisors.multiprocess.Multiprocess-functions","title":"Functions","text":""},{"location":"api/faststream/cli/supervisors/multiprocess/Multiprocess/#faststream.cli.supervisors.multiprocess.Multiprocess.__init__","title":"__init__","text":"<pre><code>__init__(\n    target: DecoratedCallable,\n    args: Tuple[Any, ...],\n    workers: int,\n) -&gt; None\n</code></pre> <p>Initialize a new instance of the class.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>DecoratedCallable</code> <p>The target callable object to be executed.</p> required <code>args</code> <code>Tuple[Any, ...]</code> <p>The arguments to be passed to the target callable.</p> required <code>workers</code> <code>int</code> <p>The number of workers to be used.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/cli/supervisors/multiprocess.py</code> <pre><code>def __init__(\n    self,\n    target: DecoratedCallable,\n    args: Tuple[Any, ...],\n    workers: int,\n) -&gt; None:\n\"\"\"Initialize a new instance of the class.\n\n    Args:\n        target: The target callable object to be executed.\n        args: The arguments to be passed to the target callable.\n        workers: The number of workers to be used.\n\n    Returns:\n        None.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    super().__init__(target, args, None)\n\n    self.workers = workers\n    self.processes: List[SpawnProcess] = []\n</code></pre>"},{"location":"api/faststream/cli/supervisors/multiprocess/Multiprocess/#faststream.cli.supervisors.multiprocess.Multiprocess.shutdown","title":"shutdown","text":"<pre><code>shutdown() -&gt; None\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/cli/supervisors/multiprocess.py</code> <pre><code>def shutdown(self) -&gt; None:\n    for process in self.processes:\n        process.terminate()\n        logger.info(f\"Stopping child process [{process.pid}]\")\n        process.join()\n\n    logger.info(f\"Stopping parent process [{self.pid}]\")\n</code></pre>"},{"location":"api/faststream/cli/supervisors/multiprocess/Multiprocess/#faststream.cli.supervisors.multiprocess.Multiprocess.startup","title":"startup","text":"<pre><code>startup() -&gt; None\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/cli/supervisors/multiprocess.py</code> <pre><code>def startup(self) -&gt; None:\n    logger.info(f\"Started parent process [{self.pid}]\")\n\n    for _ in range(self.workers):\n        process = self._start_process()\n        logger.info(f\"Started child process [{process.pid}]\")\n        self.processes.append(process)\n</code></pre>"},{"location":"api/faststream/cli/supervisors/utils/get_subprocess/","title":"get_subprocess","text":""},{"location":"api/faststream/cli/supervisors/utils/get_subprocess/#faststream.cli.supervisors.utils.get_subprocess","title":"faststream.cli.supervisors.utils.get_subprocess","text":"<pre><code>get_subprocess(\n    target: DecoratedCallableNone, args: Any\n) -&gt; SpawnProcess\n</code></pre> <p>Spawn a subprocess.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>DecoratedCallableNone</code> <p>The target function to be executed in the subprocess.</p> required <code>args</code> <code>Any</code> <p>The arguments to be passed to the target function.</p> required <p>Returns:</p> Type Description <code>SpawnProcess</code> <p>The spawned subprocess.</p> <p>Raises:</p> Type Description <code>OSError</code> <p>If there is an error getting the file descriptor of sys.stdin.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/cli/supervisors/utils.py</code> <pre><code>def get_subprocess(target: DecoratedCallableNone, args: Any) -&gt; SpawnProcess:\n\"\"\"Spawn a subprocess.\n\n    Args:\n        target: The target function to be executed in the subprocess.\n        args: The arguments to be passed to the target function.\n\n    Returns:\n        The spawned subprocess.\n\n    Raises:\n        OSError: If there is an error getting the file descriptor of sys.stdin.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    stdin_fileno: Optional[int]\n    try:\n        stdin_fileno = sys.stdin.fileno()\n    except OSError:\n        stdin_fileno = None\n\n    return spawn.Process(\n        target=subprocess_started,\n        args=args,\n        kwargs={\"t\": target, \"stdin_fileno\": stdin_fileno},\n    )\n</code></pre>"},{"location":"api/faststream/cli/supervisors/utils/set_exit/","title":"set_exit","text":""},{"location":"api/faststream/cli/supervisors/utils/set_exit/#faststream.cli.supervisors.utils.set_exit","title":"faststream.cli.supervisors.utils.set_exit","text":"<pre><code>set_exit(\n    func: Callable[[int, Optional[FrameType]], Any]\n) -&gt; None\n</code></pre> <p>Set exit handler for signals.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[int, Optional[FrameType]], Any]</code> <p>A callable object that takes an integer and an optional frame type as arguments and returns any value.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/cli/supervisors/utils.py</code> <pre><code>def set_exit(func: Callable[[int, Optional[FrameType]], Any]) -&gt; None:\n\"\"\"Set exit handler for signals.\n\n    Args:\n        func: A callable object that takes an integer and an optional frame type as arguments and returns any value.\n\n    Returns:\n        None\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    for sig in HANDLED_SIGNALS:\n        signal.signal(sig, func)\n</code></pre>"},{"location":"api/faststream/cli/supervisors/utils/subprocess_started/","title":"subprocess_started","text":""},{"location":"api/faststream/cli/supervisors/utils/subprocess_started/#faststream.cli.supervisors.utils.subprocess_started","title":"faststream.cli.supervisors.utils.subprocess_started","text":"<pre><code>subprocess_started(\n    *args: Any,\n    t: DecoratedCallableNone,\n    stdin_fileno: Optional[int]\n) -&gt; None\n</code></pre> <p>Start a subprocess.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Any</code> <p>Arguments to be passed to the subprocess.</p> <code>()</code> <code>t</code> <code>DecoratedCallableNone</code> <p>The decorated callable function.</p> required <code>stdin_fileno</code> <code>Optional[int]</code> <p>File descriptor for the standard input of the subprocess.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/cli/supervisors/utils.py</code> <pre><code>def subprocess_started(\n    *args: Any,\n    t: DecoratedCallableNone,\n    stdin_fileno: Optional[int],\n) -&gt; None:\n\"\"\"Start a subprocess.\n\n    Args:\n        *args: Arguments to be passed to the subprocess.\n        t: The decorated callable function.\n        stdin_fileno: File descriptor for the standard input of the subprocess.\n\n    Returns:\n        None\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    if stdin_fileno is not None:  # pragma: no cover\n        sys.stdin = os.fdopen(stdin_fileno)\n    t(*args)\n</code></pre>"},{"location":"api/faststream/cli/supervisors/watchfiles/ExtendedFilter/","title":"ExtendedFilter","text":""},{"location":"api/faststream/cli/supervisors/watchfiles/ExtendedFilter/#faststream.cli.supervisors.watchfiles.ExtendedFilter","title":"faststream.cli.supervisors.watchfiles.ExtendedFilter","text":"<p>             Bases: <code>PythonFilter</code></p> <p>A class that extends the <code>watchfiles.PythonFilter</code> class.</p> <p>Attributes:</p> Name Type Description <code>ignore_dirs</code> <p>Tuple of directories to ignore</p> <p>Methods:</p> Name Description <code>__init__ </code> <p>Initializes the <code>ExtendedFilter</code> object Args:     ignore_paths : Optional sequence of paths to ignore     extra_extensions : Sequence of extra extensions to include</p> <p>Returns:     None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/cli/supervisors/watchfiles.py</code> <pre><code>class ExtendedFilter(watchfiles.PythonFilter):\n\"\"\"A class that extends the `watchfiles.PythonFilter` class.\n\n    Attributes:\n        ignore_dirs : Tuple of directories to ignore\n\n    Methods:\n        __init__ : Initializes the `ExtendedFilter` object\n            Args:\n                ignore_paths : Optional sequence of paths to ignore\n                extra_extensions : Sequence of extra extensions to include\n\n            Returns:\n                None\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    ignore_dirs: Tuple[str, ...]\n\n    def __init__(\n        self,\n        *,\n        ignore_paths: Optional[Sequence[Union[str, Path]]] = None,\n        extra_extensions: Sequence[str] = (),\n    ) -&gt; None:\n\"\"\"Initialize the class.\n\n        Args:\n            ignore_paths: Optional sequence of paths to ignore.\n            extra_extensions: Sequence of extra extensions.\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        super().__init__(ignore_paths=ignore_paths, extra_extensions=extra_extensions)\n        self.extensions = self.extensions + (\".env\", \".yaml\")\n        self.ignore_dirs = self.ignore_dirs + (\n            \"venv\",\n            \"env\",\n            \".github\",\n            \".mypy_cache\",\n            \".pytest_cache\",\n            \".ruff_cache\",\n        )\n</code></pre>"},{"location":"api/faststream/cli/supervisors/watchfiles/ExtendedFilter/#faststream.cli.supervisors.watchfiles.ExtendedFilter-attributes","title":"Attributes","text":""},{"location":"api/faststream/cli/supervisors/watchfiles/ExtendedFilter/#faststream.cli.supervisors.watchfiles.ExtendedFilter.extensions","title":"extensions  <code>instance-attribute</code>","text":"<pre><code>extensions = self.extensions + ('.env', '.yaml')\n</code></pre>"},{"location":"api/faststream/cli/supervisors/watchfiles/ExtendedFilter/#faststream.cli.supervisors.watchfiles.ExtendedFilter.ignore_dirs","title":"ignore_dirs  <code>instance-attribute</code>","text":"<pre><code>ignore_dirs: Tuple[str, ...] = self.ignore_dirs + (\n    \"venv\",\n    \"env\",\n    \".github\",\n    \".mypy_cache\",\n    \".pytest_cache\",\n    \".ruff_cache\",\n)\n</code></pre>"},{"location":"api/faststream/cli/supervisors/watchfiles/ExtendedFilter/#faststream.cli.supervisors.watchfiles.ExtendedFilter-functions","title":"Functions","text":""},{"location":"api/faststream/cli/supervisors/watchfiles/ExtendedFilter/#faststream.cli.supervisors.watchfiles.ExtendedFilter.__init__","title":"__init__","text":"<pre><code>__init__(\n    *,\n    ignore_paths: Optional[\n        Sequence[Union[str, Path]]\n    ] = None,\n    extra_extensions: Sequence[str] = ()\n) -&gt; None\n</code></pre> <p>Initialize the class.</p> <p>Parameters:</p> Name Type Description Default <code>ignore_paths</code> <code>Optional[Sequence[Union[str, Path]]]</code> <p>Optional sequence of paths to ignore.</p> <code>None</code> <code>extra_extensions</code> <code>Sequence[str]</code> <p>Sequence of extra extensions.</p> <code>()</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/cli/supervisors/watchfiles.py</code> <pre><code>def __init__(\n    self,\n    *,\n    ignore_paths: Optional[Sequence[Union[str, Path]]] = None,\n    extra_extensions: Sequence[str] = (),\n) -&gt; None:\n\"\"\"Initialize the class.\n\n    Args:\n        ignore_paths: Optional sequence of paths to ignore.\n        extra_extensions: Sequence of extra extensions.\n\n    Returns:\n        None\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    super().__init__(ignore_paths=ignore_paths, extra_extensions=extra_extensions)\n    self.extensions = self.extensions + (\".env\", \".yaml\")\n    self.ignore_dirs = self.ignore_dirs + (\n        \"venv\",\n        \"env\",\n        \".github\",\n        \".mypy_cache\",\n        \".pytest_cache\",\n        \".ruff_cache\",\n    )\n</code></pre>"},{"location":"api/faststream/cli/supervisors/watchfiles/WatchReloader/","title":"WatchReloader","text":""},{"location":"api/faststream/cli/supervisors/watchfiles/WatchReloader/#faststream.cli.supervisors.watchfiles.WatchReloader","title":"faststream.cli.supervisors.watchfiles.WatchReloader","text":"<p>             Bases: <code>BaseReload</code></p> <p>A class to reload a target function when files in specified directories change.</p> <p>Attributes:</p> Name Type Description <code>target</code> <p>the function to be reloaded</p> <code>args</code> <p>arguments to be passed to the target function</p> <code>reload_dirs</code> <p>directories to watch for file changes</p> <code>reload_delay</code> <p>delay in seconds between each check for file changes</p> <p>Methods:</p> Name Description <code>should_restart</code> <p>Checks if any files in the watched directories have changed and returns True if a change is detected, False otherwise.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/cli/supervisors/watchfiles.py</code> <pre><code>class WatchReloader(BaseReload):\n\"\"\"A class to reload a target function when files in specified directories change.\n\n    Attributes:\n        target : the function to be reloaded\n        args : arguments to be passed to the target function\n        reload_dirs : directories to watch for file changes\n        reload_delay : delay in seconds between each check for file changes\n\n    Methods:\n        should_restart() -&gt; bool: Checks if any files in the watched directories have changed and returns True if a change is detected, False otherwise.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    def __init__(\n        self,\n        target: DecoratedCallable,\n        args: Tuple[Any, ...],\n        reload_dirs: Sequence[Union[Path, str]],\n        reload_delay: float = 0.3,\n    ) -&gt; None:\n\"\"\"Initialize a WatchFilesReloader object.\n\n        Args:\n            target: The target callable to be executed.\n            args: The arguments to be passed to the target callable.\n            reload_dirs: A sequence of directories to watch for changes.\n            reload_delay: The delay in seconds between checking for changes. Default is 0.3.\n\n        Returns:\n            None.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        super().__init__(target, args, reload_delay)\n        self.reloader_name = \"WatchFiles\"\n        self.watcher = watchfiles.watch(\n            *reload_dirs,\n            step=int(reload_delay * 1000),\n            watch_filter=ExtendedFilter(),\n            stop_event=self.should_exit,\n            yield_on_timeout=True,\n        )\n\n    def should_restart(self) -&gt; bool:\n        for changes in self.watcher:  # pragma: no branch\n            if changes:  # pragma: no branch\n                unique_paths = {Path(c[1]).name for c in changes}\n                message = \"WatchReloader detected file change in '%s'. Reloading...\"\n                logger.info(message % tuple(unique_paths))\n                return True\n        return False  # pragma: no cover\n</code></pre>"},{"location":"api/faststream/cli/supervisors/watchfiles/WatchReloader/#faststream.cli.supervisors.watchfiles.WatchReloader-attributes","title":"Attributes","text":""},{"location":"api/faststream/cli/supervisors/watchfiles/WatchReloader/#faststream.cli.supervisors.watchfiles.WatchReloader.reloader_name","title":"reloader_name  <code>instance-attribute</code>","text":"<pre><code>reloader_name = 'WatchFiles'\n</code></pre>"},{"location":"api/faststream/cli/supervisors/watchfiles/WatchReloader/#faststream.cli.supervisors.watchfiles.WatchReloader.watcher","title":"watcher  <code>instance-attribute</code>","text":"<pre><code>watcher = watchfiles.watch(\n    *reload_dirs,\n    step=int(reload_delay * 1000),\n    watch_filter=ExtendedFilter(),\n    stop_event=self.should_exit,\n    yield_on_timeout=True\n)\n</code></pre>"},{"location":"api/faststream/cli/supervisors/watchfiles/WatchReloader/#faststream.cli.supervisors.watchfiles.WatchReloader-functions","title":"Functions","text":""},{"location":"api/faststream/cli/supervisors/watchfiles/WatchReloader/#faststream.cli.supervisors.watchfiles.WatchReloader.__init__","title":"__init__","text":"<pre><code>__init__(\n    target: DecoratedCallable,\n    args: Tuple[Any, ...],\n    reload_dirs: Sequence[Union[Path, str]],\n    reload_delay: float = 0.3,\n) -&gt; None\n</code></pre> <p>Initialize a WatchFilesReloader object.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>DecoratedCallable</code> <p>The target callable to be executed.</p> required <code>args</code> <code>Tuple[Any, ...]</code> <p>The arguments to be passed to the target callable.</p> required <code>reload_dirs</code> <code>Sequence[Union[Path, str]]</code> <p>A sequence of directories to watch for changes.</p> required <code>reload_delay</code> <code>float</code> <p>The delay in seconds between checking for changes. Default is 0.3.</p> <code>0.3</code> <p>Returns:</p> Type Description <code>None</code> <p>None.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/cli/supervisors/watchfiles.py</code> <pre><code>def __init__(\n    self,\n    target: DecoratedCallable,\n    args: Tuple[Any, ...],\n    reload_dirs: Sequence[Union[Path, str]],\n    reload_delay: float = 0.3,\n) -&gt; None:\n\"\"\"Initialize a WatchFilesReloader object.\n\n    Args:\n        target: The target callable to be executed.\n        args: The arguments to be passed to the target callable.\n        reload_dirs: A sequence of directories to watch for changes.\n        reload_delay: The delay in seconds between checking for changes. Default is 0.3.\n\n    Returns:\n        None.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    super().__init__(target, args, reload_delay)\n    self.reloader_name = \"WatchFiles\"\n    self.watcher = watchfiles.watch(\n        *reload_dirs,\n        step=int(reload_delay * 1000),\n        watch_filter=ExtendedFilter(),\n        stop_event=self.should_exit,\n        yield_on_timeout=True,\n    )\n</code></pre>"},{"location":"api/faststream/cli/supervisors/watchfiles/WatchReloader/#faststream.cli.supervisors.watchfiles.WatchReloader.should_restart","title":"should_restart","text":"<pre><code>should_restart() -&gt; bool\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/cli/supervisors/watchfiles.py</code> <pre><code>def should_restart(self) -&gt; bool:\n    for changes in self.watcher:  # pragma: no branch\n        if changes:  # pragma: no branch\n            unique_paths = {Path(c[1]).name for c in changes}\n            message = \"WatchReloader detected file change in '%s'. Reloading...\"\n            logger.info(message % tuple(unique_paths))\n            return True\n    return False  # pragma: no cover\n</code></pre>"},{"location":"api/faststream/cli/utils/imports/get_app_path/","title":"get_app_path","text":""},{"location":"api/faststream/cli/utils/imports/get_app_path/#faststream.cli.utils.imports.get_app_path","title":"faststream.cli.utils.imports.get_app_path","text":"<pre><code>get_app_path(app: str) -&gt; Tuple[Path, str]\n</code></pre> <p>Get the application path.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>str</code> <p>The name of the application in the format \"module:app_name\".</p> required <p>Returns:</p> Type Description <code>Tuple[Path, str]</code> <p>Tuple[Path, str]: A tuple containing the path to the module and the name of the application.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the given app is not in the format \"module:app_name\".</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/cli/utils/imports.py</code> <pre><code>def get_app_path(app: str) -&gt; Tuple[Path, str]:\n\"\"\"Get the application path.\n\n    Args:\n        app (str): The name of the application in the format \"module:app_name\".\n\n    Returns:\n        Tuple[Path, str]: A tuple containing the path to the module and the name of the application.\n\n    Raises:\n        ValueError: If the given app is not in the format \"module:app_name\".\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    if \":\" not in app:\n        raise ValueError(f\"{app} is not a FastStream\")\n\n    module, app_name = app.split(\":\", 2)\n\n    mod_path = Path.cwd()\n    for i in module.split(\".\"):\n        mod_path = mod_path / i\n\n    return mod_path, app_name\n</code></pre>"},{"location":"api/faststream/cli/utils/imports/import_object/","title":"import_object","text":""},{"location":"api/faststream/cli/utils/imports/import_object/#faststream.cli.utils.imports.import_object","title":"faststream.cli.utils.imports.import_object","text":"<pre><code>import_object(module: Path, app: str) -&gt; object\n</code></pre> <p>Import an object from a module.</p> <p>Parameters:</p> Name Type Description Default <code>module</code> <code>Path</code> <p>The path to the module file.</p> required <code>app</code> <code>str</code> <p>The name of the object to import.</p> required <p>Returns:</p> Type Description <code>object</code> <p>The imported object.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the module file is not found.</p> <code>ValueError</code> <p>If the module has no loader.</p> <code>AttributeError</code> <p>If the object is not found in the module.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/cli/utils/imports.py</code> <pre><code>def import_object(module: Path, app: str) -&gt; object:\n\"\"\"Import an object from a module.\n\n    Args:\n        module: The path to the module file.\n        app: The name of the object to import.\n\n    Returns:\n        The imported object.\n\n    Raises:\n        FileNotFoundError: If the module file is not found.\n        ValueError: If the module has no loader.\n        AttributeError: If the object is not found in the module.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    spec = spec_from_file_location(\n        \"mode\",\n        f\"{module}.py\",\n        submodule_search_locations=[str(module.parent.absolute())],\n    )\n\n    if spec is None:  # pragma: no cover\n        raise FileNotFoundError(module)\n\n    mod = module_from_spec(spec)\n    loader = spec.loader\n\n    if loader is None:  # pragma: no cover\n        raise ValueError(f\"{spec} has no loader\")\n\n    loader.exec_module(mod)\n\n    try:\n        obj = getattr(mod, app)\n    except AttributeError as e:\n        raise FileNotFoundError(module) from e\n\n    return obj\n</code></pre>"},{"location":"api/faststream/cli/utils/imports/try_import_app/","title":"try_import_app","text":""},{"location":"api/faststream/cli/utils/imports/try_import_app/#faststream.cli.utils.imports.try_import_app","title":"faststream.cli.utils.imports.try_import_app","text":"<pre><code>try_import_app(module: Path, app: str) -&gt; FastStream\n</code></pre> <p>Tries to import a FastStream app from a module.</p> <p>Parameters:</p> Name Type Description Default <code>module</code> <code>Path</code> <p>Path to the module containing the app.</p> required <code>app</code> <code>str</code> <p>Name of the FastStream app.</p> required <p>Returns:</p> Type Description <code>FastStream</code> <p>The imported FastStream app object.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the module file is not found.</p> <code>BadParameter</code> <p>If the module or app name is not provided correctly.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/cli/utils/imports.py</code> <pre><code>def try_import_app(module: Path, app: str) -&gt; FastStream:\n\"\"\"Tries to import a FastStream app from a module.\n\n    Args:\n        module: Path to the module containing the app.\n        app: Name of the FastStream app.\n\n    Returns:\n        The imported FastStream app object.\n\n    Raises:\n        FileNotFoundError: If the module file is not found.\n        typer.BadParameter: If the module or app name is not provided correctly.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    try:\n        app_object = import_object(module, app)\n\n    except FileNotFoundError as e:\n        typer.echo(e, err=True)\n        raise typer.BadParameter(\n            \"Please, input module like [python_file:faststream_app_name]\"\n        ) from e\n\n    else:\n        return app_object  # type: ignore\n</code></pre>"},{"location":"api/faststream/cli/utils/logs/LogLevels/","title":"LogLevels","text":""},{"location":"api/faststream/cli/utils/logs/LogLevels/#faststream.cli.utils.logs.LogLevels","title":"faststream.cli.utils.logs.LogLevels","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p> <p>A class to represent log levels.</p> <p>Attributes:</p> Name Type Description <code>critical</code> <p>critical log level</p> <code>error</code> <p>error log level</p> <code>warning</code> <p>warning log level</p> <code>info</code> <p>info log level</p> <code>debug</code> <p>debug log level</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/cli/utils/logs.py</code> <pre><code>class LogLevels(str, Enum):\n\"\"\"A class to represent log levels.\n\n    Attributes:\n        critical : critical log level\n        error : error log level\n        warning : warning log level\n        info : info log level\n        debug : debug log level\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    critical = \"critical\"\n    error = \"error\"\n    warning = \"warning\"\n    info = \"info\"\n    debug = \"debug\"\n</code></pre>"},{"location":"api/faststream/cli/utils/logs/LogLevels/#faststream.cli.utils.logs.LogLevels-attributes","title":"Attributes","text":""},{"location":"api/faststream/cli/utils/logs/LogLevels/#faststream.cli.utils.logs.LogLevels.critical","title":"critical  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>critical = 'critical'\n</code></pre>"},{"location":"api/faststream/cli/utils/logs/LogLevels/#faststream.cli.utils.logs.LogLevels.debug","title":"debug  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>debug = 'debug'\n</code></pre>"},{"location":"api/faststream/cli/utils/logs/LogLevels/#faststream.cli.utils.logs.LogLevels.error","title":"error  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>error = 'error'\n</code></pre>"},{"location":"api/faststream/cli/utils/logs/LogLevels/#faststream.cli.utils.logs.LogLevels.info","title":"info  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>info = 'info'\n</code></pre>"},{"location":"api/faststream/cli/utils/logs/LogLevels/#faststream.cli.utils.logs.LogLevels.warning","title":"warning  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>warning = 'warning'\n</code></pre>"},{"location":"api/faststream/cli/utils/logs/get_log_level/","title":"get_log_level","text":""},{"location":"api/faststream/cli/utils/logs/get_log_level/#faststream.cli.utils.logs.get_log_level","title":"faststream.cli.utils.logs.get_log_level","text":"<pre><code>get_log_level(level: Union[LogLevels, str, int]) -&gt; int\n</code></pre> <p>Get the log level.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>Union[LogLevels, str, int]</code> <p>The log level to get. Can be an integer, a LogLevels enum value, or a string.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The log level as an integer.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/cli/utils/logs.py</code> <pre><code>def get_log_level(level: Union[LogLevels, str, int]) -&gt; int:\n\"\"\"Get the log level.\n\n    Args:\n        level: The log level to get. Can be an integer, a LogLevels enum value, or a string.\n\n    Returns:\n        The log level as an integer.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    if isinstance(level, int):\n        return level\n\n    if isinstance(level, LogLevels):\n        return LOG_LEVELS[level.value]\n\n    if isinstance(level, str):  # pragma: no branch\n        return LOG_LEVELS[level.lower()]\n</code></pre>"},{"location":"api/faststream/cli/utils/logs/set_log_level/","title":"set_log_level","text":""},{"location":"api/faststream/cli/utils/logs/set_log_level/#faststream.cli.utils.logs.set_log_level","title":"faststream.cli.utils.logs.set_log_level","text":"<pre><code>set_log_level(level: int, app: FastStream) -&gt; None\n</code></pre> <p>Sets the log level for an application.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>int</code> <p>The log level to set.</p> required <code>app</code> <code>FastStream</code> <p>The application object.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/cli/utils/logs.py</code> <pre><code>def set_log_level(level: int, app: FastStream) -&gt; None:\n\"\"\"Sets the log level for an application.\n\n    Args:\n        level (int): The log level to set.\n        app (FastStream): The application object.\n\n    Returns:\n        None\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    if app.logger:\n        app.logger.setLevel(level)\n\n    broker_logger: Optional[logging.Logger] = getattr(app.broker, \"logger\", None)\n    if broker_logger is not None:\n        broker_logger.setLevel(level)\n</code></pre>"},{"location":"api/faststream/cli/utils/parser/parse_cli_args/","title":"parse_cli_args","text":""},{"location":"api/faststream/cli/utils/parser/parse_cli_args/#faststream.cli.utils.parser.parse_cli_args","title":"faststream.cli.utils.parser.parse_cli_args","text":"<pre><code>parse_cli_args(\n    *args: str,\n) -&gt; Tuple[str, Dict[str, SettingField]]\n</code></pre> <p>Parses command line arguments.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>str</code> <p>Command line arguments as strings.</p> <code>()</code> <p>Returns:</p> Type Description <code>Tuple[str, Dict[str, SettingField]]</code> <p>A tuple containing the application name and a dictionary of additional keyword arguments.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/cli/utils/parser.py</code> <pre><code>def parse_cli_args(*args: str) -&gt; Tuple[str, Dict[str, SettingField]]:\n\"\"\"Parses command line arguments.\n\n    Args:\n        *args: Command line arguments as strings.\n\n    Returns:\n        A tuple containing the application name and a dictionary of additional keyword arguments.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    extra_kwargs: Dict[str, SettingField] = {}\n\n    k: str = \"\"\n    v: SettingField\n\n    field_args: List[str] = []\n    app = \"\"\n    for item in reduce(\n        lambda acc, x: acc + x.split(\"=\"),  # type: ignore\n        args,\n        [],\n    ) + [\"-\"]:\n        if \":\" in item:\n            app = item\n\n        else:\n            if \"-\" in item:\n                if k:\n                    k = k.strip().lstrip(\"-\").replace(\"-\", \"_\")\n\n                    if len(field_args) == 0:\n                        v = not k.startswith(\"no_\")\n                    elif len(field_args) == 1:\n                        v = field_args[0]\n                    else:\n                        v = field_args\n\n                    extra_kwargs[remove_prefix(k, \"no_\")] = v\n                    field_args = []\n\n                k = item\n\n            else:\n                field_args.append(item)\n\n    return app, extra_kwargs\n</code></pre>"},{"location":"api/faststream/cli/utils/parser/remove_prefix/","title":"remove_prefix","text":""},{"location":"api/faststream/cli/utils/parser/remove_prefix/#faststream.cli.utils.parser.remove_prefix","title":"faststream.cli.utils.parser.remove_prefix","text":"<pre><code>remove_prefix(text: str, prefix: str) -&gt; str\n</code></pre> <p>Removes a prefix from a given text.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The text from which the prefix will be removed.</p> required <code>prefix</code> <code>str</code> <p>The prefix to be removed from the text.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The text with the prefix removed. If the text does not start with the prefix, the original text is returned.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/cli/utils/parser.py</code> <pre><code>def remove_prefix(text: str, prefix: str) -&gt; str:\n\"\"\"Removes a prefix from a given text.\n\n    Args:\n        text (str): The text from which the prefix will be removed.\n        prefix (str): The prefix to be removed from the text.\n\n    Returns:\n        str: The text with the prefix removed. If the text does not start with the prefix, the original text is returned.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    if text.startswith(prefix):\n        return text[len(prefix) :]\n    return text\n</code></pre>"},{"location":"api/faststream/constants/ContentTypes/","title":"ContentTypes","text":""},{"location":"api/faststream/constants/ContentTypes/#faststream.constants.ContentTypes","title":"faststream.constants.ContentTypes","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p> <p>A class to represent content types.</p> <p>Attributes:</p> Name Type Description <code>text</code> <p>content type for plain text</p> <code>json</code> <p>content type for JSON data</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/constants.py</code> <pre><code>class ContentTypes(str, Enum):\n\"\"\"A class to represent content types.\n\n    Attributes:\n        text : content type for plain text\n        json : content type for JSON data\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    text = \"text/plain\"\n    json = \"application/json\"\n</code></pre>"},{"location":"api/faststream/constants/ContentTypes/#faststream.constants.ContentTypes-attributes","title":"Attributes","text":""},{"location":"api/faststream/constants/ContentTypes/#faststream.constants.ContentTypes.json","title":"json  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>json = 'application/json'\n</code></pre>"},{"location":"api/faststream/constants/ContentTypes/#faststream.constants.ContentTypes.text","title":"text  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>text = 'text/plain'\n</code></pre>"},{"location":"api/faststream/exceptions/AckMessage/","title":"AckMessage","text":""},{"location":"api/faststream/exceptions/AckMessage/#faststream.exceptions.AckMessage","title":"faststream.exceptions.AckMessage","text":"<p>             Bases: <code>HandlerException</code></p> <p>Raise it to <code>ack</code> a message immediately</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/exceptions.py</code> <pre><code>class AckMessage(HandlerException):\n\"\"\"Raise it to `ack` a message immediately\"\"\"\n</code></pre>"},{"location":"api/faststream/exceptions/HandlerException/","title":"HandlerException","text":""},{"location":"api/faststream/exceptions/HandlerException/#faststream.exceptions.HandlerException","title":"faststream.exceptions.HandlerException","text":"<p>             Bases: <code>Exception</code></p> <p>Base Handler Exception</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/exceptions.py</code> <pre><code>class HandlerException(Exception):\n\"\"\"Base Handler Exception\"\"\"\n</code></pre>"},{"location":"api/faststream/exceptions/NackMessage/","title":"NackMessage","text":""},{"location":"api/faststream/exceptions/NackMessage/#faststream.exceptions.NackMessage","title":"faststream.exceptions.NackMessage","text":"<p>             Bases: <code>HandlerException</code></p> <p>Raise it to <code>nack</code> a message immediately</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/exceptions.py</code> <pre><code>class NackMessage(HandlerException):\n\"\"\"Raise it to `nack` a message immediately\"\"\"\n</code></pre>"},{"location":"api/faststream/exceptions/RejectMessage/","title":"RejectMessage","text":""},{"location":"api/faststream/exceptions/RejectMessage/#faststream.exceptions.RejectMessage","title":"faststream.exceptions.RejectMessage","text":"<p>             Bases: <code>HandlerException</code></p> <p>Raise it to <code>reject</code> a message immediately</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/exceptions.py</code> <pre><code>class RejectMessage(HandlerException):\n\"\"\"Raise it to `reject` a message immediately\"\"\"\n</code></pre>"},{"location":"api/faststream/exceptions/SkipMessage/","title":"SkipMessage","text":""},{"location":"api/faststream/exceptions/SkipMessage/#faststream.exceptions.SkipMessage","title":"faststream.exceptions.SkipMessage","text":"<p>             Bases: <code>Exception</code></p> <p>Watcher Instruction to skip message</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/exceptions.py</code> <pre><code>class SkipMessage(Exception):\n\"\"\"Watcher Instruction to skip message\"\"\"\n</code></pre>"},{"location":"api/faststream/exceptions/StopConsume/","title":"StopConsume","text":""},{"location":"api/faststream/exceptions/StopConsume/#faststream.exceptions.StopConsume","title":"faststream.exceptions.StopConsume","text":"<p>             Bases: <code>Exception</code></p> <p>Raise it to stop Handler consuming</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/exceptions.py</code> <pre><code>class StopConsume(Exception):\n\"\"\"Raise it to stop Handler consuming\"\"\"\n</code></pre>"},{"location":"api/faststream/kafka/asyncapi/Handler/","title":"Handler","text":""},{"location":"api/faststream/kafka/asyncapi/Handler/#faststream.kafka.asyncapi.Handler","title":"faststream.kafka.asyncapi.Handler","text":"<p>             Bases: <code>LogicHandler</code>, <code>AsyncAPIOperation</code></p> <p>A class to handle logic and async API operations.</p> <p>Methods:</p> Name Description <code>schema</code> <p>Returns a dictionary of channels.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/asyncapi.py</code> <pre><code>class Handler(LogicHandler, AsyncAPIOperation):\n\"\"\"A class to handle logic and async API operations.\n\n    Methods:\n        schema() -&gt; Dict[str, Channel]: Returns a dictionary of channels.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    def schema(self) -&gt; Dict[str, Channel]:\n        name: str\n        if self.name is True:\n            name, add_topic = self.call_name, True\n        elif self.name is False:  # pragma: no cover\n            name, add_topic = \"Handler\", True\n        else:\n            name, add_topic = self.name, False\n\n        channels = {}\n\n        for t in self.topics:\n            if add_topic:\n                t_ = to_camelcase(t)\n                if not name.lower().endswith(t_.lower()):\n                    name_ = f\"{name}{t_}\"\n                else:\n                    name_ = name\n            else:\n                name_ = name\n\n            payloads = []\n            for _, _, _, _, _, dep in self.calls:\n                body = parse_handler_params(dep, prefix=name_)\n                payloads.append(body)\n\n            channels[name_] = Channel(\n                description=self.description,\n                subscribe=Operation(\n                    message=Message(\n                        title=f\"{name_}Message\",\n                        payload=resolve_payloads(payloads),\n                        correlationId=CorrelationId(\n                            location=\"$message.header#/correlation_id\"\n                        ),\n                    ),\n                ),\n                bindings=ChannelBinding(kafka=kafka.ChannelBinding(topic=t)),\n            )\n\n        return channels\n</code></pre>"},{"location":"api/faststream/kafka/asyncapi/Handler/#faststream.kafka.asyncapi.Handler-functions","title":"Functions","text":""},{"location":"api/faststream/kafka/asyncapi/Handler/#faststream.kafka.asyncapi.Handler.schema","title":"schema","text":"<pre><code>schema() -&gt; Dict[str, Channel]\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/asyncapi.py</code> <pre><code>def schema(self) -&gt; Dict[str, Channel]:\n    name: str\n    if self.name is True:\n        name, add_topic = self.call_name, True\n    elif self.name is False:  # pragma: no cover\n        name, add_topic = \"Handler\", True\n    else:\n        name, add_topic = self.name, False\n\n    channels = {}\n\n    for t in self.topics:\n        if add_topic:\n            t_ = to_camelcase(t)\n            if not name.lower().endswith(t_.lower()):\n                name_ = f\"{name}{t_}\"\n            else:\n                name_ = name\n        else:\n            name_ = name\n\n        payloads = []\n        for _, _, _, _, _, dep in self.calls:\n            body = parse_handler_params(dep, prefix=name_)\n            payloads.append(body)\n\n        channels[name_] = Channel(\n            description=self.description,\n            subscribe=Operation(\n                message=Message(\n                    title=f\"{name_}Message\",\n                    payload=resolve_payloads(payloads),\n                    correlationId=CorrelationId(\n                        location=\"$message.header#/correlation_id\"\n                    ),\n                ),\n            ),\n            bindings=ChannelBinding(kafka=kafka.ChannelBinding(topic=t)),\n        )\n\n    return channels\n</code></pre>"},{"location":"api/faststream/kafka/asyncapi/Publisher/","title":"Publisher","text":""},{"location":"api/faststream/kafka/asyncapi/Publisher/#faststream.kafka.asyncapi.Publisher","title":"faststream.kafka.asyncapi.Publisher","text":"<p>             Bases: <code>LogicPublisher</code>, <code>AsyncAPIOperation</code></p> <p>A class representing a publisher.</p> <p>Attributes:</p> Name Type Description <code>name</code> <p>name of the publisher</p> <p>Methods:</p> Name Description <code>schema</code> <p>returns the schema for the publisher</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If silent animals are not supported</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/asyncapi.py</code> <pre><code>class Publisher(LogicPublisher, AsyncAPIOperation):\n\"\"\"A class representing a publisher.\n\n    Attributes:\n        name : name of the publisher\n\n    Methods:\n        schema() : returns the schema for the publisher\n\n    Raises:\n        NotImplementedError: If silent animals are not supported\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    @property\n    def name(self) -&gt; str:\n        return self.title or f\"{self.topic.title()}Publisher\"\n\n    def schema(self) -&gt; Dict[str, Channel]:\n        payloads = []\n        for call in self.calls:\n            call_model = build_call_model(call)\n            body = get_response_schema(\n                call_model,\n                prefix=to_camelcase(call_model.call_name),\n            )\n            if body:\n                payloads.append(body)\n\n        return {\n            self.name: Channel(\n                description=self.description,\n                publish=Operation(\n                    message=Message(\n                        title=f\"{self.name}Message\",\n                        payload=resolve_payloads(payloads),\n                        correlationId=CorrelationId(\n                            location=\"$message.header#/correlation_id\"\n                        ),\n                    ),\n                ),\n                bindings=ChannelBinding(kafka=kafka.ChannelBinding(topic=self.topic)),\n            )\n        }\n</code></pre>"},{"location":"api/faststream/kafka/asyncapi/Publisher/#faststream.kafka.asyncapi.Publisher-attributes","title":"Attributes","text":""},{"location":"api/faststream/kafka/asyncapi/Publisher/#faststream.kafka.asyncapi.Publisher.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"api/faststream/kafka/asyncapi/Publisher/#faststream.kafka.asyncapi.Publisher-functions","title":"Functions","text":""},{"location":"api/faststream/kafka/asyncapi/Publisher/#faststream.kafka.asyncapi.Publisher.schema","title":"schema","text":"<pre><code>schema() -&gt; Dict[str, Channel]\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/asyncapi.py</code> <pre><code>def schema(self) -&gt; Dict[str, Channel]:\n    payloads = []\n    for call in self.calls:\n        call_model = build_call_model(call)\n        body = get_response_schema(\n            call_model,\n            prefix=to_camelcase(call_model.call_name),\n        )\n        if body:\n            payloads.append(body)\n\n    return {\n        self.name: Channel(\n            description=self.description,\n            publish=Operation(\n                message=Message(\n                    title=f\"{self.name}Message\",\n                    payload=resolve_payloads(payloads),\n                    correlationId=CorrelationId(\n                        location=\"$message.header#/correlation_id\"\n                    ),\n                ),\n            ),\n            bindings=ChannelBinding(kafka=kafka.ChannelBinding(topic=self.topic)),\n        )\n    }\n</code></pre>"},{"location":"api/faststream/kafka/broker/KafkaBroker/","title":"KafkaBroker","text":""},{"location":"api/faststream/kafka/broker/KafkaBroker/#faststream.kafka.broker.KafkaBroker","title":"faststream.kafka.broker.KafkaBroker","text":"<p>             Bases: <code>KafkaLoggingMixin</code>, <code>BrokerAsyncUsecase[ConsumerRecord, ConsumerConnectionParams]</code></p> <p>KafkaBroker is a class for managing Kafka message consumption and publishing. It extends BrokerAsyncUsecase to handle asynchronous operations.</p> <p>Parameters:</p> Name Type Description Default <code>bootstrap_servers</code> <code>Union[str, Iterable[str]]</code> <p>Kafka bootstrap server(s).</p> <code>'localhost'</code> <code>protocol</code> <code>str</code> <p>The protocol used (default is \"kafka\").</p> <code>None</code> <code>protocol_version</code> <code>str</code> <p>The Kafka protocol version (default is \"auto\").</p> <code>'auto'</code> <code>client_id</code> <code>str</code> <p>The client ID for the Kafka client.</p> <code>'faststream-' + __version__</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Attributes:</p> Name Type Description <code>handlers</code> <code>Dict[str, Handler]</code> <p>A dictionary of message handlers.</p> <code>_publishers</code> <code>Dict[str, Publisher]</code> <p>A dictionary of message publishers.</p> <code>_producer</code> <code>Optional[AioKafkaFastProducer]</code> <p>An optional Kafka producer.</p> <p>Methods:</p> Name Description <code>connect</code> <p>Establishes a connection to Kafka.</p> <code>start</code> <p>Starts the KafkaBroker and message handlers.</p> <code>publish</code> <p>Publishes a message to Kafka.</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/broker.py</code> <pre><code>class KafkaBroker(\n    KafkaLoggingMixin,\n    BrokerAsyncUsecase[aiokafka.ConsumerRecord, ConsumerConnectionParams],\n):\n\"\"\"\n    KafkaBroker is a class for managing Kafka message consumption and publishing.\n    It extends BrokerAsyncUsecase to handle asynchronous operations.\n\n    Args:\n        bootstrap_servers (Union[str, Iterable[str]]): Kafka bootstrap server(s).\n        protocol (str): The protocol used (default is \"kafka\").\n        protocol_version (str): The Kafka protocol version (default is \"auto\").\n        client_id (str): The client ID for the Kafka client.\n        **kwargs: Additional keyword arguments.\n\n    Attributes:\n        handlers (Dict[str, Handler]): A dictionary of message handlers.\n        _publishers (Dict[str, Publisher]): A dictionary of message publishers.\n        _producer (Optional[AioKafkaFastProducer]): An optional Kafka producer.\n\n    Methods:\n        connect(*args, **kwargs): Establishes a connection to Kafka.\n        start(): Starts the KafkaBroker and message handlers.\n        publish(*args, **kwargs): Publishes a message to Kafka.\n    \"\"\"\n\n    handlers: Dict[str, Handler]  # type: ignore[assignment]\n    _publishers: Dict[str, Publisher]  # type: ignore[assignment]\n    _producer: Optional[AioKafkaFastProducer]\n\n    def __init__(\n        self,\n        bootstrap_servers: Union[str, Iterable[str]] = \"localhost\",\n        *,\n        protocol: Optional[str] = None,\n        protocol_version: str = \"auto\",\n        client_id: str = \"faststream-\" + __version__,\n        security: Optional[BaseSecurity] = None,\n        **kwargs: Any,\n    ) -&gt; None:\n\"\"\"\n        Initialize a KafkaBroker instance.\n\n        Args:\n            bootstrap_servers (Union[str, Iterable[str]]): Kafka bootstrap server(s).\n            protocol (str): The protocol used (default is \"kafka\").\n            protocol_version (str): The Kafka protocol version (default is \"auto\").\n            client_id (str): The client ID for the Kafka client.\n            security (Optional[BaseSecurity]): Security protocol to use in communication with the broker (default is None).\n            **kwargs: Additional keyword arguments.\n        \"\"\"\n        if protocol is None:\n            if security is not None and security.use_ssl:\n                protocol = \"kafka-secure\"\n            else:\n                protocol = \"kafka\"\n\n        super().__init__(\n            url=bootstrap_servers,\n            protocol=protocol,\n            protocol_version=protocol_version,\n            security=security,\n            **kwargs,\n            client_id=client_id,\n            bootstrap_servers=bootstrap_servers,\n        )\n        self.client_id = client_id\n        self._producer = None\n\n    async def _close(\n        self,\n        exc_type: Optional[Type[BaseException]] = None,\n        exc_val: Optional[BaseException] = None,\n        exec_tb: Optional[TracebackType] = None,\n    ) -&gt; None:\n\"\"\"\n        Close the KafkaBroker, stopping the producer and cleaning up resources.\n\n        Args:\n            exc_type (Optional[Type[BaseException]]): The exception type.\n            exc_val (Optional[BaseException]]): The exception value.\n            exec_tb (Optional[TracebackType]]): The traceback.\n        \"\"\"\n        if self._producer is not None:  # pragma: no branch\n            await self._producer.stop()\n            self._producer = None\n\n        await super()._close(exc_type, exc_val, exec_tb)\n\n    async def connect(\n        self,\n        *args: Any,\n        **kwargs: Any,\n    ) -&gt; ConsumerConnectionParams:\n\"\"\"\n        Establishes a connection to Kafka and returns connection parameters.\n\n        Args:\n            *args: Additional arguments.\n            **kwargs: Additional keyword arguments.\n\n        Returns:\n            ConsumerConnectionParams: The connection parameters.\n        \"\"\"\n        connection = await super().connect(*args, **kwargs)\n        for p in self._publishers.values():\n            p._producer = self._producer\n        return connection\n\n    @override\n    async def _connect(  # type: ignore[override]\n        self,\n        *,\n        client_id: str,\n        **kwargs: Any,\n    ) -&gt; ConsumerConnectionParams:\n\"\"\"\n        Connects to Kafka, initializes the producer, and returns connection parameters.\n\n        Args:\n            client_id (str): The client ID.\n            **kwargs: Additional keyword arguments.\n\n        Returns:\n            ConsumerConnectionParams: The connection parameters.\n        \"\"\"\n        security_params = parse_security(self.security)\n        producer = aiokafka.AIOKafkaProducer(\n            **kwargs, **security_params, client_id=client_id\n        )\n        await producer.start()\n        self._producer = AioKafkaFastProducer(\n            producer=producer,\n        )\n        return filter_by_dict(ConsumerConnectionParams, {**kwargs, **security_params})\n\n    async def start(self) -&gt; None:\n\"\"\"\n        Start the KafkaBroker and message handlers.\n        \"\"\"\n        context.set_local(\n            \"log_context\",\n            self._get_log_context(None, \"\"),\n        )\n\n        await super().start()\n\n        for handler in self.handlers.values():\n            c = self._get_log_context(None, handler.topics)\n\n            if (name := handler.name) is True:\n                name = handler.call_name\n\n            self._log(f\"`{name}` waiting for messages\", extra=c)\n            await handler.start(**(self._connection or {}))\n\n    def _process_message(\n        self,\n        func: Callable[[KafkaMessage], Awaitable[T_HandlerReturn]],\n        watcher: BaseWatcher,\n    ) -&gt; Callable[[KafkaMessage], Awaitable[WrappedReturn[T_HandlerReturn]],]:\n\"\"\"\n        Wrap a message processing function with a watcher and publisher.\n\n        Args:\n            func (Callable[[KafkaMessage], Awaitable[T_HandlerReturn]]): The message processing function.\n            watcher (BaseWatcher): The message watcher.\n\n        Returns:\n            Callable[[KafkaMessage], Awaitable[WrappedReturn[T_HandlerReturn]]]: The wrapped message processing function.\n        \"\"\"\n\n        @wraps(func)\n        async def process_wrapper(\n            message: KafkaMessage,\n        ) -&gt; WrappedReturn[T_HandlerReturn]:\n\"\"\"Asynchronously process a Kafka message and wrap the return value.\n\n            Args:\n                message (KafkaMessage): The Kafka message to process.\n\n            Returns:\n                WrappedReturn[T_HandlerReturn]: The wrapped return value.\n\n            Raises:\n                AssertionError: If the code reaches an unreachable point.\n            !!! note\n\n                The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n            \"\"\"\n            async with WatcherContext(watcher, message):\n                r = await self._execute_handler(func, message)\n\n                pub_response: Optional[AsyncPublisherProtocol]\n                if message.reply_to:\n                    pub_response = FakePublisher(\n                        partial(self.publish, topic=message.reply_to)\n                    )\n                else:\n                    pub_response = None\n\n                return r, pub_response\n\n            raise AssertionError(\"unreachable\")\n\n        return process_wrapper\n\n    @override\n    def subscriber(  # type: ignore[override]\n        self,\n        *topics: str,\n        group_id: Optional[str] = None,\n        key_deserializer: Optional[Callable[[bytes], Any]] = None,\n        value_deserializer: Optional[Callable[[bytes], Any]] = None,\n        fetch_max_wait_ms: int = 500,\n        fetch_max_bytes: int = 52428800,\n        fetch_min_bytes: int = 1,\n        max_partition_fetch_bytes: int = 1 * 1024 * 1024,\n        auto_offset_reset: Literal[\n            \"latest\",\n            \"earliest\",\n            \"none\",\n        ] = \"latest\",\n        enable_auto_commit: bool = True,\n        auto_commit_interval_ms: int = 5000,\n        check_crcs: bool = True,\n        partition_assignment_strategy: Sequence[AbstractPartitionAssignor] = (\n            RoundRobinPartitionAssignor,\n        ),\n        max_poll_interval_ms: int = 300000,\n        rebalance_timeout_ms: Optional[int] = None,\n        session_timeout_ms: int = 10000,\n        heartbeat_interval_ms: int = 3000,\n        consumer_timeout_ms: int = 200,\n        max_poll_records: Optional[int] = None,\n        exclude_internal_topics: bool = True,\n        isolation_level: Literal[\n            \"read_uncommitted\",\n            \"read_committed\",\n        ] = \"read_uncommitted\",\n        # broker arguments\n        dependencies: Sequence[Depends] = (),\n        parser: Optional[\n            Union[\n                CustomParser[aiokafka.ConsumerRecord],\n                CustomParser[Tuple[aiokafka.ConsumerRecord, ...]],\n            ]\n        ] = None,\n        decoder: Optional[\n            Union[\n                CustomDecoder[aiokafka.ConsumerRecord],\n                CustomDecoder[Tuple[aiokafka.ConsumerRecord, ...]],\n            ]\n        ] = None,\n        middlewares: Optional[\n            Sequence[\n                Callable[\n                    [aiokafka.ConsumerRecord],\n                    BaseMiddleware,\n                ]\n            ]\n        ] = None,\n        filter: Union[\n            Filter[KafkaMessage],\n            Filter[StreamMessage[Tuple[aiokafka.ConsumerRecord, ...]]],\n        ] = default_filter,\n        batch: bool = False,\n        max_records: Optional[int] = None,\n        batch_timeout_ms: int = 200,\n        # AsyncAPI information\n        title: Optional[str] = None,\n        description: Optional[str] = None,\n        **original_kwargs: Any,\n    ) -&gt; Callable[\n        [Callable[P_HandlerParams, T_HandlerReturn]],\n        Union[\n            HandlerCallWrapper[\n                aiokafka.ConsumerRecord, P_HandlerParams, T_HandlerReturn\n            ],\n            HandlerCallWrapper[\n                Tuple[aiokafka.ConsumerRecord, ...], P_HandlerParams, T_HandlerReturn\n            ],\n        ],\n    ]:\n\"\"\"\n        Create a message subscriber for the specified topics.\n\n        Args:\n            *topics (str): The topics to subscribe to.\n            group_id (Optional[str]): The Kafka consumer group ID.\n            key_deserializer (Optional[Callable[[bytes], Any]]): Key deserializer function.\n            value_deserializer (Optional[Callable[[bytes], Any]]): Value deserializer function.\n            fetch_max_wait_ms (int): The maximum time to wait for data.\n            fetch_max_bytes (int): The maximum number of bytes to fetch.\n            fetch_min_bytes (int): The minimum number of bytes to fetch.\n            max_partition_fetch_bytes (int): The maximum bytes to fetch for a partition.\n            auto_offset_reset (Literal[\"latest\", \"earliest\", \"none\"]): Auto offset reset policy.\n            enable_auto_commit (bool): Whether to enable auto-commit.\n            auto_commit_interval_ms (int): Auto-commit interval in milliseconds.\n            check_crcs (bool): Whether to check CRCs.\n            partition_assignment_strategy (Sequence[AbstractPartitionAssignor]): Partition assignment strategy.\n            max_poll_interval_ms (int): Maximum poll interval in milliseconds.\n            rebalance_timeout_ms (Optional[int]): Rebalance timeout in milliseconds.\n            session_timeout_ms (int): Session timeout in milliseconds.\n            heartbeat_interval_ms (int): Heartbeat interval in milliseconds.\n            consumer_timeout_ms (int): Consumer timeout in milliseconds.\n            max_poll_records (Optional[int]): Maximum number of records to poll.\n            exclude_internal_topics (bool): Whether to exclude internal topics.\n            isolation_level (Literal[\"read_uncommitted\", \"read_committed\"]): Isolation level.\n            dependencies (Sequence[Depends]): Additional dependencies for message handling.\n            parser (Optional[Union[CustomParser[aiokafka.ConsumerRecord], CustomParser[Tuple[aiokafka.ConsumerRecord, ...]]]]): Message parser.\n            decoder (Optional[Union[CustomDecoder[aiokafka.ConsumerRecord], CustomDecoder[Tuple[aiokafka.ConsumerRecord, ...]]]]): Message decoder.\n            middlewares (Optional[Sequence[Callable[[aiokafka.ConsumerRecord], BaseMiddleware]]]): Message middlewares.\n            filter (Union[Filter[KafkaMessage], Filter[StreamMessage[Tuple[aiokafka.ConsumerRecord, ...]]]]): Message filter.\n            batch (bool): Whether to process messages in batches.\n            max_records (Optional[int]): Maximum number of records to process in each batch.\n            batch_timeout_ms (int): Batch timeout in milliseconds.\n            title (Optional[str]): AsyncAPI title.\n            description (Optional[str]): AsyncAPI description.\n            **original_kwargs: Additional keyword arguments.\n\n        Returns:\n            Callable: A decorator that wraps a message handler function.\n        \"\"\"\n        super().subscriber()\n\n        self._setup_log_context(topics)\n\n        key = \"\".join(topics)\n        builder = partial(\n            aiokafka.AIOKafkaConsumer,\n            key_deserializer=key_deserializer,\n            value_deserializer=value_deserializer,\n            fetch_max_wait_ms=fetch_max_wait_ms,\n            fetch_max_bytes=fetch_max_bytes,\n            fetch_min_bytes=fetch_min_bytes,\n            max_partition_fetch_bytes=max_partition_fetch_bytes,\n            auto_offset_reset=auto_offset_reset,\n            enable_auto_commit=enable_auto_commit,\n            auto_commit_interval_ms=auto_commit_interval_ms,\n            check_crcs=check_crcs,\n            partition_assignment_strategy=partition_assignment_strategy,\n            max_poll_interval_ms=max_poll_interval_ms,\n            rebalance_timeout_ms=rebalance_timeout_ms,\n            session_timeout_ms=session_timeout_ms,\n            heartbeat_interval_ms=heartbeat_interval_ms,\n            consumer_timeout_ms=consumer_timeout_ms,\n            max_poll_records=max_poll_records,\n            exclude_internal_topics=exclude_internal_topics,\n            isolation_level=isolation_level,\n        )\n        handler = self.handlers.get(\n            key,\n            Handler(\n                *topics,\n                group_id=group_id,\n                client_id=self.client_id,\n                builder=builder,\n                description=description,\n                title=title,\n                batch=batch,\n                batch_timeout_ms=batch_timeout_ms,\n                max_records=max_records,\n            ),\n        )\n\n        self.handlers[key] = handler\n\n        def consumer_wrapper(\n            func: Callable[P_HandlerParams, T_HandlerReturn],\n        ) -&gt; HandlerCallWrapper[\n            aiokafka.ConsumerRecord, P_HandlerParams, T_HandlerReturn\n        ]:\n\"\"\"A wrapper function for a consumer handler.\n\n            Args:\n                func : The consumer handler function to be wrapped.\n\n            Returns:\n                The wrapped handler call.\n\n            Raises:\n                NotImplementedError: If silent animals are not supported.\n            !!! note\n\n                The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n            \"\"\"\n            handler_call, dependant = self._wrap_handler(\n                func=func,\n                extra_dependencies=dependencies,\n                **original_kwargs,\n                topics=topics,\n            )\n\n            handler.add_call(\n                handler=handler_call,\n                filter=filter,\n                middlewares=middlewares,\n                parser=parser or self._global_parser,\n                decoder=decoder or self._global_decoder,\n                dependant=dependant,\n            )\n\n            return handler_call\n\n        return consumer_wrapper\n\n    @override\n    def publisher(  # type: ignore[override]\n        self,\n        topic: str,\n        key: Optional[bytes] = None,\n        partition: Optional[int] = None,\n        timestamp_ms: Optional[int] = None,\n        headers: Optional[Dict[str, str]] = None,\n        reply_to: str = \"\",\n        batch: bool = False,\n        # AsyncAPI information\n        title: Optional[str] = None,\n        description: Optional[str] = None,\n    ) -&gt; Publisher:\n\"\"\"\n        Create a message publisher for the specified topic.\n\n        Args:\n            topic (str): The topic to publish messages to.\n            key (Optional[bytes]): Message key.\n            partition (Optional[int]): Partition to send the message to.\n            timestamp_ms (Optional[int]): Message timestamp in milliseconds.\n            headers (Optional[Dict[str, str]]): Message headers.\n            reply_to (str): The topic to which responses should be sent.\n            batch (bool): Whether to publish messages in batches.\n            title (Optional[str]): AsyncAPI title.\n            description (Optional[str]): AsyncAPI description.\n\n        Returns:\n            Publisher: A message publisher.\n        \"\"\"\n        publisher = self._publishers.get(\n            topic,\n            Publisher(\n                topic=topic,\n                client_id=self.client_id,\n                key=key,\n                batch=batch,\n                partition=partition,\n                timestamp_ms=timestamp_ms,\n                headers=headers,\n                reply_to=reply_to,\n                title=title,\n                _description=description,\n            ),\n        )\n        super().publisher(topic, publisher)\n        return publisher\n\n    @override\n    async def publish(  # type: ignore[override]\n        self,\n        *args: Any,\n        **kwargs: Any,\n    ) -&gt; None:\n\"\"\"\n        Publish a message to Kafka.\n\n        Args:\n            *args: Positional arguments for message publishing.\n            **kwargs: Keyword arguments for message publishing.\n\n        Raises:\n            RuntimeError: If KafkaBroker is not started yet.\n        \"\"\"\n        assert self._producer, \"KafkaBroker is not started yet\"  # nosec B101\n        return await self._producer.publish(*args, **kwargs)\n\n    async def publish_batch(\n        self,\n        *args: Any,\n        **kwargs: Any,\n    ) -&gt; None:\n\"\"\"\n        Publish a batch of messages to Kafka.\n\n        Args:\n            *args: Positional arguments for message publishing.\n            **kwargs: Keyword arguments for message publishing.\n\n        Raises:\n            RuntimeError: If KafkaBroker is not started yet.\n        \"\"\"\n        assert self._producer, \"KafkaBroker is not started yet\"  # nosec B101\n        await self._producer.publish_batch(*args, **kwargs)\n</code></pre>"},{"location":"api/faststream/kafka/broker/KafkaBroker/#faststream.kafka.broker.KafkaBroker-attributes","title":"Attributes","text":""},{"location":"api/faststream/kafka/broker/KafkaBroker/#faststream.kafka.broker.KafkaBroker.client_id","title":"client_id  <code>instance-attribute</code>","text":"<pre><code>client_id = client_id\n</code></pre>"},{"location":"api/faststream/kafka/broker/KafkaBroker/#faststream.kafka.broker.KafkaBroker.handlers","title":"handlers  <code>instance-attribute</code>","text":"<pre><code>handlers: Dict[str, Handler]\n</code></pre>"},{"location":"api/faststream/kafka/broker/KafkaBroker/#faststream.kafka.broker.KafkaBroker-functions","title":"Functions","text":""},{"location":"api/faststream/kafka/broker/KafkaBroker/#faststream.kafka.broker.KafkaBroker.__init__","title":"__init__","text":"<pre><code>__init__(\n    bootstrap_servers: Union[\n        str, Iterable[str]\n    ] = \"localhost\",\n    *,\n    protocol: str = None,\n    protocol_version: str = \"auto\",\n    client_id: str = \"faststream-\" + __version__,\n    security: Optional[BaseSecurity] = None,\n    **kwargs: Any\n) -&gt; None\n</code></pre> <p>Initialize a KafkaBroker instance.</p> <p>Parameters:</p> Name Type Description Default <code>bootstrap_servers</code> <code>Union[str, Iterable[str]]</code> <p>Kafka bootstrap server(s).</p> <code>'localhost'</code> <code>protocol</code> <code>str</code> <p>The protocol used (default is \"kafka\").</p> <code>None</code> <code>protocol_version</code> <code>str</code> <p>The Kafka protocol version (default is \"auto\").</p> <code>'auto'</code> <code>client_id</code> <code>str</code> <p>The client ID for the Kafka client.</p> <code>'faststream-' + __version__</code> <code>security</code> <code>Optional[BaseSecurity]</code> <p>Security protocol to use in communication with the broker (default is None).</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments.</p> <code>{}</code> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/broker.py</code> <pre><code>def __init__(\n    self,\n    bootstrap_servers: Union[str, Iterable[str]] = \"localhost\",\n    *,\n    protocol: Optional[str] = None,\n    protocol_version: str = \"auto\",\n    client_id: str = \"faststream-\" + __version__,\n    security: Optional[BaseSecurity] = None,\n    **kwargs: Any,\n) -&gt; None:\n\"\"\"\n    Initialize a KafkaBroker instance.\n\n    Args:\n        bootstrap_servers (Union[str, Iterable[str]]): Kafka bootstrap server(s).\n        protocol (str): The protocol used (default is \"kafka\").\n        protocol_version (str): The Kafka protocol version (default is \"auto\").\n        client_id (str): The client ID for the Kafka client.\n        security (Optional[BaseSecurity]): Security protocol to use in communication with the broker (default is None).\n        **kwargs: Additional keyword arguments.\n    \"\"\"\n    if protocol is None:\n        if security is not None and security.use_ssl:\n            protocol = \"kafka-secure\"\n        else:\n            protocol = \"kafka\"\n\n    super().__init__(\n        url=bootstrap_servers,\n        protocol=protocol,\n        protocol_version=protocol_version,\n        security=security,\n        **kwargs,\n        client_id=client_id,\n        bootstrap_servers=bootstrap_servers,\n    )\n    self.client_id = client_id\n    self._producer = None\n</code></pre>"},{"location":"api/faststream/kafka/broker/KafkaBroker/#faststream.kafka.broker.KafkaBroker.connect","title":"connect  <code>async</code>","text":"<pre><code>connect(\n    *args: Any, **kwargs: Any\n) -&gt; ConsumerConnectionParams\n</code></pre> <p>Establishes a connection to Kafka and returns connection parameters.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Any</code> <p>Additional arguments.</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>ConsumerConnectionParams</code> <code>ConsumerConnectionParams</code> <p>The connection parameters.</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/broker.py</code> <pre><code>async def connect(\n    self,\n    *args: Any,\n    **kwargs: Any,\n) -&gt; ConsumerConnectionParams:\n\"\"\"\n    Establishes a connection to Kafka and returns connection parameters.\n\n    Args:\n        *args: Additional arguments.\n        **kwargs: Additional keyword arguments.\n\n    Returns:\n        ConsumerConnectionParams: The connection parameters.\n    \"\"\"\n    connection = await super().connect(*args, **kwargs)\n    for p in self._publishers.values():\n        p._producer = self._producer\n    return connection\n</code></pre>"},{"location":"api/faststream/kafka/broker/KafkaBroker/#faststream.kafka.broker.KafkaBroker.publish","title":"publish  <code>async</code>","text":"<pre><code>publish(*args: Any, **kwargs: Any) -&gt; None\n</code></pre> <p>Publish a message to Kafka.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Any</code> <p>Positional arguments for message publishing.</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments for message publishing.</p> <code>{}</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If KafkaBroker is not started yet.</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/broker.py</code> <pre><code>@override\nasync def publish(  # type: ignore[override]\n    self,\n    *args: Any,\n    **kwargs: Any,\n) -&gt; None:\n\"\"\"\n    Publish a message to Kafka.\n\n    Args:\n        *args: Positional arguments for message publishing.\n        **kwargs: Keyword arguments for message publishing.\n\n    Raises:\n        RuntimeError: If KafkaBroker is not started yet.\n    \"\"\"\n    assert self._producer, \"KafkaBroker is not started yet\"  # nosec B101\n    return await self._producer.publish(*args, **kwargs)\n</code></pre>"},{"location":"api/faststream/kafka/broker/KafkaBroker/#faststream.kafka.broker.KafkaBroker.publish_batch","title":"publish_batch  <code>async</code>","text":"<pre><code>publish_batch(*args: Any, **kwargs: Any) -&gt; None\n</code></pre> <p>Publish a batch of messages to Kafka.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Any</code> <p>Positional arguments for message publishing.</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments for message publishing.</p> <code>{}</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If KafkaBroker is not started yet.</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/broker.py</code> <pre><code>async def publish_batch(\n    self,\n    *args: Any,\n    **kwargs: Any,\n) -&gt; None:\n\"\"\"\n    Publish a batch of messages to Kafka.\n\n    Args:\n        *args: Positional arguments for message publishing.\n        **kwargs: Keyword arguments for message publishing.\n\n    Raises:\n        RuntimeError: If KafkaBroker is not started yet.\n    \"\"\"\n    assert self._producer, \"KafkaBroker is not started yet\"  # nosec B101\n    await self._producer.publish_batch(*args, **kwargs)\n</code></pre>"},{"location":"api/faststream/kafka/broker/KafkaBroker/#faststream.kafka.broker.KafkaBroker.publisher","title":"publisher","text":"<pre><code>publisher(\n    topic: str,\n    key: Optional[bytes] = None,\n    partition: Optional[int] = None,\n    timestamp_ms: Optional[int] = None,\n    headers: Optional[Dict[str, str]] = None,\n    reply_to: str = \"\",\n    batch: bool = False,\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n) -&gt; Publisher\n</code></pre> <p>Create a message publisher for the specified topic.</p> <p>Parameters:</p> Name Type Description Default <code>topic</code> <code>str</code> <p>The topic to publish messages to.</p> required <code>key</code> <code>Optional[bytes]</code> <p>Message key.</p> <code>None</code> <code>partition</code> <code>Optional[int]</code> <p>Partition to send the message to.</p> <code>None</code> <code>timestamp_ms</code> <code>Optional[int]</code> <p>Message timestamp in milliseconds.</p> <code>None</code> <code>headers</code> <code>Optional[Dict[str, str]]</code> <p>Message headers.</p> <code>None</code> <code>reply_to</code> <code>str</code> <p>The topic to which responses should be sent.</p> <code>''</code> <code>batch</code> <code>bool</code> <p>Whether to publish messages in batches.</p> <code>False</code> <code>title</code> <code>Optional[str]</code> <p>AsyncAPI title.</p> <code>None</code> <code>description</code> <code>Optional[str]</code> <p>AsyncAPI description.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Publisher</code> <code>Publisher</code> <p>A message publisher.</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/broker.py</code> <pre><code>@override\ndef publisher(  # type: ignore[override]\n    self,\n    topic: str,\n    key: Optional[bytes] = None,\n    partition: Optional[int] = None,\n    timestamp_ms: Optional[int] = None,\n    headers: Optional[Dict[str, str]] = None,\n    reply_to: str = \"\",\n    batch: bool = False,\n    # AsyncAPI information\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n) -&gt; Publisher:\n\"\"\"\n    Create a message publisher for the specified topic.\n\n    Args:\n        topic (str): The topic to publish messages to.\n        key (Optional[bytes]): Message key.\n        partition (Optional[int]): Partition to send the message to.\n        timestamp_ms (Optional[int]): Message timestamp in milliseconds.\n        headers (Optional[Dict[str, str]]): Message headers.\n        reply_to (str): The topic to which responses should be sent.\n        batch (bool): Whether to publish messages in batches.\n        title (Optional[str]): AsyncAPI title.\n        description (Optional[str]): AsyncAPI description.\n\n    Returns:\n        Publisher: A message publisher.\n    \"\"\"\n    publisher = self._publishers.get(\n        topic,\n        Publisher(\n            topic=topic,\n            client_id=self.client_id,\n            key=key,\n            batch=batch,\n            partition=partition,\n            timestamp_ms=timestamp_ms,\n            headers=headers,\n            reply_to=reply_to,\n            title=title,\n            _description=description,\n        ),\n    )\n    super().publisher(topic, publisher)\n    return publisher\n</code></pre>"},{"location":"api/faststream/kafka/broker/KafkaBroker/#faststream.kafka.broker.KafkaBroker.start","title":"start  <code>async</code>","text":"<pre><code>start() -&gt; None\n</code></pre> <p>Start the KafkaBroker and message handlers.</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/broker.py</code> <pre><code>async def start(self) -&gt; None:\n\"\"\"\n    Start the KafkaBroker and message handlers.\n    \"\"\"\n    context.set_local(\n        \"log_context\",\n        self._get_log_context(None, \"\"),\n    )\n\n    await super().start()\n\n    for handler in self.handlers.values():\n        c = self._get_log_context(None, handler.topics)\n\n        if (name := handler.name) is True:\n            name = handler.call_name\n\n        self._log(f\"`{name}` waiting for messages\", extra=c)\n        await handler.start(**(self._connection or {}))\n</code></pre>"},{"location":"api/faststream/kafka/broker/KafkaBroker/#faststream.kafka.broker.KafkaBroker.subscriber","title":"subscriber","text":"<pre><code>subscriber(\n    *topics: str,\n    group_id: Optional[str] = None,\n    key_deserializer: Optional[\n        Callable[[bytes], Any]\n    ] = None,\n    value_deserializer: Optional[\n        Callable[[bytes], Any]\n    ] = None,\n    fetch_max_wait_ms: int = 500,\n    fetch_max_bytes: int = 52428800,\n    fetch_min_bytes: int = 1,\n    max_partition_fetch_bytes: int = 1 * 1024 * 1024,\n    auto_offset_reset: Literal[\n        \"latest\", \"earliest\", \"none\"\n    ] = \"latest\",\n    enable_auto_commit: bool = True,\n    auto_commit_interval_ms: int = 5000,\n    check_crcs: bool = True,\n    partition_assignment_strategy: Sequence[\n        AbstractPartitionAssignor\n    ] = (RoundRobinPartitionAssignor),\n    max_poll_interval_ms: int = 300000,\n    rebalance_timeout_ms: Optional[int] = None,\n    session_timeout_ms: int = 10000,\n    heartbeat_interval_ms: int = 3000,\n    consumer_timeout_ms: int = 200,\n    max_poll_records: Optional[int] = None,\n    exclude_internal_topics: bool = True,\n    isolation_level: Literal[\n        \"read_uncommitted\", \"read_committed\"\n    ] = \"read_uncommitted\",\n    dependencies: Sequence[Depends] = (),\n    parser: Optional[\n        Union[\n            CustomParser[aiokafka.ConsumerRecord],\n            CustomParser[\n                Tuple[aiokafka.ConsumerRecord, ...]\n            ],\n        ]\n    ] = None,\n    decoder: Optional[\n        Union[\n            CustomDecoder[aiokafka.ConsumerRecord],\n            CustomDecoder[\n                Tuple[aiokafka.ConsumerRecord, ...]\n            ],\n        ]\n    ] = None,\n    middlewares: Optional[\n        Sequence[\n            Callable[\n                [aiokafka.ConsumerRecord], BaseMiddleware\n            ]\n        ]\n    ] = None,\n    filter: Union[\n        Filter[KafkaMessage],\n        Filter[\n            StreamMessage[\n                Tuple[aiokafka.ConsumerRecord, ...]\n            ]\n        ],\n    ] = default_filter,\n    batch: bool = False,\n    max_records: Optional[int] = None,\n    batch_timeout_ms: int = 200,\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n    **original_kwargs: Any\n) -&gt; Callable[\n    [Callable[P_HandlerParams, T_HandlerReturn]],\n    Union[\n        HandlerCallWrapper[\n            aiokafka.ConsumerRecord,\n            P_HandlerParams,\n            T_HandlerReturn,\n        ],\n        HandlerCallWrapper[\n            Tuple[aiokafka.ConsumerRecord, ...],\n            P_HandlerParams,\n            T_HandlerReturn,\n        ],\n    ],\n]\n</code></pre> <p>Create a message subscriber for the specified topics.</p> <p>Parameters:</p> Name Type Description Default <code>*topics</code> <code>str</code> <p>The topics to subscribe to.</p> <code>()</code> <code>group_id</code> <code>Optional[str]</code> <p>The Kafka consumer group ID.</p> <code>None</code> <code>key_deserializer</code> <code>Optional[Callable[[bytes], Any]]</code> <p>Key deserializer function.</p> <code>None</code> <code>value_deserializer</code> <code>Optional[Callable[[bytes], Any]]</code> <p>Value deserializer function.</p> <code>None</code> <code>fetch_max_wait_ms</code> <code>int</code> <p>The maximum time to wait for data.</p> <code>500</code> <code>fetch_max_bytes</code> <code>int</code> <p>The maximum number of bytes to fetch.</p> <code>52428800</code> <code>fetch_min_bytes</code> <code>int</code> <p>The minimum number of bytes to fetch.</p> <code>1</code> <code>max_partition_fetch_bytes</code> <code>int</code> <p>The maximum bytes to fetch for a partition.</p> <code>1 * 1024 * 1024</code> <code>auto_offset_reset</code> <code>Literal['latest', 'earliest', 'none']</code> <p>Auto offset reset policy.</p> <code>'latest'</code> <code>enable_auto_commit</code> <code>bool</code> <p>Whether to enable auto-commit.</p> <code>True</code> <code>auto_commit_interval_ms</code> <code>int</code> <p>Auto-commit interval in milliseconds.</p> <code>5000</code> <code>check_crcs</code> <code>bool</code> <p>Whether to check CRCs.</p> <code>True</code> <code>partition_assignment_strategy</code> <code>Sequence[AbstractPartitionAssignor]</code> <p>Partition assignment strategy.</p> <code>(RoundRobinPartitionAssignor)</code> <code>max_poll_interval_ms</code> <code>int</code> <p>Maximum poll interval in milliseconds.</p> <code>300000</code> <code>rebalance_timeout_ms</code> <code>Optional[int]</code> <p>Rebalance timeout in milliseconds.</p> <code>None</code> <code>session_timeout_ms</code> <code>int</code> <p>Session timeout in milliseconds.</p> <code>10000</code> <code>heartbeat_interval_ms</code> <code>int</code> <p>Heartbeat interval in milliseconds.</p> <code>3000</code> <code>consumer_timeout_ms</code> <code>int</code> <p>Consumer timeout in milliseconds.</p> <code>200</code> <code>max_poll_records</code> <code>Optional[int]</code> <p>Maximum number of records to poll.</p> <code>None</code> <code>exclude_internal_topics</code> <code>bool</code> <p>Whether to exclude internal topics.</p> <code>True</code> <code>isolation_level</code> <code>Literal['read_uncommitted', 'read_committed']</code> <p>Isolation level.</p> <code>'read_uncommitted'</code> <code>dependencies</code> <code>Sequence[Depends]</code> <p>Additional dependencies for message handling.</p> <code>()</code> <code>parser</code> <code>Optional[Union[CustomParser[ConsumerRecord], CustomParser[Tuple[ConsumerRecord, ...]]]]</code> <p>Message parser.</p> <code>None</code> <code>decoder</code> <code>Optional[Union[CustomDecoder[ConsumerRecord], CustomDecoder[Tuple[ConsumerRecord, ...]]]]</code> <p>Message decoder.</p> <code>None</code> <code>middlewares</code> <code>Optional[Sequence[Callable[[ConsumerRecord], BaseMiddleware]]]</code> <p>Message middlewares.</p> <code>None</code> <code>filter</code> <code>Union[Filter[KafkaMessage], Filter[StreamMessage[Tuple[ConsumerRecord, ...]]]]</code> <p>Message filter.</p> <code>default_filter</code> <code>batch</code> <code>bool</code> <p>Whether to process messages in batches.</p> <code>False</code> <code>max_records</code> <code>Optional[int]</code> <p>Maximum number of records to process in each batch.</p> <code>None</code> <code>batch_timeout_ms</code> <code>int</code> <p>Batch timeout in milliseconds.</p> <code>200</code> <code>title</code> <code>Optional[str]</code> <p>AsyncAPI title.</p> <code>None</code> <code>description</code> <code>Optional[str]</code> <p>AsyncAPI description.</p> <code>None</code> <code>**original_kwargs</code> <code>Any</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Callable</code> <code>Callable[[Callable[P_HandlerParams, T_HandlerReturn]], Union[HandlerCallWrapper[ConsumerRecord, P_HandlerParams, T_HandlerReturn], HandlerCallWrapper[Tuple[ConsumerRecord, ...], P_HandlerParams, T_HandlerReturn]]]</code> <p>A decorator that wraps a message handler function.</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/broker.py</code> <pre><code>@override\ndef subscriber(  # type: ignore[override]\n    self,\n    *topics: str,\n    group_id: Optional[str] = None,\n    key_deserializer: Optional[Callable[[bytes], Any]] = None,\n    value_deserializer: Optional[Callable[[bytes], Any]] = None,\n    fetch_max_wait_ms: int = 500,\n    fetch_max_bytes: int = 52428800,\n    fetch_min_bytes: int = 1,\n    max_partition_fetch_bytes: int = 1 * 1024 * 1024,\n    auto_offset_reset: Literal[\n        \"latest\",\n        \"earliest\",\n        \"none\",\n    ] = \"latest\",\n    enable_auto_commit: bool = True,\n    auto_commit_interval_ms: int = 5000,\n    check_crcs: bool = True,\n    partition_assignment_strategy: Sequence[AbstractPartitionAssignor] = (\n        RoundRobinPartitionAssignor,\n    ),\n    max_poll_interval_ms: int = 300000,\n    rebalance_timeout_ms: Optional[int] = None,\n    session_timeout_ms: int = 10000,\n    heartbeat_interval_ms: int = 3000,\n    consumer_timeout_ms: int = 200,\n    max_poll_records: Optional[int] = None,\n    exclude_internal_topics: bool = True,\n    isolation_level: Literal[\n        \"read_uncommitted\",\n        \"read_committed\",\n    ] = \"read_uncommitted\",\n    # broker arguments\n    dependencies: Sequence[Depends] = (),\n    parser: Optional[\n        Union[\n            CustomParser[aiokafka.ConsumerRecord],\n            CustomParser[Tuple[aiokafka.ConsumerRecord, ...]],\n        ]\n    ] = None,\n    decoder: Optional[\n        Union[\n            CustomDecoder[aiokafka.ConsumerRecord],\n            CustomDecoder[Tuple[aiokafka.ConsumerRecord, ...]],\n        ]\n    ] = None,\n    middlewares: Optional[\n        Sequence[\n            Callable[\n                [aiokafka.ConsumerRecord],\n                BaseMiddleware,\n            ]\n        ]\n    ] = None,\n    filter: Union[\n        Filter[KafkaMessage],\n        Filter[StreamMessage[Tuple[aiokafka.ConsumerRecord, ...]]],\n    ] = default_filter,\n    batch: bool = False,\n    max_records: Optional[int] = None,\n    batch_timeout_ms: int = 200,\n    # AsyncAPI information\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n    **original_kwargs: Any,\n) -&gt; Callable[\n    [Callable[P_HandlerParams, T_HandlerReturn]],\n    Union[\n        HandlerCallWrapper[\n            aiokafka.ConsumerRecord, P_HandlerParams, T_HandlerReturn\n        ],\n        HandlerCallWrapper[\n            Tuple[aiokafka.ConsumerRecord, ...], P_HandlerParams, T_HandlerReturn\n        ],\n    ],\n]:\n\"\"\"\n    Create a message subscriber for the specified topics.\n\n    Args:\n        *topics (str): The topics to subscribe to.\n        group_id (Optional[str]): The Kafka consumer group ID.\n        key_deserializer (Optional[Callable[[bytes], Any]]): Key deserializer function.\n        value_deserializer (Optional[Callable[[bytes], Any]]): Value deserializer function.\n        fetch_max_wait_ms (int): The maximum time to wait for data.\n        fetch_max_bytes (int): The maximum number of bytes to fetch.\n        fetch_min_bytes (int): The minimum number of bytes to fetch.\n        max_partition_fetch_bytes (int): The maximum bytes to fetch for a partition.\n        auto_offset_reset (Literal[\"latest\", \"earliest\", \"none\"]): Auto offset reset policy.\n        enable_auto_commit (bool): Whether to enable auto-commit.\n        auto_commit_interval_ms (int): Auto-commit interval in milliseconds.\n        check_crcs (bool): Whether to check CRCs.\n        partition_assignment_strategy (Sequence[AbstractPartitionAssignor]): Partition assignment strategy.\n        max_poll_interval_ms (int): Maximum poll interval in milliseconds.\n        rebalance_timeout_ms (Optional[int]): Rebalance timeout in milliseconds.\n        session_timeout_ms (int): Session timeout in milliseconds.\n        heartbeat_interval_ms (int): Heartbeat interval in milliseconds.\n        consumer_timeout_ms (int): Consumer timeout in milliseconds.\n        max_poll_records (Optional[int]): Maximum number of records to poll.\n        exclude_internal_topics (bool): Whether to exclude internal topics.\n        isolation_level (Literal[\"read_uncommitted\", \"read_committed\"]): Isolation level.\n        dependencies (Sequence[Depends]): Additional dependencies for message handling.\n        parser (Optional[Union[CustomParser[aiokafka.ConsumerRecord], CustomParser[Tuple[aiokafka.ConsumerRecord, ...]]]]): Message parser.\n        decoder (Optional[Union[CustomDecoder[aiokafka.ConsumerRecord], CustomDecoder[Tuple[aiokafka.ConsumerRecord, ...]]]]): Message decoder.\n        middlewares (Optional[Sequence[Callable[[aiokafka.ConsumerRecord], BaseMiddleware]]]): Message middlewares.\n        filter (Union[Filter[KafkaMessage], Filter[StreamMessage[Tuple[aiokafka.ConsumerRecord, ...]]]]): Message filter.\n        batch (bool): Whether to process messages in batches.\n        max_records (Optional[int]): Maximum number of records to process in each batch.\n        batch_timeout_ms (int): Batch timeout in milliseconds.\n        title (Optional[str]): AsyncAPI title.\n        description (Optional[str]): AsyncAPI description.\n        **original_kwargs: Additional keyword arguments.\n\n    Returns:\n        Callable: A decorator that wraps a message handler function.\n    \"\"\"\n    super().subscriber()\n\n    self._setup_log_context(topics)\n\n    key = \"\".join(topics)\n    builder = partial(\n        aiokafka.AIOKafkaConsumer,\n        key_deserializer=key_deserializer,\n        value_deserializer=value_deserializer,\n        fetch_max_wait_ms=fetch_max_wait_ms,\n        fetch_max_bytes=fetch_max_bytes,\n        fetch_min_bytes=fetch_min_bytes,\n        max_partition_fetch_bytes=max_partition_fetch_bytes,\n        auto_offset_reset=auto_offset_reset,\n        enable_auto_commit=enable_auto_commit,\n        auto_commit_interval_ms=auto_commit_interval_ms,\n        check_crcs=check_crcs,\n        partition_assignment_strategy=partition_assignment_strategy,\n        max_poll_interval_ms=max_poll_interval_ms,\n        rebalance_timeout_ms=rebalance_timeout_ms,\n        session_timeout_ms=session_timeout_ms,\n        heartbeat_interval_ms=heartbeat_interval_ms,\n        consumer_timeout_ms=consumer_timeout_ms,\n        max_poll_records=max_poll_records,\n        exclude_internal_topics=exclude_internal_topics,\n        isolation_level=isolation_level,\n    )\n    handler = self.handlers.get(\n        key,\n        Handler(\n            *topics,\n            group_id=group_id,\n            client_id=self.client_id,\n            builder=builder,\n            description=description,\n            title=title,\n            batch=batch,\n            batch_timeout_ms=batch_timeout_ms,\n            max_records=max_records,\n        ),\n    )\n\n    self.handlers[key] = handler\n\n    def consumer_wrapper(\n        func: Callable[P_HandlerParams, T_HandlerReturn],\n    ) -&gt; HandlerCallWrapper[\n        aiokafka.ConsumerRecord, P_HandlerParams, T_HandlerReturn\n    ]:\n\"\"\"A wrapper function for a consumer handler.\n\n        Args:\n            func : The consumer handler function to be wrapped.\n\n        Returns:\n            The wrapped handler call.\n\n        Raises:\n            NotImplementedError: If silent animals are not supported.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        handler_call, dependant = self._wrap_handler(\n            func=func,\n            extra_dependencies=dependencies,\n            **original_kwargs,\n            topics=topics,\n        )\n\n        handler.add_call(\n            handler=handler_call,\n            filter=filter,\n            middlewares=middlewares,\n            parser=parser or self._global_parser,\n            decoder=decoder or self._global_decoder,\n            dependant=dependant,\n        )\n\n        return handler_call\n\n    return consumer_wrapper\n</code></pre>"},{"location":"api/faststream/kafka/fastapi/KafkaRouter/","title":"KafkaRouter","text":""},{"location":"api/faststream/kafka/fastapi/KafkaRouter/#faststream.kafka.fastapi.KafkaRouter","title":"faststream.kafka.fastapi.KafkaRouter","text":"<p>             Bases: <code>StreamRouter[ConsumerRecord]</code></p> <p>A class to route Kafka streams.</p> <p>Attributes:</p> Name Type Description <code>broker_class</code> <p>class representing the Kafka broker</p> <p>Methods:</p> Name Description <code>_setup_log_context </code> <p>sets up the log context for the main broker and including broker</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/fastapi.py</code> <pre><code>class KafkaRouter(StreamRouter[ConsumerRecord]):\n\"\"\"A class to route Kafka streams.\n\n    Attributes:\n        broker_class : class representing the Kafka broker\n\n    Methods:\n        _setup_log_context : sets up the log context for the main broker and including broker\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    broker_class = KafkaBroker\n\n    @staticmethod\n    def _setup_log_context(\n        main_broker: KafkaBroker,\n        including_broker: KafkaBroker,\n    ) -&gt; None:\n\"\"\"Set up log context for a Kafka broker.\n\n        Args:\n            main_broker: The main Kafka broker.\n            including_broker: The Kafka broker to include in the log context.\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        for h in including_broker.handlers.values():\n            main_broker._setup_log_context(h.topics)\n</code></pre>"},{"location":"api/faststream/kafka/fastapi/KafkaRouter/#faststream.kafka.fastapi.KafkaRouter-attributes","title":"Attributes","text":""},{"location":"api/faststream/kafka/fastapi/KafkaRouter/#faststream.kafka.fastapi.KafkaRouter.broker_class","title":"broker_class  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>broker_class: Type[KafkaBroker] = KafkaBroker\n</code></pre>"},{"location":"api/faststream/kafka/fastapi/KafkaRouter/#faststream.kafka.fastapi.KafkaRouter-functions","title":"Functions","text":""},{"location":"api/faststream/kafka/fastapi/KafkaRouter/#faststream.kafka.fastapi.KafkaRouter.__init__","title":"__init__","text":"<pre><code>__init__(\n    bootstrap_servers: Union[\n        str, Iterable[str]\n    ] = \"localhost\",\n    *,\n    client_id: str = \"faststream-\" + __version__,\n    request_timeout_ms: int = 40 * 1000,\n    retry_backoff_ms: int = 100,\n    metadata_max_age_ms: int = 5 * 60 * 1000,\n    api_version: str = \"auto\",\n    connections_max_idle_ms: int = 540000,\n    security: Optional[BaseSecurity] = None,\n    acks: Union[\n        Literal[0, 1, -1, \"all\"], object\n    ] = _missing,\n    key_serializer: Optional[Callable[[Any], bytes]] = None,\n    value_serializer: Optional[\n        Callable[[Any], bytes]\n    ] = None,\n    compression_type: Optional[\n        Literal[\"gzip\", \"snappy\", \"lz4\", \"zstd\"]\n    ] = None,\n    max_batch_size: int = 16384,\n    partitioner: Callable[\n        [bytes, List[Partition], List[Partition]], Partition\n    ] = DefaultPartitioner(),\n    max_request_size: int = 1048576,\n    linger_ms: int = 0,\n    send_backoff_ms: int = 100,\n    enable_idempotence: bool = False,\n    transactional_id: Optional[str] = None,\n    transaction_timeout_ms: int = 60000,\n    loop: Optional[AbstractEventLoop] = None,\n    prefix: str = \"\",\n    tags: Optional[List[Union[str, Enum]]] = None,\n    dependencies: Optional[Sequence[params.Depends]] = None,\n    default_response_class: Type[Response] = Default(\n        JSONResponse\n    ),\n    responses: Optional[\n        Dict[Union[int, str], Dict[str, Any]]\n    ] = None,\n    callbacks: Optional[List[routing.BaseRoute]] = None,\n    routes: Optional[List[routing.BaseRoute]] = None,\n    redirect_slashes: bool = True,\n    default: Optional[ASGIApp] = None,\n    dependency_overrides_provider: Optional[Any] = None,\n    route_class: Type[APIRoute] = APIRoute,\n    on_startup: Optional[\n        Sequence[Callable[[], Any]]\n    ] = None,\n    on_shutdown: Optional[\n        Sequence[Callable[[], Any]]\n    ] = None,\n    deprecated: Optional[bool] = None,\n    include_in_schema: bool = True,\n    lifespan: Optional[Lifespan[Any]] = None,\n    generate_unique_id_function: Callable[\n        [APIRoute], str\n    ] = Default(generate_unique_id),\n    apply_types: bool = True,\n    decoder: Optional[\n        CustomDecoder[aiokafka.ConsumerRecord]\n    ] = None,\n    parser: Optional[\n        CustomParser[aiokafka.ConsumerRecord]\n    ] = None,\n    middlewares: Optional[\n        Sequence[\n            Callable[\n                [aiokafka.ConsumerRecord], BaseMiddleware\n            ]\n        ]\n    ] = None,\n    protocol: str = \"kafka\",\n    protocol_version: str = \"auto\",\n    description: Optional[str] = None,\n    asyncapi_tags: Optional[Sequence[asyncapi.Tag]] = None,\n    schema_url: Optional[str] = \"/asyncapi\",\n    logger: Optional[logging.Logger] = access_logger,\n    log_level: int = logging.INFO,\n    log_fmt: Optional[str] = None,\n    **kwargs: Any\n) -&gt; None\n</code></pre>"},{"location":"api/faststream/kafka/fastapi/KafkaRouter/#faststream.kafka.fastapi.KafkaRouter.publisher","title":"publisher","text":"<pre><code>publisher(\n    topic: str,\n    key: Optional[bytes] = None,\n    partition: Optional[int] = None,\n    timestamp_ms: Optional[int] = None,\n    headers: Optional[Dict[str, str]] = None,\n    reply_to: str = \"\",\n    batch: bool = False,\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n) -&gt; Publisher\n</code></pre>"},{"location":"api/faststream/kafka/handler/LogicHandler/","title":"LogicHandler","text":""},{"location":"api/faststream/kafka/handler/LogicHandler/#faststream.kafka.handler.LogicHandler","title":"faststream.kafka.handler.LogicHandler","text":"<p>             Bases: <code>AsyncHandler[ConsumerRecord]</code></p> <p>A class to handle logic for consuming messages from Kafka.</p> <p>Attributes:</p> Name Type Description <code>topics</code> <p>sequence of strings representing the topics to consume from</p> <code>group_id</code> <p>optional string representing the consumer group ID</p> <code>consumer</code> <p>optional AIOKafkaConsumer object representing the Kafka consumer</p> <code>task</code> <p>optional asyncio.Task object representing the task for consuming messages</p> <code>batch</code> <p>boolean indicating whether to consume messages in batches</p> <p>Methods:</p> Name Description <code>__init__ </code> <p>constructor method for the LogicHandler class</p> <code>start </code> <p>method to start consuming messages from Kafka</p> <code>close </code> <p>method to close the Kafka consumer and cancel the consuming task</p> <code>add_call </code> <p>method to add a handler call for processing consumed messages</p> <code>_consume </code> <p>method to consume messages from Kafka and call the appropriate handler</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/handler.py</code> <pre><code>class LogicHandler(AsyncHandler[ConsumerRecord]):\n\"\"\"A class to handle logic for consuming messages from Kafka.\n\n    Attributes:\n        topics : sequence of strings representing the topics to consume from\n        group_id : optional string representing the consumer group ID\n        consumer : optional AIOKafkaConsumer object representing the Kafka consumer\n        task : optional asyncio.Task object representing the task for consuming messages\n        batch : boolean indicating whether to consume messages in batches\n\n    Methods:\n        __init__ : constructor method for the LogicHandler class\n        start : method to start consuming messages from Kafka\n        close : method to close the Kafka consumer and cancel the consuming task\n        add_call : method to add a handler call for processing consumed messages\n        _consume : method to consume messages from Kafka and call the appropriate handler\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    topics: Sequence[str]\n    group_id: Optional[str] = None\n\n    consumer: Optional[AIOKafkaConsumer] = None\n    task: Optional[\"asyncio.Task[Any]\"] = None\n    batch: bool = False\n\n    @override\n    def __init__(\n        self,\n        *topics: str,\n        # Kafka information\n        group_id: Optional[str] = None,\n        client_id: str = \"faststream-\" + __version__,\n        builder: Callable[..., AIOKafkaConsumer],\n        batch: bool = False,\n        batch_timeout_ms: int = 200,\n        max_records: Optional[int] = None,\n        # AsyncAPI information\n        title: Optional[str] = None,\n        description: Optional[str] = None,\n    ):\n\"\"\"Initialize a Kafka consumer for the specified topics.\n\n        Args:\n            *topics: Variable length argument list of topics to consume from.\n            group_id: Optional group ID for the consumer.\n            client_id: Client ID for the consumer.\n            builder: Callable that constructs an AIOKafkaConsumer instance.\n            batch: Flag indicating whether to consume messages in batches.\n            batch_timeout_ms: Timeout in milliseconds for batch consumption.\n            max_records: Maximum number of records to consume in a batch.\n            title: Optional title for the consumer.\n            description: Optional description for the consumer.\n\n        Raises:\n            NotImplementedError: If silent animals are not supported.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        super().__init__(\n            description=description,\n            title=title,\n        )\n\n        self.group_id = group_id\n        self.client_id = client_id\n        self.topics = topics\n\n        self.batch = batch\n        self.batch_timeout_ms = batch_timeout_ms\n        self.max_records = max_records\n\n        self.builder = builder\n        self.task = None\n        self.consumer = None\n\n    # TODO: use **kwargs: Unpack[ConsumerConnectionParams] with py3.12 release 2023-10-02\n    async def start(self, **consumer_kwargs: Any) -&gt; None:\n\"\"\"Start the consumer.\n\n        Args:\n            **consumer_kwargs: Additional keyword arguments to pass to the consumer.\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        self.consumer = consumer = self.builder(\n            *self.topics,\n            group_id=self.group_id,\n            client_id=self.client_id,\n            **consumer_kwargs,\n        )\n        await consumer.start()\n        self.task = asyncio.create_task(self._consume())\n\n    async def close(self) -&gt; None:\n        if self.consumer is not None:\n            await self.consumer.stop()\n            self.consumer = None\n\n        if self.task is not None:\n            self.task.cancel()\n            self.task = None\n\n    def add_call(\n        self,\n        *,\n        handler: HandlerCallWrapper[ConsumerRecord, P_HandlerParams, T_HandlerReturn],\n        dependant: CallModel[P_HandlerParams, T_HandlerReturn],\n        parser: Optional[\n            Union[\n                CustomParser[ConsumerRecord],\n                CustomParser[Tuple[ConsumerRecord, ...]],\n            ]\n        ],\n        decoder: Optional[\n            Union[\n                CustomDecoder[ConsumerRecord],\n                CustomDecoder[Tuple[ConsumerRecord, ...]],\n            ]\n        ],\n        filter: Union[\n            Filter[KafkaMessage],\n            Filter[StreamMessage[Tuple[ConsumerRecord, ...]]],\n        ],\n        middlewares: Optional[Sequence[Callable[[ConsumerRecord], BaseMiddleware]]],\n    ) -&gt; None:\n\"\"\"Adds a call to the handler.\n\n        Args:\n            handler: The handler function to be called.\n            dependant: The dependant model.\n            parser: Optional custom parser for parsing the input.\n            decoder: Optional custom decoder for decoding the input.\n            filter: The filter for filtering the input.\n            middlewares: Optional sequence of middlewares to be applied.\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        parser_ = resolve_custom_func(\n            parser,\n            (\n                AioKafkaParser.parse_message_batch\n                if self.batch\n                else AioKafkaParser.parse_message\n            ),\n        )\n        decoder_ = resolve_custom_func(\n            decoder,  # type: ignore[arg-type]\n            (\n                AioKafkaParser.decode_message_batch  # type: ignore[arg-type]\n                if self.batch\n                else AioKafkaParser.decode_message\n            ),\n        )\n        super().add_call(\n            handler=handler,\n            parser=parser_,\n            decoder=decoder_,\n            filter=filter,  # type: ignore[arg-type]\n            dependant=dependant,\n            middlewares=middlewares,\n        )\n\n    async def _consume(self) -&gt; Never:\n        assert self.consumer, \"You need to start handler first\"  # nosec B101\n\n        connected = True\n        while True:\n            try:\n                if self.batch:\n                    messages = await self.consumer.getmany(\n                        timeout_ms=self.batch_timeout_ms,\n                        max_records=self.max_records,\n                    )\n                    if not messages:\n                        await anyio.sleep(self.batch_timeout_ms / 1000)\n                        continue\n                    msg = tuple(chain(*messages.values()))\n                else:\n                    msg = await self.consumer.getone()\n\n            except Exception:\n                if connected is True:\n                    connected = False\n                await anyio.sleep(5)\n\n            else:\n                if connected is False:\n                    connected = True\n                await self.consume(msg)\n</code></pre>"},{"location":"api/faststream/kafka/handler/LogicHandler/#faststream.kafka.handler.LogicHandler-attributes","title":"Attributes","text":""},{"location":"api/faststream/kafka/handler/LogicHandler/#faststream.kafka.handler.LogicHandler.batch","title":"batch  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>batch: bool = batch\n</code></pre>"},{"location":"api/faststream/kafka/handler/LogicHandler/#faststream.kafka.handler.LogicHandler.batch_timeout_ms","title":"batch_timeout_ms  <code>instance-attribute</code>","text":"<pre><code>batch_timeout_ms = batch_timeout_ms\n</code></pre>"},{"location":"api/faststream/kafka/handler/LogicHandler/#faststream.kafka.handler.LogicHandler.builder","title":"builder  <code>instance-attribute</code>","text":"<pre><code>builder = builder\n</code></pre>"},{"location":"api/faststream/kafka/handler/LogicHandler/#faststream.kafka.handler.LogicHandler.client_id","title":"client_id  <code>instance-attribute</code>","text":"<pre><code>client_id = client_id\n</code></pre>"},{"location":"api/faststream/kafka/handler/LogicHandler/#faststream.kafka.handler.LogicHandler.consumer","title":"consumer  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>consumer: Optional[AIOKafkaConsumer] = None\n</code></pre>"},{"location":"api/faststream/kafka/handler/LogicHandler/#faststream.kafka.handler.LogicHandler.group_id","title":"group_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>group_id: Optional[str] = group_id\n</code></pre>"},{"location":"api/faststream/kafka/handler/LogicHandler/#faststream.kafka.handler.LogicHandler.max_records","title":"max_records  <code>instance-attribute</code>","text":"<pre><code>max_records = max_records\n</code></pre>"},{"location":"api/faststream/kafka/handler/LogicHandler/#faststream.kafka.handler.LogicHandler.task","title":"task  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>task: Optional[asyncio.Task[Any]] = None\n</code></pre>"},{"location":"api/faststream/kafka/handler/LogicHandler/#faststream.kafka.handler.LogicHandler.topics","title":"topics  <code>instance-attribute</code>","text":"<pre><code>topics: Sequence[str] = topics\n</code></pre>"},{"location":"api/faststream/kafka/handler/LogicHandler/#faststream.kafka.handler.LogicHandler-functions","title":"Functions","text":""},{"location":"api/faststream/kafka/handler/LogicHandler/#faststream.kafka.handler.LogicHandler.__init__","title":"__init__","text":"<pre><code>__init__(\n    *topics: str,\n    group_id: Optional[str] = None,\n    client_id: str = \"faststream-\" + __version__,\n    builder: Callable[..., AIOKafkaConsumer],\n    batch: bool = False,\n    batch_timeout_ms: int = 200,\n    max_records: Optional[int] = None,\n    title: Optional[str] = None,\n    description: Optional[str] = None\n)\n</code></pre> <p>Initialize a Kafka consumer for the specified topics.</p> <p>Parameters:</p> Name Type Description Default <code>*topics</code> <code>str</code> <p>Variable length argument list of topics to consume from.</p> <code>()</code> <code>group_id</code> <code>Optional[str]</code> <p>Optional group ID for the consumer.</p> <code>None</code> <code>client_id</code> <code>str</code> <p>Client ID for the consumer.</p> <code>'faststream-' + __version__</code> <code>builder</code> <code>Callable[..., AIOKafkaConsumer]</code> <p>Callable that constructs an AIOKafkaConsumer instance.</p> required <code>batch</code> <code>bool</code> <p>Flag indicating whether to consume messages in batches.</p> <code>False</code> <code>batch_timeout_ms</code> <code>int</code> <p>Timeout in milliseconds for batch consumption.</p> <code>200</code> <code>max_records</code> <code>Optional[int]</code> <p>Maximum number of records to consume in a batch.</p> <code>None</code> <code>title</code> <code>Optional[str]</code> <p>Optional title for the consumer.</p> <code>None</code> <code>description</code> <code>Optional[str]</code> <p>Optional description for the consumer.</p> <code>None</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If silent animals are not supported.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/handler.py</code> <pre><code>@override\ndef __init__(\n    self,\n    *topics: str,\n    # Kafka information\n    group_id: Optional[str] = None,\n    client_id: str = \"faststream-\" + __version__,\n    builder: Callable[..., AIOKafkaConsumer],\n    batch: bool = False,\n    batch_timeout_ms: int = 200,\n    max_records: Optional[int] = None,\n    # AsyncAPI information\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n):\n\"\"\"Initialize a Kafka consumer for the specified topics.\n\n    Args:\n        *topics: Variable length argument list of topics to consume from.\n        group_id: Optional group ID for the consumer.\n        client_id: Client ID for the consumer.\n        builder: Callable that constructs an AIOKafkaConsumer instance.\n        batch: Flag indicating whether to consume messages in batches.\n        batch_timeout_ms: Timeout in milliseconds for batch consumption.\n        max_records: Maximum number of records to consume in a batch.\n        title: Optional title for the consumer.\n        description: Optional description for the consumer.\n\n    Raises:\n        NotImplementedError: If silent animals are not supported.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    super().__init__(\n        description=description,\n        title=title,\n    )\n\n    self.group_id = group_id\n    self.client_id = client_id\n    self.topics = topics\n\n    self.batch = batch\n    self.batch_timeout_ms = batch_timeout_ms\n    self.max_records = max_records\n\n    self.builder = builder\n    self.task = None\n    self.consumer = None\n</code></pre>"},{"location":"api/faststream/kafka/handler/LogicHandler/#faststream.kafka.handler.LogicHandler.add_call","title":"add_call","text":"<pre><code>add_call(\n    *,\n    handler: HandlerCallWrapper[\n        ConsumerRecord, P_HandlerParams, T_HandlerReturn\n    ],\n    dependant: CallModel[P_HandlerParams, T_HandlerReturn],\n    parser: Optional[\n        Union[\n            CustomParser[ConsumerRecord],\n            CustomParser[Tuple[ConsumerRecord, ...]],\n        ]\n    ],\n    decoder: Optional[\n        Union[\n            CustomDecoder[ConsumerRecord],\n            CustomDecoder[Tuple[ConsumerRecord, ...]],\n        ]\n    ],\n    filter: Union[\n        Filter[KafkaMessage],\n        Filter[StreamMessage[Tuple[ConsumerRecord, ...]]],\n    ],\n    middlewares: Optional[\n        Sequence[Callable[[ConsumerRecord], BaseMiddleware]]\n    ]\n) -&gt; None\n</code></pre> <p>Adds a call to the handler.</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>HandlerCallWrapper[ConsumerRecord, P_HandlerParams, T_HandlerReturn]</code> <p>The handler function to be called.</p> required <code>dependant</code> <code>CallModel[P_HandlerParams, T_HandlerReturn]</code> <p>The dependant model.</p> required <code>parser</code> <code>Optional[Union[CustomParser[ConsumerRecord], CustomParser[Tuple[ConsumerRecord, ...]]]]</code> <p>Optional custom parser for parsing the input.</p> required <code>decoder</code> <code>Optional[Union[CustomDecoder[ConsumerRecord], CustomDecoder[Tuple[ConsumerRecord, ...]]]]</code> <p>Optional custom decoder for decoding the input.</p> required <code>filter</code> <code>Union[Filter[KafkaMessage], Filter[StreamMessage[Tuple[ConsumerRecord, ...]]]]</code> <p>The filter for filtering the input.</p> required <code>middlewares</code> <code>Optional[Sequence[Callable[[ConsumerRecord], BaseMiddleware]]]</code> <p>Optional sequence of middlewares to be applied.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/handler.py</code> <pre><code>def add_call(\n    self,\n    *,\n    handler: HandlerCallWrapper[ConsumerRecord, P_HandlerParams, T_HandlerReturn],\n    dependant: CallModel[P_HandlerParams, T_HandlerReturn],\n    parser: Optional[\n        Union[\n            CustomParser[ConsumerRecord],\n            CustomParser[Tuple[ConsumerRecord, ...]],\n        ]\n    ],\n    decoder: Optional[\n        Union[\n            CustomDecoder[ConsumerRecord],\n            CustomDecoder[Tuple[ConsumerRecord, ...]],\n        ]\n    ],\n    filter: Union[\n        Filter[KafkaMessage],\n        Filter[StreamMessage[Tuple[ConsumerRecord, ...]]],\n    ],\n    middlewares: Optional[Sequence[Callable[[ConsumerRecord], BaseMiddleware]]],\n) -&gt; None:\n\"\"\"Adds a call to the handler.\n\n    Args:\n        handler: The handler function to be called.\n        dependant: The dependant model.\n        parser: Optional custom parser for parsing the input.\n        decoder: Optional custom decoder for decoding the input.\n        filter: The filter for filtering the input.\n        middlewares: Optional sequence of middlewares to be applied.\n\n    Returns:\n        None\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    parser_ = resolve_custom_func(\n        parser,\n        (\n            AioKafkaParser.parse_message_batch\n            if self.batch\n            else AioKafkaParser.parse_message\n        ),\n    )\n    decoder_ = resolve_custom_func(\n        decoder,  # type: ignore[arg-type]\n        (\n            AioKafkaParser.decode_message_batch  # type: ignore[arg-type]\n            if self.batch\n            else AioKafkaParser.decode_message\n        ),\n    )\n    super().add_call(\n        handler=handler,\n        parser=parser_,\n        decoder=decoder_,\n        filter=filter,  # type: ignore[arg-type]\n        dependant=dependant,\n        middlewares=middlewares,\n    )\n</code></pre>"},{"location":"api/faststream/kafka/handler/LogicHandler/#faststream.kafka.handler.LogicHandler.close","title":"close  <code>async</code>","text":"<pre><code>close() -&gt; None\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/handler.py</code> <pre><code>async def close(self) -&gt; None:\n    if self.consumer is not None:\n        await self.consumer.stop()\n        self.consumer = None\n\n    if self.task is not None:\n        self.task.cancel()\n        self.task = None\n</code></pre>"},{"location":"api/faststream/kafka/handler/LogicHandler/#faststream.kafka.handler.LogicHandler.start","title":"start  <code>async</code>","text":"<pre><code>start(**consumer_kwargs: Any) -&gt; None\n</code></pre> <p>Start the consumer.</p> <p>Parameters:</p> Name Type Description Default <code>**consumer_kwargs</code> <code>Any</code> <p>Additional keyword arguments to pass to the consumer.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/handler.py</code> <pre><code>async def start(self, **consumer_kwargs: Any) -&gt; None:\n\"\"\"Start the consumer.\n\n    Args:\n        **consumer_kwargs: Additional keyword arguments to pass to the consumer.\n\n    Returns:\n        None\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    self.consumer = consumer = self.builder(\n        *self.topics,\n        group_id=self.group_id,\n        client_id=self.client_id,\n        **consumer_kwargs,\n    )\n    await consumer.start()\n    self.task = asyncio.create_task(self._consume())\n</code></pre>"},{"location":"api/faststream/kafka/message/KafkaMessage/","title":"KafkaMessage","text":""},{"location":"api/faststream/kafka/message/KafkaMessage/#faststream.kafka.message.KafkaMessage","title":"faststream.kafka.message.KafkaMessage","text":"<p>             Bases: <code>StreamMessage[ConsumerRecord]</code></p> <p>Represents a Kafka message in the FastStream framework.</p> <p>This class extends <code>StreamMessage</code> and is specialized for handling Kafka ConsumerRecord objects.</p> <p>Methods:</p> Name Description <code>ack</code> <p>Acknowledge the Kafka message.</p> <code>nack</code> <p>Negative acknowledgment of the Kafka message.</p> <code>reject</code> <p>Reject the Kafka message.</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/message.py</code> <pre><code>class KafkaMessage(StreamMessage[aiokafka.ConsumerRecord]):\n\"\"\"\n    Represents a Kafka message in the FastStream framework.\n\n    This class extends `StreamMessage` and is specialized for handling Kafka ConsumerRecord objects.\n\n    Methods:\n        ack(**kwargs) -&gt; None:\n            Acknowledge the Kafka message.\n\n        nack(**kwargs) -&gt; None:\n            Negative acknowledgment of the Kafka message.\n\n        reject(**kwargs) -&gt; None:\n            Reject the Kafka message.\n    \"\"\"\n\n    async def ack(self, **kwargs: Any) -&gt; None:\n\"\"\"\n        Acknowledge the Kafka message.\n\n        Args:\n            **kwargs (Any): Additional keyword arguments.\n\n        Returns:\n            None: This method does not return a value.\n        \"\"\"\n        return None\n\n    async def nack(self, **kwargs: Any) -&gt; None:\n\"\"\"\n        Negative acknowledgment of the Kafka message.\n\n        Args:\n            **kwargs (Any): Additional keyword arguments.\n\n        Returns:\n            None: This method does not return a value.\n        \"\"\"\n        return None\n\n    async def reject(self, **kwargs: Any) -&gt; None:\n\"\"\"\n        Reject the Kafka message.\n\n        Args:\n            **kwargs (Any): Additional keyword arguments.\n\n        Returns:\n            None: This method does not return a value.\n        \"\"\"\n        return None\n</code></pre>"},{"location":"api/faststream/kafka/message/KafkaMessage/#faststream.kafka.message.KafkaMessage-functions","title":"Functions","text":""},{"location":"api/faststream/kafka/message/KafkaMessage/#faststream.kafka.message.KafkaMessage.ack","title":"ack  <code>async</code>","text":"<pre><code>ack(**kwargs: Any) -&gt; None\n</code></pre> <p>Acknowledge the Kafka message.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>This method does not return a value.</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/message.py</code> <pre><code>async def ack(self, **kwargs: Any) -&gt; None:\n\"\"\"\n    Acknowledge the Kafka message.\n\n    Args:\n        **kwargs (Any): Additional keyword arguments.\n\n    Returns:\n        None: This method does not return a value.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"api/faststream/kafka/message/KafkaMessage/#faststream.kafka.message.KafkaMessage.nack","title":"nack  <code>async</code>","text":"<pre><code>nack(**kwargs: Any) -&gt; None\n</code></pre> <p>Negative acknowledgment of the Kafka message.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>This method does not return a value.</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/message.py</code> <pre><code>async def nack(self, **kwargs: Any) -&gt; None:\n\"\"\"\n    Negative acknowledgment of the Kafka message.\n\n    Args:\n        **kwargs (Any): Additional keyword arguments.\n\n    Returns:\n        None: This method does not return a value.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"api/faststream/kafka/message/KafkaMessage/#faststream.kafka.message.KafkaMessage.reject","title":"reject  <code>async</code>","text":"<pre><code>reject(**kwargs: Any) -&gt; None\n</code></pre> <p>Reject the Kafka message.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>This method does not return a value.</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/message.py</code> <pre><code>async def reject(self, **kwargs: Any) -&gt; None:\n\"\"\"\n    Reject the Kafka message.\n\n    Args:\n        **kwargs (Any): Additional keyword arguments.\n\n    Returns:\n        None: This method does not return a value.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"api/faststream/kafka/parser/AioKafkaParser/","title":"AioKafkaParser","text":""},{"location":"api/faststream/kafka/parser/AioKafkaParser/#faststream.kafka.parser.AioKafkaParser","title":"faststream.kafka.parser.AioKafkaParser","text":"Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/parser.py</code> <pre><code>class AioKafkaParser:\n    @staticmethod\n    async def parse_message(\n        message: ConsumerRecord,\n    ) -&gt; StreamMessage[ConsumerRecord]:\n\"\"\"Parses a Kafka message.\n\n        Args:\n            message: The Kafka message to parse.\n\n        Returns:\n            A StreamMessage object representing the parsed message.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        headers = {i: j.decode() for i, j in message.headers}\n        return KafkaMessage(\n            body=message.value,\n            headers=headers,\n            reply_to=headers.get(\"reply_to\", \"\"),\n            content_type=headers.get(\"content-type\"),\n            message_id=f\"{message.offset}-{message.timestamp}\",\n            correlation_id=headers.get(\"correlation_id\", str(uuid4())),\n            raw_message=message,\n        )\n\n    @staticmethod\n    async def parse_message_batch(\n        message: Tuple[ConsumerRecord, ...],\n    ) -&gt; StreamMessage[Tuple[ConsumerRecord, ...]]:\n\"\"\"Parses a batch of messages from a Kafka consumer.\n\n        Args:\n            message : A tuple of ConsumerRecord objects representing the messages to parse.\n\n        Returns:\n            A StreamMessage object containing the parsed messages.\n\n        Raises:\n            NotImplementedError: If any of the messages are silent (i.e., have no sound).\n\n        Static Method:\n            This method is a static method. It does not require an instance of the class to be called.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        first = message[0]\n        last = message[-1]\n        headers = {i: j.decode() for i, j in first.headers}\n        return KafkaMessage(\n            body=[m.value for m in message],\n            headers=headers,\n            reply_to=headers.get(\"reply_to\", \"\"),\n            content_type=headers.get(\"content-type\"),\n            message_id=f\"{first.offset}-{last.offset}-{first.timestamp}\",\n            correlation_id=headers.get(\"correlation_id\", str(uuid4())),\n            raw_message=message,\n        )\n\n    @staticmethod\n    async def decode_message(msg: StreamMessage[ConsumerRecord]) -&gt; DecodedMessage:\n\"\"\"Decodes a message.\n\n        Args:\n            msg: The message to be decoded.\n\n        Returns:\n            The decoded message.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        return decode_message(msg)\n\n    @classmethod\n    async def decode_message_batch(\n        cls, msg: StreamMessage[Tuple[ConsumerRecord, ...]]\n    ) -&gt; List[DecodedMessage]:\n\"\"\"Decode a batch of messages.\n\n        Args:\n            msg: A stream message containing a tuple of consumer records.\n\n        Returns:\n            A list of decoded messages.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        return [decode_message(await cls.parse_message(m)) for m in msg.raw_message]\n</code></pre>"},{"location":"api/faststream/kafka/parser/AioKafkaParser/#faststream.kafka.parser.AioKafkaParser-functions","title":"Functions","text":""},{"location":"api/faststream/kafka/parser/AioKafkaParser/#faststream.kafka.parser.AioKafkaParser.decode_message","title":"decode_message  <code>async</code> <code>staticmethod</code>","text":"<pre><code>decode_message(\n    msg: StreamMessage[ConsumerRecord],\n) -&gt; DecodedMessage\n</code></pre> <p>Decodes a message.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>StreamMessage[ConsumerRecord]</code> <p>The message to be decoded.</p> required <p>Returns:</p> Type Description <code>DecodedMessage</code> <p>The decoded message.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/parser.py</code> <pre><code>@staticmethod\nasync def decode_message(msg: StreamMessage[ConsumerRecord]) -&gt; DecodedMessage:\n\"\"\"Decodes a message.\n\n    Args:\n        msg: The message to be decoded.\n\n    Returns:\n        The decoded message.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    return decode_message(msg)\n</code></pre>"},{"location":"api/faststream/kafka/parser/AioKafkaParser/#faststream.kafka.parser.AioKafkaParser.decode_message_batch","title":"decode_message_batch  <code>async</code> <code>classmethod</code>","text":"<pre><code>decode_message_batch(\n    msg: StreamMessage[Tuple[ConsumerRecord, ...]]\n) -&gt; List[DecodedMessage]\n</code></pre> <p>Decode a batch of messages.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>StreamMessage[Tuple[ConsumerRecord, ...]]</code> <p>A stream message containing a tuple of consumer records.</p> required <p>Returns:</p> Type Description <code>List[DecodedMessage]</code> <p>A list of decoded messages.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/parser.py</code> <pre><code>@classmethod\nasync def decode_message_batch(\n    cls, msg: StreamMessage[Tuple[ConsumerRecord, ...]]\n) -&gt; List[DecodedMessage]:\n\"\"\"Decode a batch of messages.\n\n    Args:\n        msg: A stream message containing a tuple of consumer records.\n\n    Returns:\n        A list of decoded messages.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    return [decode_message(await cls.parse_message(m)) for m in msg.raw_message]\n</code></pre>"},{"location":"api/faststream/kafka/parser/AioKafkaParser/#faststream.kafka.parser.AioKafkaParser.parse_message","title":"parse_message  <code>async</code> <code>staticmethod</code>","text":"<pre><code>parse_message(\n    message: ConsumerRecord,\n) -&gt; StreamMessage[ConsumerRecord]\n</code></pre> <p>Parses a Kafka message.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>ConsumerRecord</code> <p>The Kafka message to parse.</p> required <p>Returns:</p> Type Description <code>StreamMessage[ConsumerRecord]</code> <p>A StreamMessage object representing the parsed message.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/parser.py</code> <pre><code>@staticmethod\nasync def parse_message(\n    message: ConsumerRecord,\n) -&gt; StreamMessage[ConsumerRecord]:\n\"\"\"Parses a Kafka message.\n\n    Args:\n        message: The Kafka message to parse.\n\n    Returns:\n        A StreamMessage object representing the parsed message.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    headers = {i: j.decode() for i, j in message.headers}\n    return KafkaMessage(\n        body=message.value,\n        headers=headers,\n        reply_to=headers.get(\"reply_to\", \"\"),\n        content_type=headers.get(\"content-type\"),\n        message_id=f\"{message.offset}-{message.timestamp}\",\n        correlation_id=headers.get(\"correlation_id\", str(uuid4())),\n        raw_message=message,\n    )\n</code></pre>"},{"location":"api/faststream/kafka/parser/AioKafkaParser/#faststream.kafka.parser.AioKafkaParser.parse_message_batch","title":"parse_message_batch  <code>async</code> <code>staticmethod</code>","text":"<pre><code>parse_message_batch(\n    message: Tuple[ConsumerRecord, ...]\n) -&gt; StreamMessage[Tuple[ConsumerRecord, ...]]\n</code></pre> <p>Parses a batch of messages from a Kafka consumer.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <p>A tuple of ConsumerRecord objects representing the messages to parse.</p> required <p>Returns:</p> Type Description <code>StreamMessage[Tuple[ConsumerRecord, ...]]</code> <p>A StreamMessage object containing the parsed messages.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If any of the messages are silent (i.e., have no sound).</p> Static Method <p>This method is a static method. It does not require an instance of the class to be called.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/parser.py</code> <pre><code>@staticmethod\nasync def parse_message_batch(\n    message: Tuple[ConsumerRecord, ...],\n) -&gt; StreamMessage[Tuple[ConsumerRecord, ...]]:\n\"\"\"Parses a batch of messages from a Kafka consumer.\n\n    Args:\n        message : A tuple of ConsumerRecord objects representing the messages to parse.\n\n    Returns:\n        A StreamMessage object containing the parsed messages.\n\n    Raises:\n        NotImplementedError: If any of the messages are silent (i.e., have no sound).\n\n    Static Method:\n        This method is a static method. It does not require an instance of the class to be called.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    first = message[0]\n    last = message[-1]\n    headers = {i: j.decode() for i, j in first.headers}\n    return KafkaMessage(\n        body=[m.value for m in message],\n        headers=headers,\n        reply_to=headers.get(\"reply_to\", \"\"),\n        content_type=headers.get(\"content-type\"),\n        message_id=f\"{first.offset}-{last.offset}-{first.timestamp}\",\n        correlation_id=headers.get(\"correlation_id\", str(uuid4())),\n        raw_message=message,\n    )\n</code></pre>"},{"location":"api/faststream/kafka/producer/AioKafkaFastProducer/","title":"AioKafkaFastProducer","text":""},{"location":"api/faststream/kafka/producer/AioKafkaFastProducer/#faststream.kafka.producer.AioKafkaFastProducer","title":"faststream.kafka.producer.AioKafkaFastProducer","text":"<p>A class to represent a fast Kafka producer.</p> <p>Attributes:</p> Name Type Description <code>_producer</code> <p>AIOKafkaProducer object representing the Kafka producer</p> <p>Methods:</p> Name Description <code>publish </code> <p>Publishes a message to a Kafka topic.</p> <code>stop </code> <p>Stops the Kafka producer.</p> <code>publish_batch </code> <p>Publishes a batch of messages to a Kafka topic.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/producer.py</code> <pre><code>class AioKafkaFastProducer:\n\"\"\"A class to represent a fast Kafka producer.\n\n    Attributes:\n        _producer : AIOKafkaProducer object representing the Kafka producer\n\n    Methods:\n        publish : Publishes a message to a Kafka topic.\n        stop : Stops the Kafka producer.\n        publish_batch : Publishes a batch of messages to a Kafka topic.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    _producer: Optional[AIOKafkaProducer]\n\n    def __init__(\n        self,\n        producer: AIOKafkaProducer,\n    ):\n\"\"\"Initialize the class.\n\n        Args:\n            producer: An instance of AIOKafkaProducer.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        self._producer = producer\n\n    async def publish(\n        self,\n        message: SendableMessage,\n        topic: str,\n        key: Optional[bytes] = None,\n        partition: Optional[int] = None,\n        timestamp_ms: Optional[int] = None,\n        headers: Optional[Dict[str, str]] = None,\n        correlation_id: Optional[str] = None,\n        *,\n        reply_to: str = \"\",\n    ) -&gt; None:\n\"\"\"Publish a message to a topic.\n\n        Args:\n            message: The message to be published.\n            topic: The topic to publish the message to.\n            key: The key associated with the message.\n            partition: The partition to which the message should be sent.\n            timestamp_ms: The timestamp of the message in milliseconds.\n            headers: Additional headers to be included with the message.\n            correlation_id: The correlation ID of the message.\n            reply_to: The topic to which the reply should be sent.\n\n        Returns:\n            None\n\n        Raises:\n            AssertionError: If the broker is not connected.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        assert self._producer, \"You need to connect broker at first\"  # nosec B101\n\n        message, content_type = encode_message(message)\n\n        headers_to_send = {\n            \"content-type\": content_type or \"\",\n            \"correlation_id\": correlation_id or str(uuid4()),\n            **(headers or {}),\n        }\n\n        if reply_to:\n            headers_to_send.update({\"reply_to\": reply_to})\n\n        await self._producer.send(\n            topic=topic,\n            value=message,\n            key=key,\n            partition=partition,\n            timestamp_ms=timestamp_ms,\n            headers=[(i, (j or \"\").encode()) for i, j in headers_to_send.items()],\n        )\n\n        return None\n\n    async def stop(self) -&gt; None:\n        if self._producer is not None:  # pragma: no branch\n            await self._producer.stop()\n\n    async def publish_batch(\n        self,\n        *msgs: SendableMessage,\n        topic: str,\n        partition: Optional[int] = None,\n        timestamp_ms: Optional[int] = None,\n        headers: Optional[Dict[str, str]] = None,\n    ) -&gt; None:\n\"\"\"Publish a batch of messages to a topic.\n\n        Args:\n            *msgs: Variable length argument list of messages to be sent.\n            topic: The topic to which the messages should be published.\n            partition: The partition to which the messages should be sent. Defaults to None.\n            timestamp_ms: The timestamp to be associated with the messages. Defaults to None.\n            headers: Additional headers to be included with the messages. Defaults to None.\n\n        Returns:\n            None\n\n        Raises:\n            AssertionError: If the broker is not connected.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        assert self._producer, \"You need to connect broker at first\"  # nosec B101\n\n        batch = self._producer.create_batch()\n\n        for msg in msgs:\n            message, content_type = encode_message(msg)\n\n            headers_to_send = {\n                \"content-type\": content_type or \"\",\n                **(headers or {}),\n            }\n\n            batch.append(\n                key=None,\n                value=message,\n                timestamp=timestamp_ms,\n                headers=[(i, j.encode()) for i, j in headers_to_send.items()],\n            )\n\n        await self._producer.send_batch(batch, topic, partition=partition)\n</code></pre>"},{"location":"api/faststream/kafka/producer/AioKafkaFastProducer/#faststream.kafka.producer.AioKafkaFastProducer-functions","title":"Functions","text":""},{"location":"api/faststream/kafka/producer/AioKafkaFastProducer/#faststream.kafka.producer.AioKafkaFastProducer.__init__","title":"__init__","text":"<pre><code>__init__(producer: AIOKafkaProducer)\n</code></pre> <p>Initialize the class.</p> <p>Parameters:</p> Name Type Description Default <code>producer</code> <code>AIOKafkaProducer</code> <p>An instance of AIOKafkaProducer.</p> required <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/producer.py</code> <pre><code>def __init__(\n    self,\n    producer: AIOKafkaProducer,\n):\n\"\"\"Initialize the class.\n\n    Args:\n        producer: An instance of AIOKafkaProducer.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    self._producer = producer\n</code></pre>"},{"location":"api/faststream/kafka/producer/AioKafkaFastProducer/#faststream.kafka.producer.AioKafkaFastProducer.publish","title":"publish  <code>async</code>","text":"<pre><code>publish(\n    message: SendableMessage,\n    topic: str,\n    key: Optional[bytes] = None,\n    partition: Optional[int] = None,\n    timestamp_ms: Optional[int] = None,\n    headers: Optional[Dict[str, str]] = None,\n    correlation_id: Optional[str] = None,\n    *,\n    reply_to: str = \"\"\n) -&gt; None\n</code></pre> <p>Publish a message to a topic.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>SendableMessage</code> <p>The message to be published.</p> required <code>topic</code> <code>str</code> <p>The topic to publish the message to.</p> required <code>key</code> <code>Optional[bytes]</code> <p>The key associated with the message.</p> <code>None</code> <code>partition</code> <code>Optional[int]</code> <p>The partition to which the message should be sent.</p> <code>None</code> <code>timestamp_ms</code> <code>Optional[int]</code> <p>The timestamp of the message in milliseconds.</p> <code>None</code> <code>headers</code> <code>Optional[Dict[str, str]]</code> <p>Additional headers to be included with the message.</p> <code>None</code> <code>correlation_id</code> <code>Optional[str]</code> <p>The correlation ID of the message.</p> <code>None</code> <code>reply_to</code> <code>str</code> <p>The topic to which the reply should be sent.</p> <code>''</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If the broker is not connected.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/producer.py</code> <pre><code>async def publish(\n    self,\n    message: SendableMessage,\n    topic: str,\n    key: Optional[bytes] = None,\n    partition: Optional[int] = None,\n    timestamp_ms: Optional[int] = None,\n    headers: Optional[Dict[str, str]] = None,\n    correlation_id: Optional[str] = None,\n    *,\n    reply_to: str = \"\",\n) -&gt; None:\n\"\"\"Publish a message to a topic.\n\n    Args:\n        message: The message to be published.\n        topic: The topic to publish the message to.\n        key: The key associated with the message.\n        partition: The partition to which the message should be sent.\n        timestamp_ms: The timestamp of the message in milliseconds.\n        headers: Additional headers to be included with the message.\n        correlation_id: The correlation ID of the message.\n        reply_to: The topic to which the reply should be sent.\n\n    Returns:\n        None\n\n    Raises:\n        AssertionError: If the broker is not connected.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    assert self._producer, \"You need to connect broker at first\"  # nosec B101\n\n    message, content_type = encode_message(message)\n\n    headers_to_send = {\n        \"content-type\": content_type or \"\",\n        \"correlation_id\": correlation_id or str(uuid4()),\n        **(headers or {}),\n    }\n\n    if reply_to:\n        headers_to_send.update({\"reply_to\": reply_to})\n\n    await self._producer.send(\n        topic=topic,\n        value=message,\n        key=key,\n        partition=partition,\n        timestamp_ms=timestamp_ms,\n        headers=[(i, (j or \"\").encode()) for i, j in headers_to_send.items()],\n    )\n\n    return None\n</code></pre>"},{"location":"api/faststream/kafka/producer/AioKafkaFastProducer/#faststream.kafka.producer.AioKafkaFastProducer.publish_batch","title":"publish_batch  <code>async</code>","text":"<pre><code>publish_batch(\n    *msgs: SendableMessage,\n    topic: str,\n    partition: Optional[int] = None,\n    timestamp_ms: Optional[int] = None,\n    headers: Optional[Dict[str, str]] = None\n) -&gt; None\n</code></pre> <p>Publish a batch of messages to a topic.</p> <p>Parameters:</p> Name Type Description Default <code>*msgs</code> <code>SendableMessage</code> <p>Variable length argument list of messages to be sent.</p> <code>()</code> <code>topic</code> <code>str</code> <p>The topic to which the messages should be published.</p> required <code>partition</code> <code>Optional[int]</code> <p>The partition to which the messages should be sent. Defaults to None.</p> <code>None</code> <code>timestamp_ms</code> <code>Optional[int]</code> <p>The timestamp to be associated with the messages. Defaults to None.</p> <code>None</code> <code>headers</code> <code>Optional[Dict[str, str]]</code> <p>Additional headers to be included with the messages. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If the broker is not connected.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/producer.py</code> <pre><code>async def publish_batch(\n    self,\n    *msgs: SendableMessage,\n    topic: str,\n    partition: Optional[int] = None,\n    timestamp_ms: Optional[int] = None,\n    headers: Optional[Dict[str, str]] = None,\n) -&gt; None:\n\"\"\"Publish a batch of messages to a topic.\n\n    Args:\n        *msgs: Variable length argument list of messages to be sent.\n        topic: The topic to which the messages should be published.\n        partition: The partition to which the messages should be sent. Defaults to None.\n        timestamp_ms: The timestamp to be associated with the messages. Defaults to None.\n        headers: Additional headers to be included with the messages. Defaults to None.\n\n    Returns:\n        None\n\n    Raises:\n        AssertionError: If the broker is not connected.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    assert self._producer, \"You need to connect broker at first\"  # nosec B101\n\n    batch = self._producer.create_batch()\n\n    for msg in msgs:\n        message, content_type = encode_message(msg)\n\n        headers_to_send = {\n            \"content-type\": content_type or \"\",\n            **(headers or {}),\n        }\n\n        batch.append(\n            key=None,\n            value=message,\n            timestamp=timestamp_ms,\n            headers=[(i, j.encode()) for i, j in headers_to_send.items()],\n        )\n\n    await self._producer.send_batch(batch, topic, partition=partition)\n</code></pre>"},{"location":"api/faststream/kafka/producer/AioKafkaFastProducer/#faststream.kafka.producer.AioKafkaFastProducer.stop","title":"stop  <code>async</code>","text":"<pre><code>stop() -&gt; None\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/producer.py</code> <pre><code>async def stop(self) -&gt; None:\n    if self._producer is not None:  # pragma: no branch\n        await self._producer.stop()\n</code></pre>"},{"location":"api/faststream/kafka/publisher/LogicPublisher/","title":"LogicPublisher","text":""},{"location":"api/faststream/kafka/publisher/LogicPublisher/#faststream.kafka.publisher.LogicPublisher","title":"faststream.kafka.publisher.LogicPublisher  <code>dataclass</code>","text":"<p>             Bases: <code>ABCPublisher[ConsumerRecord]</code></p> <p>A class to publish messages to a Kafka topic.</p> <p>Attributes:</p> Name Type Description <code>_producer</code> <p>An optional instance of AioKafkaFastProducer</p> <code>batch</code> <p>A boolean indicating whether to send messages in batch</p> <code>client_id</code> <p>A string representing the client ID</p> <p>Methods:</p> Name Description <code>publish </code> <p>Publishes messages to the Kafka topic</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If <code>_producer</code> is not set up or if multiple messages are sent without the <code>batch</code> flag</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/publisher.py</code> <pre><code>@dataclass\nclass LogicPublisher(ABCPublisher[ConsumerRecord]):\n\"\"\"A class to publish messages to a Kafka topic.\n\n    Attributes:\n        _producer : An optional instance of AioKafkaFastProducer\n        batch : A boolean indicating whether to send messages in batch\n        client_id : A string representing the client ID\n\n    Methods:\n        publish : Publishes messages to the Kafka topic\n\n    Raises:\n        AssertionError: If `_producer` is not set up or if multiple messages are sent without the `batch` flag\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    _producer: Optional[AioKafkaFastProducer] = field(default=None, init=False)\n    batch: bool = field(default=False)\n    client_id: str = field(default=\"faststream-\" + __version__)\n\n    @override\n    async def publish(  # type: ignore[override]\n        self,\n        *messages: SendableMessage,\n        message: SendableMessage = \"\",\n        key: Optional[bytes] = None,\n        partition: Optional[int] = None,\n        timestamp_ms: Optional[int] = None,\n        headers: Optional[Dict[str, str]] = None,\n        correlation_id: Optional[str] = None,\n    ) -&gt; None:\n\"\"\"Publish messages to a topic.\n\n        Args:\n            *messages: Variable length argument list of SendableMessage objects.\n            message: A SendableMessage object. Default is an empty string.\n            key: Optional bytes object representing the message key.\n            partition: Optional integer representing the partition to publish the message to.\n            timestamp_ms: Optional integer representing the timestamp of the message in milliseconds.\n            headers: Optional dictionary of header key-value pairs.\n            correlation_id: Optional string representing the correlation ID of the message.\n\n        Returns:\n            None\n\n        Raises:\n            AssertionError: If `_producer` is not set up.\n            AssertionError: If `batch` flag is not set and there are multiple messages.\n            ValueError: If `message` is not a sequence when `messages` is empty.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        assert self._producer, \"Please, setup `_producer` first\"  # nosec B101\n        assert (  # nosec B101\n            self.batch or len(messages) &lt; 2\n        ), \"You can't send multiple messages without `batch` flag\"\n\n        if not self.batch:\n            return await self._producer.publish(\n                message=next(iter(messages), message),\n                topic=self.topic,\n                key=key or self.key,\n                partition=partition or self.partition,\n                timestamp_ms=timestamp_ms or self.timestamp_ms,\n                correlation_id=correlation_id,\n                headers=headers or self.headers,\n                reply_to=self.reply_to or \"\",\n            )\n        else:\n            to_send: Sequence[SendableMessage]\n            if not messages:\n                if not isinstance(message, Sequence):\n                    raise ValueError(\n                        f\"Message: {messages} should be Sequence type to send in batch\"\n                    )\n                else:\n                    to_send = message\n            else:\n                to_send = messages\n\n            await self._producer.publish_batch(\n                *to_send,\n                topic=self.topic,\n                partition=partition or self.partition,\n                timestamp_ms=timestamp_ms or self.timestamp_ms,\n                headers=headers or self.headers,\n            )\n            return None\n</code></pre>"},{"location":"api/faststream/kafka/publisher/LogicPublisher/#faststream.kafka.publisher.LogicPublisher-attributes","title":"Attributes","text":""},{"location":"api/faststream/kafka/publisher/LogicPublisher/#faststream.kafka.publisher.LogicPublisher.batch","title":"batch  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>batch: bool = field(default=False)\n</code></pre>"},{"location":"api/faststream/kafka/publisher/LogicPublisher/#faststream.kafka.publisher.LogicPublisher.client_id","title":"client_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>client_id: str = field(default='faststream-' + __version__)\n</code></pre>"},{"location":"api/faststream/kafka/publisher/LogicPublisher/#faststream.kafka.publisher.LogicPublisher-functions","title":"Functions","text":""},{"location":"api/faststream/kafka/publisher/LogicPublisher/#faststream.kafka.publisher.LogicPublisher.publish","title":"publish  <code>async</code>","text":"<pre><code>publish(\n    *messages: SendableMessage,\n    message: SendableMessage = \"\",\n    key: Optional[bytes] = None,\n    partition: Optional[int] = None,\n    timestamp_ms: Optional[int] = None,\n    headers: Optional[Dict[str, str]] = None,\n    correlation_id: Optional[str] = None\n) -&gt; None\n</code></pre> <p>Publish messages to a topic.</p> <p>Parameters:</p> Name Type Description Default <code>*messages</code> <code>SendableMessage</code> <p>Variable length argument list of SendableMessage objects.</p> <code>()</code> <code>message</code> <code>SendableMessage</code> <p>A SendableMessage object. Default is an empty string.</p> <code>''</code> <code>key</code> <code>Optional[bytes]</code> <p>Optional bytes object representing the message key.</p> <code>None</code> <code>partition</code> <code>Optional[int]</code> <p>Optional integer representing the partition to publish the message to.</p> <code>None</code> <code>timestamp_ms</code> <code>Optional[int]</code> <p>Optional integer representing the timestamp of the message in milliseconds.</p> <code>None</code> <code>headers</code> <code>Optional[Dict[str, str]]</code> <p>Optional dictionary of header key-value pairs.</p> <code>None</code> <code>correlation_id</code> <code>Optional[str]</code> <p>Optional string representing the correlation ID of the message.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If <code>_producer</code> is not set up.</p> <code>AssertionError</code> <p>If <code>batch</code> flag is not set and there are multiple messages.</p> <code>ValueError</code> <p>If <code>message</code> is not a sequence when <code>messages</code> is empty.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/publisher.py</code> <pre><code>@override\nasync def publish(  # type: ignore[override]\n    self,\n    *messages: SendableMessage,\n    message: SendableMessage = \"\",\n    key: Optional[bytes] = None,\n    partition: Optional[int] = None,\n    timestamp_ms: Optional[int] = None,\n    headers: Optional[Dict[str, str]] = None,\n    correlation_id: Optional[str] = None,\n) -&gt; None:\n\"\"\"Publish messages to a topic.\n\n    Args:\n        *messages: Variable length argument list of SendableMessage objects.\n        message: A SendableMessage object. Default is an empty string.\n        key: Optional bytes object representing the message key.\n        partition: Optional integer representing the partition to publish the message to.\n        timestamp_ms: Optional integer representing the timestamp of the message in milliseconds.\n        headers: Optional dictionary of header key-value pairs.\n        correlation_id: Optional string representing the correlation ID of the message.\n\n    Returns:\n        None\n\n    Raises:\n        AssertionError: If `_producer` is not set up.\n        AssertionError: If `batch` flag is not set and there are multiple messages.\n        ValueError: If `message` is not a sequence when `messages` is empty.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    assert self._producer, \"Please, setup `_producer` first\"  # nosec B101\n    assert (  # nosec B101\n        self.batch or len(messages) &lt; 2\n    ), \"You can't send multiple messages without `batch` flag\"\n\n    if not self.batch:\n        return await self._producer.publish(\n            message=next(iter(messages), message),\n            topic=self.topic,\n            key=key or self.key,\n            partition=partition or self.partition,\n            timestamp_ms=timestamp_ms or self.timestamp_ms,\n            correlation_id=correlation_id,\n            headers=headers or self.headers,\n            reply_to=self.reply_to or \"\",\n        )\n    else:\n        to_send: Sequence[SendableMessage]\n        if not messages:\n            if not isinstance(message, Sequence):\n                raise ValueError(\n                    f\"Message: {messages} should be Sequence type to send in batch\"\n                )\n            else:\n                to_send = message\n        else:\n            to_send = messages\n\n        await self._producer.publish_batch(\n            *to_send,\n            topic=self.topic,\n            partition=partition or self.partition,\n            timestamp_ms=timestamp_ms or self.timestamp_ms,\n            headers=headers or self.headers,\n        )\n        return None\n</code></pre>"},{"location":"api/faststream/kafka/router/KafkaRouter/","title":"KafkaRouter","text":""},{"location":"api/faststream/kafka/router/KafkaRouter/#faststream.kafka.router.KafkaRouter","title":"faststream.kafka.router.KafkaRouter","text":"<p>             Bases: <code>KafkaRouter</code></p> <p>A class to represent a Kafka router.</p> <p>Attributes:</p> Name Type Description <code>_publishers</code> <p>Dictionary of publishers</p> <p>Methods:</p> Name Description <code>_get_publisher_key </code> <p>Get the key for a publisher</p> <code>_update_publisher_prefix </code> <p>Update the prefix of a publisher</p> <code>publisher </code> <p>Create a new publisher</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/router.py</code> <pre><code>class KafkaRouter(BaseRouter):\n\"\"\"A class to represent a Kafka router.\n\n    Attributes:\n        _publishers : Dictionary of publishers\n\n    Methods:\n        _get_publisher_key : Get the key for a publisher\n        _update_publisher_prefix : Update the prefix of a publisher\n        publisher : Create a new publisher\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    _publishers: Dict[str, Publisher]  # type: ignore[assignment]\n\n    @override\n    @staticmethod\n    def _get_publisher_key(publisher: Publisher) -&gt; str:  # type: ignore[override]\n\"\"\"Get the publisher key.\n\n        Args:\n            publisher: The publisher object.\n\n        Returns:\n            The publisher key.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        return publisher.topic\n\n    @override\n    @staticmethod\n    def _update_publisher_prefix(  # type: ignore[override]\n        prefix: str,\n        publisher: Publisher,\n    ) -&gt; Publisher:\n\"\"\"Updates the prefix of a publisher.\n\n        Args:\n            prefix: The prefix to be added to the publisher's topic.\n            publisher: The publisher object to be updated.\n\n        Returns:\n            The updated publisher object.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        publisher.topic = prefix + publisher.topic\n        return publisher\n\n    @override\n    def publisher(  # type: ignore[override]\n        self,\n        topic: str,\n        key: Optional[bytes] = None,\n        partition: Optional[int] = None,\n        timestamp_ms: Optional[int] = None,\n        headers: Optional[Dict[str, str]] = None,\n        reply_to: str = \"\",\n        batch: bool = False,\n        # AsyncAPI information\n        title: Optional[str] = None,\n        description: Optional[str] = None,\n    ) -&gt; Publisher:\n\"\"\"Publishes a message to a topic.\n\n        Args:\n            topic (str): The topic to publish the message to.\n            key (bytes, optional): The key associated with the message.\n            partition (int, optional): The partition to publish the message to.\n            timestamp_ms (int, optional): The timestamp of the message in milliseconds.\n            headers (Dict[str, str], optional): Additional headers for the message.\n            reply_to (str, optional): The topic to reply to.\n            batch (bool, optional): Whether to publish the message as part of a batch.\n            title (str, optional): The title of the message.\n            description (str, optional): The description of the message.\n\n        Returns:\n            Publisher: The publisher object used to publish the message.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        new_publisher = self._update_publisher_prefix(\n            self.prefix,\n            Publisher(\n                topic=topic,\n                key=key,\n                partition=partition,\n                timestamp_ms=timestamp_ms,\n                headers=headers,\n                reply_to=reply_to,\n                title=title,\n                batch=batch,\n                _description=description,\n            ),\n        )\n        publisher_key = self._get_publisher_key(new_publisher)\n        publisher = self._publishers[publisher_key] = self._publishers.get(\n            publisher_key, new_publisher\n        )\n        return publisher\n</code></pre>"},{"location":"api/faststream/kafka/router/KafkaRouter/#faststream.kafka.router.KafkaRouter-functions","title":"Functions","text":""},{"location":"api/faststream/kafka/router/KafkaRouter/#faststream.kafka.router.KafkaRouter.publisher","title":"publisher","text":"<pre><code>publisher(\n    topic: str,\n    key: Optional[bytes] = None,\n    partition: Optional[int] = None,\n    timestamp_ms: Optional[int] = None,\n    headers: Optional[Dict[str, str]] = None,\n    reply_to: str = \"\",\n    batch: bool = False,\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n) -&gt; Publisher\n</code></pre> <p>Publishes a message to a topic.</p> <p>Parameters:</p> Name Type Description Default <code>topic</code> <code>str</code> <p>The topic to publish the message to.</p> required <code>key</code> <code>bytes</code> <p>The key associated with the message.</p> <code>None</code> <code>partition</code> <code>int</code> <p>The partition to publish the message to.</p> <code>None</code> <code>timestamp_ms</code> <code>int</code> <p>The timestamp of the message in milliseconds.</p> <code>None</code> <code>headers</code> <code>Dict[str, str]</code> <p>Additional headers for the message.</p> <code>None</code> <code>reply_to</code> <code>str</code> <p>The topic to reply to.</p> <code>''</code> <code>batch</code> <code>bool</code> <p>Whether to publish the message as part of a batch.</p> <code>False</code> <code>title</code> <code>str</code> <p>The title of the message.</p> <code>None</code> <code>description</code> <code>str</code> <p>The description of the message.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Publisher</code> <code>Publisher</code> <p>The publisher object used to publish the message.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/router.py</code> <pre><code>@override\ndef publisher(  # type: ignore[override]\n    self,\n    topic: str,\n    key: Optional[bytes] = None,\n    partition: Optional[int] = None,\n    timestamp_ms: Optional[int] = None,\n    headers: Optional[Dict[str, str]] = None,\n    reply_to: str = \"\",\n    batch: bool = False,\n    # AsyncAPI information\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n) -&gt; Publisher:\n\"\"\"Publishes a message to a topic.\n\n    Args:\n        topic (str): The topic to publish the message to.\n        key (bytes, optional): The key associated with the message.\n        partition (int, optional): The partition to publish the message to.\n        timestamp_ms (int, optional): The timestamp of the message in milliseconds.\n        headers (Dict[str, str], optional): Additional headers for the message.\n        reply_to (str, optional): The topic to reply to.\n        batch (bool, optional): Whether to publish the message as part of a batch.\n        title (str, optional): The title of the message.\n        description (str, optional): The description of the message.\n\n    Returns:\n        Publisher: The publisher object used to publish the message.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    new_publisher = self._update_publisher_prefix(\n        self.prefix,\n        Publisher(\n            topic=topic,\n            key=key,\n            partition=partition,\n            timestamp_ms=timestamp_ms,\n            headers=headers,\n            reply_to=reply_to,\n            title=title,\n            batch=batch,\n            _description=description,\n        ),\n    )\n    publisher_key = self._get_publisher_key(new_publisher)\n    publisher = self._publishers[publisher_key] = self._publishers.get(\n        publisher_key, new_publisher\n    )\n    return publisher\n</code></pre>"},{"location":"api/faststream/kafka/router/KafkaRouter/#faststream.kafka.router.KafkaRouter.subscriber","title":"subscriber","text":"<pre><code>subscriber(\n    *topics: str,\n    group_id: Optional[str] = None,\n    key_deserializer: Optional[\n        Callable[[bytes], Any]\n    ] = None,\n    value_deserializer: Optional[\n        Callable[[bytes], Any]\n    ] = None,\n    fetch_max_wait_ms: int = 500,\n    fetch_max_bytes: int = 52428800,\n    fetch_min_bytes: int = 1,\n    max_partition_fetch_bytes: int = 1 * 1024 * 1024,\n    auto_offset_reset: Literal[\n        \"latest\", \"earliest\", \"none\"\n    ] = \"latest\",\n    enable_auto_commit: bool = True,\n    auto_commit_interval_ms: int = 5000,\n    check_crcs: bool = True,\n    partition_assignment_strategy: Sequence[\n        AbstractPartitionAssignor\n    ] = (RoundRobinPartitionAssignor),\n    max_poll_interval_ms: int = 300000,\n    rebalance_timeout_ms: Optional[int] = None,\n    session_timeout_ms: int = 10000,\n    heartbeat_interval_ms: int = 3000,\n    consumer_timeout_ms: int = 200,\n    max_poll_records: Optional[int] = None,\n    exclude_internal_topics: bool = True,\n    isolation_level: Literal[\n        \"read_uncommitted\", \"read_committed\"\n    ] = \"read_uncommitted\",\n    dependencies: Sequence[Depends] = (),\n    parser: Optional[\n        CustomParser[aiokafka.ConsumerRecord]\n    ] = None,\n    decoder: Optional[\n        CustomDecoder[aiokafka.ConsumerRecord]\n    ] = None,\n    middlewares: Optional[\n        Sequence[\n            Callable[\n                [aiokafka.ConsumerRecord], BaseMiddleware\n            ]\n        ]\n    ] = None,\n    filter: Filter[KafkaMessage] = default_filter,\n    batch: bool = False,\n    max_records: Optional[int] = None,\n    batch_timeout_ms: int = 200,\n    retry: Union[bool, int] = False,\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n    **__service_kwargs: Any\n) -&gt; Callable[\n    [Callable[P_HandlerParams, T_HandlerReturn]],\n    HandlerCallWrapper[\n        aiokafka.ConsumerRecord,\n        P_HandlerParams,\n        T_HandlerReturn,\n    ],\n]\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/router.py</code> <pre><code>        publisher: The publisher object to be updated.\n\n    Returns:\n        The updated publisher object.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n\"\"\"\n    publisher.topic = prefix + publisher.topic\n    return publisher\n\n@override\ndef publisher(  # type: ignore[override]\n    self,\n    topic: str,\n    key: Optional[bytes] = None,\n    partition: Optional[int] = None,\n    timestamp_ms: Optional[int] = None,\n    headers: Optional[Dict[str, str]] = None,\n    reply_to: str = \"\",\n    batch: bool = False,\n    # AsyncAPI information\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n) -&gt; Publisher:\n    \"\"\"Publishes a message to a topic.\n\n    Args:\n        topic (str): The topic to publish the message to.\n        key (bytes, optional): The key associated with the message.\n        partition (int, optional): The partition to publish the message to.\n        timestamp_ms (int, optional): The timestamp of the message in milliseconds.\n        headers (Dict[str, str], optional): Additional headers for the message.\n        reply_to (str, optional): The topic to reply to.\n        batch (bool, optional): Whether to publish the message as part of a batch.\n        title (str, optional): The title of the message.\n        description (str, optional): The description of the message.\n\n    Returns:\n        Publisher: The publisher object used to publish the message.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    new_publisher = self._update_publisher_prefix(\n        self.prefix,\n        Publisher(\n            topic=topic,\n            key=key,\n            partition=partition,\n            timestamp_ms=timestamp_ms,\n            headers=headers,\n            reply_to=reply_to,\n            title=title,\n            batch=batch,\n            _description=description,\n        ),\n    )\n</code></pre>"},{"location":"api/faststream/kafka/security/parse_security/","title":"parse_security","text":""},{"location":"api/faststream/kafka/security/parse_security/#faststream.kafka.security.parse_security","title":"faststream.kafka.security.parse_security","text":"<pre><code>parse_security(\n    security: Optional[BaseSecurity],\n) -&gt; Dict[str, Any]\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/security.py</code> <pre><code>def parse_security(security: Optional[BaseSecurity]) -&gt; Dict[str, Any]:\n    if security is None:\n        return {}\n    elif type(security) == BaseSecurity:\n        return _parse_base_security(security)\n    elif type(security) == SASLPlaintext:\n        return _parse_sasl_plaintext(security)\n    elif type(security) == SASLScram256:\n        return _parse_sasl_scram256(security)\n    elif type(security) == SASLScram512:\n        return _parse_sasl_scram512(security)\n    else:\n        raise NotImplementedError(f\"KafkaBroker does not support {type(security)}\")\n</code></pre>"},{"location":"api/faststream/kafka/shared/logging/KafkaLoggingMixin/","title":"KafkaLoggingMixin","text":""},{"location":"api/faststream/kafka/shared/logging/KafkaLoggingMixin/#faststream.kafka.shared.logging.KafkaLoggingMixin","title":"faststream.kafka.shared.logging.KafkaLoggingMixin","text":"<p>             Bases: <code>LoggingMixin</code></p> <p>A class that provides logging functionality for Kafka.</p> <p>Attributes:</p> Name Type Description <code>_max_topic_len</code> <p>maximum length of the topic name</p> <p>Methods:</p> Name Description <code>__init__ </code> <p>initializes the KafkaLoggingMixin object</p> <code>_get_log_context </code> <p>returns the log context for a given message and topics</p> <code>fmt </code> <p>returns the log format string</p> <code>_setup_log_context </code> <p>sets up the log context for a given list of topics</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/shared/logging.py</code> <pre><code>class KafkaLoggingMixin(LoggingMixin):\n\"\"\"A class that provides logging functionality for Kafka.\n\n    Attributes:\n        _max_topic_len : maximum length of the topic name\n\n    Methods:\n        __init__ : initializes the KafkaLoggingMixin object\n        _get_log_context : returns the log context for a given message and topics\n        fmt : returns the log format string\n        _setup_log_context : sets up the log context for a given list of topics\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    _max_topic_len: int\n\n    def __init__(\n        self,\n        *args: Any,\n        logger: Optional[logging.Logger] = access_logger,\n        log_level: int = logging.INFO,\n        log_fmt: Optional[str] = None,\n        **kwargs: Any,\n    ) -&gt; None:\n\"\"\"Initialize the class.\n\n        Args:\n            *args: Variable length argument list\n            logger: Optional logger object\n            log_level: Log level (default: logging.INFO)\n            log_fmt: Optional log format string\n            **kwargs: Arbitrary keyword arguments\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        super().__init__(\n            *args,\n            logger=logger,\n            log_level=log_level,\n            log_fmt=log_fmt,\n            **kwargs,\n        )\n        self._max_topic_len = 4\n\n    @override\n    def _get_log_context(  # type: ignore[override]\n        self,\n        message: Optional[StreamMessage[ConsumerRecord]],\n        topics: Sequence[str] = (),\n    ) -&gt; AnyDict:\n\"\"\"Get the log context.\n\n        Args:\n            message: Optional stream message of type ConsumerRecord\n            topics: Sequence of topics\n\n        Returns:\n            A dictionary containing the log context\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        if topics:\n            topic = \", \".join(topics)\n        elif message is not None:\n            topic = message.raw_message.topic\n        else:\n            topic = \"\"\n\n        context = {\n            \"topic\": topic,\n            **super()._get_log_context(message),\n        }\n        return context\n\n    @property\n    def fmt(self) -&gt; str:\n        return super().fmt or (\n            \"%(asctime)s %(levelname)s - \"\n            f\"%(topic)-{self._max_topic_len}s | \"\n            \"%(message_id)-10s \"\n            \"- %(message)s\"\n        )\n\n    def _setup_log_context(self, topics: Iterable[str]) -&gt; None:\n\"\"\"Set up log context.\n\n        Args:\n            topics: An iterable of topics.\n\n        Returns:\n            None.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        for t in topics:\n            self._max_topic_len = max((self._max_topic_len, len(t)))\n</code></pre>"},{"location":"api/faststream/kafka/shared/logging/KafkaLoggingMixin/#faststream.kafka.shared.logging.KafkaLoggingMixin-attributes","title":"Attributes","text":""},{"location":"api/faststream/kafka/shared/logging/KafkaLoggingMixin/#faststream.kafka.shared.logging.KafkaLoggingMixin.fmt","title":"fmt  <code>property</code>","text":"<pre><code>fmt: str\n</code></pre>"},{"location":"api/faststream/kafka/shared/logging/KafkaLoggingMixin/#faststream.kafka.shared.logging.KafkaLoggingMixin-functions","title":"Functions","text":""},{"location":"api/faststream/kafka/shared/logging/KafkaLoggingMixin/#faststream.kafka.shared.logging.KafkaLoggingMixin.__init__","title":"__init__","text":"<pre><code>__init__(\n    *args: Any,\n    logger: Optional[logging.Logger] = access_logger,\n    log_level: int = logging.INFO,\n    log_fmt: Optional[str] = None,\n    **kwargs: Any\n) -&gt; None\n</code></pre> <p>Initialize the class.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Any</code> <p>Variable length argument list</p> <code>()</code> <code>logger</code> <code>Optional[Logger]</code> <p>Optional logger object</p> <code>access_logger</code> <code>log_level</code> <code>int</code> <p>Log level (default: logging.INFO)</p> <code>INFO</code> <code>log_fmt</code> <code>Optional[str]</code> <p>Optional log format string</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Arbitrary keyword arguments</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/shared/logging.py</code> <pre><code>def __init__(\n    self,\n    *args: Any,\n    logger: Optional[logging.Logger] = access_logger,\n    log_level: int = logging.INFO,\n    log_fmt: Optional[str] = None,\n    **kwargs: Any,\n) -&gt; None:\n\"\"\"Initialize the class.\n\n    Args:\n        *args: Variable length argument list\n        logger: Optional logger object\n        log_level: Log level (default: logging.INFO)\n        log_fmt: Optional log format string\n        **kwargs: Arbitrary keyword arguments\n\n    Returns:\n        None\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    super().__init__(\n        *args,\n        logger=logger,\n        log_level=log_level,\n        log_fmt=log_fmt,\n        **kwargs,\n    )\n    self._max_topic_len = 4\n</code></pre>"},{"location":"api/faststream/kafka/shared/publisher/ABCPublisher/","title":"ABCPublisher","text":""},{"location":"api/faststream/kafka/shared/publisher/ABCPublisher/#faststream.kafka.shared.publisher.ABCPublisher","title":"faststream.kafka.shared.publisher.ABCPublisher  <code>dataclass</code>","text":"<p>             Bases: <code>ABC</code>, <code>BasePublisher[MsgType]</code></p> <p>A class representing an ABCPublisher.</p> <p>Attributes:</p> Name Type Description <code>topic</code> <p>str The topic of the publisher.</p> <code>key</code> <p>Optional[bytes] The key of the publisher.</p> <code>partition</code> <p>Optional[int] The partition of the publisher.</p> <code>timestamp_ms</code> <p>Optional[int] The timestamp in milliseconds of the publisher.</p> <code>headers</code> <p>Optional[Dict[str, str]] The headers of the publisher.</p> <code>reply_to</code> <p>Optional[str] The reply-to address of the publisher.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/shared/publisher.py</code> <pre><code>@dataclass\nclass ABCPublisher(ABC, BasePublisher[MsgType]):\n\"\"\"A class representing an ABCPublisher.\n\n    Attributes:\n        topic : str\n            The topic of the publisher.\n        key : Optional[bytes]\n            The key of the publisher.\n        partition : Optional[int]\n            The partition of the publisher.\n        timestamp_ms : Optional[int]\n            The timestamp in milliseconds of the publisher.\n        headers : Optional[Dict[str, str]]\n            The headers of the publisher.\n        reply_to : Optional[str]\n            The reply-to address of the publisher.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    topic: str = \"\"\n    key: Optional[bytes] = None\n    partition: Optional[int] = None\n    timestamp_ms: Optional[int] = None\n    headers: Optional[Dict[str, str]] = None\n    reply_to: Optional[str] = \"\"\n</code></pre>"},{"location":"api/faststream/kafka/shared/publisher/ABCPublisher/#faststream.kafka.shared.publisher.ABCPublisher-attributes","title":"Attributes","text":""},{"location":"api/faststream/kafka/shared/publisher/ABCPublisher/#faststream.kafka.shared.publisher.ABCPublisher.headers","title":"headers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>headers: Optional[Dict[str, str]] = None\n</code></pre>"},{"location":"api/faststream/kafka/shared/publisher/ABCPublisher/#faststream.kafka.shared.publisher.ABCPublisher.key","title":"key  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>key: Optional[bytes] = None\n</code></pre>"},{"location":"api/faststream/kafka/shared/publisher/ABCPublisher/#faststream.kafka.shared.publisher.ABCPublisher.partition","title":"partition  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>partition: Optional[int] = None\n</code></pre>"},{"location":"api/faststream/kafka/shared/publisher/ABCPublisher/#faststream.kafka.shared.publisher.ABCPublisher.reply_to","title":"reply_to  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>reply_to: Optional[str] = ''\n</code></pre>"},{"location":"api/faststream/kafka/shared/publisher/ABCPublisher/#faststream.kafka.shared.publisher.ABCPublisher.timestamp_ms","title":"timestamp_ms  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>timestamp_ms: Optional[int] = None\n</code></pre>"},{"location":"api/faststream/kafka/shared/publisher/ABCPublisher/#faststream.kafka.shared.publisher.ABCPublisher.topic","title":"topic  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>topic: str = ''\n</code></pre>"},{"location":"api/faststream/kafka/shared/router/KafkaRouter/","title":"KafkaRouter","text":""},{"location":"api/faststream/kafka/shared/router/KafkaRouter/#faststream.kafka.shared.router.KafkaRouter","title":"faststream.kafka.shared.router.KafkaRouter","text":"<p>             Bases: <code>BrokerRouter[str, ConsumerRecord]</code></p> <p>A class to represent a Kafka router.</p> <p>Attributes:</p> Name Type Description <code>prefix</code> <p>prefix for the topics</p> <code>handlers</code> <p>sequence of Kafka routes</p> <code>kwargs</code> <p>additional keyword arguments</p> <p>Methods:</p> Name Description <code>subscriber </code> <p>decorator for subscribing to topics and handling messages</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/shared/router.py</code> <pre><code>class KafkaRouter(BrokerRouter[str, ConsumerRecord]):\n\"\"\"A class to represent a Kafka router.\n\n    Attributes:\n        prefix : prefix for the topics\n        handlers : sequence of Kafka routes\n        kwargs : additional keyword arguments\n\n    Methods:\n        subscriber : decorator for subscribing to topics and handling messages\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    def __init__(\n        self,\n        prefix: str = \"\",\n        handlers: Sequence[KafkaRoute[ConsumerRecord, SendableMessage]] = (),\n        **kwargs: Any,\n    ):\n\"\"\"Initialize the class.\n\n        Args:\n            prefix (str): Prefix string.\n            handlers (Sequence[KafkaRoute[ConsumerRecord, SendableMessage]]): Sequence of KafkaRoute objects.\n            **kwargs (Any): Additional keyword arguments.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        for h in handlers:\n            h.args = tuple(prefix + x for x in h.args)\n        super().__init__(prefix, handlers, **kwargs)\n\n    def subscriber(\n        self,\n        *topics: str,\n        **broker_kwargs: Any,\n    ) -&gt; Callable[\n        [Callable[P_HandlerParams, T_HandlerReturn]],\n        HandlerCallWrapper[ConsumerRecord, P_HandlerParams, T_HandlerReturn],\n    ]:\n\"\"\"A function to subscribe to topics.\n\n        Args:\n            *topics : variable number of topic names\n            **broker_kwargs : keyword arguments for the broker\n\n        Returns:\n            A callable function that wraps the handler function\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        return self._wrap_subscriber(\n            *(self.prefix + x for x in topics),\n            **broker_kwargs,\n        )\n</code></pre>"},{"location":"api/faststream/kafka/shared/router/KafkaRouter/#faststream.kafka.shared.router.KafkaRouter-functions","title":"Functions","text":""},{"location":"api/faststream/kafka/shared/router/KafkaRouter/#faststream.kafka.shared.router.KafkaRouter.__init__","title":"__init__","text":"<pre><code>__init__(\n    prefix: str = \"\",\n    handlers: Sequence[\n        KafkaRoute[ConsumerRecord, SendableMessage]\n    ] = (),\n    **kwargs: Any\n)\n</code></pre> <p>Initialize the class.</p> <p>Parameters:</p> Name Type Description Default <code>prefix</code> <code>str</code> <p>Prefix string.</p> <code>''</code> <code>handlers</code> <code>Sequence[BrokerRoute[ConsumerRecord, SendableMessage]]</code> <p>Sequence of KafkaRoute objects.</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/shared/router.py</code> <pre><code>def __init__(\n    self,\n    prefix: str = \"\",\n    handlers: Sequence[KafkaRoute[ConsumerRecord, SendableMessage]] = (),\n    **kwargs: Any,\n):\n\"\"\"Initialize the class.\n\n    Args:\n        prefix (str): Prefix string.\n        handlers (Sequence[KafkaRoute[ConsumerRecord, SendableMessage]]): Sequence of KafkaRoute objects.\n        **kwargs (Any): Additional keyword arguments.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    for h in handlers:\n        h.args = tuple(prefix + x for x in h.args)\n    super().__init__(prefix, handlers, **kwargs)\n</code></pre>"},{"location":"api/faststream/kafka/shared/router/KafkaRouter/#faststream.kafka.shared.router.KafkaRouter.subscriber","title":"subscriber","text":"<pre><code>subscriber(\n    *topics: str, **broker_kwargs: Any\n) -&gt; Callable[\n    [Callable[P_HandlerParams, T_HandlerReturn]],\n    HandlerCallWrapper[\n        ConsumerRecord, P_HandlerParams, T_HandlerReturn\n    ],\n]\n</code></pre> <p>A function to subscribe to topics.</p> <p>Parameters:</p> Name Type Description Default <code>*topics</code> <p>variable number of topic names</p> <code>()</code> <code>**broker_kwargs</code> <p>keyword arguments for the broker</p> <code>{}</code> <p>Returns:</p> Type Description <code>Callable[[Callable[P_HandlerParams, T_HandlerReturn]], HandlerCallWrapper[ConsumerRecord, P_HandlerParams, T_HandlerReturn]]</code> <p>A callable function that wraps the handler function</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/shared/router.py</code> <pre><code>def subscriber(\n    self,\n    *topics: str,\n    **broker_kwargs: Any,\n) -&gt; Callable[\n    [Callable[P_HandlerParams, T_HandlerReturn]],\n    HandlerCallWrapper[ConsumerRecord, P_HandlerParams, T_HandlerReturn],\n]:\n\"\"\"A function to subscribe to topics.\n\n    Args:\n        *topics : variable number of topic names\n        **broker_kwargs : keyword arguments for the broker\n\n    Returns:\n        A callable function that wraps the handler function\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    return self._wrap_subscriber(\n        *(self.prefix + x for x in topics),\n        **broker_kwargs,\n    )\n</code></pre>"},{"location":"api/faststream/kafka/shared/schemas/ConsumerConnectionParams/","title":"ConsumerConnectionParams","text":""},{"location":"api/faststream/kafka/shared/schemas/ConsumerConnectionParams/#faststream.kafka.shared.schemas.ConsumerConnectionParams","title":"faststream.kafka.shared.schemas.ConsumerConnectionParams","text":"<p>             Bases: <code>TypedDict</code></p> <p>A class to represent the connection parameters for a consumer.</p> <p>Attributes:</p> Name Type Description <code>bootstrap_servers</code> <p>Required. The bootstrap servers to connect to.</p> <code>loop</code> <p>Optional. The event loop to use for asynchronous operations.</p> <code>client_id</code> <p>The client ID to use for the connection.</p> <code>request_timeout_ms</code> <p>The timeout for network requests in milliseconds.</p> <code>retry_backoff_ms</code> <p>The backoff time in milliseconds for retrying failed requests.</p> <code>metadata_max_age_ms</code> <p>The maximum age of metadata in milliseconds.</p> <code>security_protocol</code> <p>The security protocol to use for the connection. Must be one of \"SSL\" or \"PLAINTEXT\".</p> <code>api_version</code> <p>The API version to use for the connection.</p> <code>connections_max_idle_ms</code> <p>The maximum idle time in milliseconds before closing a connection.</p> <code>sasl_mechanism</code> <p>The SASL mechanism to use for authentication. Must be one of \"PLAIN\", \"GSSAPI\", \"SCRAM-SHA-256\", \"SCRAM-SHA-512\", or \"OAUTHBEARER\".</p> <code>sasl_plain_password</code> <p>The password to use for PLAIN SASL mechanism.</p> <code>sasl_plain_username</code> <p>The username to use for PLAIN SASL mechanism.</p> <code>sasl_kerberos_service_name</code> <p>The service</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/shared/schemas.py</code> <pre><code>class ConsumerConnectionParams(TypedDict, total=False):\n\"\"\"A class to represent the connection parameters for a consumer.\n\n    Attributes:\n        bootstrap_servers : Required. The bootstrap servers to connect to.\n        loop : Optional. The event loop to use for asynchronous operations.\n        client_id : The client ID to use for the connection.\n        request_timeout_ms : The timeout for network requests in milliseconds.\n        retry_backoff_ms : The backoff time in milliseconds for retrying failed requests.\n        metadata_max_age_ms : The maximum age of metadata in milliseconds.\n        security_protocol : The security protocol to use for the connection. Must be one of \"SSL\" or \"PLAINTEXT\".\n        api_version : The API version to use for the connection.\n        connections_max_idle_ms : The maximum idle time in milliseconds before closing a connection.\n        sasl_mechanism : The SASL mechanism to use for authentication. Must be one of \"PLAIN\", \"GSSAPI\", \"SCRAM-SHA-256\", \"SCRAM-SHA-512\", or \"OAUTHBEARER\".\n        sasl_plain_password : The password to use for PLAIN SASL mechanism.\n        sasl_plain_username : The username to use for PLAIN SASL mechanism.\n        sasl_kerberos_service_name : The service\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    bootstrap_servers: Required[Union[str, List[str]]]\n    loop: Optional[AbstractEventLoop]\n    client_id: str\n    request_timeout_ms: int\n    retry_backoff_ms: int\n    metadata_max_age_ms: int\n    security_protocol: Literal[\n        \"SSL\",\n        \"PLAINTEXT\",\n    ]\n    api_version: str\n    connections_max_idle_ms: int\n    sasl_mechanism: Literal[\n        \"PLAIN\",\n        \"GSSAPI\",\n        \"SCRAM-SHA-256\",\n        \"SCRAM-SHA-512\",\n        \"OAUTHBEARER\",\n    ]\n    sasl_plain_password: str\n    sasl_plain_username: str\n    sasl_kerberos_service_name: str\n    sasl_kerberos_domain_name: str\n    ssl_context: ssl.SSLContext\n    sasl_oauth_token_provider: AbstractTokenProvider\n</code></pre>"},{"location":"api/faststream/kafka/shared/schemas/ConsumerConnectionParams/#faststream.kafka.shared.schemas.ConsumerConnectionParams-attributes","title":"Attributes","text":""},{"location":"api/faststream/kafka/shared/schemas/ConsumerConnectionParams/#faststream.kafka.shared.schemas.ConsumerConnectionParams.api_version","title":"api_version  <code>instance-attribute</code>","text":"<pre><code>api_version: str\n</code></pre>"},{"location":"api/faststream/kafka/shared/schemas/ConsumerConnectionParams/#faststream.kafka.shared.schemas.ConsumerConnectionParams.bootstrap_servers","title":"bootstrap_servers  <code>instance-attribute</code>","text":"<pre><code>bootstrap_servers: Required[Union[str, List[str]]]\n</code></pre>"},{"location":"api/faststream/kafka/shared/schemas/ConsumerConnectionParams/#faststream.kafka.shared.schemas.ConsumerConnectionParams.client_id","title":"client_id  <code>instance-attribute</code>","text":"<pre><code>client_id: str\n</code></pre>"},{"location":"api/faststream/kafka/shared/schemas/ConsumerConnectionParams/#faststream.kafka.shared.schemas.ConsumerConnectionParams.connections_max_idle_ms","title":"connections_max_idle_ms  <code>instance-attribute</code>","text":"<pre><code>connections_max_idle_ms: int\n</code></pre>"},{"location":"api/faststream/kafka/shared/schemas/ConsumerConnectionParams/#faststream.kafka.shared.schemas.ConsumerConnectionParams.loop","title":"loop  <code>instance-attribute</code>","text":"<pre><code>loop: Optional[AbstractEventLoop]\n</code></pre>"},{"location":"api/faststream/kafka/shared/schemas/ConsumerConnectionParams/#faststream.kafka.shared.schemas.ConsumerConnectionParams.metadata_max_age_ms","title":"metadata_max_age_ms  <code>instance-attribute</code>","text":"<pre><code>metadata_max_age_ms: int\n</code></pre>"},{"location":"api/faststream/kafka/shared/schemas/ConsumerConnectionParams/#faststream.kafka.shared.schemas.ConsumerConnectionParams.request_timeout_ms","title":"request_timeout_ms  <code>instance-attribute</code>","text":"<pre><code>request_timeout_ms: int\n</code></pre>"},{"location":"api/faststream/kafka/shared/schemas/ConsumerConnectionParams/#faststream.kafka.shared.schemas.ConsumerConnectionParams.retry_backoff_ms","title":"retry_backoff_ms  <code>instance-attribute</code>","text":"<pre><code>retry_backoff_ms: int\n</code></pre>"},{"location":"api/faststream/kafka/shared/schemas/ConsumerConnectionParams/#faststream.kafka.shared.schemas.ConsumerConnectionParams.sasl_kerberos_domain_name","title":"sasl_kerberos_domain_name  <code>instance-attribute</code>","text":"<pre><code>sasl_kerberos_domain_name: str\n</code></pre>"},{"location":"api/faststream/kafka/shared/schemas/ConsumerConnectionParams/#faststream.kafka.shared.schemas.ConsumerConnectionParams.sasl_kerberos_service_name","title":"sasl_kerberos_service_name  <code>instance-attribute</code>","text":"<pre><code>sasl_kerberos_service_name: str\n</code></pre>"},{"location":"api/faststream/kafka/shared/schemas/ConsumerConnectionParams/#faststream.kafka.shared.schemas.ConsumerConnectionParams.sasl_mechanism","title":"sasl_mechanism  <code>instance-attribute</code>","text":"<pre><code>sasl_mechanism: Literal[\n    \"PLAIN\",\n    \"GSSAPI\",\n    \"SCRAM-SHA-256\",\n    \"SCRAM-SHA-512\",\n    \"OAUTHBEARER\",\n]\n</code></pre>"},{"location":"api/faststream/kafka/shared/schemas/ConsumerConnectionParams/#faststream.kafka.shared.schemas.ConsumerConnectionParams.sasl_oauth_token_provider","title":"sasl_oauth_token_provider  <code>instance-attribute</code>","text":"<pre><code>sasl_oauth_token_provider: AbstractTokenProvider\n</code></pre>"},{"location":"api/faststream/kafka/shared/schemas/ConsumerConnectionParams/#faststream.kafka.shared.schemas.ConsumerConnectionParams.sasl_plain_password","title":"sasl_plain_password  <code>instance-attribute</code>","text":"<pre><code>sasl_plain_password: str\n</code></pre>"},{"location":"api/faststream/kafka/shared/schemas/ConsumerConnectionParams/#faststream.kafka.shared.schemas.ConsumerConnectionParams.sasl_plain_username","title":"sasl_plain_username  <code>instance-attribute</code>","text":"<pre><code>sasl_plain_username: str\n</code></pre>"},{"location":"api/faststream/kafka/shared/schemas/ConsumerConnectionParams/#faststream.kafka.shared.schemas.ConsumerConnectionParams.security_protocol","title":"security_protocol  <code>instance-attribute</code>","text":"<pre><code>security_protocol: Literal['SSL', 'PLAINTEXT']\n</code></pre>"},{"location":"api/faststream/kafka/shared/schemas/ConsumerConnectionParams/#faststream.kafka.shared.schemas.ConsumerConnectionParams.ssl_context","title":"ssl_context  <code>instance-attribute</code>","text":"<pre><code>ssl_context: ssl.SSLContext\n</code></pre>"},{"location":"api/faststream/kafka/test/FakeProducer/","title":"FakeProducer","text":""},{"location":"api/faststream/kafka/test/FakeProducer/#faststream.kafka.test.FakeProducer","title":"faststream.kafka.test.FakeProducer","text":"<p>             Bases: <code>AioKafkaFastProducer</code></p> <p>A fake Kafka producer for testing purposes.</p> <p>This class extends AioKafkaFastProducer and is used to simulate Kafka message publishing during tests.</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/test.py</code> <pre><code>class FakeProducer(AioKafkaFastProducer):\n\"\"\"\n    A fake Kafka producer for testing purposes.\n\n    This class extends AioKafkaFastProducer and is used to simulate Kafka message publishing during tests.\n    \"\"\"\n\n    def __init__(self, broker: KafkaBroker):\n\"\"\"\n        Initialize the FakeProducer.\n\n        Args:\n            broker (KafkaBroker): The KafkaBroker instance to associate with this FakeProducer.\n        \"\"\"\n        self.broker = broker\n\n    @override\n    async def publish(  # type: ignore[override]\n        self,\n        message: SendableMessage,\n        topic: str,\n        key: Optional[bytes] = None,\n        partition: Optional[int] = None,\n        timestamp_ms: Optional[int] = None,\n        headers: Optional[Dict[str, str]] = None,\n        correlation_id: Optional[str] = None,\n        *,\n        reply_to: str = \"\",\n        rpc: bool = False,\n        rpc_timeout: Optional[float] = None,\n        raise_timeout: bool = False,\n    ) -&gt; Optional[SendableMessage]:\n\"\"\"\n        Publish a message to the Kafka broker.\n\n        Args:\n            message (SendableMessage): The message to be published.\n            topic (str): The Kafka topic to publish the message to.\n            key (Optional[bytes], optional): The message key. Defaults to None.\n            partition (Optional[int], optional): The Kafka partition to use. Defaults to None.\n            timestamp_ms (Optional[int], optional): The message timestamp in milliseconds. Defaults to None.\n            headers (Optional[Dict[str, str]], optional): Additional headers for the message. Defaults to None.\n            correlation_id (Optional[str], optional): The correlation ID for the message. Defaults to None.\n            reply_to (str, optional): The topic to which responses should be sent. Defaults to \"\".\n            rpc (bool, optional): If True, treat the message as an RPC request. Defaults to False.\n            rpc_timeout (Optional[float], optional): Timeout for RPC requests. Defaults to None.\n            raise_timeout (bool, optional): If True, raise an exception on timeout. Defaults to False.\n\n        Returns:\n            Optional[SendableMessage]: The response message, if this was an RPC request, otherwise None.\n        \"\"\"\n        incoming = build_message(\n            message=message,\n            topic=topic,\n            key=key,\n            partition=partition,\n            timestamp_ms=timestamp_ms,\n            headers=headers,\n            correlation_id=correlation_id,\n            reply_to=reply_to,\n        )\n\n        for handler in self.broker.handlers.values():  # pragma: no branch\n            if topic in handler.topics:\n                r = await call_handler(\n                    handler=handler,\n                    message=[incoming] if handler.batch else incoming,\n                    rpc=rpc,\n                    rpc_timeout=rpc_timeout,\n                    raise_timeout=raise_timeout,\n                )\n\n                if rpc:  # pragma: no branch\n                    return r\n\n        return None\n\n    async def publish_batch(\n        self,\n        *msgs: SendableMessage,\n        topic: str,\n        partition: Optional[int] = None,\n        timestamp_ms: Optional[int] = None,\n        headers: Optional[Dict[str, str]] = None,\n    ) -&gt; None:\n\"\"\"\n        Publish a batch of messages to the Kafka broker.\n\n        Args:\n            *msgs (SendableMessage): Variable number of messages to be published.\n            topic (str): The Kafka topic to publish the messages to.\n            partition (Optional[int], optional): The Kafka partition to use. Defaults to None.\n            timestamp_ms (Optional[int], optional): The message timestamp in milliseconds. Defaults to None.\n            headers (Optional[Dict[str, str]], optional): Additional headers for the messages. Defaults to None.\n\n        Returns:\n            None: This method does not return a value.\n        \"\"\"\n        for handler in self.broker.handlers.values():  # pragma: no branch\n            if topic in handler.topics:\n                await call_handler(\n                    handler=handler,\n                    message=[\n                        build_message(\n                            message=message,\n                            topic=topic,\n                            partition=partition,\n                            timestamp_ms=timestamp_ms,\n                            headers=headers,\n                        )\n                        for message in msgs\n                    ],\n                )\n\n        return None\n</code></pre>"},{"location":"api/faststream/kafka/test/FakeProducer/#faststream.kafka.test.FakeProducer-attributes","title":"Attributes","text":""},{"location":"api/faststream/kafka/test/FakeProducer/#faststream.kafka.test.FakeProducer.broker","title":"broker  <code>instance-attribute</code>","text":"<pre><code>broker = broker\n</code></pre>"},{"location":"api/faststream/kafka/test/FakeProducer/#faststream.kafka.test.FakeProducer-functions","title":"Functions","text":""},{"location":"api/faststream/kafka/test/FakeProducer/#faststream.kafka.test.FakeProducer.__init__","title":"__init__","text":"<pre><code>__init__(broker: KafkaBroker)\n</code></pre> <p>Initialize the FakeProducer.</p> <p>Parameters:</p> Name Type Description Default <code>broker</code> <code>KafkaBroker</code> <p>The KafkaBroker instance to associate with this FakeProducer.</p> required Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/test.py</code> <pre><code>def __init__(self, broker: KafkaBroker):\n\"\"\"\n    Initialize the FakeProducer.\n\n    Args:\n        broker (KafkaBroker): The KafkaBroker instance to associate with this FakeProducer.\n    \"\"\"\n    self.broker = broker\n</code></pre>"},{"location":"api/faststream/kafka/test/FakeProducer/#faststream.kafka.test.FakeProducer.publish","title":"publish  <code>async</code>","text":"<pre><code>publish(\n    message: SendableMessage,\n    topic: str,\n    key: Optional[bytes] = None,\n    partition: Optional[int] = None,\n    timestamp_ms: Optional[int] = None,\n    headers: Optional[Dict[str, str]] = None,\n    correlation_id: Optional[str] = None,\n    *,\n    reply_to: str = \"\",\n    rpc: bool = False,\n    rpc_timeout: Optional[float] = None,\n    raise_timeout: bool = False\n) -&gt; Optional[SendableMessage]\n</code></pre> <p>Publish a message to the Kafka broker.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>SendableMessage</code> <p>The message to be published.</p> required <code>topic</code> <code>str</code> <p>The Kafka topic to publish the message to.</p> required <code>key</code> <code>Optional[bytes]</code> <p>The message key. Defaults to None.</p> <code>None</code> <code>partition</code> <code>Optional[int]</code> <p>The Kafka partition to use. Defaults to None.</p> <code>None</code> <code>timestamp_ms</code> <code>Optional[int]</code> <p>The message timestamp in milliseconds. Defaults to None.</p> <code>None</code> <code>headers</code> <code>Optional[Dict[str, str]]</code> <p>Additional headers for the message. Defaults to None.</p> <code>None</code> <code>correlation_id</code> <code>Optional[str]</code> <p>The correlation ID for the message. Defaults to None.</p> <code>None</code> <code>reply_to</code> <code>str</code> <p>The topic to which responses should be sent. Defaults to \"\".</p> <code>''</code> <code>rpc</code> <code>bool</code> <p>If True, treat the message as an RPC request. Defaults to False.</p> <code>False</code> <code>rpc_timeout</code> <code>Optional[float]</code> <p>Timeout for RPC requests. Defaults to None.</p> <code>None</code> <code>raise_timeout</code> <code>bool</code> <p>If True, raise an exception on timeout. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Optional[SendableMessage]</code> <p>Optional[SendableMessage]: The response message, if this was an RPC request, otherwise None.</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/test.py</code> <pre><code>@override\nasync def publish(  # type: ignore[override]\n    self,\n    message: SendableMessage,\n    topic: str,\n    key: Optional[bytes] = None,\n    partition: Optional[int] = None,\n    timestamp_ms: Optional[int] = None,\n    headers: Optional[Dict[str, str]] = None,\n    correlation_id: Optional[str] = None,\n    *,\n    reply_to: str = \"\",\n    rpc: bool = False,\n    rpc_timeout: Optional[float] = None,\n    raise_timeout: bool = False,\n) -&gt; Optional[SendableMessage]:\n\"\"\"\n    Publish a message to the Kafka broker.\n\n    Args:\n        message (SendableMessage): The message to be published.\n        topic (str): The Kafka topic to publish the message to.\n        key (Optional[bytes], optional): The message key. Defaults to None.\n        partition (Optional[int], optional): The Kafka partition to use. Defaults to None.\n        timestamp_ms (Optional[int], optional): The message timestamp in milliseconds. Defaults to None.\n        headers (Optional[Dict[str, str]], optional): Additional headers for the message. Defaults to None.\n        correlation_id (Optional[str], optional): The correlation ID for the message. Defaults to None.\n        reply_to (str, optional): The topic to which responses should be sent. Defaults to \"\".\n        rpc (bool, optional): If True, treat the message as an RPC request. Defaults to False.\n        rpc_timeout (Optional[float], optional): Timeout for RPC requests. Defaults to None.\n        raise_timeout (bool, optional): If True, raise an exception on timeout. Defaults to False.\n\n    Returns:\n        Optional[SendableMessage]: The response message, if this was an RPC request, otherwise None.\n    \"\"\"\n    incoming = build_message(\n        message=message,\n        topic=topic,\n        key=key,\n        partition=partition,\n        timestamp_ms=timestamp_ms,\n        headers=headers,\n        correlation_id=correlation_id,\n        reply_to=reply_to,\n    )\n\n    for handler in self.broker.handlers.values():  # pragma: no branch\n        if topic in handler.topics:\n            r = await call_handler(\n                handler=handler,\n                message=[incoming] if handler.batch else incoming,\n                rpc=rpc,\n                rpc_timeout=rpc_timeout,\n                raise_timeout=raise_timeout,\n            )\n\n            if rpc:  # pragma: no branch\n                return r\n\n    return None\n</code></pre>"},{"location":"api/faststream/kafka/test/FakeProducer/#faststream.kafka.test.FakeProducer.publish_batch","title":"publish_batch  <code>async</code>","text":"<pre><code>publish_batch(\n    *msgs: SendableMessage,\n    topic: str,\n    partition: Optional[int] = None,\n    timestamp_ms: Optional[int] = None,\n    headers: Optional[Dict[str, str]] = None\n) -&gt; None\n</code></pre> <p>Publish a batch of messages to the Kafka broker.</p> <p>Parameters:</p> Name Type Description Default <code>*msgs</code> <code>SendableMessage</code> <p>Variable number of messages to be published.</p> <code>()</code> <code>topic</code> <code>str</code> <p>The Kafka topic to publish the messages to.</p> required <code>partition</code> <code>Optional[int]</code> <p>The Kafka partition to use. Defaults to None.</p> <code>None</code> <code>timestamp_ms</code> <code>Optional[int]</code> <p>The message timestamp in milliseconds. Defaults to None.</p> <code>None</code> <code>headers</code> <code>Optional[Dict[str, str]]</code> <p>Additional headers for the messages. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>This method does not return a value.</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/test.py</code> <pre><code>async def publish_batch(\n    self,\n    *msgs: SendableMessage,\n    topic: str,\n    partition: Optional[int] = None,\n    timestamp_ms: Optional[int] = None,\n    headers: Optional[Dict[str, str]] = None,\n) -&gt; None:\n\"\"\"\n    Publish a batch of messages to the Kafka broker.\n\n    Args:\n        *msgs (SendableMessage): Variable number of messages to be published.\n        topic (str): The Kafka topic to publish the messages to.\n        partition (Optional[int], optional): The Kafka partition to use. Defaults to None.\n        timestamp_ms (Optional[int], optional): The message timestamp in milliseconds. Defaults to None.\n        headers (Optional[Dict[str, str]], optional): Additional headers for the messages. Defaults to None.\n\n    Returns:\n        None: This method does not return a value.\n    \"\"\"\n    for handler in self.broker.handlers.values():  # pragma: no branch\n        if topic in handler.topics:\n            await call_handler(\n                handler=handler,\n                message=[\n                    build_message(\n                        message=message,\n                        topic=topic,\n                        partition=partition,\n                        timestamp_ms=timestamp_ms,\n                        headers=headers,\n                    )\n                    for message in msgs\n                ],\n            )\n\n    return None\n</code></pre>"},{"location":"api/faststream/kafka/test/TestKafkaBroker/","title":"TestKafkaBroker","text":""},{"location":"api/faststream/kafka/test/TestKafkaBroker/#faststream.kafka.test.TestKafkaBroker","title":"faststream.kafka.test.TestKafkaBroker","text":"<p>A context manager for creating a test KafkaBroker instance with optional mocking.</p> <p>This class serves as a context manager for creating a KafkaBroker instance for testing purposes. It can either use the original KafkaBroker instance (if <code>with_real</code> is True) or replace certain components with mocks (if <code>with_real</code> is False) to isolate the broker during testing.</p> <p>Parameters:</p> Name Type Description Default <code>broker</code> <code>KafkaBroker</code> <p>The KafkaBroker instance to be used in testing.</p> required <code>with_real</code> <code>bool</code> <p>If True, the original broker is returned; if False, components are replaced with mock objects. Defaults to False.</p> <code>False</code> <p>Attributes:</p> Name Type Description <code>broker</code> <code>KafkaBroker</code> <p>The KafkaBroker instance provided for testing.</p> <code>with_real</code> <code>bool</code> <p>A boolean flag indicating whether to use the original broker (True) or replace components with mocks (False).</p> <p>Methods:</p> Name Description <code>__aenter__</code> <p>Enter the context and return the KafkaBroker instance.</p> <code>__aexit__</code> <p>Any) -&gt; None: Exit the context.</p> <p>Example usage:</p> <p>```python real_broker = KafkaBroker() with TestKafkaBroker(real_broker, with_real=True) as broker:     # Use the real KafkaBroker instance for testing.</p> <p>with TestKafkaBroker(real_broker, with_real=False) as broker:     # Use a mocked KafkaBroker instance for testing.</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/test.py</code> <pre><code>class TestKafkaBroker:\n\"\"\"\n    A context manager for creating a test KafkaBroker instance with optional mocking.\n\n    This class serves as a context manager for creating a KafkaBroker instance for testing purposes. It can either use the\n    original KafkaBroker instance (if `with_real` is True) or replace certain components with mocks (if `with_real` is\n    False) to isolate the broker during testing.\n\n    Args:\n        broker (KafkaBroker): The KafkaBroker instance to be used in testing.\n        with_real (bool, optional): If True, the original broker is returned; if False, components are replaced with\n            mock objects. Defaults to False.\n\n    Attributes:\n        broker (KafkaBroker): The KafkaBroker instance provided for testing.\n        with_real (bool): A boolean flag indicating whether to use the original broker (True) or replace components with\n            mocks (False).\n\n    Methods:\n        __aenter__(self) -&gt; KafkaBroker:\n            Enter the context and return the KafkaBroker instance.\n\n        __aexit__(self, *args: Any) -&gt; None:\n            Exit the context.\n\n    Example usage:\n\n    ```python\n    real_broker = KafkaBroker()\n    with TestKafkaBroker(real_broker, with_real=True) as broker:\n        # Use the real KafkaBroker instance for testing.\n\n    with TestKafkaBroker(real_broker, with_real=False) as broker:\n        # Use a mocked KafkaBroker instance for testing.\n    \"\"\"\n\n    # This is set so pytest ignores this class\n    __test__ = False\n\n    def __init__(self, broker: KafkaBroker, with_real: bool = False):\n\"\"\"\n        Initialize a TestKafkaBroker instance.\n\n        Args:\n            broker (KafkaBroker): The KafkaBroker instance to be used in testing.\n            with_real (bool, optional): If True, the original broker is returned; if False, components are replaced with\n                mock objects. Defaults to False.\n        \"\"\"\n        self.with_real = with_real\n        self.broker = broker\n\n    @asynccontextmanager\n    async def _create_ctx(self) -&gt; AsyncGenerator[KafkaBroker, None]:\n\"\"\"\n        Create the context for the context manager.\n\n        Yields:\n            KafkaBroker: The KafkaBroker instance for testing, either with or without mocks.\n        \"\"\"\n        if not self.with_real:\n            self.broker.start = AsyncMock(wraps=partial(_fake_start, self.broker))  # type: ignore[method-assign]\n            self.broker._connect = MethodType(_fake_connect, self.broker)  # type: ignore[method-assign]\n            self.broker.close = MethodType(_fake_close, self.broker)  # type: ignore[method-assign]\n        else:\n            _fake_start(self.broker)\n\n        async with self.broker:\n            try:\n                await self.broker.start()\n                yield self.broker\n            finally:\n                pass\n\n    async def __aenter__(self) -&gt; KafkaBroker:\n\"\"\"\n        Enter the context and return the KafkaBroker instance.\n\n        Returns:\n            KafkaBroker: The KafkaBroker instance for testing, either with or without mocks.\n        \"\"\"\n        self._ctx = self._create_ctx()\n        return await self._ctx.__aenter__()\n\n    async def __aexit__(self, *args: Any) -&gt; None:\n\"\"\"\n        Exit the context.\n\n        Args:\n            *args: Variable-length argument list.\n        \"\"\"\n        await self._ctx.__aexit__(*args)\n</code></pre>"},{"location":"api/faststream/kafka/test/TestKafkaBroker/#faststream.kafka.test.TestKafkaBroker-attributes","title":"Attributes","text":""},{"location":"api/faststream/kafka/test/TestKafkaBroker/#faststream.kafka.test.TestKafkaBroker.__test__","title":"__test__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__test__ = False\n</code></pre>"},{"location":"api/faststream/kafka/test/TestKafkaBroker/#faststream.kafka.test.TestKafkaBroker.broker","title":"broker  <code>instance-attribute</code>","text":"<pre><code>broker = broker\n</code></pre>"},{"location":"api/faststream/kafka/test/TestKafkaBroker/#faststream.kafka.test.TestKafkaBroker.with_real","title":"with_real  <code>instance-attribute</code>","text":"<pre><code>with_real = with_real\n</code></pre>"},{"location":"api/faststream/kafka/test/TestKafkaBroker/#faststream.kafka.test.TestKafkaBroker-functions","title":"Functions","text":""},{"location":"api/faststream/kafka/test/TestKafkaBroker/#faststream.kafka.test.TestKafkaBroker.__aenter__","title":"__aenter__  <code>async</code>","text":"<pre><code>__aenter__() -&gt; KafkaBroker\n</code></pre> <p>Enter the context and return the KafkaBroker instance.</p> <p>Returns:</p> Name Type Description <code>KafkaBroker</code> <code>KafkaBroker</code> <p>The KafkaBroker instance for testing, either with or without mocks.</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/test.py</code> <pre><code>async def __aenter__(self) -&gt; KafkaBroker:\n\"\"\"\n    Enter the context and return the KafkaBroker instance.\n\n    Returns:\n        KafkaBroker: The KafkaBroker instance for testing, either with or without mocks.\n    \"\"\"\n    self._ctx = self._create_ctx()\n    return await self._ctx.__aenter__()\n</code></pre>"},{"location":"api/faststream/kafka/test/TestKafkaBroker/#faststream.kafka.test.TestKafkaBroker.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(*args: Any) -&gt; None\n</code></pre> <p>Exit the context.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Any</code> <p>Variable-length argument list.</p> <code>()</code> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/test.py</code> <pre><code>async def __aexit__(self, *args: Any) -&gt; None:\n\"\"\"\n    Exit the context.\n\n    Args:\n        *args: Variable-length argument list.\n    \"\"\"\n    await self._ctx.__aexit__(*args)\n</code></pre>"},{"location":"api/faststream/kafka/test/TestKafkaBroker/#faststream.kafka.test.TestKafkaBroker.__init__","title":"__init__","text":"<pre><code>__init__(broker: KafkaBroker, with_real: bool = False)\n</code></pre> <p>Initialize a TestKafkaBroker instance.</p> <p>Parameters:</p> Name Type Description Default <code>broker</code> <code>KafkaBroker</code> <p>The KafkaBroker instance to be used in testing.</p> required <code>with_real</code> <code>bool</code> <p>If True, the original broker is returned; if False, components are replaced with mock objects. Defaults to False.</p> <code>False</code> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/test.py</code> <pre><code>def __init__(self, broker: KafkaBroker, with_real: bool = False):\n\"\"\"\n    Initialize a TestKafkaBroker instance.\n\n    Args:\n        broker (KafkaBroker): The KafkaBroker instance to be used in testing.\n        with_real (bool, optional): If True, the original broker is returned; if False, components are replaced with\n            mock objects. Defaults to False.\n    \"\"\"\n    self.with_real = with_real\n    self.broker = broker\n</code></pre>"},{"location":"api/faststream/kafka/test/build_message/","title":"build_message","text":""},{"location":"api/faststream/kafka/test/build_message/#faststream.kafka.test.build_message","title":"faststream.kafka.test.build_message","text":"<pre><code>build_message(\n    message: SendableMessage,\n    topic: str,\n    partition: Optional[int] = None,\n    timestamp_ms: Optional[int] = None,\n    key: Optional[bytes] = None,\n    headers: Optional[Dict[str, str]] = None,\n    correlation_id: Optional[str] = None,\n    *,\n    reply_to: str = \"\"\n) -&gt; ConsumerRecord\n</code></pre> <p>Build a Kafka ConsumerRecord for a sendable message.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>SendableMessage</code> <p>The sendable message to be encoded.</p> required <code>topic</code> <code>str</code> <p>The Kafka topic for the message.</p> required <code>partition</code> <code>Optional[int]</code> <p>The Kafka partition for the message. Defaults to None.</p> <code>None</code> <code>timestamp_ms</code> <code>Optional[int]</code> <p>The message timestamp in milliseconds. Defaults to None.</p> <code>None</code> <code>key</code> <code>Optional[bytes]</code> <p>The message key. Defaults to None.</p> <code>None</code> <code>headers</code> <code>Optional[Dict[str, str]]</code> <p>Additional headers for the message. Defaults to None.</p> <code>None</code> <code>correlation_id</code> <code>Optional[str]</code> <p>The correlation ID for the message. Defaults to None.</p> <code>None</code> <code>reply_to</code> <code>str</code> <p>The topic to which responses should be sent. Defaults to \"\".</p> <code>''</code> <p>Returns:</p> Name Type Description <code>ConsumerRecord</code> <code>ConsumerRecord</code> <p>A Kafka ConsumerRecord object.</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/test.py</code> <pre><code>def build_message(\n    message: SendableMessage,\n    topic: str,\n    partition: Optional[int] = None,\n    timestamp_ms: Optional[int] = None,\n    key: Optional[bytes] = None,\n    headers: Optional[Dict[str, str]] = None,\n    correlation_id: Optional[str] = None,\n    *,\n    reply_to: str = \"\",\n) -&gt; ConsumerRecord:\n\"\"\"\n    Build a Kafka ConsumerRecord for a sendable message.\n\n    Args:\n        message (SendableMessage): The sendable message to be encoded.\n        topic (str): The Kafka topic for the message.\n        partition (Optional[int], optional): The Kafka partition for the message. Defaults to None.\n        timestamp_ms (Optional[int], optional): The message timestamp in milliseconds. Defaults to None.\n        key (Optional[bytes], optional): The message key. Defaults to None.\n        headers (Optional[Dict[str, str]], optional): Additional headers for the message. Defaults to None.\n        correlation_id (Optional[str], optional): The correlation ID for the message. Defaults to None.\n        reply_to (str, optional): The topic to which responses should be sent. Defaults to \"\".\n\n    Returns:\n        ConsumerRecord: A Kafka ConsumerRecord object.\n    \"\"\"\n    msg, content_type = encode_message(message)\n    k = key or b\"\"\n    headers = {\n        \"content-type\": content_type or \"\",\n        \"correlation_id\": correlation_id or str(uuid4()),\n        \"reply_to\": reply_to,\n        **(headers or {}),\n    }\n\n    return ConsumerRecord(\n        value=msg,\n        topic=topic,\n        partition=partition or 0,\n        timestamp=timestamp_ms or int(datetime.now().timestamp()),\n        timestamp_type=0,\n        key=k,\n        serialized_key_size=len(k),\n        serialized_value_size=len(msg),\n        checksum=sum(msg),\n        offset=0,\n        headers=[(i, j.encode()) for i, j in headers.items()],\n    )\n</code></pre>"},{"location":"api/faststream/log/formatter/ColourizedFormatter/","title":"ColourizedFormatter","text":""},{"location":"api/faststream/log/formatter/ColourizedFormatter/#faststream.log.formatter.ColourizedFormatter","title":"faststream.log.formatter.ColourizedFormatter","text":"<p>             Bases: <code>Formatter</code></p> <p>A class to format log messages with colorized level names.</p> <p>Attributes:</p> Name Type Description <code>level_name_colors</code> <p>A dictionary mapping log level names to functions that colorize the level names.</p> <p>Methods:</p> Name Description <code>__init__ </code> <p>Initialize the formatter with specified format strings.</p> <code>color_level_name </code> <p>Colorize the level name based on the log level.</p> <code>formatMessage </code> <p>Format the log record message with colorized level name.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/log/formatter.py</code> <pre><code>class ColourizedFormatter(logging.Formatter):\n\"\"\"A class to format log messages with colorized level names.\n\n    Attributes:\n        level_name_colors : A dictionary mapping log level names to functions that colorize the level names.\n\n    Methods:\n        __init__ : Initialize the formatter with specified format strings.\n        color_level_name : Colorize the level name based on the log level.\n        formatMessage : Format the log record message with colorized level name.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    level_name_colors: DefaultDict[str, Callable[[str], str]] = defaultdict(\n        lambda: str,\n        **{\n            str(logging.DEBUG): lambda level_name: click.style(\n                str(level_name), fg=\"cyan\"\n            ),\n            str(logging.INFO): lambda level_name: click.style(\n                str(level_name), fg=\"green\"\n            ),\n            str(logging.WARNING): lambda level_name: click.style(\n                str(level_name), fg=\"yellow\"\n            ),\n            str(logging.ERROR): lambda level_name: click.style(\n                str(level_name), fg=\"red\"\n            ),\n            str(logging.CRITICAL): lambda level_name: click.style(\n                str(level_name), fg=\"bright_red\"\n            ),\n        },\n    )\n\n    def __init__(\n        self,\n        fmt: Optional[str] = None,\n        datefmt: Optional[str] = None,\n        style: Literal[\"%\", \"{\", \"$\"] = \"%\",\n        use_colors: Optional[bool] = None,\n    ):\n\"\"\"\n        Initialize the formatter with specified format strings.\n\n        Initialize the formatter either with the specified format string, or a\n        default as described above. Allow for specialized date formatting with\n        the optional datefmt argument. If datefmt is omitted, you get an\n        ISO8601-like (or RFC 3339-like) format.\n\n        Use a style parameter of '%', '{' or '$' to specify that you want to\n        use one of %-formatting, :meth:`str.format` (``{}``) formatting or\n        :class:`string.Template` formatting in your format string.\n        \"\"\"\n        if use_colors in (True, False):\n            self.use_colors = use_colors\n        else:\n            self.use_colors = sys.stdout.isatty()\n        super().__init__(fmt=fmt, datefmt=datefmt, style=style)\n\n    def color_level_name(self, level_name: str, level_no: int) -&gt; str:\n\"\"\"Returns the colored level name.\n\n        Args:\n            level_name: The name of the level.\n            level_no: The number of the level.\n\n        Returns:\n            The colored level name.\n\n        Raises:\n            KeyError: If the level number is not found in the level name colors dictionary.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        return self.level_name_colors[str(level_no)](level_name)\n\n    def formatMessage(self, record: logging.LogRecord) -&gt; str:\n\"\"\"Formats the log message.\n\n        Args:\n            record (logging.LogRecord): The log record to format.\n\n        Returns:\n            str: The formatted log message.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        levelname = expand_log_field(record.levelname, 8)\n        if self.use_colors is True:  # pragma: no cover\n            levelname = self.color_level_name(levelname, record.levelno)\n        record.__dict__[\"levelname\"] = levelname\n        return super().formatMessage(record)\n</code></pre>"},{"location":"api/faststream/log/formatter/ColourizedFormatter/#faststream.log.formatter.ColourizedFormatter-attributes","title":"Attributes","text":""},{"location":"api/faststream/log/formatter/ColourizedFormatter/#faststream.log.formatter.ColourizedFormatter.level_name_colors","title":"level_name_colors  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>level_name_colors: DefaultDict[\n    str, Callable[[str], str]\n] = defaultdict(\n    lambda: str,\n    **{\n        str(logging.DEBUG): lambda: click.style(\n            str(level_name), fg=\"cyan\"\n        ),\n        str(logging.INFO): lambda: click.style(\n            str(level_name), fg=\"green\"\n        ),\n        str(logging.WARNING): lambda: click.style(\n            str(level_name), fg=\"yellow\"\n        ),\n        str(logging.ERROR): lambda: click.style(\n            str(level_name), fg=\"red\"\n        ),\n        str(logging.CRITICAL): lambda: click.style(\n            str(level_name), fg=\"bright_red\"\n        ),\n    }\n)\n</code></pre>"},{"location":"api/faststream/log/formatter/ColourizedFormatter/#faststream.log.formatter.ColourizedFormatter.use_colors","title":"use_colors  <code>instance-attribute</code>","text":"<pre><code>use_colors = use_colors\n</code></pre>"},{"location":"api/faststream/log/formatter/ColourizedFormatter/#faststream.log.formatter.ColourizedFormatter-functions","title":"Functions","text":""},{"location":"api/faststream/log/formatter/ColourizedFormatter/#faststream.log.formatter.ColourizedFormatter.__init__","title":"__init__","text":"<pre><code>__init__(\n    fmt: Optional[str] = None,\n    datefmt: Optional[str] = None,\n    style: Literal[\"%\", \"{\", \"$\"] = \"%\",\n    use_colors: Optional[bool] = None,\n)\n</code></pre> <p>Initialize the formatter with specified format strings.</p> <p>Initialize the formatter either with the specified format string, or a default as described above. Allow for specialized date formatting with the optional datefmt argument. If datefmt is omitted, you get an ISO8601-like (or RFC 3339-like) format.</p> <p>Use a style parameter of '%', '{' or '$' to specify that you want to use one of %-formatting, :meth:<code>str.format</code> (<code>{}</code>) formatting or :class:<code>string.Template</code> formatting in your format string.</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/log/formatter.py</code> <pre><code>def __init__(\n    self,\n    fmt: Optional[str] = None,\n    datefmt: Optional[str] = None,\n    style: Literal[\"%\", \"{\", \"$\"] = \"%\",\n    use_colors: Optional[bool] = None,\n):\n\"\"\"\n    Initialize the formatter with specified format strings.\n\n    Initialize the formatter either with the specified format string, or a\n    default as described above. Allow for specialized date formatting with\n    the optional datefmt argument. If datefmt is omitted, you get an\n    ISO8601-like (or RFC 3339-like) format.\n\n    Use a style parameter of '%', '{' or '$' to specify that you want to\n    use one of %-formatting, :meth:`str.format` (``{}``) formatting or\n    :class:`string.Template` formatting in your format string.\n    \"\"\"\n    if use_colors in (True, False):\n        self.use_colors = use_colors\n    else:\n        self.use_colors = sys.stdout.isatty()\n    super().__init__(fmt=fmt, datefmt=datefmt, style=style)\n</code></pre>"},{"location":"api/faststream/log/formatter/ColourizedFormatter/#faststream.log.formatter.ColourizedFormatter.color_level_name","title":"color_level_name","text":"<pre><code>color_level_name(level_name: str, level_no: int) -&gt; str\n</code></pre> <p>Returns the colored level name.</p> <p>Parameters:</p> Name Type Description Default <code>level_name</code> <code>str</code> <p>The name of the level.</p> required <code>level_no</code> <code>int</code> <p>The number of the level.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The colored level name.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the level number is not found in the level name colors dictionary.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/log/formatter.py</code> <pre><code>def color_level_name(self, level_name: str, level_no: int) -&gt; str:\n\"\"\"Returns the colored level name.\n\n    Args:\n        level_name: The name of the level.\n        level_no: The number of the level.\n\n    Returns:\n        The colored level name.\n\n    Raises:\n        KeyError: If the level number is not found in the level name colors dictionary.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    return self.level_name_colors[str(level_no)](level_name)\n</code></pre>"},{"location":"api/faststream/log/formatter/ColourizedFormatter/#faststream.log.formatter.ColourizedFormatter.formatMessage","title":"formatMessage","text":"<pre><code>formatMessage(record: logging.LogRecord) -&gt; str\n</code></pre> <p>Formats the log message.</p> <p>Parameters:</p> Name Type Description Default <code>record</code> <code>LogRecord</code> <p>The log record to format.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The formatted log message.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/log/formatter.py</code> <pre><code>def formatMessage(self, record: logging.LogRecord) -&gt; str:\n\"\"\"Formats the log message.\n\n    Args:\n        record (logging.LogRecord): The log record to format.\n\n    Returns:\n        str: The formatted log message.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    levelname = expand_log_field(record.levelname, 8)\n    if self.use_colors is True:  # pragma: no cover\n        levelname = self.color_level_name(levelname, record.levelno)\n    record.__dict__[\"levelname\"] = levelname\n    return super().formatMessage(record)\n</code></pre>"},{"location":"api/faststream/log/formatter/expand_log_field/","title":"expand_log_field","text":""},{"location":"api/faststream/log/formatter/expand_log_field/#faststream.log.formatter.expand_log_field","title":"faststream.log.formatter.expand_log_field","text":"<pre><code>expand_log_field(field: str, symbols: int) -&gt; str\n</code></pre> <p>Expands a log field by adding spaces.</p> <p>Parameters:</p> Name Type Description Default <code>field</code> <code>str</code> <p>The log field to expand.</p> required <code>symbols</code> <code>int</code> <p>The desired length of the expanded field.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The expanded log field.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/log/formatter.py</code> <pre><code>def expand_log_field(field: str, symbols: int) -&gt; str:\n\"\"\"Expands a log field by adding spaces.\n\n    Args:\n        field: The log field to expand.\n        symbols: The desired length of the expanded field.\n\n    Returns:\n        The expanded log field.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    return field + (\" \" * (symbols - len(field)))\n</code></pre>"},{"location":"api/faststream/log/formatter/make_record_with_extra/","title":"make_record_with_extra","text":""},{"location":"api/faststream/log/formatter/make_record_with_extra/#faststream.log.formatter.make_record_with_extra","title":"faststream.log.formatter.make_record_with_extra","text":"<pre><code>make_record_with_extra(\n    self: logging.Logger,\n    name: str,\n    level: int,\n    fn: str,\n    lno: int,\n    msg: str,\n    args: Tuple[str],\n    exc_info: Optional[\n        Union[\n            Tuple[\n                Type[BaseException],\n                BaseException,\n                Optional[TracebackType],\n            ],\n            Tuple[None, None, None],\n        ]\n    ],\n    func: Optional[str] = None,\n    extra: Optional[Mapping[str, object]] = None,\n    sinfo: Optional[str] = None,\n) -&gt; logging.LogRecord\n</code></pre> <p>Creates a log record with additional information.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <code>Logger</code> <p>The logger object.</p> required <code>name</code> <code>str</code> <p>The name of the logger.</p> required <code>level</code> <code>int</code> <p>The logging level.</p> required <code>fn</code> <code>str</code> <p>The filename where the log message originated.</p> required <code>lno</code> <code>int</code> <p>The line number where the log message originated.</p> required <code>msg</code> <code>str</code> <p>The log message.</p> required <code>args</code> <code>Tuple[str]</code> <p>The arguments for the log message.</p> required <code>exc_info</code> <code>Optional[Union[Tuple[Type[BaseException], BaseException, Optional[TracebackType]], Tuple[None, None, None]]]</code> <p>Information about an exception.</p> required <code>func</code> <code>Optional[str]</code> <p>The name of the function where the log message originated.</p> <code>None</code> <code>extra</code> <code>Optional[Mapping[str, object]]</code> <p>Additional information to include in the log record.</p> <code>None</code> <code>sinfo</code> <code>Optional[str]</code> <p>Stack information.</p> <code>None</code> <p>Returns:</p> Type Description <code>LogRecord</code> <p>The log record.</p> Note <p>If <code>extra</code> is <code>None</code>, it will be set to the value of <code>context.get_local(\"log_context\")</code>.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/log/formatter.py</code> <pre><code>def make_record_with_extra(\n    self: logging.Logger,\n    name: str,\n    level: int,\n    fn: str,\n    lno: int,\n    msg: str,\n    args: Tuple[str],\n    exc_info: Optional[\n        Union[\n            Tuple[Type[BaseException], BaseException, Optional[TracebackType]],\n            Tuple[None, None, None],\n        ]\n    ],\n    func: Optional[str] = None,\n    extra: Optional[Mapping[str, object]] = None,\n    sinfo: Optional[str] = None,\n) -&gt; logging.LogRecord:\n\"\"\"Creates a log record with additional information.\n\n    Args:\n        self: The logger object.\n        name: The name of the logger.\n        level: The logging level.\n        fn: The filename where the log message originated.\n        lno: The line number where the log message originated.\n        msg: The log message.\n        args: The arguments for the log message.\n        exc_info: Information about an exception.\n        func: The name of the function where the log message originated.\n        extra: Additional information to include in the log record.\n        sinfo: Stack information.\n\n    Returns:\n        The log record.\n\n    Note:\n        If `extra` is `None`, it will be set to the value of `context.get_local(\"log_context\")`.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    if extra is None:\n        extra = context.get_local(\"log_context\")\n\n    record = original_makeRecord(\n        self,\n        name,\n        level,\n        fn,\n        lno,\n        msg,\n        args,\n        exc_info,\n        func,\n        extra,\n        sinfo,\n    )\n\n    return record\n</code></pre>"},{"location":"api/faststream/log/logging/configure_formatter/","title":"configure_formatter","text":""},{"location":"api/faststream/log/logging/configure_formatter/#faststream.log.logging.configure_formatter","title":"faststream.log.logging.configure_formatter","text":"<pre><code>configure_formatter(\n    formatter: Type[logging.Formatter],\n    *args: Any,\n    **kwargs: Any\n) -&gt; logging.Formatter\n</code></pre> <p>Configures a logging formatter.</p> <p>Parameters:</p> Name Type Description Default <code>formatter</code> <code>Type[Formatter]</code> <p>The type of logging formatter to configure.</p> required <code>*args</code> <code>Any</code> <p>Additional positional arguments to pass to the formatter constructor.</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments to pass to the formatter constructor.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Formatter</code> <p>An instance of the configured logging formatter.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/log/logging.py</code> <pre><code>def configure_formatter(\n    formatter: Type[logging.Formatter], *args: Any, **kwargs: Any\n) -&gt; logging.Formatter:\n\"\"\"Configures a logging formatter.\n\n    Args:\n        formatter: The type of logging formatter to configure.\n        *args: Additional positional arguments to pass to the formatter constructor.\n        **kwargs: Additional keyword arguments to pass to the formatter constructor.\n\n    Returns:\n        An instance of the configured logging formatter.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    return formatter(*args, **kwargs)\n</code></pre>"},{"location":"api/faststream/rabbit/asyncapi/Handler/","title":"Handler","text":""},{"location":"api/faststream/rabbit/asyncapi/Handler/#faststream.rabbit.asyncapi.Handler","title":"faststream.rabbit.asyncapi.Handler","text":"<p>             Bases: <code>RMQAsyncAPIChannel</code>, <code>LogicHandler</code></p> <p>A class that serves as a handler for RMQAsyncAPIChannel and LogicHandler.</p> <p>Methods:</p> Name Description <code>- name</code> <p>Returns the name of the handler.</p> <code>- get_payloads</code> <p>Returns a list of payloads.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/asyncapi.py</code> <pre><code>class Handler(RMQAsyncAPIChannel, LogicHandler):\n\"\"\"A class that serves as a handler for RMQAsyncAPIChannel and LogicHandler.\n\n    Methods:\n        - name(): Returns the name of the handler.\n        - get_payloads(): Returns a list of payloads.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    @property\n    def name(self) -&gt; str:\n        original = super().name\n\n        name: str\n        queue_ = to_camelcase(self.queue.name)\n        if original is True:\n            if not self.call_name.lower().endswith(queue_.lower()):\n                name = f\"{self.call_name}{queue_}\"\n            else:\n                name = self.call_name\n        elif original is False:  # pragma: no cover\n            name = f\"Handler{queue_}\"\n        else:\n            name = original\n\n        return name\n\n    def get_payloads(self) -&gt; List[AnyDict]:\n        payloads = []\n        for _, _, _, _, _, dep in self.calls:\n            body = parse_handler_params(dep, prefix=self.name)\n            payloads.append(body)\n\n        return payloads\n</code></pre>"},{"location":"api/faststream/rabbit/asyncapi/Handler/#faststream.rabbit.asyncapi.Handler-attributes","title":"Attributes","text":""},{"location":"api/faststream/rabbit/asyncapi/Handler/#faststream.rabbit.asyncapi.Handler.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"api/faststream/rabbit/asyncapi/Handler/#faststream.rabbit.asyncapi.Handler-functions","title":"Functions","text":""},{"location":"api/faststream/rabbit/asyncapi/Handler/#faststream.rabbit.asyncapi.Handler.get_payloads","title":"get_payloads","text":"<pre><code>get_payloads() -&gt; List[AnyDict]\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/asyncapi.py</code> <pre><code>def get_payloads(self) -&gt; List[AnyDict]:\n    payloads = []\n    for _, _, _, _, _, dep in self.calls:\n        body = parse_handler_params(dep, prefix=self.name)\n        payloads.append(body)\n\n    return payloads\n</code></pre>"},{"location":"api/faststream/rabbit/asyncapi/Publisher/","title":"Publisher","text":""},{"location":"api/faststream/rabbit/asyncapi/Publisher/#faststream.rabbit.asyncapi.Publisher","title":"faststream.rabbit.asyncapi.Publisher","text":"<p>             Bases: <code>RMQAsyncAPIChannel</code>, <code>LogicPublisher</code></p> <p>A class representing a publisher.</p> <p>Attributes:</p> Name Type Description <code>name</code> <p>name of the publisher</p> <p>Methods:</p> Name Description <code>get_payloads </code> <p>Get the payloads for the publisher</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/asyncapi.py</code> <pre><code>class Publisher(RMQAsyncAPIChannel, LogicPublisher):\n\"\"\"A class representing a publisher.\n\n    Attributes:\n        name : name of the publisher\n\n    Methods:\n        get_payloads : Get the payloads for the publisher\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    @property\n    def name(self) -&gt; str:\n        return self.title or f\"{self.queue.name.title()}Publisher\"\n\n    def get_payloads(self) -&gt; List[AnyDict]:\n        payloads = []\n        for call in self.calls:\n            call_model = build_call_model(call)\n            body = get_response_schema(\n                call_model,\n                prefix=to_camelcase(call_model.call_name),\n            )\n            if body:\n                payloads.append(body)\n\n        return payloads\n</code></pre>"},{"location":"api/faststream/rabbit/asyncapi/Publisher/#faststream.rabbit.asyncapi.Publisher-attributes","title":"Attributes","text":""},{"location":"api/faststream/rabbit/asyncapi/Publisher/#faststream.rabbit.asyncapi.Publisher.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"api/faststream/rabbit/asyncapi/Publisher/#faststream.rabbit.asyncapi.Publisher-functions","title":"Functions","text":""},{"location":"api/faststream/rabbit/asyncapi/Publisher/#faststream.rabbit.asyncapi.Publisher.get_payloads","title":"get_payloads","text":"<pre><code>get_payloads() -&gt; List[AnyDict]\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/asyncapi.py</code> <pre><code>def get_payloads(self) -&gt; List[AnyDict]:\n    payloads = []\n    for call in self.calls:\n        call_model = build_call_model(call)\n        body = get_response_schema(\n            call_model,\n            prefix=to_camelcase(call_model.call_name),\n        )\n        if body:\n            payloads.append(body)\n\n    return payloads\n</code></pre>"},{"location":"api/faststream/rabbit/asyncapi/RMQAsyncAPIChannel/","title":"RMQAsyncAPIChannel","text":""},{"location":"api/faststream/rabbit/asyncapi/RMQAsyncAPIChannel/#faststream.rabbit.asyncapi.RMQAsyncAPIChannel","title":"faststream.rabbit.asyncapi.RMQAsyncAPIChannel","text":"<p>             Bases: <code>AsyncAPIOperation</code>, <code>BaseRMQInformation</code></p> <p>A class representing an RMQAsyncAPIChannel.</p> <p>Methods:</p> Name Description <code>get_payloads</code> <p>Abstract method that returns a list of dictionaries representing the payloads.</p> <code>schema</code> <p>Returns a dictionary representing the schema of the channel.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/asyncapi.py</code> <pre><code>class RMQAsyncAPIChannel(AsyncAPIOperation, BaseRMQInformation):\n\"\"\"A class representing an RMQAsyncAPIChannel.\n\n    Methods:\n        get_payloads: Abstract method that returns a list of dictionaries representing the payloads.\n        schema: Returns a dictionary representing the schema of the channel.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    @abstractmethod\n    def get_payloads(self) -&gt; List[AnyDict]:\n        raise NotImplementedError()\n\n    def schema(self) -&gt; Dict[str, Channel]:\n        payloads = self.get_payloads()\n\n        return {\n            self.name: Channel(\n                description=self.description,  # type: ignore[attr-defined]\n                subscribe=Operation(\n                    bindings=OperationBinding(\n                        amqp=amqp.OperationBinding(\n                            cc=self.queue.name,\n                        ),\n                    )\n                    if _is_exchange(self.exchange)\n                    else None,\n                    message=Message(\n                        title=f\"{self.name}Message\",\n                        payload=resolve_payloads(payloads),\n                        correlationId=CorrelationId(\n                            location=\"$message.header#/correlation_id\"\n                        ),\n                    ),\n                ),\n                bindings=ChannelBinding(\n                    amqp=amqp.ChannelBinding(\n                        **{\n                            \"is\": \"routingKey\",  # type: ignore\n                            \"queue\": amqp.Queue(\n                                name=self.queue.name,\n                                durable=self.queue.durable,\n                                exclusive=self.queue.exclusive,\n                                autoDelete=self.queue.auto_delete,\n                            )\n                            if _is_exchange(self.exchange)\n                            else None,\n                            \"exchange\": (\n                                amqp.Exchange(type=\"default\")\n                                if self.exchange is None\n                                else amqp.Exchange(\n                                    type=self.exchange.type,  # type: ignore\n                                    name=self.exchange.name,\n                                    durable=self.exchange.durable,\n                                    autoDelete=self.exchange.auto_delete,\n                                )\n                            ),\n                        }\n                    )\n                ),\n            )\n        }\n</code></pre>"},{"location":"api/faststream/rabbit/asyncapi/RMQAsyncAPIChannel/#faststream.rabbit.asyncapi.RMQAsyncAPIChannel-functions","title":"Functions","text":""},{"location":"api/faststream/rabbit/asyncapi/RMQAsyncAPIChannel/#faststream.rabbit.asyncapi.RMQAsyncAPIChannel.get_payloads","title":"get_payloads  <code>abstractmethod</code>","text":"<pre><code>get_payloads() -&gt; List[AnyDict]\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/asyncapi.py</code> <pre><code>@abstractmethod\ndef get_payloads(self) -&gt; List[AnyDict]:\n    raise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/rabbit/asyncapi/RMQAsyncAPIChannel/#faststream.rabbit.asyncapi.RMQAsyncAPIChannel.schema","title":"schema","text":"<pre><code>schema() -&gt; Dict[str, Channel]\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/asyncapi.py</code> <pre><code>def schema(self) -&gt; Dict[str, Channel]:\n    payloads = self.get_payloads()\n\n    return {\n        self.name: Channel(\n            description=self.description,  # type: ignore[attr-defined]\n            subscribe=Operation(\n                bindings=OperationBinding(\n                    amqp=amqp.OperationBinding(\n                        cc=self.queue.name,\n                    ),\n                )\n                if _is_exchange(self.exchange)\n                else None,\n                message=Message(\n                    title=f\"{self.name}Message\",\n                    payload=resolve_payloads(payloads),\n                    correlationId=CorrelationId(\n                        location=\"$message.header#/correlation_id\"\n                    ),\n                ),\n            ),\n            bindings=ChannelBinding(\n                amqp=amqp.ChannelBinding(\n                    **{\n                        \"is\": \"routingKey\",  # type: ignore\n                        \"queue\": amqp.Queue(\n                            name=self.queue.name,\n                            durable=self.queue.durable,\n                            exclusive=self.queue.exclusive,\n                            autoDelete=self.queue.auto_delete,\n                        )\n                        if _is_exchange(self.exchange)\n                        else None,\n                        \"exchange\": (\n                            amqp.Exchange(type=\"default\")\n                            if self.exchange is None\n                            else amqp.Exchange(\n                                type=self.exchange.type,  # type: ignore\n                                name=self.exchange.name,\n                                durable=self.exchange.durable,\n                                autoDelete=self.exchange.auto_delete,\n                            )\n                        ),\n                    }\n                )\n            ),\n        )\n    }\n</code></pre>"},{"location":"api/faststream/rabbit/broker/RabbitBroker/","title":"RabbitBroker","text":""},{"location":"api/faststream/rabbit/broker/RabbitBroker/#faststream.rabbit.broker.RabbitBroker","title":"faststream.rabbit.broker.RabbitBroker","text":"<p>             Bases: <code>RabbitLoggingMixin</code>, <code>BrokerAsyncUsecase[IncomingMessage, RobustConnection]</code></p> <p>A RabbitMQ broker for FastAPI applications.</p> <p>This class extends the base <code>BrokerAsyncUsecase</code> and provides asynchronous support for RabbitMQ as a message broker.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>Union[str, URL, None]</code> <p>The RabbitMQ connection URL. Defaults to \"amqp://guest:guest@localhost:5672/\".</p> <code>'amqp://guest:guest@localhost:5672/'</code> <code>max_consumers</code> <code>Optional[int]</code> <p>Maximum number of consumers to limit message consumption. Defaults to None.</p> <code>None</code> <code>protocol</code> <code>str</code> <p>The protocol to use (e.g., \"amqp\"). Defaults to \"amqp\".</p> <code>'amqp'</code> <code>protocol_version</code> <code>Optional[str]</code> <p>The protocol version to use (e.g., \"0.9.1\"). Defaults to \"0.9.1\".</p> <code>'0.9.1'</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Attributes:</p> Name Type Description <code>handlers</code> <code>Dict[int, Handler]</code> <p>A dictionary of message handlers.</p> <code>_publishers</code> <code>Dict[int, Publisher]</code> <p>A dictionary of message publishers.</p> <code>declarer</code> <code>Optional[RabbitDeclarer]</code> <p>The RabbitMQ declarer instance.</p> <code>_producer</code> <code>Optional[AioPikaFastProducer]</code> <p>The RabbitMQ producer instance.</p> <code>_connection</code> <code>Optional[RobustConnection]</code> <p>The RabbitMQ connection instance.</p> <code>_channel</code> <code>Optional[RobustChannel]</code> <p>The RabbitMQ channel instance.</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/broker.py</code> <pre><code>class RabbitBroker(\n    RabbitLoggingMixin,\n    BrokerAsyncUsecase[aio_pika.IncomingMessage, aio_pika.RobustConnection],\n):\n\"\"\"\n    A RabbitMQ broker for FastAPI applications.\n\n    This class extends the base `BrokerAsyncUsecase` and provides asynchronous support for RabbitMQ as a message broker.\n\n    Args:\n        url (Union[str, URL, None], optional): The RabbitMQ connection URL. Defaults to \"amqp://guest:guest@localhost:5672/\".\n        max_consumers (Optional[int], optional): Maximum number of consumers to limit message consumption. Defaults to None.\n        protocol (str, optional): The protocol to use (e.g., \"amqp\"). Defaults to \"amqp\".\n        protocol_version (Optional[str], optional): The protocol version to use (e.g., \"0.9.1\"). Defaults to \"0.9.1\".\n        **kwargs: Additional keyword arguments.\n\n    Attributes:\n        handlers (Dict[int, Handler]): A dictionary of message handlers.\n        _publishers (Dict[int, Publisher]): A dictionary of message publishers.\n        declarer (Optional[RabbitDeclarer]): The RabbitMQ declarer instance.\n        _producer (Optional[AioPikaFastProducer]): The RabbitMQ producer instance.\n        _connection (Optional[aio_pika.RobustConnection]): The RabbitMQ connection instance.\n        _channel (Optional[aio_pika.RobustChannel]): The RabbitMQ channel instance.\n    \"\"\"\n\n    handlers: Dict[int, Handler]  # type: ignore[assignment]\n    _publishers: Dict[int, Publisher]  # type: ignore[assignment]\n\n    declarer: Optional[RabbitDeclarer]\n    _producer: Optional[AioPikaFastProducer]\n    _connection: Optional[aio_pika.RobustConnection]\n    _channel: Optional[aio_pika.RobustChannel]\n\n    def __init__(\n        self,\n        url: Union[str, URL, None] = \"amqp://guest:guest@localhost:5672/\",\n        *,\n        max_consumers: Optional[int] = None,\n        protocol: str = \"amqp\",\n        protocol_version: Optional[str] = \"0.9.1\",\n        security: Optional[BaseSecurity] = None,\n        **kwargs: Any,\n    ) -&gt; None:\n\"\"\"\n        Initialize the RabbitBroker.\n\n        Args:\n            url (Union[str, URL, None], optional): The RabbitMQ connection URL. Defaults to \"amqp://guest:guest@localhost:5672/\".\n            max_consumers (Optional[int], optional): Maximum number of consumers to limit message consumption. Defaults to None.\n            protocol (str, optional): The protocol to use (e.g., \"amqp\"). Defaults to \"amqp\".\n            protocol_version (Optional[str], optional): The protocol version to use (e.g., \"0.9.1\"). Defaults to \"0.9.1\".\n            **kwargs: Additional keyword arguments.\n        \"\"\"\n        super().__init__(\n            url=url,\n            protocol=protocol,\n            protocol_version=protocol_version,\n            security=security,\n            **kwargs,\n        )\n\n        self._max_consumers = max_consumers\n\n        self._channel = None\n        self.declarer = None\n        self._producer = None\n\n    async def _close(\n        self,\n        exc_type: Optional[Type[BaseException]] = None,\n        exc_val: Optional[BaseException] = None,\n        exec_tb: Optional[TracebackType] = None,\n    ) -&gt; None:\n\"\"\"\n        Close the RabbitMQ broker.\n\n        Args:\n            exc_type (Optional[Type[BaseException]], optional): The type of exception. Defaults to None.\n            exc_val (Optional[BaseException], optional): The exception instance. Defaults to None.\n            exec_tb (Optional[TracebackType], optional): The traceback. Defaults to None.\n        \"\"\"\n        if self._channel is not None:\n            await self._channel.close()\n            self._channel = None\n\n        if self.declarer is not None:\n            self.declarer = None\n\n        if self._producer is not None:\n            self._producer = None\n\n        if self._connection is not None:  # pragma: no branch\n            await self._connection.close()\n\n        await super()._close(exc_type, exc_val, exec_tb)\n\n    async def connect(self, *args: Any, **kwargs: Any) -&gt; aio_pika.RobustConnection:\n\"\"\"\n        Connect to the RabbitMQ server.\n\n        Args:\n            *args: Additional positional arguments.\n            **kwargs: Additional keyword arguments.\n\n        Returns:\n            aio_pika.RobustConnection: The RabbitMQ connection instance.\n        \"\"\"\n        connection = await super().connect(*args, **kwargs)\n        for p in self._publishers.values():\n            p._producer = self._producer\n        return connection\n\n    async def _connect(\n        self,\n        **kwargs: Any,\n    ) -&gt; aio_pika.RobustConnection:\n\"\"\"\n        Connect to the RabbitMQ server.\n\n        Args:\n            **kwargs: Additional keyword arguments.\n\n        Returns:\n            aio_pika.RobustConnection: The RabbitMQ connection instance.\n        \"\"\"\n        connection = cast(\n            aio_pika.RobustConnection,\n            await aio_pika.connect_robust(**kwargs, **parse_security(self.security)),\n        )\n\n        if self._channel is None:  # pragma: no branch\n            max_consumers = self._max_consumers\n            channel = self._channel = cast(\n                aio_pika.RobustChannel,\n                await connection.channel(),\n            )\n\n            declarer = self.declarer = RabbitDeclarer(channel)\n            self.declarer.queues[RABBIT_REPLY] = cast(\n                aio_pika.RobustQueue,\n                await channel.get_queue(RABBIT_REPLY, ensure=False),\n            )\n\n            self._producer = AioPikaFastProducer(\n                channel,\n                declarer,\n                decoder=self._global_decoder,\n                parser=self._global_parser,\n            )\n\n            if max_consumers:\n                c = self._get_log_context(None, RabbitQueue(\"\"), RabbitExchange(\"\"))\n                self._log(f\"Set max consumers to {max_consumers}\", extra=c)\n                await channel.set_qos(prefetch_count=int(max_consumers))\n\n        return connection\n\n    async def start(self) -&gt; None:\n\"\"\"\n        Start the RabbitMQ broker.\n\n        Raises:\n            RuntimeError: If the declarer is not initialized in the `connect` method.\n        \"\"\"\n        context.set_local(\n            \"log_context\",\n            self._get_log_context(None, RabbitQueue(\"\"), RabbitExchange(\"\")),\n        )\n\n        await super().start()\n        assert (  # nosec B101\n            self.declarer\n        ), \"Declarer should be initialized in `connect` method\"\n\n        for handler in self.handlers.values():\n            c = self._get_log_context(None, handler.queue, handler.exchange)\n            self._log(f\"`{handler.name}` waiting for messages\", extra=c)\n            await handler.start(self.declarer)\n\n    @override\n    def subscriber(  # type: ignore[override]\n        self,\n        queue: Union[str, RabbitQueue],\n        exchange: Union[str, RabbitExchange, None] = None,\n        *,\n        consume_args: Optional[AnyDict] = None,\n        # broker arguments\n        dependencies: Sequence[Depends] = (),\n        parser: Optional[CustomParser[aio_pika.IncomingMessage]] = None,\n        decoder: Optional[CustomDecoder[aio_pika.IncomingMessage]] = None,\n        middlewares: Optional[\n            Sequence[Callable[[aio_pika.IncomingMessage], BaseMiddleware]]\n        ] = None,\n        filter: Filter[RabbitMessage] = default_filter,\n        # AsyncAPI information\n        title: Optional[str] = None,\n        description: Optional[str] = None,\n        **original_kwargs: Any,\n    ) -&gt; Callable[\n        [Callable[P_HandlerParams, T_HandlerReturn]],\n        HandlerCallWrapper[aio_pika.IncomingMessage, P_HandlerParams, T_HandlerReturn],\n    ]:\n\"\"\"\n        Decorator to define a message subscriber.\n\n        Args:\n            queue (Union[str, RabbitQueue]): The name of the RabbitMQ queue.\n            exchange (Union[str, RabbitExchange, None], optional): The name of the RabbitMQ exchange. Defaults to None.\n            consume_args (Optional[AnyDict], optional): Additional arguments for message consumption.\n            title (Optional[str]): Title for AsyncAPI docs.\n            description (Optional[str]): Description for AsyncAPI docs.\n\n        Returns:\n            Callable: A decorator function for defining message subscribers.\n        \"\"\"\n        super().subscriber()\n\n        r_queue = RabbitQueue.validate(queue)\n        r_exchange = RabbitExchange.validate(exchange)\n\n        self._setup_log_context(r_queue, r_exchange)\n\n        key = get_routing_hash(r_queue, r_exchange)\n        handler = self.handlers.get(\n            key,\n            Handler(\n                queue=r_queue,\n                exchange=r_exchange,\n                consume_args=consume_args,\n                description=description,\n                title=title,\n            ),\n        )\n\n        self.handlers[key] = handler\n\n        def consumer_wrapper(\n            func: Callable[P_HandlerParams, T_HandlerReturn],\n        ) -&gt; HandlerCallWrapper[\n            aio_pika.IncomingMessage, P_HandlerParams, T_HandlerReturn\n        ]:\n\"\"\"Wraps a consumer function with additional functionality.\n\n            Args:\n                func: The consumer function to be wrapped.\n\n            Returns:\n                The wrapped consumer function.\n\n            Raises:\n                NotImplementedError: If silent animals are not supported.\n            !!! note\n\n                The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n            \"\"\"\n            handler_call, dependant = self._wrap_handler(\n                func,\n                extra_dependencies=dependencies,\n                **original_kwargs,\n                queue=r_queue,\n                exchange=r_exchange,\n            )\n\n            handler.add_call(\n                handler=handler_call,\n                filter=to_async(filter),\n                middlewares=middlewares,\n                parser=parser or self._global_parser,\n                decoder=decoder or self._global_decoder,\n                dependant=dependant,\n            )\n\n            return handler_call\n\n        return consumer_wrapper\n\n    @override\n    def publisher(  # type: ignore[override]\n        self,\n        queue: Union[RabbitQueue, str] = \"\",\n        exchange: Union[RabbitExchange, str, None] = None,\n        *,\n        routing_key: str = \"\",\n        mandatory: bool = True,\n        immediate: bool = False,\n        timeout: TimeoutType = None,\n        persist: bool = False,\n        reply_to: Optional[str] = None,\n        # AsyncAPI information\n        title: Optional[str] = None,\n        description: Optional[str] = None,\n        **message_kwargs: Any,\n    ) -&gt; Publisher:\n\"\"\"\n        Define a message publisher.\n\n        Args:\n            queue (Union[RabbitQueue, str], optional): The name of the RabbitMQ queue. Defaults to \"\".\n            exchange (Union[RabbitExchange, str, None], optional): The name of the RabbitMQ exchange. Defaults to None.\n            routing_key (str, optional): The routing key for messages. Defaults to \"\".\n            mandatory (bool, optional): Whether the message is mandatory. Defaults to True.\n            immediate (bool, optional): Whether the message should be sent immediately. Defaults to False.\n            timeout (TimeoutType, optional): Timeout for message publishing. Defaults to None.\n            persist (bool, optional): Whether to persist messages. Defaults to False.\n            reply_to (Optional[str], optional): The reply-to queue name. Defaults to None.\n            title (Optional[str]): Title for AsyncAPI docs.\n            description (Optional[str]): Description for AsyncAPI docs.\n            **message_kwargs (Any): Additional message properties and content.\n\n        Returns:\n            Publisher: A message publisher instance.\n        \"\"\"\n        q, ex = RabbitQueue.validate(queue), RabbitExchange.validate(exchange)\n        key = get_routing_hash(q, ex)\n        publisher = self._publishers.get(\n            key,\n            Publisher(\n                title=title,\n                queue=q,\n                exchange=ex,\n                routing_key=routing_key,\n                mandatory=mandatory,\n                immediate=immediate,\n                timeout=timeout,\n                persist=persist,\n                reply_to=reply_to,\n                message_kwargs=message_kwargs,\n                _description=description,\n            ),\n        )\n        super().publisher(key, publisher)\n        return publisher\n\n    @override\n    async def publish(  # type: ignore[override]\n        self,\n        *args: Any,\n        **kwargs: Any,\n    ) -&gt; Union[aiormq.abc.ConfirmationFrameType, SendableMessage]:\n\"\"\"\n        Publish a message to the RabbitMQ broker.\n\n        Args:\n            *args: Additional positional arguments.\n            **kwargs: Additional keyword arguments.\n\n        Returns:\n            Union[aiormq.abc.ConfirmationFrameType, SendableMessage]: The confirmation frame or the response message.\n        \"\"\"\n\n        assert self._producer, \"RabbitBroker channel is not started yet\"  # nosec B101\n        return await self._producer.publish(*args, **kwargs)\n\n    def _process_message(\n        self,\n        func: Callable[\n            [StreamMessage[aio_pika.IncomingMessage]], Awaitable[T_HandlerReturn]\n        ],\n        watcher: BaseWatcher,\n    ) -&gt; Callable[\n        [StreamMessage[aio_pika.IncomingMessage]],\n        Awaitable[WrappedReturn[T_HandlerReturn]],\n    ]:\n\"\"\"\n        Process a message using the provided handler function.\n\n        Args:\n            func (Callable): The handler function for processing the message.\n            watcher (BaseWatcher): The message watcher for tracking message processing.\n\n        Returns:\n            Callable: A wrapper function for processing messages.\n        \"\"\"\n\n        @wraps(func)\n        async def process_wrapper(\n            message: RabbitMessage,\n        ) -&gt; WrappedReturn[T_HandlerReturn]:\n\"\"\"Asynchronously process a message and wrap the return value.\n\n            Args:\n                message: The RabbitMessage to process.\n\n            Returns:\n                A tuple containing the return value of the handler function and an optional AsyncPublisherProtocol.\n\n            Raises:\n                AssertionError: If the code reaches an unreachable point.\n            !!! note\n\n                The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n            \"\"\"\n            async with WatcherContext(watcher, message):\n                r = await self._execute_handler(func, message)\n\n                pub_response: Optional[AsyncPublisherProtocol]\n                if message.reply_to:\n                    pub_response = FakePublisher(\n                        partial(self.publish, routing_key=message.reply_to)\n                    )\n                else:\n                    pub_response = None\n\n                return r, pub_response\n\n            raise AssertionError(\"unreachable\")\n\n        return process_wrapper\n\n    async def declare_queue(\n        self,\n        queue: RabbitQueue,\n    ) -&gt; aio_pika.RobustQueue:\n\"\"\"\n        Declare a RabbitMQ queue.\n\n        Args:\n            queue (RabbitQueue): The RabbitMQ queue to declare.\n\n        Returns:\n            aio_pika.RobustQueue: The declared RabbitMQ queue.\n\n        Raises:\n            RuntimeError: If the declarer is not initialized in the `connect` method.\n        \"\"\"\n        assert (  # nosec B101\n            self.declarer\n        ), \"Declarer should be initialized in `connect` method\"\n        return await self.declarer.declare_queue(queue)\n\n    async def declare_exchange(\n        self,\n        exchange: RabbitExchange,\n    ) -&gt; aio_pika.RobustExchange:\n\"\"\"\n        Declare a RabbitMQ exchange.\n\n        Args:\n            exchange (RabbitExchange): The RabbitMQ exchange to declare.\n\n        Returns:\n            aio_pika.RobustExchange: The declared RabbitMQ exchange.\n\n        Raises:\n            RuntimeError: If the declarer is not initialized in the `connect` method.\n        \"\"\"\n        assert (  # nosec B101\n            self.declarer\n        ), \"Declarer should be initialized in `connect` method\"\n        return await self.declarer.declare_exchange(exchange)\n</code></pre>"},{"location":"api/faststream/rabbit/broker/RabbitBroker/#faststream.rabbit.broker.RabbitBroker-attributes","title":"Attributes","text":""},{"location":"api/faststream/rabbit/broker/RabbitBroker/#faststream.rabbit.broker.RabbitBroker.declarer","title":"declarer  <code>instance-attribute</code>","text":"<pre><code>declarer: Optional[RabbitDeclarer] = None\n</code></pre>"},{"location":"api/faststream/rabbit/broker/RabbitBroker/#faststream.rabbit.broker.RabbitBroker.handlers","title":"handlers  <code>instance-attribute</code>","text":"<pre><code>handlers: Dict[int, Handler]\n</code></pre>"},{"location":"api/faststream/rabbit/broker/RabbitBroker/#faststream.rabbit.broker.RabbitBroker-functions","title":"Functions","text":""},{"location":"api/faststream/rabbit/broker/RabbitBroker/#faststream.rabbit.broker.RabbitBroker.__init__","title":"__init__","text":"<pre><code>__init__(\n    url: Union[\n        str, URL, None\n    ] = \"amqp://guest:guest@localhost:5672/\",\n    *,\n    max_consumers: Optional[int] = None,\n    protocol: str = \"amqp\",\n    protocol_version: Optional[str] = \"0.9.1\",\n    security: Optional[BaseSecurity] = None,\n    **kwargs: Any\n) -&gt; None\n</code></pre> <p>Initialize the RabbitBroker.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>Union[str, URL, None]</code> <p>The RabbitMQ connection URL. Defaults to \"amqp://guest:guest@localhost:5672/\".</p> <code>'amqp://guest:guest@localhost:5672/'</code> <code>max_consumers</code> <code>Optional[int]</code> <p>Maximum number of consumers to limit message consumption. Defaults to None.</p> <code>None</code> <code>protocol</code> <code>str</code> <p>The protocol to use (e.g., \"amqp\"). Defaults to \"amqp\".</p> <code>'amqp'</code> <code>protocol_version</code> <code>Optional[str]</code> <p>The protocol version to use (e.g., \"0.9.1\"). Defaults to \"0.9.1\".</p> <code>'0.9.1'</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments.</p> <code>{}</code> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/broker.py</code> <pre><code>def __init__(\n    self,\n    url: Union[str, URL, None] = \"amqp://guest:guest@localhost:5672/\",\n    *,\n    max_consumers: Optional[int] = None,\n    protocol: str = \"amqp\",\n    protocol_version: Optional[str] = \"0.9.1\",\n    security: Optional[BaseSecurity] = None,\n    **kwargs: Any,\n) -&gt; None:\n\"\"\"\n    Initialize the RabbitBroker.\n\n    Args:\n        url (Union[str, URL, None], optional): The RabbitMQ connection URL. Defaults to \"amqp://guest:guest@localhost:5672/\".\n        max_consumers (Optional[int], optional): Maximum number of consumers to limit message consumption. Defaults to None.\n        protocol (str, optional): The protocol to use (e.g., \"amqp\"). Defaults to \"amqp\".\n        protocol_version (Optional[str], optional): The protocol version to use (e.g., \"0.9.1\"). Defaults to \"0.9.1\".\n        **kwargs: Additional keyword arguments.\n    \"\"\"\n    super().__init__(\n        url=url,\n        protocol=protocol,\n        protocol_version=protocol_version,\n        security=security,\n        **kwargs,\n    )\n\n    self._max_consumers = max_consumers\n\n    self._channel = None\n    self.declarer = None\n    self._producer = None\n</code></pre>"},{"location":"api/faststream/rabbit/broker/RabbitBroker/#faststream.rabbit.broker.RabbitBroker.connect","title":"connect  <code>async</code>","text":"<pre><code>connect(\n    *args: Any, **kwargs: Any\n) -&gt; aio_pika.RobustConnection\n</code></pre> <p>Connect to the RabbitMQ server.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Any</code> <p>Additional positional arguments.</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>RobustConnection</code> <p>aio_pika.RobustConnection: The RabbitMQ connection instance.</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/broker.py</code> <pre><code>async def connect(self, *args: Any, **kwargs: Any) -&gt; aio_pika.RobustConnection:\n\"\"\"\n    Connect to the RabbitMQ server.\n\n    Args:\n        *args: Additional positional arguments.\n        **kwargs: Additional keyword arguments.\n\n    Returns:\n        aio_pika.RobustConnection: The RabbitMQ connection instance.\n    \"\"\"\n    connection = await super().connect(*args, **kwargs)\n    for p in self._publishers.values():\n        p._producer = self._producer\n    return connection\n</code></pre>"},{"location":"api/faststream/rabbit/broker/RabbitBroker/#faststream.rabbit.broker.RabbitBroker.declare_exchange","title":"declare_exchange  <code>async</code>","text":"<pre><code>declare_exchange(\n    exchange: RabbitExchange,\n) -&gt; aio_pika.RobustExchange\n</code></pre> <p>Declare a RabbitMQ exchange.</p> <p>Parameters:</p> Name Type Description Default <code>exchange</code> <code>RabbitExchange</code> <p>The RabbitMQ exchange to declare.</p> required <p>Returns:</p> Type Description <code>RobustExchange</code> <p>aio_pika.RobustExchange: The declared RabbitMQ exchange.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the declarer is not initialized in the <code>connect</code> method.</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/broker.py</code> <pre><code>async def declare_exchange(\n    self,\n    exchange: RabbitExchange,\n) -&gt; aio_pika.RobustExchange:\n\"\"\"\n    Declare a RabbitMQ exchange.\n\n    Args:\n        exchange (RabbitExchange): The RabbitMQ exchange to declare.\n\n    Returns:\n        aio_pika.RobustExchange: The declared RabbitMQ exchange.\n\n    Raises:\n        RuntimeError: If the declarer is not initialized in the `connect` method.\n    \"\"\"\n    assert (  # nosec B101\n        self.declarer\n    ), \"Declarer should be initialized in `connect` method\"\n    return await self.declarer.declare_exchange(exchange)\n</code></pre>"},{"location":"api/faststream/rabbit/broker/RabbitBroker/#faststream.rabbit.broker.RabbitBroker.declare_queue","title":"declare_queue  <code>async</code>","text":"<pre><code>declare_queue(queue: RabbitQueue) -&gt; aio_pika.RobustQueue\n</code></pre> <p>Declare a RabbitMQ queue.</p> <p>Parameters:</p> Name Type Description Default <code>queue</code> <code>RabbitQueue</code> <p>The RabbitMQ queue to declare.</p> required <p>Returns:</p> Type Description <code>RobustQueue</code> <p>aio_pika.RobustQueue: The declared RabbitMQ queue.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the declarer is not initialized in the <code>connect</code> method.</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/broker.py</code> <pre><code>async def declare_queue(\n    self,\n    queue: RabbitQueue,\n) -&gt; aio_pika.RobustQueue:\n\"\"\"\n    Declare a RabbitMQ queue.\n\n    Args:\n        queue (RabbitQueue): The RabbitMQ queue to declare.\n\n    Returns:\n        aio_pika.RobustQueue: The declared RabbitMQ queue.\n\n    Raises:\n        RuntimeError: If the declarer is not initialized in the `connect` method.\n    \"\"\"\n    assert (  # nosec B101\n        self.declarer\n    ), \"Declarer should be initialized in `connect` method\"\n    return await self.declarer.declare_queue(queue)\n</code></pre>"},{"location":"api/faststream/rabbit/broker/RabbitBroker/#faststream.rabbit.broker.RabbitBroker.publish","title":"publish  <code>async</code>","text":"<pre><code>publish(\n    *args: Any, **kwargs: Any\n) -&gt; Union[\n    aiormq.abc.ConfirmationFrameType, SendableMessage\n]\n</code></pre> <p>Publish a message to the RabbitMQ broker.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Any</code> <p>Additional positional arguments.</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Union[ConfirmationFrameType, SendableMessage]</code> <p>Union[aiormq.abc.ConfirmationFrameType, SendableMessage]: The confirmation frame or the response message.</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/broker.py</code> <pre><code>@override\nasync def publish(  # type: ignore[override]\n    self,\n    *args: Any,\n    **kwargs: Any,\n) -&gt; Union[aiormq.abc.ConfirmationFrameType, SendableMessage]:\n\"\"\"\n    Publish a message to the RabbitMQ broker.\n\n    Args:\n        *args: Additional positional arguments.\n        **kwargs: Additional keyword arguments.\n\n    Returns:\n        Union[aiormq.abc.ConfirmationFrameType, SendableMessage]: The confirmation frame or the response message.\n    \"\"\"\n\n    assert self._producer, \"RabbitBroker channel is not started yet\"  # nosec B101\n    return await self._producer.publish(*args, **kwargs)\n</code></pre>"},{"location":"api/faststream/rabbit/broker/RabbitBroker/#faststream.rabbit.broker.RabbitBroker.publisher","title":"publisher","text":"<pre><code>publisher(\n    queue: Union[RabbitQueue, str] = \"\",\n    exchange: Union[RabbitExchange, str, None] = None,\n    *,\n    routing_key: str = \"\",\n    mandatory: bool = True,\n    immediate: bool = False,\n    timeout: TimeoutType = None,\n    persist: bool = False,\n    reply_to: Optional[str] = None,\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n    **message_kwargs: Any\n) -&gt; Publisher\n</code></pre> <p>Define a message publisher.</p> <p>Parameters:</p> Name Type Description Default <code>queue</code> <code>Union[RabbitQueue, str]</code> <p>The name of the RabbitMQ queue. Defaults to \"\".</p> <code>''</code> <code>exchange</code> <code>Union[RabbitExchange, str, None]</code> <p>The name of the RabbitMQ exchange. Defaults to None.</p> <code>None</code> <code>routing_key</code> <code>str</code> <p>The routing key for messages. Defaults to \"\".</p> <code>''</code> <code>mandatory</code> <code>bool</code> <p>Whether the message is mandatory. Defaults to True.</p> <code>True</code> <code>immediate</code> <code>bool</code> <p>Whether the message should be sent immediately. Defaults to False.</p> <code>False</code> <code>timeout</code> <code>TimeoutType</code> <p>Timeout for message publishing. Defaults to None.</p> <code>None</code> <code>persist</code> <code>bool</code> <p>Whether to persist messages. Defaults to False.</p> <code>False</code> <code>reply_to</code> <code>Optional[str]</code> <p>The reply-to queue name. Defaults to None.</p> <code>None</code> <code>title</code> <code>Optional[str]</code> <p>Title for AsyncAPI docs.</p> <code>None</code> <code>description</code> <code>Optional[str]</code> <p>Description for AsyncAPI docs.</p> <code>None</code> <code>**message_kwargs</code> <code>Any</code> <p>Additional message properties and content.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Publisher</code> <code>Publisher</code> <p>A message publisher instance.</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/broker.py</code> <pre><code>@override\ndef publisher(  # type: ignore[override]\n    self,\n    queue: Union[RabbitQueue, str] = \"\",\n    exchange: Union[RabbitExchange, str, None] = None,\n    *,\n    routing_key: str = \"\",\n    mandatory: bool = True,\n    immediate: bool = False,\n    timeout: TimeoutType = None,\n    persist: bool = False,\n    reply_to: Optional[str] = None,\n    # AsyncAPI information\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n    **message_kwargs: Any,\n) -&gt; Publisher:\n\"\"\"\n    Define a message publisher.\n\n    Args:\n        queue (Union[RabbitQueue, str], optional): The name of the RabbitMQ queue. Defaults to \"\".\n        exchange (Union[RabbitExchange, str, None], optional): The name of the RabbitMQ exchange. Defaults to None.\n        routing_key (str, optional): The routing key for messages. Defaults to \"\".\n        mandatory (bool, optional): Whether the message is mandatory. Defaults to True.\n        immediate (bool, optional): Whether the message should be sent immediately. Defaults to False.\n        timeout (TimeoutType, optional): Timeout for message publishing. Defaults to None.\n        persist (bool, optional): Whether to persist messages. Defaults to False.\n        reply_to (Optional[str], optional): The reply-to queue name. Defaults to None.\n        title (Optional[str]): Title for AsyncAPI docs.\n        description (Optional[str]): Description for AsyncAPI docs.\n        **message_kwargs (Any): Additional message properties and content.\n\n    Returns:\n        Publisher: A message publisher instance.\n    \"\"\"\n    q, ex = RabbitQueue.validate(queue), RabbitExchange.validate(exchange)\n    key = get_routing_hash(q, ex)\n    publisher = self._publishers.get(\n        key,\n        Publisher(\n            title=title,\n            queue=q,\n            exchange=ex,\n            routing_key=routing_key,\n            mandatory=mandatory,\n            immediate=immediate,\n            timeout=timeout,\n            persist=persist,\n            reply_to=reply_to,\n            message_kwargs=message_kwargs,\n            _description=description,\n        ),\n    )\n    super().publisher(key, publisher)\n    return publisher\n</code></pre>"},{"location":"api/faststream/rabbit/broker/RabbitBroker/#faststream.rabbit.broker.RabbitBroker.start","title":"start  <code>async</code>","text":"<pre><code>start() -&gt; None\n</code></pre> <p>Start the RabbitMQ broker.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the declarer is not initialized in the <code>connect</code> method.</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/broker.py</code> <pre><code>async def start(self) -&gt; None:\n\"\"\"\n    Start the RabbitMQ broker.\n\n    Raises:\n        RuntimeError: If the declarer is not initialized in the `connect` method.\n    \"\"\"\n    context.set_local(\n        \"log_context\",\n        self._get_log_context(None, RabbitQueue(\"\"), RabbitExchange(\"\")),\n    )\n\n    await super().start()\n    assert (  # nosec B101\n        self.declarer\n    ), \"Declarer should be initialized in `connect` method\"\n\n    for handler in self.handlers.values():\n        c = self._get_log_context(None, handler.queue, handler.exchange)\n        self._log(f\"`{handler.name}` waiting for messages\", extra=c)\n        await handler.start(self.declarer)\n</code></pre>"},{"location":"api/faststream/rabbit/broker/RabbitBroker/#faststream.rabbit.broker.RabbitBroker.subscriber","title":"subscriber","text":"<pre><code>subscriber(\n    queue: Union[str, RabbitQueue],\n    exchange: Union[str, RabbitExchange, None] = None,\n    *,\n    consume_args: Optional[AnyDict] = None,\n    dependencies: Sequence[Depends] = (),\n    parser: Optional[\n        CustomParser[aio_pika.IncomingMessage]\n    ] = None,\n    decoder: Optional[\n        CustomDecoder[aio_pika.IncomingMessage]\n    ] = None,\n    middlewares: Optional[\n        Sequence[\n            Callable[\n                [aio_pika.IncomingMessage], BaseMiddleware\n            ]\n        ]\n    ] = None,\n    filter: Filter[RabbitMessage] = default_filter,\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n    **original_kwargs: Any\n) -&gt; Callable[\n    [Callable[P_HandlerParams, T_HandlerReturn]],\n    HandlerCallWrapper[\n        aio_pika.IncomingMessage,\n        P_HandlerParams,\n        T_HandlerReturn,\n    ],\n]\n</code></pre> <p>Decorator to define a message subscriber.</p> <p>Parameters:</p> Name Type Description Default <code>queue</code> <code>Union[str, RabbitQueue]</code> <p>The name of the RabbitMQ queue.</p> required <code>exchange</code> <code>Union[str, RabbitExchange, None]</code> <p>The name of the RabbitMQ exchange. Defaults to None.</p> <code>None</code> <code>consume_args</code> <code>Optional[AnyDict]</code> <p>Additional arguments for message consumption.</p> <code>None</code> <code>title</code> <code>Optional[str]</code> <p>Title for AsyncAPI docs.</p> <code>None</code> <code>description</code> <code>Optional[str]</code> <p>Description for AsyncAPI docs.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Callable</code> <code>Callable[[Callable[P_HandlerParams, T_HandlerReturn]], HandlerCallWrapper[IncomingMessage, P_HandlerParams, T_HandlerReturn]]</code> <p>A decorator function for defining message subscribers.</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/broker.py</code> <pre><code>@override\ndef subscriber(  # type: ignore[override]\n    self,\n    queue: Union[str, RabbitQueue],\n    exchange: Union[str, RabbitExchange, None] = None,\n    *,\n    consume_args: Optional[AnyDict] = None,\n    # broker arguments\n    dependencies: Sequence[Depends] = (),\n    parser: Optional[CustomParser[aio_pika.IncomingMessage]] = None,\n    decoder: Optional[CustomDecoder[aio_pika.IncomingMessage]] = None,\n    middlewares: Optional[\n        Sequence[Callable[[aio_pika.IncomingMessage], BaseMiddleware]]\n    ] = None,\n    filter: Filter[RabbitMessage] = default_filter,\n    # AsyncAPI information\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n    **original_kwargs: Any,\n) -&gt; Callable[\n    [Callable[P_HandlerParams, T_HandlerReturn]],\n    HandlerCallWrapper[aio_pika.IncomingMessage, P_HandlerParams, T_HandlerReturn],\n]:\n\"\"\"\n    Decorator to define a message subscriber.\n\n    Args:\n        queue (Union[str, RabbitQueue]): The name of the RabbitMQ queue.\n        exchange (Union[str, RabbitExchange, None], optional): The name of the RabbitMQ exchange. Defaults to None.\n        consume_args (Optional[AnyDict], optional): Additional arguments for message consumption.\n        title (Optional[str]): Title for AsyncAPI docs.\n        description (Optional[str]): Description for AsyncAPI docs.\n\n    Returns:\n        Callable: A decorator function for defining message subscribers.\n    \"\"\"\n    super().subscriber()\n\n    r_queue = RabbitQueue.validate(queue)\n    r_exchange = RabbitExchange.validate(exchange)\n\n    self._setup_log_context(r_queue, r_exchange)\n\n    key = get_routing_hash(r_queue, r_exchange)\n    handler = self.handlers.get(\n        key,\n        Handler(\n            queue=r_queue,\n            exchange=r_exchange,\n            consume_args=consume_args,\n            description=description,\n            title=title,\n        ),\n    )\n\n    self.handlers[key] = handler\n\n    def consumer_wrapper(\n        func: Callable[P_HandlerParams, T_HandlerReturn],\n    ) -&gt; HandlerCallWrapper[\n        aio_pika.IncomingMessage, P_HandlerParams, T_HandlerReturn\n    ]:\n\"\"\"Wraps a consumer function with additional functionality.\n\n        Args:\n            func: The consumer function to be wrapped.\n\n        Returns:\n            The wrapped consumer function.\n\n        Raises:\n            NotImplementedError: If silent animals are not supported.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        handler_call, dependant = self._wrap_handler(\n            func,\n            extra_dependencies=dependencies,\n            **original_kwargs,\n            queue=r_queue,\n            exchange=r_exchange,\n        )\n\n        handler.add_call(\n            handler=handler_call,\n            filter=to_async(filter),\n            middlewares=middlewares,\n            parser=parser or self._global_parser,\n            decoder=decoder or self._global_decoder,\n            dependant=dependant,\n        )\n\n        return handler_call\n\n    return consumer_wrapper\n</code></pre>"},{"location":"api/faststream/rabbit/fastapi/RabbitRouter/","title":"RabbitRouter","text":""},{"location":"api/faststream/rabbit/fastapi/RabbitRouter/#faststream.rabbit.fastapi.RabbitRouter","title":"faststream.rabbit.fastapi.RabbitRouter","text":"<p>             Bases: <code>StreamRouter[IncomingMessage]</code></p> <p>A class to represent a RabbitMQ router for incoming messages.</p> <p>Attributes:</p> Name Type Description <code>broker_class</code> <p>the class representing the RabbitMQ broker</p> <p>Methods:</p> Name Description <code>_setup_log_context </code> <p>sets up the log context for the main broker and the including broker</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/fastapi.py</code> <pre><code>class RabbitRouter(StreamRouter[IncomingMessage]):\n\"\"\"A class to represent a RabbitMQ router for incoming messages.\n\n    Attributes:\n        broker_class : the class representing the RabbitMQ broker\n\n    Methods:\n        _setup_log_context : sets up the log context for the main broker and the including broker\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    broker_class = RabbitBroker\n\n    @staticmethod\n    def _setup_log_context(\n        main_broker: RabbitBroker,\n        including_broker: RabbitBroker,\n    ) -&gt; None:\n\"\"\"Sets up the log context for a main broker and an including broker.\n\n        Args:\n            main_broker: The main broker object.\n            including_broker: The including broker object.\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        for h in including_broker.handlers.values():\n            main_broker._setup_log_context(h.queue, h.exchange)\n</code></pre>"},{"location":"api/faststream/rabbit/fastapi/RabbitRouter/#faststream.rabbit.fastapi.RabbitRouter-attributes","title":"Attributes","text":""},{"location":"api/faststream/rabbit/fastapi/RabbitRouter/#faststream.rabbit.fastapi.RabbitRouter.broker_class","title":"broker_class  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>broker_class: Type[RabbitBroker] = RabbitBroker\n</code></pre>"},{"location":"api/faststream/rabbit/fastapi/RabbitRouter/#faststream.rabbit.fastapi.RabbitRouter-functions","title":"Functions","text":""},{"location":"api/faststream/rabbit/fastapi/RabbitRouter/#faststream.rabbit.fastapi.RabbitRouter.__init__","title":"__init__","text":"<pre><code>__init__(\n    url: Union[\n        str, URL, None\n    ] = \"amqp://guest:guest@localhost:5672/\",\n    *,\n    host: str = \"localhost\",\n    port: int = 5672,\n    login: str = \"guest\",\n    password: str = \"guest\",\n    virtualhost: str = \"/\",\n    ssl: bool = False,\n    ssl_options: Optional[aio_pika.abc.SSLOptions] = None,\n    ssl_context: Optional[SSLContext] = None,\n    timeout: aio_pika.abc.TimeoutType = None,\n    client_properties: Optional[FieldTable] = None,\n    max_consumers: Optional[int] = None,\n    decoder: Optional[\n        CustomDecoder[aio_pika.IncomingMessage]\n    ] = None,\n    parser: Optional[\n        CustomParser[aio_pika.IncomingMessage]\n    ] = None,\n    middlewares: Optional[\n        Sequence[\n            Callable[\n                [aio_pika.IncomingMessage], BaseMiddleware\n            ]\n        ]\n    ] = None,\n    protocol: str = \"amqp\",\n    protocol_version: Optional[str] = \"0.9.1\",\n    description: Optional[str] = None,\n    asyncapi_tags: Optional[Sequence[asyncapi.Tag]] = None,\n    schema_url: Optional[str] = \"/asyncapi\",\n    prefix: str = \"\",\n    tags: Optional[List[Union[str, Enum]]] = None,\n    dependencies: Optional[Sequence[params.Depends]] = None,\n    default_response_class: Type[Response] = Default(\n        JSONResponse\n    ),\n    responses: Optional[\n        Dict[Union[int, str], Dict[str, Any]]\n    ] = None,\n    callbacks: Optional[List[routing.BaseRoute]] = None,\n    routes: Optional[List[routing.BaseRoute]] = None,\n    redirect_slashes: bool = True,\n    default: Optional[ASGIApp] = None,\n    dependency_overrides_provider: Optional[Any] = None,\n    route_class: Type[APIRoute] = APIRoute,\n    on_startup: Optional[\n        Sequence[Callable[[], Any]]\n    ] = None,\n    on_shutdown: Optional[\n        Sequence[Callable[[], Any]]\n    ] = None,\n    deprecated: Optional[bool] = None,\n    include_in_schema: bool = True,\n    lifespan: Optional[Lifespan[Any]] = None,\n    generate_unique_id_function: Callable[\n        [APIRoute], str\n    ] = Default(generate_unique_id)\n) -&gt; None\n</code></pre>"},{"location":"api/faststream/rabbit/fastapi/RabbitRouter/#faststream.rabbit.fastapi.RabbitRouter.add_api_mq_route","title":"add_api_mq_route","text":"<pre><code>add_api_mq_route(\n    queue: Union[str, RabbitQueue],\n    *,\n    endpoint: Callable[..., T_HandlerReturn],\n    exchange: Union[str, RabbitExchange, None] = None,\n    consume_args: Optional[AnyDict] = None,\n    dependencies: Sequence[params.Depends] = (),\n    filter: Filter[RabbitMessage] = default_filter,\n    parser: Optional[\n        CustomParser[aio_pika.IncomingMessage]\n    ] = None,\n    decoder: Optional[\n        CustomDecoder[aio_pika.IncomingMessage]\n    ] = None,\n    middlewares: Optional[\n        Sequence[\n            Callable[\n                [aio_pika.IncomingMessage], BaseMiddleware\n            ]\n        ]\n    ] = None,\n    retry: Union[bool, int] = False,\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n    **__service_kwargs: Any\n) -&gt; Callable[\n    [IncomingMessage, bool], Awaitable[T_HandlerReturn]\n]\n</code></pre>"},{"location":"api/faststream/rabbit/fastapi/RabbitRouter/#faststream.rabbit.fastapi.RabbitRouter.publisher","title":"publisher","text":"<pre><code>publisher(\n    queue: Union[RabbitQueue, str] = \"\",\n    exchange: Union[RabbitExchange, str, None] = None,\n    *,\n    routing_key: str = \"\",\n    mandatory: bool = True,\n    immediate: bool = False,\n    timeout: TimeoutType = None,\n    persist: bool = False,\n    reply_to: Optional[str] = None,\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n    headers: Optional[aio_pika.abc.HeadersType] = None,\n    content_type: Optional[str] = None,\n    content_encoding: Optional[str] = None,\n    priority: Optional[int] = None,\n    correlation_id: Optional[str] = None,\n    expiration: Optional[aio_pika.abc.DateType] = None,\n    message_id: Optional[str] = None,\n    timestamp: Optional[aio_pika.abc.DateType] = None,\n    type: Optional[str] = None,\n    user_id: Optional[str] = None,\n    app_id: Optional[str] = None\n) -&gt; Publisher\n</code></pre>"},{"location":"api/faststream/rabbit/fastapi/RabbitRouter/#faststream.rabbit.fastapi.RabbitRouter.subscriber","title":"subscriber","text":"<pre><code>subscriber(\n    queue: Union[str, RabbitQueue],\n    exchange: Union[str, RabbitExchange, None] = None,\n    *,\n    consume_args: Optional[AnyDict] = None,\n    dependencies: Sequence[params.Depends] = (),\n    filter: Filter[RabbitMessage] = default_filter,\n    parser: Optional[\n        CustomParser[aio_pika.IncomingMessage]\n    ] = None,\n    decoder: Optional[\n        CustomDecoder[aio_pika.IncomingMessage]\n    ] = None,\n    middlewares: Optional[\n        Sequence[\n            Callable[\n                [aio_pika.IncomingMessage], BaseMiddleware\n            ]\n        ]\n    ] = None,\n    retry: Union[bool, int] = False,\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n    **__service_kwargs: Any\n) -&gt; Callable[\n    [Callable[P_HandlerParams, T_HandlerReturn]],\n    HandlerCallWrapper[\n        aio_pika.IncomingMessage,\n        P_HandlerParams,\n        T_HandlerReturn,\n    ],\n]\n</code></pre>"},{"location":"api/faststream/rabbit/handler/LogicHandler/","title":"LogicHandler","text":""},{"location":"api/faststream/rabbit/handler/LogicHandler/#faststream.rabbit.handler.LogicHandler","title":"faststream.rabbit.handler.LogicHandler","text":"<p>             Bases: <code>AsyncHandler[IncomingMessage]</code>, <code>BaseRMQInformation</code></p> <p>A class to handle logic for RabbitMQ message consumption.</p> <p>Attributes:</p> Name Type Description <code>queue</code> <p>RabbitQueue object representing the queue to consume from</p> <code>exchange</code> <p>Optional RabbitExchange object representing the exchange to bind the queue to</p> <code>consume_args</code> <p>Additional arguments to pass when consuming from the queue</p> <code>_consumer_tag</code> <p>Optional string representing the consumer tag</p> <code>_queue_obj</code> <p>Optional aio_pika.RobustQueue object representing the declared queue</p> <p>Methods:</p> Name Description <code>__init__ </code> <p>Initializes the LogicHandler object</p> <code>add_call </code> <p>Adds a call to be handled by the LogicHandler</p> <code>start </code> <p>Starts consuming messages from the queue</p> <code>close </code> <p>Closes the consumer and cancels message consumption</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/handler.py</code> <pre><code>class LogicHandler(AsyncHandler[aio_pika.IncomingMessage], BaseRMQInformation):\n\"\"\"A class to handle logic for RabbitMQ message consumption.\n\n    Attributes:\n        queue : RabbitQueue object representing the queue to consume from\n        exchange : Optional RabbitExchange object representing the exchange to bind the queue to\n        consume_args : Additional arguments to pass when consuming from the queue\n        _consumer_tag : Optional string representing the consumer tag\n        _queue_obj : Optional aio_pika.RobustQueue object representing the declared queue\n\n    Methods:\n        __init__ : Initializes the LogicHandler object\n        add_call : Adds a call to be handled by the LogicHandler\n        start : Starts consuming messages from the queue\n        close : Closes the consumer and cancels message consumption\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    queue: RabbitQueue\n    exchange: Optional[RabbitExchange]\n    consume_args: AnyDict\n\n    _consumer_tag: Optional[str]\n    _queue_obj: Optional[aio_pika.RobustQueue]\n\n    def __init__(\n        self,\n        queue: RabbitQueue,\n        # RMQ information\n        exchange: Optional[RabbitExchange] = None,\n        consume_args: Optional[AnyDict] = None,\n        # AsyncAPI information\n        description: Optional[str] = None,\n        title: Optional[str] = None,\n    ):\n\"\"\"Initialize a RabbitMQ consumer.\n\n        Args:\n            queue: RabbitQueue object representing the queue to consume from\n            exchange: RabbitExchange object representing the exchange to bind the queue to (optional)\n            consume_args: Additional arguments for consuming from the queue (optional)\n            description: Description of the consumer (optional)\n            title: Title of the consumer (optional)\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        super().__init__(\n            description=description,\n            title=title,\n        )\n\n        self.queue = queue\n        self.exchange = exchange\n        self.consume_args = consume_args or {}\n\n        self._consumer_tag = None\n        self._queue_obj = None\n\n    def add_call(\n        self,\n        *,\n        handler: HandlerCallWrapper[\n            aio_pika.IncomingMessage, P_HandlerParams, T_HandlerReturn\n        ],\n        dependant: CallModel[P_HandlerParams, T_HandlerReturn],\n        parser: Optional[CustomParser[aio_pika.IncomingMessage]],\n        decoder: Optional[CustomDecoder[aio_pika.IncomingMessage]],\n        filter: Filter[RabbitMessage],\n        middlewares: Optional[\n            Sequence[Callable[[aio_pika.IncomingMessage], BaseMiddleware]]\n        ],\n    ) -&gt; None:\n\"\"\"Add a call to the handler.\n\n        Args:\n            handler: The handler for the call.\n            dependant: The dependant for the call.\n            parser: Optional custom parser for the call.\n            decoder: Optional custom decoder for the call.\n            filter: The filter for the call.\n            middlewares: Optional sequence of middlewares for the call.\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        super().add_call(\n            handler=handler,\n            parser=resolve_custom_func(parser, AioPikaParser.parse_message),\n            decoder=resolve_custom_func(decoder, AioPikaParser.decode_message),\n            filter=filter,  # type: ignore[arg-type]\n            dependant=dependant,\n            middlewares=middlewares,\n        )\n\n    @override\n    async def start(self, declarer: RabbitDeclarer) -&gt; None:  # type: ignore[override]\n\"\"\"Starts the consumer for the RabbitMQ queue.\n\n        Args:\n            declarer: RabbitDeclarer object used to declare the queue and exchange\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        self._queue_obj = queue = await declarer.declare_queue(self.queue)\n\n        if self.exchange is not None:\n            exchange = await declarer.declare_exchange(self.exchange)\n            await queue.bind(\n                exchange,\n                routing_key=self.queue.routing,\n                arguments=self.queue.bind_arguments,\n            )\n\n        self._consumer_tag = await queue.consume(\n            # NOTE: aio-pika expects AbstractIncomingMessage, not IncomingMessage\n            self.consume,  # type: ignore[arg-type]\n            arguments=self.consume_args,\n        )\n\n    async def close(self) -&gt; None:\n        if self._queue_obj is not None:\n            if self._consumer_tag is not None:  # pragma: no branch\n                await self._queue_obj.cancel(self._consumer_tag)\n                self._consumer_tag = None\n            self._queue_obj = None\n</code></pre>"},{"location":"api/faststream/rabbit/handler/LogicHandler/#faststream.rabbit.handler.LogicHandler-attributes","title":"Attributes","text":""},{"location":"api/faststream/rabbit/handler/LogicHandler/#faststream.rabbit.handler.LogicHandler.consume_args","title":"consume_args  <code>instance-attribute</code>","text":"<pre><code>consume_args: AnyDict = consume_args or {}\n</code></pre>"},{"location":"api/faststream/rabbit/handler/LogicHandler/#faststream.rabbit.handler.LogicHandler.exchange","title":"exchange  <code>instance-attribute</code>","text":"<pre><code>exchange: Optional[RabbitExchange] = exchange\n</code></pre>"},{"location":"api/faststream/rabbit/handler/LogicHandler/#faststream.rabbit.handler.LogicHandler.queue","title":"queue  <code>instance-attribute</code>","text":"<pre><code>queue: RabbitQueue = queue\n</code></pre>"},{"location":"api/faststream/rabbit/handler/LogicHandler/#faststream.rabbit.handler.LogicHandler-functions","title":"Functions","text":""},{"location":"api/faststream/rabbit/handler/LogicHandler/#faststream.rabbit.handler.LogicHandler.__init__","title":"__init__","text":"<pre><code>__init__(\n    queue: RabbitQueue,\n    exchange: Optional[RabbitExchange] = None,\n    consume_args: Optional[AnyDict] = None,\n    description: Optional[str] = None,\n    title: Optional[str] = None,\n)\n</code></pre> <p>Initialize a RabbitMQ consumer.</p> <p>Parameters:</p> Name Type Description Default <code>queue</code> <code>RabbitQueue</code> <p>RabbitQueue object representing the queue to consume from</p> required <code>exchange</code> <code>Optional[RabbitExchange]</code> <p>RabbitExchange object representing the exchange to bind the queue to (optional)</p> <code>None</code> <code>consume_args</code> <code>Optional[AnyDict]</code> <p>Additional arguments for consuming from the queue (optional)</p> <code>None</code> <code>description</code> <code>Optional[str]</code> <p>Description of the consumer (optional)</p> <code>None</code> <code>title</code> <code>Optional[str]</code> <p>Title of the consumer (optional)</p> <code>None</code> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/handler.py</code> <pre><code>def __init__(\n    self,\n    queue: RabbitQueue,\n    # RMQ information\n    exchange: Optional[RabbitExchange] = None,\n    consume_args: Optional[AnyDict] = None,\n    # AsyncAPI information\n    description: Optional[str] = None,\n    title: Optional[str] = None,\n):\n\"\"\"Initialize a RabbitMQ consumer.\n\n    Args:\n        queue: RabbitQueue object representing the queue to consume from\n        exchange: RabbitExchange object representing the exchange to bind the queue to (optional)\n        consume_args: Additional arguments for consuming from the queue (optional)\n        description: Description of the consumer (optional)\n        title: Title of the consumer (optional)\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    super().__init__(\n        description=description,\n        title=title,\n    )\n\n    self.queue = queue\n    self.exchange = exchange\n    self.consume_args = consume_args or {}\n\n    self._consumer_tag = None\n    self._queue_obj = None\n</code></pre>"},{"location":"api/faststream/rabbit/handler/LogicHandler/#faststream.rabbit.handler.LogicHandler.add_call","title":"add_call","text":"<pre><code>add_call(\n    *,\n    handler: HandlerCallWrapper[\n        aio_pika.IncomingMessage,\n        P_HandlerParams,\n        T_HandlerReturn,\n    ],\n    dependant: CallModel[P_HandlerParams, T_HandlerReturn],\n    parser: Optional[\n        CustomParser[aio_pika.IncomingMessage]\n    ],\n    decoder: Optional[\n        CustomDecoder[aio_pika.IncomingMessage]\n    ],\n    filter: Filter[RabbitMessage],\n    middlewares: Optional[\n        Sequence[\n            Callable[\n                [aio_pika.IncomingMessage], BaseMiddleware\n            ]\n        ]\n    ]\n) -&gt; None\n</code></pre> <p>Add a call to the handler.</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>HandlerCallWrapper[IncomingMessage, P_HandlerParams, T_HandlerReturn]</code> <p>The handler for the call.</p> required <code>dependant</code> <code>CallModel[P_HandlerParams, T_HandlerReturn]</code> <p>The dependant for the call.</p> required <code>parser</code> <code>Optional[CustomParser[IncomingMessage]]</code> <p>Optional custom parser for the call.</p> required <code>decoder</code> <code>Optional[CustomDecoder[IncomingMessage]]</code> <p>Optional custom decoder for the call.</p> required <code>filter</code> <code>Filter[RabbitMessage]</code> <p>The filter for the call.</p> required <code>middlewares</code> <code>Optional[Sequence[Callable[[IncomingMessage], BaseMiddleware]]]</code> <p>Optional sequence of middlewares for the call.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/handler.py</code> <pre><code>def add_call(\n    self,\n    *,\n    handler: HandlerCallWrapper[\n        aio_pika.IncomingMessage, P_HandlerParams, T_HandlerReturn\n    ],\n    dependant: CallModel[P_HandlerParams, T_HandlerReturn],\n    parser: Optional[CustomParser[aio_pika.IncomingMessage]],\n    decoder: Optional[CustomDecoder[aio_pika.IncomingMessage]],\n    filter: Filter[RabbitMessage],\n    middlewares: Optional[\n        Sequence[Callable[[aio_pika.IncomingMessage], BaseMiddleware]]\n    ],\n) -&gt; None:\n\"\"\"Add a call to the handler.\n\n    Args:\n        handler: The handler for the call.\n        dependant: The dependant for the call.\n        parser: Optional custom parser for the call.\n        decoder: Optional custom decoder for the call.\n        filter: The filter for the call.\n        middlewares: Optional sequence of middlewares for the call.\n\n    Returns:\n        None\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    super().add_call(\n        handler=handler,\n        parser=resolve_custom_func(parser, AioPikaParser.parse_message),\n        decoder=resolve_custom_func(decoder, AioPikaParser.decode_message),\n        filter=filter,  # type: ignore[arg-type]\n        dependant=dependant,\n        middlewares=middlewares,\n    )\n</code></pre>"},{"location":"api/faststream/rabbit/handler/LogicHandler/#faststream.rabbit.handler.LogicHandler.close","title":"close  <code>async</code>","text":"<pre><code>close() -&gt; None\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/handler.py</code> <pre><code>async def close(self) -&gt; None:\n    if self._queue_obj is not None:\n        if self._consumer_tag is not None:  # pragma: no branch\n            await self._queue_obj.cancel(self._consumer_tag)\n            self._consumer_tag = None\n        self._queue_obj = None\n</code></pre>"},{"location":"api/faststream/rabbit/handler/LogicHandler/#faststream.rabbit.handler.LogicHandler.start","title":"start  <code>async</code>","text":"<pre><code>start(declarer: RabbitDeclarer) -&gt; None\n</code></pre> <p>Starts the consumer for the RabbitMQ queue.</p> <p>Parameters:</p> Name Type Description Default <code>declarer</code> <code>RabbitDeclarer</code> <p>RabbitDeclarer object used to declare the queue and exchange</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/handler.py</code> <pre><code>@override\nasync def start(self, declarer: RabbitDeclarer) -&gt; None:  # type: ignore[override]\n\"\"\"Starts the consumer for the RabbitMQ queue.\n\n    Args:\n        declarer: RabbitDeclarer object used to declare the queue and exchange\n\n    Returns:\n        None\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    self._queue_obj = queue = await declarer.declare_queue(self.queue)\n\n    if self.exchange is not None:\n        exchange = await declarer.declare_exchange(self.exchange)\n        await queue.bind(\n            exchange,\n            routing_key=self.queue.routing,\n            arguments=self.queue.bind_arguments,\n        )\n\n    self._consumer_tag = await queue.consume(\n        # NOTE: aio-pika expects AbstractIncomingMessage, not IncomingMessage\n        self.consume,  # type: ignore[arg-type]\n        arguments=self.consume_args,\n    )\n</code></pre>"},{"location":"api/faststream/rabbit/helpers/RabbitDeclarer/","title":"RabbitDeclarer","text":""},{"location":"api/faststream/rabbit/helpers/RabbitDeclarer/#faststream.rabbit.helpers.RabbitDeclarer","title":"faststream.rabbit.helpers.RabbitDeclarer","text":"<p>             Bases: <code>Singleton</code></p> <p>A class to declare RabbitMQ queues and exchanges.</p> <p>Attributes:</p> Name Type Description <code>channel</code> <p>aio_pika.RobustChannel The RabbitMQ channel to use for declaration.</p> <code>queues</code> <p>Dict[Union[RabbitQueue, str], aio_pika.RobustQueue] A dictionary to store the declared queues.</p> <code>exchanges</code> <p>Dict[Union[RabbitExchange, str], aio_pika.RobustExchange] A dictionary to store the declared exchanges.</p> <p>Methods:</p> Name Description <code>__init__</code> <p>aio_pika.RobustChannel) -&gt; None Initializes the RabbitDeclarer with a channel.</p> <code>declare_queue</code> <p>RabbitQueue) -&gt; aio_pika.RobustQueue Declares a queue and returns the declared queue object.</p> <code>declare_exchange</code> <p>RabbitExchange) -&gt; aio_pika.RobustExchange Declares an exchange and returns the declared exchange object.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/helpers.py</code> <pre><code>class RabbitDeclarer(Singleton):\n\"\"\"A class to declare RabbitMQ queues and exchanges.\n\n    Attributes:\n        channel : aio_pika.RobustChannel\n            The RabbitMQ channel to use for declaration.\n        queues : Dict[Union[RabbitQueue, str], aio_pika.RobustQueue]\n            A dictionary to store the declared queues.\n        exchanges : Dict[Union[RabbitExchange, str], aio_pika.RobustExchange]\n            A dictionary to store the declared exchanges.\n\n    Methods:\n        __init__(channel: aio_pika.RobustChannel) -&gt; None\n            Initializes the RabbitDeclarer with a channel.\n\n        declare_queue(queue: RabbitQueue) -&gt; aio_pika.RobustQueue\n            Declares a queue and returns the declared queue object.\n\n        declare_exchange(exchange: RabbitExchange) -&gt; aio_pika.RobustExchange\n            Declares an exchange and returns the declared exchange object.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    channel: aio_pika.RobustChannel\n    queues: Dict[Union[RabbitQueue, str], aio_pika.RobustQueue]\n    exchanges: Dict[Union[RabbitExchange, str], aio_pika.RobustExchange]\n\n    def __init__(self, channel: aio_pika.RobustChannel) -&gt; None:\n\"\"\"Initialize the class.\n\n        Args:\n            channel: Aio_pika RobustChannel object\n\n        Attributes:\n            channel: Aio_pika RobustChannel object\n            queues: A dictionary to store queues\n            exchanges: A dictionary to store exchanges\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        self.channel = channel\n        self.queues = {}\n        self.exchanges = {}\n\n    async def declare_queue(\n        self,\n        queue: RabbitQueue,\n    ) -&gt; aio_pika.RobustQueue:\n\"\"\"Declare a queue.\n\n        Args:\n            queue: RabbitQueue object representing the queue to be declared.\n\n        Returns:\n            aio_pika.RobustQueue: The declared queue.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        q = self.queues.get(queue)\n        if q is None:\n            q = cast(\n                aio_pika.RobustQueue,\n                await self.channel.declare_queue(\n                    **model_to_dict(\n                        queue,\n                        exclude={\n                            \"routing_key\",\n                            \"bind_arguments\",\n                        },\n                    )\n                ),\n            )\n            self.queues[queue] = q\n        return q\n\n    async def declare_exchange(\n        self,\n        exchange: RabbitExchange,\n    ) -&gt; aio_pika.RobustExchange:\n\"\"\"Declare an exchange.\n\n        Args:\n            exchange: RabbitExchange object representing the exchange to be declared.\n\n        Returns:\n            aio_pika.RobustExchange: The declared exchange.\n\n        Raises:\n            NotImplementedError: If silent animals are not supported.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        exch = self.exchanges.get(exchange)\n\n        if exch is None:\n            exch = cast(\n                aio_pika.RobustExchange,\n                await self.channel.declare_exchange(\n                    **model_to_dict(\n                        exchange,\n                        exclude={\n                            \"routing_key\",\n                            \"bind_arguments\",\n                            \"bind_to\",\n                        },\n                    )\n                ),\n            )\n            self.exchanges[exchange] = exch\n\n        if exchange.bind_to is not None:\n            parent = await self.declare_exchange(exchange.bind_to)\n            await exch.bind(\n                exchange=parent,\n                routing_key=exchange.routing_key,\n                arguments=exchange.arguments,\n            )\n\n        return exch\n</code></pre>"},{"location":"api/faststream/rabbit/helpers/RabbitDeclarer/#faststream.rabbit.helpers.RabbitDeclarer-attributes","title":"Attributes","text":""},{"location":"api/faststream/rabbit/helpers/RabbitDeclarer/#faststream.rabbit.helpers.RabbitDeclarer.channel","title":"channel  <code>instance-attribute</code>","text":"<pre><code>channel: aio_pika.RobustChannel = channel\n</code></pre>"},{"location":"api/faststream/rabbit/helpers/RabbitDeclarer/#faststream.rabbit.helpers.RabbitDeclarer.exchanges","title":"exchanges  <code>instance-attribute</code>","text":"<pre><code>exchanges: Dict[\n    Union[RabbitExchange, str], aio_pika.RobustExchange\n] = {}\n</code></pre>"},{"location":"api/faststream/rabbit/helpers/RabbitDeclarer/#faststream.rabbit.helpers.RabbitDeclarer.queues","title":"queues  <code>instance-attribute</code>","text":"<pre><code>queues: Dict[\n    Union[RabbitQueue, str], aio_pika.RobustQueue\n] = {}\n</code></pre>"},{"location":"api/faststream/rabbit/helpers/RabbitDeclarer/#faststream.rabbit.helpers.RabbitDeclarer-functions","title":"Functions","text":""},{"location":"api/faststream/rabbit/helpers/RabbitDeclarer/#faststream.rabbit.helpers.RabbitDeclarer.__init__","title":"__init__","text":"<pre><code>__init__(channel: aio_pika.RobustChannel) -&gt; None\n</code></pre> <p>Initialize the class.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>RobustChannel</code> <p>Aio_pika RobustChannel object</p> required <p>Attributes:</p> Name Type Description <code>channel</code> <p>Aio_pika RobustChannel object</p> <code>queues</code> <p>A dictionary to store queues</p> <code>exchanges</code> <p>A dictionary to store exchanges</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/helpers.py</code> <pre><code>def __init__(self, channel: aio_pika.RobustChannel) -&gt; None:\n\"\"\"Initialize the class.\n\n    Args:\n        channel: Aio_pika RobustChannel object\n\n    Attributes:\n        channel: Aio_pika RobustChannel object\n        queues: A dictionary to store queues\n        exchanges: A dictionary to store exchanges\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    self.channel = channel\n    self.queues = {}\n    self.exchanges = {}\n</code></pre>"},{"location":"api/faststream/rabbit/helpers/RabbitDeclarer/#faststream.rabbit.helpers.RabbitDeclarer.declare_exchange","title":"declare_exchange  <code>async</code>","text":"<pre><code>declare_exchange(\n    exchange: RabbitExchange,\n) -&gt; aio_pika.RobustExchange\n</code></pre> <p>Declare an exchange.</p> <p>Parameters:</p> Name Type Description Default <code>exchange</code> <code>RabbitExchange</code> <p>RabbitExchange object representing the exchange to be declared.</p> required <p>Returns:</p> Type Description <code>RobustExchange</code> <p>aio_pika.RobustExchange: The declared exchange.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If silent animals are not supported.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/helpers.py</code> <pre><code>async def declare_exchange(\n    self,\n    exchange: RabbitExchange,\n) -&gt; aio_pika.RobustExchange:\n\"\"\"Declare an exchange.\n\n    Args:\n        exchange: RabbitExchange object representing the exchange to be declared.\n\n    Returns:\n        aio_pika.RobustExchange: The declared exchange.\n\n    Raises:\n        NotImplementedError: If silent animals are not supported.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    exch = self.exchanges.get(exchange)\n\n    if exch is None:\n        exch = cast(\n            aio_pika.RobustExchange,\n            await self.channel.declare_exchange(\n                **model_to_dict(\n                    exchange,\n                    exclude={\n                        \"routing_key\",\n                        \"bind_arguments\",\n                        \"bind_to\",\n                    },\n                )\n            ),\n        )\n        self.exchanges[exchange] = exch\n\n    if exchange.bind_to is not None:\n        parent = await self.declare_exchange(exchange.bind_to)\n        await exch.bind(\n            exchange=parent,\n            routing_key=exchange.routing_key,\n            arguments=exchange.arguments,\n        )\n\n    return exch\n</code></pre>"},{"location":"api/faststream/rabbit/helpers/RabbitDeclarer/#faststream.rabbit.helpers.RabbitDeclarer.declare_queue","title":"declare_queue  <code>async</code>","text":"<pre><code>declare_queue(queue: RabbitQueue) -&gt; aio_pika.RobustQueue\n</code></pre> <p>Declare a queue.</p> <p>Parameters:</p> Name Type Description Default <code>queue</code> <code>RabbitQueue</code> <p>RabbitQueue object representing the queue to be declared.</p> required <p>Returns:</p> Type Description <code>RobustQueue</code> <p>aio_pika.RobustQueue: The declared queue.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/helpers.py</code> <pre><code>async def declare_queue(\n    self,\n    queue: RabbitQueue,\n) -&gt; aio_pika.RobustQueue:\n\"\"\"Declare a queue.\n\n    Args:\n        queue: RabbitQueue object representing the queue to be declared.\n\n    Returns:\n        aio_pika.RobustQueue: The declared queue.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    q = self.queues.get(queue)\n    if q is None:\n        q = cast(\n            aio_pika.RobustQueue,\n            await self.channel.declare_queue(\n                **model_to_dict(\n                    queue,\n                    exclude={\n                        \"routing_key\",\n                        \"bind_arguments\",\n                    },\n                )\n            ),\n        )\n        self.queues[queue] = q\n    return q\n</code></pre>"},{"location":"api/faststream/rabbit/message/RabbitMessage/","title":"RabbitMessage","text":""},{"location":"api/faststream/rabbit/message/RabbitMessage/#faststream.rabbit.message.RabbitMessage","title":"faststream.rabbit.message.RabbitMessage","text":"<p>             Bases: <code>StreamMessage[IncomingMessage]</code></p> <p>A message class for working with RabbitMQ messages.</p> <p>This class extends <code>StreamMessage</code> to provide additional functionality for acknowledging, rejecting, or nack-ing RabbitMQ messages.</p> <p>Methods:</p> Name Description <code>ack</code> <p>Acknowledge the RabbitMQ message.</p> <code>nack</code> <p>Negative Acknowledgment of the RabbitMQ message.</p> <code>reject</code> <p>Reject the RabbitMQ message.</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/message.py</code> <pre><code>class RabbitMessage(StreamMessage[aio_pika.IncomingMessage]):\n\"\"\"\n    A message class for working with RabbitMQ messages.\n\n    This class extends `StreamMessage` to provide additional functionality for acknowledging, rejecting,\n    or nack-ing RabbitMQ messages.\n\n    Methods:\n        ack(**kwargs) -&gt; None:\n            Acknowledge the RabbitMQ message.\n\n        nack(**kwargs) -&gt; None:\n            Negative Acknowledgment of the RabbitMQ message.\n\n        reject(**kwargs) -&gt; None:\n            Reject the RabbitMQ message.\n\n    \"\"\"\n\n    async def ack(self, **kwargs: Any) -&gt; None:\n\"\"\"\n        Acknowledge the RabbitMQ message.\n\n        Acknowledgment indicates that the message has been successfully processed.\n\n        Args:\n            **kwargs (Any): Additional keyword arguments (not used).\n\n        \"\"\"\n        pika_message = self.raw_message\n        if (\n            pika_message._IncomingMessage__processed  # type: ignore[attr-defined]\n            or pika_message._IncomingMessage__no_ack  # type: ignore[attr-defined]\n        ):\n            return\n        await pika_message.ack()\n\n    async def nack(self, **kwargs: Any) -&gt; None:\n\"\"\"\n        Negative Acknowledgment of the RabbitMQ message.\n\n        Nack-ing a message indicates that the message processing has failed and should be requeued.\n\n        Args:\n            **kwargs (Any): Additional keyword arguments (not used).\n\n        \"\"\"\n        pika_message = self.raw_message\n        if (\n            pika_message._IncomingMessage__processed  # type: ignore[attr-defined]\n            or pika_message._IncomingMessage__no_ack  # type: ignore[attr-defined]\n        ):\n            return\n        await pika_message.nack()\n\n    async def reject(self, **kwargs: Any) -&gt; None:\n\"\"\"\n        Reject the RabbitMQ message.\n\n        Rejecting a message indicates that the message processing has failed, and it should not be requeued.\n\n        Args:\n            **kwargs (Any): Additional keyword arguments (not used).\n\n        \"\"\"\n        pika_message = self.raw_message\n        if (\n            pika_message._IncomingMessage__processed  # type: ignore[attr-defined]\n            or pika_message._IncomingMessage__no_ack  # type: ignore[attr-defined]\n        ):\n            return\n        await pika_message.reject()\n</code></pre>"},{"location":"api/faststream/rabbit/message/RabbitMessage/#faststream.rabbit.message.RabbitMessage-functions","title":"Functions","text":""},{"location":"api/faststream/rabbit/message/RabbitMessage/#faststream.rabbit.message.RabbitMessage.ack","title":"ack  <code>async</code>","text":"<pre><code>ack(**kwargs: Any) -&gt; None\n</code></pre> <p>Acknowledge the RabbitMQ message.</p> <p>Acknowledgment indicates that the message has been successfully processed.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments (not used).</p> <code>{}</code> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/message.py</code> <pre><code>async def ack(self, **kwargs: Any) -&gt; None:\n\"\"\"\n    Acknowledge the RabbitMQ message.\n\n    Acknowledgment indicates that the message has been successfully processed.\n\n    Args:\n        **kwargs (Any): Additional keyword arguments (not used).\n\n    \"\"\"\n    pika_message = self.raw_message\n    if (\n        pika_message._IncomingMessage__processed  # type: ignore[attr-defined]\n        or pika_message._IncomingMessage__no_ack  # type: ignore[attr-defined]\n    ):\n        return\n    await pika_message.ack()\n</code></pre>"},{"location":"api/faststream/rabbit/message/RabbitMessage/#faststream.rabbit.message.RabbitMessage.nack","title":"nack  <code>async</code>","text":"<pre><code>nack(**kwargs: Any) -&gt; None\n</code></pre> <p>Negative Acknowledgment of the RabbitMQ message.</p> <p>Nack-ing a message indicates that the message processing has failed and should be requeued.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments (not used).</p> <code>{}</code> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/message.py</code> <pre><code>async def nack(self, **kwargs: Any) -&gt; None:\n\"\"\"\n    Negative Acknowledgment of the RabbitMQ message.\n\n    Nack-ing a message indicates that the message processing has failed and should be requeued.\n\n    Args:\n        **kwargs (Any): Additional keyword arguments (not used).\n\n    \"\"\"\n    pika_message = self.raw_message\n    if (\n        pika_message._IncomingMessage__processed  # type: ignore[attr-defined]\n        or pika_message._IncomingMessage__no_ack  # type: ignore[attr-defined]\n    ):\n        return\n    await pika_message.nack()\n</code></pre>"},{"location":"api/faststream/rabbit/message/RabbitMessage/#faststream.rabbit.message.RabbitMessage.reject","title":"reject  <code>async</code>","text":"<pre><code>reject(**kwargs: Any) -&gt; None\n</code></pre> <p>Reject the RabbitMQ message.</p> <p>Rejecting a message indicates that the message processing has failed, and it should not be requeued.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments (not used).</p> <code>{}</code> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/message.py</code> <pre><code>async def reject(self, **kwargs: Any) -&gt; None:\n\"\"\"\n    Reject the RabbitMQ message.\n\n    Rejecting a message indicates that the message processing has failed, and it should not be requeued.\n\n    Args:\n        **kwargs (Any): Additional keyword arguments (not used).\n\n    \"\"\"\n    pika_message = self.raw_message\n    if (\n        pika_message._IncomingMessage__processed  # type: ignore[attr-defined]\n        or pika_message._IncomingMessage__no_ack  # type: ignore[attr-defined]\n    ):\n        return\n    await pika_message.reject()\n</code></pre>"},{"location":"api/faststream/rabbit/parser/AioPikaParser/","title":"AioPikaParser","text":""},{"location":"api/faststream/rabbit/parser/AioPikaParser/#faststream.rabbit.parser.AioPikaParser","title":"faststream.rabbit.parser.AioPikaParser","text":"<p>A class for parsing, encoding, and decoding messages using aio-pika.</p> <p>Methods:</p> Name Description <code>parse_message</code> <p>aio_pika.IncomingMessage) -&gt; StreamMessage[aio_pika.IncomingMessage]: Parses an incoming message and returns a StreamMessage object.</p> <code>decode_message</code> <p>StreamMessage[aio_pika.IncomingMessage]) -&gt; DecodedMessage: Decodes a StreamMessage object and returns a DecodedMessage object.</p> <code>encode_message</code> <p>AioPikaSendableMessage, persist: bool = False, callback_queue: Optional[aio_pika.abc.AbstractRobustQueue] = None, reply_to: Optional[str] = None, **message_kwargs: Any) -&gt; aio_pika.Message: Encodes a message into an aio_pika.Message object.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/parser.py</code> <pre><code>class AioPikaParser:\n\"\"\"A class for parsing, encoding, and decoding messages using aio-pika.\n\n    Methods:\n        parse_message(message: aio_pika.IncomingMessage) -&gt; StreamMessage[aio_pika.IncomingMessage]:\n            Parses an incoming message and returns a StreamMessage object.\n\n        decode_message(msg: StreamMessage[aio_pika.IncomingMessage]) -&gt; DecodedMessage:\n            Decodes a StreamMessage object and returns a DecodedMessage object.\n\n        encode_message(message: AioPikaSendableMessage, persist: bool = False, callback_queue: Optional[aio_pika.abc.AbstractRobustQueue] = None, reply_to: Optional[str] = None, **message_kwargs: Any) -&gt; aio_pika.Message:\n            Encodes a message into an aio_pika.Message object.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    @staticmethod\n    async def parse_message(\n        message: aio_pika.IncomingMessage,\n    ) -&gt; StreamMessage[aio_pika.IncomingMessage]:\n\"\"\"Parses an incoming message and returns a RabbitMessage object.\n\n        Args:\n            message: The incoming message to parse.\n\n        Returns:\n            A StreamMessage object representing the parsed message.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        return RabbitMessage(\n            body=message.body,\n            headers=message.headers,\n            reply_to=message.reply_to or \"\",\n            content_type=message.content_type,\n            message_id=message.message_id or str(uuid4()),\n            correlation_id=message.correlation_id or str(uuid4()),\n            raw_message=message,\n        )\n\n    @staticmethod\n    async def decode_message(\n        msg: StreamMessage[aio_pika.IncomingMessage],\n    ) -&gt; DecodedMessage:\n\"\"\"Decode a message.\n\n        Args:\n            msg: The message to decode.\n\n        Returns:\n            The decoded message.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        return decode_message(msg)\n\n    @staticmethod\n    def encode_message(\n        message: AioPikaSendableMessage,\n        persist: bool = False,\n        callback_queue: Optional[aio_pika.abc.AbstractRobustQueue] = None,\n        reply_to: Optional[str] = None,\n        **message_kwargs: Any,\n    ) -&gt; aio_pika.Message:\n\"\"\"Encodes a message for sending using AioPika.\n\n        Args:\n            message (AioPikaSendableMessage): The message to encode.\n            persist (bool, optional): Whether to persist the message. Defaults to False.\n            callback_queue (aio_pika.abc.AbstractRobustQueue, optional): The callback queue to use for replies. Defaults to None.\n            reply_to (str, optional): The reply-to queue to use for replies. Defaults to None.\n            **message_kwargs (Any): Additional keyword arguments to include in the encoded message.\n\n        Returns:\n            aio_pika.Message: The encoded message.\n\n        Raises:\n            NotImplementedError: If the message is not an instance of aio_pika.Message.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        if not isinstance(message, aio_pika.Message):\n            message, content_type = encode_message(message)\n\n            delivery_mode = (\n                DeliveryMode.PERSISTENT if persist else DeliveryMode.NOT_PERSISTENT\n            )\n\n            message = aio_pika.Message(\n                message,\n                **{\n                    \"delivery_mode\": delivery_mode,\n                    \"content_type\": content_type,\n                    \"reply_to\": callback_queue or reply_to,\n                    \"correlation_id\": str(uuid4()),\n                    **message_kwargs,\n                },\n            )\n\n        return message\n</code></pre>"},{"location":"api/faststream/rabbit/parser/AioPikaParser/#faststream.rabbit.parser.AioPikaParser-functions","title":"Functions","text":""},{"location":"api/faststream/rabbit/parser/AioPikaParser/#faststream.rabbit.parser.AioPikaParser.decode_message","title":"decode_message  <code>async</code> <code>staticmethod</code>","text":"<pre><code>decode_message(\n    msg: StreamMessage[aio_pika.IncomingMessage],\n) -&gt; DecodedMessage\n</code></pre> <p>Decode a message.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>StreamMessage[IncomingMessage]</code> <p>The message to decode.</p> required <p>Returns:</p> Type Description <code>DecodedMessage</code> <p>The decoded message.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/parser.py</code> <pre><code>@staticmethod\nasync def decode_message(\n    msg: StreamMessage[aio_pika.IncomingMessage],\n) -&gt; DecodedMessage:\n\"\"\"Decode a message.\n\n    Args:\n        msg: The message to decode.\n\n    Returns:\n        The decoded message.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    return decode_message(msg)\n</code></pre>"},{"location":"api/faststream/rabbit/parser/AioPikaParser/#faststream.rabbit.parser.AioPikaParser.encode_message","title":"encode_message  <code>staticmethod</code>","text":"<pre><code>encode_message(\n    message: AioPikaSendableMessage,\n    persist: bool = False,\n    callback_queue: Optional[\n        aio_pika.abc.AbstractRobustQueue\n    ] = None,\n    reply_to: Optional[str] = None,\n    **message_kwargs: Any\n) -&gt; aio_pika.Message\n</code></pre> <p>Encodes a message for sending using AioPika.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>AioPikaSendableMessage</code> <p>The message to encode.</p> required <code>persist</code> <code>bool</code> <p>Whether to persist the message. Defaults to False.</p> <code>False</code> <code>callback_queue</code> <code>AbstractRobustQueue</code> <p>The callback queue to use for replies. Defaults to None.</p> <code>None</code> <code>reply_to</code> <code>str</code> <p>The reply-to queue to use for replies. Defaults to None.</p> <code>None</code> <code>**message_kwargs</code> <code>Any</code> <p>Additional keyword arguments to include in the encoded message.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Message</code> <p>aio_pika.Message: The encoded message.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the message is not an instance of aio_pika.Message.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/parser.py</code> <pre><code>@staticmethod\ndef encode_message(\n    message: AioPikaSendableMessage,\n    persist: bool = False,\n    callback_queue: Optional[aio_pika.abc.AbstractRobustQueue] = None,\n    reply_to: Optional[str] = None,\n    **message_kwargs: Any,\n) -&gt; aio_pika.Message:\n\"\"\"Encodes a message for sending using AioPika.\n\n    Args:\n        message (AioPikaSendableMessage): The message to encode.\n        persist (bool, optional): Whether to persist the message. Defaults to False.\n        callback_queue (aio_pika.abc.AbstractRobustQueue, optional): The callback queue to use for replies. Defaults to None.\n        reply_to (str, optional): The reply-to queue to use for replies. Defaults to None.\n        **message_kwargs (Any): Additional keyword arguments to include in the encoded message.\n\n    Returns:\n        aio_pika.Message: The encoded message.\n\n    Raises:\n        NotImplementedError: If the message is not an instance of aio_pika.Message.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    if not isinstance(message, aio_pika.Message):\n        message, content_type = encode_message(message)\n\n        delivery_mode = (\n            DeliveryMode.PERSISTENT if persist else DeliveryMode.NOT_PERSISTENT\n        )\n\n        message = aio_pika.Message(\n            message,\n            **{\n                \"delivery_mode\": delivery_mode,\n                \"content_type\": content_type,\n                \"reply_to\": callback_queue or reply_to,\n                \"correlation_id\": str(uuid4()),\n                **message_kwargs,\n            },\n        )\n\n    return message\n</code></pre>"},{"location":"api/faststream/rabbit/parser/AioPikaParser/#faststream.rabbit.parser.AioPikaParser.parse_message","title":"parse_message  <code>async</code> <code>staticmethod</code>","text":"<pre><code>parse_message(\n    message: aio_pika.IncomingMessage,\n) -&gt; StreamMessage[aio_pika.IncomingMessage]\n</code></pre> <p>Parses an incoming message and returns a RabbitMessage object.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>IncomingMessage</code> <p>The incoming message to parse.</p> required <p>Returns:</p> Type Description <code>StreamMessage[IncomingMessage]</code> <p>A StreamMessage object representing the parsed message.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/parser.py</code> <pre><code>@staticmethod\nasync def parse_message(\n    message: aio_pika.IncomingMessage,\n) -&gt; StreamMessage[aio_pika.IncomingMessage]:\n\"\"\"Parses an incoming message and returns a RabbitMessage object.\n\n    Args:\n        message: The incoming message to parse.\n\n    Returns:\n        A StreamMessage object representing the parsed message.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    return RabbitMessage(\n        body=message.body,\n        headers=message.headers,\n        reply_to=message.reply_to or \"\",\n        content_type=message.content_type,\n        message_id=message.message_id or str(uuid4()),\n        correlation_id=message.correlation_id or str(uuid4()),\n        raw_message=message,\n    )\n</code></pre>"},{"location":"api/faststream/rabbit/producer/AioPikaFastProducer/","title":"AioPikaFastProducer","text":""},{"location":"api/faststream/rabbit/producer/AioPikaFastProducer/#faststream.rabbit.producer.AioPikaFastProducer","title":"faststream.rabbit.producer.AioPikaFastProducer","text":"<p>A class for fast producing messages using aio-pika.</p> <p>Attributes:</p> Name Type Description <code>_channel</code> <p>aio_pika.RobustChannel The channel used for publishing messages.</p> <code>_rpc_lock</code> <p>anyio.Lock Lock used for RPC calls.</p> <code>_decoder</code> <p>AsyncDecoder[aio_pika.IncomingMessage] Decoder used for decoding incoming messages.</p> <code>_parser</code> <p>AsyncParser[aio_pika.IncomingMessage] Parser used for parsing incoming messages.</p> <code>declarer</code> <p>RabbitDeclarer The declarer object used for declaring exchanges and queues.</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Initializes the AioPikaFastProducer object.</p> <code>publish</code> <p>Publishes a message to a queue or exchange.</p> <code>_publish</code> <p>Publishes a message to an exchange.</p> <p>Note: This docstring is incomplete as it is difficult to understand the purpose and functionality of the class and its methods without more context.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/producer.py</code> <pre><code>class AioPikaFastProducer:\n\"\"\"A class for fast producing messages using aio-pika.\n\n    Attributes:\n        _channel : aio_pika.RobustChannel\n            The channel used for publishing messages.\n        _rpc_lock : anyio.Lock\n            Lock used for RPC calls.\n        _decoder : AsyncDecoder[aio_pika.IncomingMessage]\n            Decoder used for decoding incoming messages.\n        _parser : AsyncParser[aio_pika.IncomingMessage]\n            Parser used for parsing incoming messages.\n        declarer : RabbitDeclarer\n            The declarer object used for declaring exchanges and queues.\n\n    Methods:\n        __init__(channel, declarer, parser, decoder): Initializes the AioPikaFastProducer object.\n        publish(message, queue, exchange, routing_key, mandatory, immediate, timeout, rpc, rpc_timeout, raise_timeout, persist, reply_to, **message_kwargs): Publishes a message to a queue or exchange.\n        _publish(message, exchange, routing_key, mandatory, immediate, timeout, persist, reply_to, **message_kwargs): Publishes a message to an exchange.\n\n    Note: This docstring is incomplete as it is difficult to understand the purpose and functionality of the class and its methods without more context.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    _channel: aio_pika.RobustChannel\n    _rpc_lock: anyio.Lock\n    _decoder: AsyncDecoder[aio_pika.IncomingMessage]\n    _parser: AsyncParser[aio_pika.IncomingMessage]\n    declarer: RabbitDeclarer\n\n    def __init__(\n        self,\n        channel: aio_pika.RobustChannel,\n        declarer: RabbitDeclarer,\n        parser: Optional[AsyncCustomParser[aio_pika.IncomingMessage]],\n        decoder: Optional[AsyncCustomDecoder[aio_pika.IncomingMessage]],\n    ):\n\"\"\"Initialize a class instance.\n\n        Args:\n            channel: The aio_pika.RobustChannel object.\n            declarer: The RabbitDeclarer object.\n            parser: An optional AsyncCustomParser object for parsing incoming messages.\n            decoder: An optional AsyncCustomDecoder object for decoding incoming messages.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        self._channel = channel\n        self.declarer = declarer\n        self._parser = resolve_custom_func(parser, AioPikaParser.parse_message)\n        self._decoder = resolve_custom_func(decoder, AioPikaParser.decode_message)\n        self._rpc_lock = anyio.Lock()\n\n    async def publish(\n        self,\n        message: AioPikaSendableMessage = \"\",\n        queue: Union[RabbitQueue, str] = \"\",\n        exchange: Union[RabbitExchange, str, None] = None,\n        *,\n        routing_key: str = \"\",\n        mandatory: bool = True,\n        immediate: bool = False,\n        timeout: TimeoutType = None,\n        rpc: bool = False,\n        rpc_timeout: Optional[float] = 30.0,\n        raise_timeout: bool = False,\n        persist: bool = False,\n        reply_to: Optional[str] = None,\n        **message_kwargs: Any,\n    ) -&gt; Union[aiormq.abc.ConfirmationFrameType, SendableMessage]:\n\"\"\"Publish a message to a RabbitMQ queue.\n\n        Args:\n            message (AioPikaSendableMessage): The message to be published.\n            queue (Union[RabbitQueue, str]): The queue to publish the message to.\n            exchange (Union[RabbitExchange, str, None]): The exchange to publish the message to.\n            routing_key (str): The routing key for the message.\n            mandatory (bool): Whether the message is mandatory.\n            immediate (bool): Whether the message should be delivered immediately.\n            timeout (TimeoutType): The timeout for the operation.\n            rpc (bool): Whether the message is for RPC.\n            rpc_timeout (Optional[float]): The timeout for RPC.\n            raise_timeout (bool): Whether to raise an exception on timeout.\n            persist (bool): Whether the message should be persisted.\n            reply_to (Optional[str]): The reply-to queue for RPC.\n            **message_kwargs (Any): Additional keyword arguments for the message.\n\n        Returns:\n            Union[aiormq.abc.ConfirmationFrameType, SendableMessage]: The result of the publish operation.\n\n        Raises:\n            WRONG_PUBLISH_ARGS: If reply_to is not None when rpc is True.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        p_queue = RabbitQueue.validate(queue)\n\n        context: AsyncContextManager[\n            Optional[MemoryObjectReceiveStream[aio_pika.IncomingMessage]]\n        ]\n        if rpc is True:\n            if reply_to is not None:\n                raise WRONG_PUBLISH_ARGS\n            else:\n                context = _RPCCallback(\n                    self._rpc_lock,\n                    self.declarer.queues[RABBIT_REPLY],\n                )\n        else:\n            context = _fake_context()\n\n        async with context as response_queue:\n            r = await self._publish(\n                message=message,\n                exchange=exchange,\n                routing_key=routing_key or p_queue.routing or \"\",\n                mandatory=mandatory,\n                immediate=immediate,\n                timeout=timeout,\n                persist=persist,\n                reply_to=RABBIT_REPLY if response_queue else reply_to,\n                **message_kwargs,\n            )\n\n            if response_queue is None:\n                return r\n\n            else:\n                scope: Callable[[Optional[float]], ContextManager[CancelScope]]\n                if raise_timeout:\n                    scope = anyio.fail_after\n                else:\n                    scope = anyio.move_on_after\n\n                msg: Optional[aio_pika.IncomingMessage] = None\n                with scope(rpc_timeout):\n                    msg = await response_queue.receive()\n\n                if msg:\n                    return await self._decoder(await self._parser(msg))\n\n        return None\n\n    async def _publish(\n        self,\n        message: AioPikaSendableMessage = \"\",\n        exchange: Union[RabbitExchange, str, None] = None,\n        *,\n        routing_key: str = \"\",\n        mandatory: bool = True,\n        immediate: bool = False,\n        timeout: TimeoutType = None,\n        persist: bool = False,\n        reply_to: Optional[str] = None,\n        **message_kwargs: Any,\n    ) -&gt; Union[aiormq.abc.ConfirmationFrameType, SendableMessage]:\n\"\"\"Publish a message to a RabbitMQ exchange.\n\n        Args:\n            message (AioPikaSendableMessage): The message to be published.\n            exchange (Union[RabbitExchange, str, None]): The exchange to publish the message to.\n            routing_key (str): The routing key for the message.\n            mandatory (bool): Whether the message is mandatory.\n            immediate (bool): Whether the message should be delivered immediately.\n            timeout (TimeoutType): The timeout for the operation.\n            persist (bool): Whether the message should be persisted.\n            reply_to (Optional[str]): The reply-to address for the message.\n            **message_kwargs (Any): Additional keyword arguments for the message.\n\n        Returns:\n            Union[aiormq.abc.ConfirmationFrameType, SendableMessage]: The result of the publish operation.\n\n        Raises:\n            NotImplementedError: If silent animals are not supported.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        p_exchange = RabbitExchange.validate(exchange)\n\n        if p_exchange is None:\n            exchange_obj = self._channel.default_exchange\n        else:\n            exchange_obj = await self.declarer.declare_exchange(p_exchange)\n\n        message = AioPikaParser.encode_message(\n            message=message,\n            persist=persist,\n            reply_to=reply_to,\n            **message_kwargs,\n        )\n\n        return await exchange_obj.publish(\n            message=message,\n            routing_key=routing_key,\n            mandatory=mandatory,\n            immediate=immediate,\n            timeout=timeout,\n        )\n</code></pre>"},{"location":"api/faststream/rabbit/producer/AioPikaFastProducer/#faststream.rabbit.producer.AioPikaFastProducer-attributes","title":"Attributes","text":""},{"location":"api/faststream/rabbit/producer/AioPikaFastProducer/#faststream.rabbit.producer.AioPikaFastProducer.declarer","title":"declarer  <code>instance-attribute</code>","text":"<pre><code>declarer: RabbitDeclarer = declarer\n</code></pre>"},{"location":"api/faststream/rabbit/producer/AioPikaFastProducer/#faststream.rabbit.producer.AioPikaFastProducer-functions","title":"Functions","text":""},{"location":"api/faststream/rabbit/producer/AioPikaFastProducer/#faststream.rabbit.producer.AioPikaFastProducer.__init__","title":"__init__","text":"<pre><code>__init__(\n    channel: aio_pika.RobustChannel,\n    declarer: RabbitDeclarer,\n    parser: Optional[\n        AsyncCustomParser[aio_pika.IncomingMessage]\n    ],\n    decoder: Optional[\n        AsyncCustomDecoder[aio_pika.IncomingMessage]\n    ],\n)\n</code></pre> <p>Initialize a class instance.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>RobustChannel</code> <p>The aio_pika.RobustChannel object.</p> required <code>declarer</code> <code>RabbitDeclarer</code> <p>The RabbitDeclarer object.</p> required <code>parser</code> <code>Optional[AsyncCustomParser[IncomingMessage]]</code> <p>An optional AsyncCustomParser object for parsing incoming messages.</p> required <code>decoder</code> <code>Optional[AsyncCustomDecoder[IncomingMessage]]</code> <p>An optional AsyncCustomDecoder object for decoding incoming messages.</p> required <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/producer.py</code> <pre><code>def __init__(\n    self,\n    channel: aio_pika.RobustChannel,\n    declarer: RabbitDeclarer,\n    parser: Optional[AsyncCustomParser[aio_pika.IncomingMessage]],\n    decoder: Optional[AsyncCustomDecoder[aio_pika.IncomingMessage]],\n):\n\"\"\"Initialize a class instance.\n\n    Args:\n        channel: The aio_pika.RobustChannel object.\n        declarer: The RabbitDeclarer object.\n        parser: An optional AsyncCustomParser object for parsing incoming messages.\n        decoder: An optional AsyncCustomDecoder object for decoding incoming messages.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    self._channel = channel\n    self.declarer = declarer\n    self._parser = resolve_custom_func(parser, AioPikaParser.parse_message)\n    self._decoder = resolve_custom_func(decoder, AioPikaParser.decode_message)\n    self._rpc_lock = anyio.Lock()\n</code></pre>"},{"location":"api/faststream/rabbit/producer/AioPikaFastProducer/#faststream.rabbit.producer.AioPikaFastProducer.publish","title":"publish  <code>async</code>","text":"<pre><code>publish(\n    message: AioPikaSendableMessage = \"\",\n    queue: Union[RabbitQueue, str] = \"\",\n    exchange: Union[RabbitExchange, str, None] = None,\n    *,\n    routing_key: str = \"\",\n    mandatory: bool = True,\n    immediate: bool = False,\n    timeout: TimeoutType = None,\n    rpc: bool = False,\n    rpc_timeout: Optional[float] = 30.0,\n    raise_timeout: bool = False,\n    persist: bool = False,\n    reply_to: Optional[str] = None,\n    **message_kwargs: Any\n) -&gt; Union[\n    aiormq.abc.ConfirmationFrameType, SendableMessage\n]\n</code></pre> <p>Publish a message to a RabbitMQ queue.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>AioPikaSendableMessage</code> <p>The message to be published.</p> <code>''</code> <code>queue</code> <code>Union[RabbitQueue, str]</code> <p>The queue to publish the message to.</p> <code>''</code> <code>exchange</code> <code>Union[RabbitExchange, str, None]</code> <p>The exchange to publish the message to.</p> <code>None</code> <code>routing_key</code> <code>str</code> <p>The routing key for the message.</p> <code>''</code> <code>mandatory</code> <code>bool</code> <p>Whether the message is mandatory.</p> <code>True</code> <code>immediate</code> <code>bool</code> <p>Whether the message should be delivered immediately.</p> <code>False</code> <code>timeout</code> <code>TimeoutType</code> <p>The timeout for the operation.</p> <code>None</code> <code>rpc</code> <code>bool</code> <p>Whether the message is for RPC.</p> <code>False</code> <code>rpc_timeout</code> <code>Optional[float]</code> <p>The timeout for RPC.</p> <code>30.0</code> <code>raise_timeout</code> <code>bool</code> <p>Whether to raise an exception on timeout.</p> <code>False</code> <code>persist</code> <code>bool</code> <p>Whether the message should be persisted.</p> <code>False</code> <code>reply_to</code> <code>Optional[str]</code> <p>The reply-to queue for RPC.</p> <code>None</code> <code>**message_kwargs</code> <code>Any</code> <p>Additional keyword arguments for the message.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Union[ConfirmationFrameType, SendableMessage]</code> <p>Union[aiormq.abc.ConfirmationFrameType, SendableMessage]: The result of the publish operation.</p> <p>Raises:</p> Type Description <code>WRONG_PUBLISH_ARGS</code> <p>If reply_to is not None when rpc is True.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/producer.py</code> <pre><code>async def publish(\n    self,\n    message: AioPikaSendableMessage = \"\",\n    queue: Union[RabbitQueue, str] = \"\",\n    exchange: Union[RabbitExchange, str, None] = None,\n    *,\n    routing_key: str = \"\",\n    mandatory: bool = True,\n    immediate: bool = False,\n    timeout: TimeoutType = None,\n    rpc: bool = False,\n    rpc_timeout: Optional[float] = 30.0,\n    raise_timeout: bool = False,\n    persist: bool = False,\n    reply_to: Optional[str] = None,\n    **message_kwargs: Any,\n) -&gt; Union[aiormq.abc.ConfirmationFrameType, SendableMessage]:\n\"\"\"Publish a message to a RabbitMQ queue.\n\n    Args:\n        message (AioPikaSendableMessage): The message to be published.\n        queue (Union[RabbitQueue, str]): The queue to publish the message to.\n        exchange (Union[RabbitExchange, str, None]): The exchange to publish the message to.\n        routing_key (str): The routing key for the message.\n        mandatory (bool): Whether the message is mandatory.\n        immediate (bool): Whether the message should be delivered immediately.\n        timeout (TimeoutType): The timeout for the operation.\n        rpc (bool): Whether the message is for RPC.\n        rpc_timeout (Optional[float]): The timeout for RPC.\n        raise_timeout (bool): Whether to raise an exception on timeout.\n        persist (bool): Whether the message should be persisted.\n        reply_to (Optional[str]): The reply-to queue for RPC.\n        **message_kwargs (Any): Additional keyword arguments for the message.\n\n    Returns:\n        Union[aiormq.abc.ConfirmationFrameType, SendableMessage]: The result of the publish operation.\n\n    Raises:\n        WRONG_PUBLISH_ARGS: If reply_to is not None when rpc is True.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    p_queue = RabbitQueue.validate(queue)\n\n    context: AsyncContextManager[\n        Optional[MemoryObjectReceiveStream[aio_pika.IncomingMessage]]\n    ]\n    if rpc is True:\n        if reply_to is not None:\n            raise WRONG_PUBLISH_ARGS\n        else:\n            context = _RPCCallback(\n                self._rpc_lock,\n                self.declarer.queues[RABBIT_REPLY],\n            )\n    else:\n        context = _fake_context()\n\n    async with context as response_queue:\n        r = await self._publish(\n            message=message,\n            exchange=exchange,\n            routing_key=routing_key or p_queue.routing or \"\",\n            mandatory=mandatory,\n            immediate=immediate,\n            timeout=timeout,\n            persist=persist,\n            reply_to=RABBIT_REPLY if response_queue else reply_to,\n            **message_kwargs,\n        )\n\n        if response_queue is None:\n            return r\n\n        else:\n            scope: Callable[[Optional[float]], ContextManager[CancelScope]]\n            if raise_timeout:\n                scope = anyio.fail_after\n            else:\n                scope = anyio.move_on_after\n\n            msg: Optional[aio_pika.IncomingMessage] = None\n            with scope(rpc_timeout):\n                msg = await response_queue.receive()\n\n            if msg:\n                return await self._decoder(await self._parser(msg))\n\n    return None\n</code></pre>"},{"location":"api/faststream/rabbit/publisher/LogicPublisher/","title":"LogicPublisher","text":""},{"location":"api/faststream/rabbit/publisher/LogicPublisher/#faststream.rabbit.publisher.LogicPublisher","title":"faststream.rabbit.publisher.LogicPublisher  <code>dataclass</code>","text":"<p>             Bases: <code>ABCPublisher[IncomingMessage]</code></p> <p>A class to publish messages for logic processing.</p> <p>Attributes:</p> Name Type Description <code>_producer</code> <p>An optional AioPikaFastProducer object.</p> <p>Methods:</p> Name Description <code>publish </code> <p>Publishes a message for logic processing.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/publisher.py</code> <pre><code>@dataclass\nclass LogicPublisher(ABCPublisher[IncomingMessage]):\n\"\"\"A class to publish messages for logic processing.\n\n    Attributes:\n        _producer : An optional AioPikaFastProducer object.\n\n    Methods:\n        publish : Publishes a message for logic processing.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    _producer: Optional[AioPikaFastProducer] = field(default=None, init=False)\n\n    @override\n    async def publish(  # type: ignore[override]\n        self,\n        message: AioPikaSendableMessage = \"\",\n        *,\n        rpc: bool = False,\n        rpc_timeout: Optional[float] = 30.0,\n        raise_timeout: bool = False,\n        correlation_id: Optional[str] = None,\n        **message_kwargs: Any,\n    ) -&gt; Union[aiormq.abc.ConfirmationFrameType, SendableMessage]:\n\"\"\"Publish a message.\n\n        Args:\n            message: The message to be published.\n            rpc: Whether the message is for RPC (Remote Procedure Call).\n            rpc_timeout: Timeout for RPC.\n            raise_timeout: Whether to raise an exception if timeout occurs.\n            correlation_id: Correlation ID for the message.\n            **message_kwargs: Additional keyword arguments for the message.\n\n        Returns:\n            ConfirmationFrameType or SendableMessage: The result of the publish operation.\n\n        Raises:\n            AssertionError: If `_producer` is not set up.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        assert self._producer, \"Please, setup `_producer` first\"  # nosec B101\n        return await self._producer.publish(\n            message=message,\n            queue=self.queue,\n            exchange=self.exchange,\n            routing_key=self.routing_key,\n            mandatory=self.mandatory,\n            immediate=self.immediate,\n            timeout=self.timeout,\n            rpc=rpc,\n            rpc_timeout=rpc_timeout,\n            raise_timeout=raise_timeout,\n            persist=self.persist,\n            reply_to=self.reply_to,\n            correlation_id=correlation_id,\n            **self.message_kwargs,\n            **message_kwargs,\n        )\n</code></pre>"},{"location":"api/faststream/rabbit/publisher/LogicPublisher/#faststream.rabbit.publisher.LogicPublisher-functions","title":"Functions","text":""},{"location":"api/faststream/rabbit/publisher/LogicPublisher/#faststream.rabbit.publisher.LogicPublisher.name","title":"name","text":"<pre><code>name() -&gt; str\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/publisher.py</code> <pre><code>    _producer : An optional AioPikaFastProducer object.\n\nMethods:\n</code></pre>"},{"location":"api/faststream/rabbit/publisher/LogicPublisher/#faststream.rabbit.publisher.LogicPublisher.publish","title":"publish  <code>async</code>","text":"<pre><code>publish(\n    message: AioPikaSendableMessage = \"\",\n    *,\n    rpc: bool = False,\n    rpc_timeout: Optional[float] = 30.0,\n    raise_timeout: bool = False,\n    correlation_id: Optional[str] = None,\n    **message_kwargs: Any\n) -&gt; Union[\n    aiormq.abc.ConfirmationFrameType, SendableMessage\n]\n</code></pre> <p>Publish a message.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>AioPikaSendableMessage</code> <p>The message to be published.</p> <code>''</code> <code>rpc</code> <code>bool</code> <p>Whether the message is for RPC (Remote Procedure Call).</p> <code>False</code> <code>rpc_timeout</code> <code>Optional[float]</code> <p>Timeout for RPC.</p> <code>30.0</code> <code>raise_timeout</code> <code>bool</code> <p>Whether to raise an exception if timeout occurs.</p> <code>False</code> <code>correlation_id</code> <code>Optional[str]</code> <p>Correlation ID for the message.</p> <code>None</code> <code>**message_kwargs</code> <code>Any</code> <p>Additional keyword arguments for the message.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Union[ConfirmationFrameType, SendableMessage]</code> <p>ConfirmationFrameType or SendableMessage: The result of the publish operation.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If <code>_producer</code> is not set up.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/publisher.py</code> <pre><code>@override\nasync def publish(  # type: ignore[override]\n    self,\n    message: AioPikaSendableMessage = \"\",\n    *,\n    rpc: bool = False,\n    rpc_timeout: Optional[float] = 30.0,\n    raise_timeout: bool = False,\n    correlation_id: Optional[str] = None,\n    **message_kwargs: Any,\n) -&gt; Union[aiormq.abc.ConfirmationFrameType, SendableMessage]:\n\"\"\"Publish a message.\n\n    Args:\n        message: The message to be published.\n        rpc: Whether the message is for RPC (Remote Procedure Call).\n        rpc_timeout: Timeout for RPC.\n        raise_timeout: Whether to raise an exception if timeout occurs.\n        correlation_id: Correlation ID for the message.\n        **message_kwargs: Additional keyword arguments for the message.\n\n    Returns:\n        ConfirmationFrameType or SendableMessage: The result of the publish operation.\n\n    Raises:\n        AssertionError: If `_producer` is not set up.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    assert self._producer, \"Please, setup `_producer` first\"  # nosec B101\n    return await self._producer.publish(\n        message=message,\n        queue=self.queue,\n        exchange=self.exchange,\n        routing_key=self.routing_key,\n        mandatory=self.mandatory,\n        immediate=self.immediate,\n        timeout=self.timeout,\n        rpc=rpc,\n        rpc_timeout=rpc_timeout,\n        raise_timeout=raise_timeout,\n        persist=self.persist,\n        reply_to=self.reply_to,\n        correlation_id=correlation_id,\n        **self.message_kwargs,\n        **message_kwargs,\n    )\n</code></pre>"},{"location":"api/faststream/rabbit/router/RabbitRouter/","title":"RabbitRouter","text":""},{"location":"api/faststream/rabbit/router/RabbitRouter/#faststream.rabbit.router.RabbitRouter","title":"faststream.rabbit.router.RabbitRouter","text":"<p>             Bases: <code>RabbitRouter</code></p> <p>A class representing a RabbitMQ router for publishing messages.</p> <p>Attributes:</p> Name Type Description <code>_publishers</code> <p>A dictionary mapping integer keys to Publisher objects</p> <p>Methods:</p> Name Description <code>_get_publisher_key </code> <p>Returns the key for a given Publisher object</p> <code>_update_publisher_prefix </code> <p>Updates the prefix of a given Publisher object</p> <code>publisher </code> <p>Publishes a message to RabbitMQ</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/router.py</code> <pre><code>class RabbitRouter(BaseRouter):\n\"\"\"A class representing a RabbitMQ router for publishing messages.\n\n    Attributes:\n        _publishers : A dictionary mapping integer keys to Publisher objects\n\n    Methods:\n        _get_publisher_key : Returns the key for a given Publisher object\n        _update_publisher_prefix : Updates the prefix of a given Publisher object\n        publisher : Publishes a message to RabbitMQ\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    _publishers: Dict[int, Publisher]\n\n    @staticmethod\n    def _get_publisher_key(publisher: Publisher) -&gt; int:\n\"\"\"Get the publisher key.\n\n        Args:\n            publisher: The publisher object.\n\n        Returns:\n            The publisher key as an integer.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        return get_routing_hash(publisher.queue, publisher.exchange)\n\n    @staticmethod\n    def _update_publisher_prefix(prefix: str, publisher: Publisher) -&gt; Publisher:\n\"\"\"Updates the publisher prefix.\n\n        Args:\n            prefix (str): The prefix to be added to the publisher's queue name.\n            publisher (Publisher): The publisher object to be updated.\n\n        Returns:\n            Publisher: The updated publisher object.\n\n        Note:\n            This function is intended to be used as a decorator.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        publisher.queue = model_copy(\n            publisher.queue, update={\"name\": prefix + publisher.queue.name}\n        )\n        return publisher\n\n    @override\n    def publisher(  # type: ignore[override]\n        self,\n        queue: Union[RabbitQueue, str] = \"\",\n        exchange: Union[RabbitExchange, str, None] = None,\n        *,\n        routing_key: str = \"\",\n        mandatory: bool = True,\n        immediate: bool = False,\n        timeout: TimeoutType = None,\n        persist: bool = False,\n        reply_to: Optional[str] = None,\n        # AsyncAPI information\n        title: Optional[str] = None,\n        description: Optional[str] = None,\n        **message_kwargs: Any,\n    ) -&gt; Publisher:\n\"\"\"Publishes a message to a RabbitMQ queue or exchange.\n\n        Args:\n            queue: The RabbitMQ queue to publish the message to. Can be either a RabbitQueue object or a string representing the queue name.\n            exchange: The RabbitMQ exchange to publish the message to. Can be either a RabbitExchange object, a string representing the exchange name, or None.\n            routing_key: The routing key to use when publishing the message.\n            mandatory: Whether the message is mandatory or not.\n            immediate: Whether the message should be delivered immediately or not.\n            timeout: The timeout for the publish operation.\n            persist: Whether the message should be persisted or not.\n            reply_to: The reply-to address for the message.\n            title: The title of the message (AsyncAPI information).\n            description: The description of the message (AsyncAPI information).\n            **message_kwargs: Additional keyword arguments to include in the message.\n\n        Returns:\n            The Publisher object used to publish the message.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        new_publisher = self._update_publisher_prefix(\n            self.prefix,\n            Publisher(\n                queue=RabbitQueue.validate(queue),\n                exchange=RabbitExchange.validate(exchange),\n                routing_key=routing_key,\n                mandatory=mandatory,\n                immediate=immediate,\n                timeout=timeout,\n                persist=persist,\n                reply_to=reply_to,\n                message_kwargs=message_kwargs,\n                title=title,\n                _description=description,\n            ),\n        )\n        key = self._get_publisher_key(new_publisher)\n        publisher = self._publishers[key] = self._publishers.get(key, new_publisher)\n        return publisher\n</code></pre>"},{"location":"api/faststream/rabbit/router/RabbitRouter/#faststream.rabbit.router.RabbitRouter-functions","title":"Functions","text":""},{"location":"api/faststream/rabbit/router/RabbitRouter/#faststream.rabbit.router.RabbitRouter.__init__","title":"__init__","text":"<pre><code>__init__(\n    prefix: str = \"\",\n    handlers: Sequence[RabbitRoute] = (),\n    *,\n    dependencies: Sequence[Depends] = (),\n    middlewares: Optional[\n        Sequence[\n            Callable[\n                [aio_pika.IncomingMessage], BaseMiddleware\n            ]\n        ]\n    ] = None,\n    parser: Optional[\n        CustomParser[aio_pika.IncomingMessage]\n    ] = None,\n    decoder: Optional[\n        CustomDecoder[aio_pika.IncomingMessage]\n    ] = None\n)\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/router.py</code> <pre><code>    The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n\"\"\"\n\n_publishers: Dict[int, Publisher]\n\n@staticmethod\ndef _get_publisher_key(publisher: Publisher) -&gt; int:\n    \"\"\"Get the publisher key.\n\n    Args:\n        publisher: The publisher object.\n</code></pre>"},{"location":"api/faststream/rabbit/router/RabbitRouter/#faststream.rabbit.router.RabbitRouter.publisher","title":"publisher","text":"<pre><code>publisher(\n    queue: Union[RabbitQueue, str] = \"\",\n    exchange: Union[RabbitExchange, str, None] = None,\n    *,\n    routing_key: str = \"\",\n    mandatory: bool = True,\n    immediate: bool = False,\n    timeout: TimeoutType = None,\n    persist: bool = False,\n    reply_to: Optional[str] = None,\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n    **message_kwargs: Any\n) -&gt; Publisher\n</code></pre> <p>Publishes a message to a RabbitMQ queue or exchange.</p> <p>Parameters:</p> Name Type Description Default <code>queue</code> <code>Union[RabbitQueue, str]</code> <p>The RabbitMQ queue to publish the message to. Can be either a RabbitQueue object or a string representing the queue name.</p> <code>''</code> <code>exchange</code> <code>Union[RabbitExchange, str, None]</code> <p>The RabbitMQ exchange to publish the message to. Can be either a RabbitExchange object, a string representing the exchange name, or None.</p> <code>None</code> <code>routing_key</code> <code>str</code> <p>The routing key to use when publishing the message.</p> <code>''</code> <code>mandatory</code> <code>bool</code> <p>Whether the message is mandatory or not.</p> <code>True</code> <code>immediate</code> <code>bool</code> <p>Whether the message should be delivered immediately or not.</p> <code>False</code> <code>timeout</code> <code>TimeoutType</code> <p>The timeout for the publish operation.</p> <code>None</code> <code>persist</code> <code>bool</code> <p>Whether the message should be persisted or not.</p> <code>False</code> <code>reply_to</code> <code>Optional[str]</code> <p>The reply-to address for the message.</p> <code>None</code> <code>title</code> <code>Optional[str]</code> <p>The title of the message (AsyncAPI information).</p> <code>None</code> <code>description</code> <code>Optional[str]</code> <p>The description of the message (AsyncAPI information).</p> <code>None</code> <code>**message_kwargs</code> <code>Any</code> <p>Additional keyword arguments to include in the message.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Publisher</code> <p>The Publisher object used to publish the message.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/router.py</code> <pre><code>@override\ndef publisher(  # type: ignore[override]\n    self,\n    queue: Union[RabbitQueue, str] = \"\",\n    exchange: Union[RabbitExchange, str, None] = None,\n    *,\n    routing_key: str = \"\",\n    mandatory: bool = True,\n    immediate: bool = False,\n    timeout: TimeoutType = None,\n    persist: bool = False,\n    reply_to: Optional[str] = None,\n    # AsyncAPI information\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n    **message_kwargs: Any,\n) -&gt; Publisher:\n\"\"\"Publishes a message to a RabbitMQ queue or exchange.\n\n    Args:\n        queue: The RabbitMQ queue to publish the message to. Can be either a RabbitQueue object or a string representing the queue name.\n        exchange: The RabbitMQ exchange to publish the message to. Can be either a RabbitExchange object, a string representing the exchange name, or None.\n        routing_key: The routing key to use when publishing the message.\n        mandatory: Whether the message is mandatory or not.\n        immediate: Whether the message should be delivered immediately or not.\n        timeout: The timeout for the publish operation.\n        persist: Whether the message should be persisted or not.\n        reply_to: The reply-to address for the message.\n        title: The title of the message (AsyncAPI information).\n        description: The description of the message (AsyncAPI information).\n        **message_kwargs: Additional keyword arguments to include in the message.\n\n    Returns:\n        The Publisher object used to publish the message.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    new_publisher = self._update_publisher_prefix(\n        self.prefix,\n        Publisher(\n            queue=RabbitQueue.validate(queue),\n            exchange=RabbitExchange.validate(exchange),\n            routing_key=routing_key,\n            mandatory=mandatory,\n            immediate=immediate,\n            timeout=timeout,\n            persist=persist,\n            reply_to=reply_to,\n            message_kwargs=message_kwargs,\n            title=title,\n            _description=description,\n        ),\n    )\n    key = self._get_publisher_key(new_publisher)\n    publisher = self._publishers[key] = self._publishers.get(key, new_publisher)\n    return publisher\n</code></pre>"},{"location":"api/faststream/rabbit/router/RabbitRouter/#faststream.rabbit.router.RabbitRouter.subscriber","title":"subscriber","text":"<pre><code>subscriber(\n    queue: Union[str, RabbitQueue],\n    exchange: Union[str, RabbitExchange, None] = None,\n    *,\n    consume_args: Optional[AnyDict] = None,\n    dependencies: Sequence[Depends] = (),\n    filter: Filter[RabbitMessage] = default_filter,\n    parser: Optional[\n        CustomParser[aio_pika.IncomingMessage]\n    ] = None,\n    decoder: Optional[\n        CustomDecoder[aio_pika.IncomingMessage]\n    ] = None,\n    middlewares: Optional[\n        Sequence[\n            Callable[\n                [aio_pika.IncomingMessage], BaseMiddleware\n            ]\n        ]\n    ] = None,\n    retry: Union[bool, int] = False,\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n    **__service_kwargs: Any\n) -&gt; Callable[\n    [Callable[P_HandlerParams, T_HandlerReturn]],\n    HandlerCallWrapper[\n        aio_pika.IncomingMessage,\n        P_HandlerParams,\n        T_HandlerReturn,\n    ],\n]\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/router.py</code> <pre><code>def _update_publisher_prefix(prefix: str, publisher: Publisher) -&gt; Publisher:\n\"\"\"Updates the publisher prefix.\n\n    Args:\n        prefix (str): The prefix to be added to the publisher's queue name.\n        publisher (Publisher): The publisher object to be updated.\n\n    Returns:\n        Publisher: The updated publisher object.\n\n    Note:\n        This function is intended to be used as a decorator.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    publisher.queue = model_copy(\n        publisher.queue, update={\"name\": prefix + publisher.queue.name}\n    )\n    return publisher\n\n@override\ndef publisher(  # type: ignore[override]\n    self,\n    queue: Union[RabbitQueue, str] = \"\",\n    exchange: Union[RabbitExchange, str, None] = None,\n    *,\n    routing_key: str = \"\",\n    mandatory: bool = True,\n</code></pre>"},{"location":"api/faststream/rabbit/security/parse_security/","title":"parse_security","text":""},{"location":"api/faststream/rabbit/security/parse_security/#faststream.rabbit.security.parse_security","title":"faststream.rabbit.security.parse_security","text":"<pre><code>parse_security(\n    security: Optional[BaseSecurity],\n) -&gt; Dict[str, Any]\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/security.py</code> <pre><code>def parse_security(security: Optional[BaseSecurity]) -&gt; Dict[str, Any]:\n    if security is None:\n        return {}\n    else:\n        raise NotImplementedError(f\"RabbitBroker does not support {type(security)}\")\n</code></pre>"},{"location":"api/faststream/rabbit/shared/constants/ExchangeType/","title":"ExchangeType","text":""},{"location":"api/faststream/rabbit/shared/constants/ExchangeType/#faststream.rabbit.shared.constants.ExchangeType","title":"faststream.rabbit.shared.constants.ExchangeType","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p> <p>A class to represent the exchange type.</p> <p>Attributes:</p> Name Type Description <code>FANOUT</code> <p>fanout exchange type</p> <code>DIRECT</code> <p>direct exchange type</p> <code>TOPIC</code> <p>topic exchange type</p> <code>HEADERS</code> <p>headers exchange type</p> <code>X_DELAYED_MESSAGE</code> <p>x-delayed-message exchange type</p> <code>X_CONSISTENT_HASH</code> <p>x-consistent-hash exchange type</p> <code>X_MODULUS_HASH</code> <p>x-modulus-hash exchange type</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/shared/constants.py</code> <pre><code>@unique\nclass ExchangeType(str, Enum):\n\"\"\"A class to represent the exchange type.\n\n    Attributes:\n        FANOUT : fanout exchange type\n        DIRECT : direct exchange type\n        TOPIC : topic exchange type\n        HEADERS : headers exchange type\n        X_DELAYED_MESSAGE : x-delayed-message exchange type\n        X_CONSISTENT_HASH : x-consistent-hash exchange type\n        X_MODULUS_HASH : x-modulus-hash exchange type\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    FANOUT = \"fanout\"\n    DIRECT = \"direct\"\n    TOPIC = \"topic\"\n    HEADERS = \"headers\"\n    X_DELAYED_MESSAGE = \"x-delayed-message\"\n    X_CONSISTENT_HASH = \"x-consistent-hash\"\n    X_MODULUS_HASH = \"x-modulus-hash\"\n</code></pre>"},{"location":"api/faststream/rabbit/shared/constants/ExchangeType/#faststream.rabbit.shared.constants.ExchangeType-attributes","title":"Attributes","text":""},{"location":"api/faststream/rabbit/shared/constants/ExchangeType/#faststream.rabbit.shared.constants.ExchangeType.DIRECT","title":"DIRECT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DIRECT = 'direct'\n</code></pre>"},{"location":"api/faststream/rabbit/shared/constants/ExchangeType/#faststream.rabbit.shared.constants.ExchangeType.FANOUT","title":"FANOUT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FANOUT = 'fanout'\n</code></pre>"},{"location":"api/faststream/rabbit/shared/constants/ExchangeType/#faststream.rabbit.shared.constants.ExchangeType.HEADERS","title":"HEADERS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>HEADERS = 'headers'\n</code></pre>"},{"location":"api/faststream/rabbit/shared/constants/ExchangeType/#faststream.rabbit.shared.constants.ExchangeType.TOPIC","title":"TOPIC  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TOPIC = 'topic'\n</code></pre>"},{"location":"api/faststream/rabbit/shared/constants/ExchangeType/#faststream.rabbit.shared.constants.ExchangeType.X_CONSISTENT_HASH","title":"X_CONSISTENT_HASH  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>X_CONSISTENT_HASH = 'x-consistent-hash'\n</code></pre>"},{"location":"api/faststream/rabbit/shared/constants/ExchangeType/#faststream.rabbit.shared.constants.ExchangeType.X_DELAYED_MESSAGE","title":"X_DELAYED_MESSAGE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>X_DELAYED_MESSAGE = 'x-delayed-message'\n</code></pre>"},{"location":"api/faststream/rabbit/shared/constants/ExchangeType/#faststream.rabbit.shared.constants.ExchangeType.X_MODULUS_HASH","title":"X_MODULUS_HASH  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>X_MODULUS_HASH = 'x-modulus-hash'\n</code></pre>"},{"location":"api/faststream/rabbit/shared/logging/RabbitLoggingMixin/","title":"RabbitLoggingMixin","text":""},{"location":"api/faststream/rabbit/shared/logging/RabbitLoggingMixin/#faststream.rabbit.shared.logging.RabbitLoggingMixin","title":"faststream.rabbit.shared.logging.RabbitLoggingMixin","text":"<p>             Bases: <code>LoggingMixin</code></p> <p>A class that extends the LoggingMixin class and adds additional functionality for logging RabbitMQ related information.</p> <p>Attributes:</p> Name Type Description <code>_max_queue_len</code> <p>maximum length of the queue name</p> <code>_max_exchange_len</code> <p>maximum length of the exchange name</p> <p>Methods:</p> Name Description <code>__init__ </code> <p>Initializes the RabbitLoggingMixin object.</p> <code>_get_log_context </code> <p>Overrides the _get_log_context method of the LoggingMixin class to include RabbitMQ related context information.</p> <code>fmt </code> <p>Returns the log format string.</p> <code>_setup_log_context </code> <p>Sets up the log context by updating the maximum lengths of the queue and exchange names.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/shared/logging.py</code> <pre><code>class RabbitLoggingMixin(LoggingMixin):\n\"\"\"A class that extends the LoggingMixin class and adds additional functionality for logging RabbitMQ related information.\n\n    Attributes:\n        _max_queue_len : maximum length of the queue name\n        _max_exchange_len : maximum length of the exchange name\n\n    Methods:\n        __init__ : Initializes the RabbitLoggingMixin object.\n        _get_log_context : Overrides the _get_log_context method of the LoggingMixin class to include RabbitMQ related context information.\n        fmt : Returns the log format string.\n        _setup_log_context : Sets up the log context by updating the maximum lengths of the queue and exchange names.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    _max_queue_len: int\n    _max_exchange_len: int\n\n    def __init__(\n        self,\n        *args: Any,\n        logger: Optional[logging.Logger] = access_logger,\n        log_level: int = logging.INFO,\n        log_fmt: Optional[str] = None,\n        **kwargs: Any,\n    ) -&gt; None:\n\"\"\"Initialize the class.\n\n        Args:\n            *args: Variable length argument list\n            logger: Optional logger object\n            log_level: Logging level\n            log_fmt: Optional log format\n            **kwargs: Arbitrary keyword arguments\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        super().__init__(\n            *args,\n            logger=logger,\n            log_level=log_level,\n            log_fmt=log_fmt,\n            **kwargs,\n        )\n        self._max_queue_len = 4\n        self._max_exchange_len = 4\n\n    @override\n    def _get_log_context(  # type: ignore[override]\n        self,\n        message: Optional[StreamMessage[Any]],\n        queue: RabbitQueue,\n        exchange: Optional[RabbitExchange] = None,\n    ) -&gt; AnyDict:\n\"\"\"Get the log context.\n\n        Args:\n            message: Optional stream message.\n            queue: RabbitQueue object.\n            exchange: Optional RabbitExchange object.\n\n        Returns:\n            Dictionary containing the log context.\n\n        Note:\n            This is a private method and should not be called directly.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        context = {\n            \"queue\": queue.name,\n            \"exchange\": exchange.name if exchange else \"default\",\n            **super()._get_log_context(message),\n        }\n        return context\n\n    @property\n    def fmt(self) -&gt; str:\n        return super().fmt or (\n            \"%(asctime)s %(levelname)s - \"\n            f\"%(exchange)-{self._max_exchange_len}s | \"\n            f\"%(queue)-{self._max_queue_len}s | \"\n            f\"%(message_id)-10s \"\n            \"- %(message)s\"\n        )\n\n    def _setup_log_context(\n        self,\n        queue: Optional[RabbitQueue] = None,\n        exchange: Optional[RabbitExchange] = None,\n    ) -&gt; None:\n\"\"\"Set up log context.\n\n        Args:\n            queue: Optional RabbitQueue object representing the queue.\n            exchange: Optional RabbitExchange object representing the exchange.\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        if exchange is not None:\n            self._max_exchange_len = max(\n                self._max_exchange_len, len(exchange.name or \"\")\n            )\n\n        if queue is not None:  # pragma: no branch\n            self._max_queue_len = max(self._max_queue_len, len(queue.name))\n</code></pre>"},{"location":"api/faststream/rabbit/shared/logging/RabbitLoggingMixin/#faststream.rabbit.shared.logging.RabbitLoggingMixin-attributes","title":"Attributes","text":""},{"location":"api/faststream/rabbit/shared/logging/RabbitLoggingMixin/#faststream.rabbit.shared.logging.RabbitLoggingMixin.fmt","title":"fmt  <code>property</code>","text":"<pre><code>fmt: str\n</code></pre>"},{"location":"api/faststream/rabbit/shared/logging/RabbitLoggingMixin/#faststream.rabbit.shared.logging.RabbitLoggingMixin-functions","title":"Functions","text":""},{"location":"api/faststream/rabbit/shared/logging/RabbitLoggingMixin/#faststream.rabbit.shared.logging.RabbitLoggingMixin.__init__","title":"__init__","text":"<pre><code>__init__(\n    *args: Any,\n    logger: Optional[logging.Logger] = access_logger,\n    log_level: int = logging.INFO,\n    log_fmt: Optional[str] = None,\n    **kwargs: Any\n) -&gt; None\n</code></pre> <p>Initialize the class.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Any</code> <p>Variable length argument list</p> <code>()</code> <code>logger</code> <code>Optional[Logger]</code> <p>Optional logger object</p> <code>access_logger</code> <code>log_level</code> <code>int</code> <p>Logging level</p> <code>INFO</code> <code>log_fmt</code> <code>Optional[str]</code> <p>Optional log format</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Arbitrary keyword arguments</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/shared/logging.py</code> <pre><code>def __init__(\n    self,\n    *args: Any,\n    logger: Optional[logging.Logger] = access_logger,\n    log_level: int = logging.INFO,\n    log_fmt: Optional[str] = None,\n    **kwargs: Any,\n) -&gt; None:\n\"\"\"Initialize the class.\n\n    Args:\n        *args: Variable length argument list\n        logger: Optional logger object\n        log_level: Logging level\n        log_fmt: Optional log format\n        **kwargs: Arbitrary keyword arguments\n\n    Returns:\n        None\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    super().__init__(\n        *args,\n        logger=logger,\n        log_level=log_level,\n        log_fmt=log_fmt,\n        **kwargs,\n    )\n    self._max_queue_len = 4\n    self._max_exchange_len = 4\n</code></pre>"},{"location":"api/faststream/rabbit/shared/publisher/ABCPublisher/","title":"ABCPublisher","text":""},{"location":"api/faststream/rabbit/shared/publisher/ABCPublisher/#faststream.rabbit.shared.publisher.ABCPublisher","title":"faststream.rabbit.shared.publisher.ABCPublisher  <code>dataclass</code>","text":"<p>             Bases: <code>ABC</code>, <code>BasePublisher[MsgType]</code>, <code>BaseRMQInformation</code></p> <p>A class representing an ABCPublisher.</p> <p>Attributes:</p> Name Type Description <code>routing_key</code> <p>str, optional The routing key for the publisher.</p> <code>mandatory</code> <p>bool, optional Whether the message is mandatory or not.</p> <code>immediate</code> <p>bool, optional Whether the message should be immediately delivered or not.</p> <code>persist</code> <p>bool, optional Whether the message should be persisted or not.</p> <code>timeout</code> <p>TimeoutType, optional The timeout for the message.</p> <code>reply_to</code> <p>str, optional The reply-to address for the message.</p> <code>message_kwargs</code> <p>dict, optional Additional keyword arguments for the message.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/shared/publisher.py</code> <pre><code>@dataclass\nclass ABCPublisher(ABC, BasePublisher[MsgType], BaseRMQInformation):\n\"\"\"A class representing an ABCPublisher.\n\n    Attributes:\n        routing_key : str, optional\n            The routing key for the publisher.\n        mandatory : bool, optional\n            Whether the message is mandatory or not.\n        immediate : bool, optional\n            Whether the message should be immediately delivered or not.\n        persist : bool, optional\n            Whether the message should be persisted or not.\n        timeout : TimeoutType, optional\n            The timeout for the message.\n        reply_to : str, optional\n            The reply-to address for the message.\n        message_kwargs : dict, optional\n            Additional keyword arguments for the message.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    routing_key: str = \"\"\n    mandatory: bool = True\n    immediate: bool = False\n    persist: bool = False\n    timeout: TimeoutType = None\n    reply_to: Optional[str] = None\n    message_kwargs: AnyDict = field(default_factory=dict)\n</code></pre>"},{"location":"api/faststream/rabbit/shared/publisher/ABCPublisher/#faststream.rabbit.shared.publisher.ABCPublisher-attributes","title":"Attributes","text":""},{"location":"api/faststream/rabbit/shared/publisher/ABCPublisher/#faststream.rabbit.shared.publisher.ABCPublisher.immediate","title":"immediate  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>immediate: bool = False\n</code></pre>"},{"location":"api/faststream/rabbit/shared/publisher/ABCPublisher/#faststream.rabbit.shared.publisher.ABCPublisher.mandatory","title":"mandatory  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mandatory: bool = True\n</code></pre>"},{"location":"api/faststream/rabbit/shared/publisher/ABCPublisher/#faststream.rabbit.shared.publisher.ABCPublisher.message_kwargs","title":"message_kwargs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>message_kwargs: AnyDict = field(default_factory=dict)\n</code></pre>"},{"location":"api/faststream/rabbit/shared/publisher/ABCPublisher/#faststream.rabbit.shared.publisher.ABCPublisher.persist","title":"persist  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>persist: bool = False\n</code></pre>"},{"location":"api/faststream/rabbit/shared/publisher/ABCPublisher/#faststream.rabbit.shared.publisher.ABCPublisher.reply_to","title":"reply_to  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>reply_to: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/rabbit/shared/publisher/ABCPublisher/#faststream.rabbit.shared.publisher.ABCPublisher.routing_key","title":"routing_key  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>routing_key: str = ''\n</code></pre>"},{"location":"api/faststream/rabbit/shared/publisher/ABCPublisher/#faststream.rabbit.shared.publisher.ABCPublisher.timeout","title":"timeout  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>timeout: TimeoutType = None\n</code></pre>"},{"location":"api/faststream/rabbit/shared/router/RabbitRouter/","title":"RabbitRouter","text":""},{"location":"api/faststream/rabbit/shared/router/RabbitRouter/#faststream.rabbit.shared.router.RabbitRouter","title":"faststream.rabbit.shared.router.RabbitRouter","text":"<p>             Bases: <code>BrokerRouter[int, IncomingMessage]</code></p> <p>A class representing a RabbitMQ router for handling incoming messages.</p> <p>Attributes:</p> Name Type Description <code>prefix</code> <p>prefix for the queue name</p> <code>handlers</code> <p>sequence of RabbitRoutes for handling incoming messages</p> <code>kwargs</code> <p>additional keyword arguments</p> <p>Methods:</p> Name Description <code>__init__ </code> <p>initializes the RabbitRouter object</p> <code>subscriber </code> <p>decorator for subscribing to a queue and registering a handler function</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/shared/router.py</code> <pre><code>class RabbitRouter(BrokerRouter[int, IncomingMessage]):\n\"\"\"A class representing a RabbitMQ router for handling incoming messages.\n\n    Attributes:\n        prefix : prefix for the queue name\n        handlers : sequence of RabbitRoutes for handling incoming messages\n        kwargs : additional keyword arguments\n\n    Methods:\n        __init__ : initializes the RabbitRouter object\n        subscriber : decorator for subscribing to a queue and registering a handler function\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    def __init__(\n        self,\n        prefix: str = \"\",\n        handlers: Sequence[RabbitRoute[IncomingMessage, SendableMessage]] = (),\n        **kwargs: Any,\n    ):\n\"\"\"Override the `__init__` method of the parent class.\n\n        Args:\n            prefix: A prefix string\n            handlers: A sequence of RabbitRoute objects\n            **kwargs: Additional keyword arguments\n\n        Raises:\n            NotImplementedError: If silent animals are not supported\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        for h in handlers:\n            q = RabbitQueue.validate(h.kwargs.pop(\"queue\", h.args[0]))\n            new_q = model_copy(q, update={\"name\": prefix + q.name})\n            h.args = (new_q, *h.args[1:])\n\n        super().__init__(prefix, handlers, **kwargs)\n\n    @override\n    def subscriber(  # type: ignore[override]\n        self,\n        queue: Union[str, RabbitQueue],\n        *broker_args: Any,\n        **broker_kwargs: Any,\n    ) -&gt; Callable[\n        [Callable[P_HandlerParams, T_HandlerReturn]],\n        HandlerCallWrapper[IncomingMessage, P_HandlerParams, T_HandlerReturn],\n    ]:\n\"\"\"A function to subscribe to a RabbitMQ queue.\n\n        Args:\n            self : the instance of the class\n            queue : the queue to subscribe to, can be a string or a RabbitQueue object\n            *broker_args : additional arguments for the broker\n            **broker_kwargs : additional keyword arguments for the broker\n\n        Returns:\n            A callable object that wraps the handler function for the incoming messages from the queue.\n\n        Raises:\n            TypeError: If the queue is not a string or a RabbitQueue object\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        q = RabbitQueue.validate(queue)\n        new_q = model_copy(q, update={\"name\": self.prefix + q.name})\n        return self._wrap_subscriber(new_q, *broker_args, **broker_kwargs)\n</code></pre>"},{"location":"api/faststream/rabbit/shared/router/RabbitRouter/#faststream.rabbit.shared.router.RabbitRouter-functions","title":"Functions","text":""},{"location":"api/faststream/rabbit/shared/router/RabbitRouter/#faststream.rabbit.shared.router.RabbitRouter.__init__","title":"__init__","text":"<pre><code>__init__(\n    prefix: str = \"\",\n    handlers: Sequence[\n        RabbitRoute[IncomingMessage, SendableMessage]\n    ] = (),\n    **kwargs: Any\n)\n</code></pre> <p>Override the <code>__init__</code> method of the parent class.</p> <p>Parameters:</p> Name Type Description Default <code>prefix</code> <code>str</code> <p>A prefix string</p> <code>''</code> <code>handlers</code> <code>Sequence[BrokerRoute[IncomingMessage, SendableMessage]]</code> <p>A sequence of RabbitRoute objects</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments</p> <code>{}</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If silent animals are not supported</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/shared/router.py</code> <pre><code>def __init__(\n    self,\n    prefix: str = \"\",\n    handlers: Sequence[RabbitRoute[IncomingMessage, SendableMessage]] = (),\n    **kwargs: Any,\n):\n\"\"\"Override the `__init__` method of the parent class.\n\n    Args:\n        prefix: A prefix string\n        handlers: A sequence of RabbitRoute objects\n        **kwargs: Additional keyword arguments\n\n    Raises:\n        NotImplementedError: If silent animals are not supported\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    for h in handlers:\n        q = RabbitQueue.validate(h.kwargs.pop(\"queue\", h.args[0]))\n        new_q = model_copy(q, update={\"name\": prefix + q.name})\n        h.args = (new_q, *h.args[1:])\n\n    super().__init__(prefix, handlers, **kwargs)\n</code></pre>"},{"location":"api/faststream/rabbit/shared/router/RabbitRouter/#faststream.rabbit.shared.router.RabbitRouter.subscriber","title":"subscriber","text":"<pre><code>subscriber(\n    queue: Union[str, RabbitQueue],\n    *broker_args: Any,\n    **broker_kwargs: Any\n) -&gt; Callable[\n    [Callable[P_HandlerParams, T_HandlerReturn]],\n    HandlerCallWrapper[\n        IncomingMessage, P_HandlerParams, T_HandlerReturn\n    ],\n]\n</code></pre> <p>A function to subscribe to a RabbitMQ queue.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <p>the instance of the class</p> required <code>queue</code> <p>the queue to subscribe to, can be a string or a RabbitQueue object</p> required <code>*broker_args</code> <p>additional arguments for the broker</p> <code>()</code> <code>**broker_kwargs</code> <p>additional keyword arguments for the broker</p> <code>{}</code> <p>Returns:</p> Type Description <code>Callable[[Callable[P_HandlerParams, T_HandlerReturn]], HandlerCallWrapper[IncomingMessage, P_HandlerParams, T_HandlerReturn]]</code> <p>A callable object that wraps the handler function for the incoming messages from the queue.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the queue is not a string or a RabbitQueue object</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/shared/router.py</code> <pre><code>@override\ndef subscriber(  # type: ignore[override]\n    self,\n    queue: Union[str, RabbitQueue],\n    *broker_args: Any,\n    **broker_kwargs: Any,\n) -&gt; Callable[\n    [Callable[P_HandlerParams, T_HandlerReturn]],\n    HandlerCallWrapper[IncomingMessage, P_HandlerParams, T_HandlerReturn],\n]:\n\"\"\"A function to subscribe to a RabbitMQ queue.\n\n    Args:\n        self : the instance of the class\n        queue : the queue to subscribe to, can be a string or a RabbitQueue object\n        *broker_args : additional arguments for the broker\n        **broker_kwargs : additional keyword arguments for the broker\n\n    Returns:\n        A callable object that wraps the handler function for the incoming messages from the queue.\n\n    Raises:\n        TypeError: If the queue is not a string or a RabbitQueue object\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    q = RabbitQueue.validate(queue)\n    new_q = model_copy(q, update={\"name\": self.prefix + q.name})\n    return self._wrap_subscriber(new_q, *broker_args, **broker_kwargs)\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/BaseRMQInformation/","title":"BaseRMQInformation","text":""},{"location":"api/faststream/rabbit/shared/schemas/BaseRMQInformation/#faststream.rabbit.shared.schemas.BaseRMQInformation","title":"faststream.rabbit.shared.schemas.BaseRMQInformation  <code>dataclass</code>","text":"<p>BaseRMQInformation.</p> <p>Attributes:</p> Name Type Description <code>queue</code> <p>RabbitQueue object representing the queue</p> <code>exchange</code> <p>Optional RabbitExchange object representing the exchange</p> <code>_description</code> <p>Optional string describing the class</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/shared/schemas.py</code> <pre><code>@dataclass\nclass BaseRMQInformation:\n\"\"\"BaseRMQInformation.\n\n    Attributes:\n        queue : RabbitQueue object representing the queue\n        exchange : Optional RabbitExchange object representing the exchange\n        _description : Optional string describing the class\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    queue: RabbitQueue = field(default=RabbitQueue(\"\"))\n    exchange: Optional[RabbitExchange] = field(default=None)\n    _description: Optional[str] = field(default=None)\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/BaseRMQInformation/#faststream.rabbit.shared.schemas.BaseRMQInformation-attributes","title":"Attributes","text":""},{"location":"api/faststream/rabbit/shared/schemas/BaseRMQInformation/#faststream.rabbit.shared.schemas.BaseRMQInformation.exchange","title":"exchange  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>exchange: Optional[RabbitExchange] = field(default=None)\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/BaseRMQInformation/#faststream.rabbit.shared.schemas.BaseRMQInformation.queue","title":"queue  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>queue: RabbitQueue = field(default=RabbitQueue(''))\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/RabbitExchange/","title":"RabbitExchange","text":""},{"location":"api/faststream/rabbit/shared/schemas/RabbitExchange/#faststream.rabbit.shared.schemas.RabbitExchange","title":"faststream.rabbit.shared.schemas.RabbitExchange","text":"<p>             Bases: <code>NameRequired</code></p> <p>A class to represent a RabbitMQ exchange.</p> <p>Attributes:</p> Name Type Description <code>name</code> <p>name of the exchange</p> <code>type</code> <p>type of the exchange</p> <code>durable</code> <p>whether the exchange is durable or not</p> <code>auto_delete</code> <p>whether the exchange is auto-deleted or not</p> <code>internal</code> <p>whether the exchange is internal or not</p> <code>passive</code> <p>whether the exchange is passive or not</p> <code>arguments</code> <p>additional arguments for the exchange</p> <code>timeout</code> <p>timeout for the exchange</p> <code>robust</code> <p>whether the exchange is robust or not</p> <code>bind_to</code> <p>exchange to bind to</p> <code>bind_arguments</code> <p>additional arguments for the binding</p> <code>routing_key</code> <p>routing key for the exchange</p> <p>Methods:</p> Name Description <code>__hash__ </code> <p>returns the hash value of the exchange</p> <code>__init__ </code> <p>initializes the RabbitExchange object</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/shared/schemas.py</code> <pre><code>class RabbitExchange(NameRequired):\n\"\"\"A class to represent a RabbitMQ exchange.\n\n    Attributes:\n        name : name of the exchange\n        type : type of the exchange\n        durable : whether the exchange is durable or not\n        auto_delete : whether the exchange is auto-deleted or not\n        internal : whether the exchange is internal or not\n        passive : whether the exchange is passive or not\n        arguments : additional arguments for the exchange\n        timeout : timeout for the exchange\n        robust : whether the exchange is robust or not\n        bind_to : exchange to bind to\n        bind_arguments : additional arguments for the binding\n        routing_key : routing key for the exchange\n\n    Methods:\n        __hash__ : returns the hash value of the exchange\n        __init__ : initializes the RabbitExchange object\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    type: str = ExchangeType.DIRECT.value\n    durable: bool = False\n    auto_delete: bool = False\n    internal: bool = False\n    passive: bool = False\n    arguments: Optional[AnyDict] = None\n    timeout: TimeoutType = None\n    robust: bool = True\n\n    bind_to: Optional[\"RabbitExchange\"] = None\n    bind_arguments: Optional[AnyDict] = None\n    routing_key: str = \"\"\n\n    def __hash__(self) -&gt; int:\n        return sum(\n            (\n                hash(self.name),\n                hash(self.type),\n                int(self.durable),\n                int(self.auto_delete),\n            )\n        )\n\n    def __init__(\n        self,\n        name: str,\n        type: ExchangeType = ExchangeType.DIRECT,\n        durable: bool = False,\n        auto_delete: bool = False,\n        internal: bool = False,\n        passive: bool = False,\n        arguments: Optional[AnyDict] = None,\n        timeout: TimeoutType = None,\n        robust: bool = True,\n        bind_to: Optional[\"RabbitExchange\"] = None,\n        bind_arguments: Optional[AnyDict] = None,\n        routing_key: str = \"\",\n    ):\n\"\"\"Initialize a RabbitExchange object.\n\n        Args:\n            name (str): Name of the exchange.\n            type (ExchangeType, optional): Type of the exchange. Defaults to ExchangeType.DIRECT.\n            durable (bool, optional): Whether the exchange should survive broker restarts. Defaults to False.\n            auto_delete (bool, optional): Whether the exchange should be deleted when no longer in use. Defaults to False.\n            internal (bool, optional): Whether the exchange is used for internal purposes and should not be published to directly. Defaults to False.\n            passive (bool, optional): Whether to check if the exchange exists before creating it. Defaults to False.\n            arguments (Optional[AnyDict], optional): Additional arguments for the exchange. Defaults to None.\n            timeout (TimeoutType, optional): Timeout for the operation. Defaults to None.\n            robust (bool, optional): Whether to use robust mode for the exchange. Defaults to True.\n            bind_to (Optional[\"RabbitExchange\"], optional): Exchange to bind to. Defaults to None.\n            bind_arguments (Optional[AnyDict], optional): Arguments for the binding. Defaults to None.\n            routing_key (str, optional): Routing key for the exchange. Defaults to \"\".\n\n        Raises:\n            NotImplementedError:\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        super().__init__(\n            name=name,\n            type=type.value,\n            durable=durable,\n            auto_delete=auto_delete,\n            routing_key=routing_key,\n            bind_to=bind_to,\n            bind_arguments=bind_arguments,\n            robust=robust,\n            internal=internal,\n            passive=passive,\n            timeout=timeout,\n            arguments=arguments,\n        )\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/RabbitExchange/#faststream.rabbit.shared.schemas.RabbitExchange-attributes","title":"Attributes","text":""},{"location":"api/faststream/rabbit/shared/schemas/RabbitExchange/#faststream.rabbit.shared.schemas.RabbitExchange.arguments","title":"arguments  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>arguments: Optional[AnyDict] = None\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/RabbitExchange/#faststream.rabbit.shared.schemas.RabbitExchange.auto_delete","title":"auto_delete  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>auto_delete: bool = False\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/RabbitExchange/#faststream.rabbit.shared.schemas.RabbitExchange.bind_arguments","title":"bind_arguments  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bind_arguments: Optional[AnyDict] = None\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/RabbitExchange/#faststream.rabbit.shared.schemas.RabbitExchange.bind_to","title":"bind_to  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bind_to: Optional[RabbitExchange] = None\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/RabbitExchange/#faststream.rabbit.shared.schemas.RabbitExchange.durable","title":"durable  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>durable: bool = False\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/RabbitExchange/#faststream.rabbit.shared.schemas.RabbitExchange.internal","title":"internal  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>internal: bool = False\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/RabbitExchange/#faststream.rabbit.shared.schemas.RabbitExchange.passive","title":"passive  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>passive: bool = False\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/RabbitExchange/#faststream.rabbit.shared.schemas.RabbitExchange.robust","title":"robust  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>robust: bool = True\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/RabbitExchange/#faststream.rabbit.shared.schemas.RabbitExchange.routing_key","title":"routing_key  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>routing_key: str = ''\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/RabbitExchange/#faststream.rabbit.shared.schemas.RabbitExchange.timeout","title":"timeout  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>timeout: TimeoutType = None\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/RabbitExchange/#faststream.rabbit.shared.schemas.RabbitExchange.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>type: str = ExchangeType.DIRECT.value\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/RabbitExchange/#faststream.rabbit.shared.schemas.RabbitExchange-functions","title":"Functions","text":""},{"location":"api/faststream/rabbit/shared/schemas/RabbitExchange/#faststream.rabbit.shared.schemas.RabbitExchange.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/shared/schemas.py</code> <pre><code>def __hash__(self) -&gt; int:\n    return sum(\n        (\n            hash(self.name),\n            hash(self.type),\n            int(self.durable),\n            int(self.auto_delete),\n        )\n    )\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/RabbitExchange/#faststream.rabbit.shared.schemas.RabbitExchange.__init__","title":"__init__","text":"<pre><code>__init__(\n    name: str,\n    type: ExchangeType = ExchangeType.DIRECT,\n    durable: bool = False,\n    auto_delete: bool = False,\n    internal: bool = False,\n    passive: bool = False,\n    arguments: Optional[AnyDict] = None,\n    timeout: TimeoutType = None,\n    robust: bool = True,\n    bind_to: Optional[RabbitExchange] = None,\n    bind_arguments: Optional[AnyDict] = None,\n    routing_key: str = \"\",\n)\n</code></pre> <p>Initialize a RabbitExchange object.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the exchange.</p> required <code>type</code> <code>ExchangeType</code> <p>Type of the exchange. Defaults to ExchangeType.DIRECT.</p> <code>DIRECT</code> <code>durable</code> <code>bool</code> <p>Whether the exchange should survive broker restarts. Defaults to False.</p> <code>False</code> <code>auto_delete</code> <code>bool</code> <p>Whether the exchange should be deleted when no longer in use. Defaults to False.</p> <code>False</code> <code>internal</code> <code>bool</code> <p>Whether the exchange is used for internal purposes and should not be published to directly. Defaults to False.</p> <code>False</code> <code>passive</code> <code>bool</code> <p>Whether to check if the exchange exists before creating it. Defaults to False.</p> <code>False</code> <code>arguments</code> <code>Optional[AnyDict]</code> <p>Additional arguments for the exchange. Defaults to None.</p> <code>None</code> <code>timeout</code> <code>TimeoutType</code> <p>Timeout for the operation. Defaults to None.</p> <code>None</code> <code>robust</code> <code>bool</code> <p>Whether to use robust mode for the exchange. Defaults to True.</p> <code>True</code> <code>bind_to</code> <code>Optional[RabbitExchange]</code> <p>Exchange to bind to. Defaults to None.</p> <code>None</code> <code>bind_arguments</code> <code>Optional[AnyDict]</code> <p>Arguments for the binding. Defaults to None.</p> <code>None</code> <code>routing_key</code> <code>str</code> <p>Routing key for the exchange. Defaults to \"\".</p> <code>''</code> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/shared/schemas.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    type: ExchangeType = ExchangeType.DIRECT,\n    durable: bool = False,\n    auto_delete: bool = False,\n    internal: bool = False,\n    passive: bool = False,\n    arguments: Optional[AnyDict] = None,\n    timeout: TimeoutType = None,\n    robust: bool = True,\n    bind_to: Optional[\"RabbitExchange\"] = None,\n    bind_arguments: Optional[AnyDict] = None,\n    routing_key: str = \"\",\n):\n\"\"\"Initialize a RabbitExchange object.\n\n    Args:\n        name (str): Name of the exchange.\n        type (ExchangeType, optional): Type of the exchange. Defaults to ExchangeType.DIRECT.\n        durable (bool, optional): Whether the exchange should survive broker restarts. Defaults to False.\n        auto_delete (bool, optional): Whether the exchange should be deleted when no longer in use. Defaults to False.\n        internal (bool, optional): Whether the exchange is used for internal purposes and should not be published to directly. Defaults to False.\n        passive (bool, optional): Whether to check if the exchange exists before creating it. Defaults to False.\n        arguments (Optional[AnyDict], optional): Additional arguments for the exchange. Defaults to None.\n        timeout (TimeoutType, optional): Timeout for the operation. Defaults to None.\n        robust (bool, optional): Whether to use robust mode for the exchange. Defaults to True.\n        bind_to (Optional[\"RabbitExchange\"], optional): Exchange to bind to. Defaults to None.\n        bind_arguments (Optional[AnyDict], optional): Arguments for the binding. Defaults to None.\n        routing_key (str, optional): Routing key for the exchange. Defaults to \"\".\n\n    Raises:\n        NotImplementedError:\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    super().__init__(\n        name=name,\n        type=type.value,\n        durable=durable,\n        auto_delete=auto_delete,\n        routing_key=routing_key,\n        bind_to=bind_to,\n        bind_arguments=bind_arguments,\n        robust=robust,\n        internal=internal,\n        passive=passive,\n        timeout=timeout,\n        arguments=arguments,\n    )\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/RabbitQueue/","title":"RabbitQueue","text":""},{"location":"api/faststream/rabbit/shared/schemas/RabbitQueue/#faststream.rabbit.shared.schemas.RabbitQueue","title":"faststream.rabbit.shared.schemas.RabbitQueue","text":"<p>             Bases: <code>NameRequired</code></p> <p>A class to represent a RabbitMQ queue.</p> <p>Attributes:</p> Name Type Description <code>name</code> <p>name of the queue</p> <code>durable</code> <p>whether the queue is durable or not</p> <code>exclusive</code> <p>whether the queue is exclusive or not</p> <code>passive</code> <p>whether the queue is passive or not</p> <code>auto_delete</code> <p>whether the queue is auto delete or not</p> <code>arguments</code> <p>additional arguments for the queue</p> <code>timeout</code> <p>timeout for the queue</p> <code>robust</code> <p>whether the queue is robust or not</p> <code>routing_key</code> <p>routing key for the queue</p> <code>bind_arguments</code> <p>additional arguments for binding the queue</p> <p>Methods:</p> Name Description <code>__hash__ </code> <p>returns the hash value of the queue</p> <code>routing </code> <p>returns the routing key of the queue</p> <code>__init__ </code> <p>initializes the RabbitQueue object with the given parameters</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/shared/schemas.py</code> <pre><code>class RabbitQueue(NameRequired):\n\"\"\"A class to represent a RabbitMQ queue.\n\n    Attributes:\n        name : name of the queue\n        durable : whether the queue is durable or not\n        exclusive : whether the queue is exclusive or not\n        passive : whether the queue is passive or not\n        auto_delete : whether the queue is auto delete or not\n        arguments : additional arguments for the queue\n        timeout : timeout for the queue\n        robust : whether the queue is robust or not\n        routing_key : routing key for the queue\n        bind_arguments : additional arguments for binding the queue\n\n    Methods:\n        __hash__ : returns the hash value of the queue\n        routing : returns the routing key of the queue\n        __init__ : initializes the RabbitQueue object with the given parameters\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    name: str = \"\"\n    durable: bool = False\n    exclusive: bool = False\n    passive: bool = False\n    auto_delete: bool = False\n    arguments: Optional[AnyDict] = None\n    timeout: TimeoutType = None\n    robust: bool = True\n\n    routing_key: str = \"\"\n    bind_arguments: Optional[AnyDict] = None\n\n    def __hash__(self) -&gt; int:\n        return sum(\n            (\n                hash(self.name),\n                int(self.durable),\n                int(self.exclusive),\n                int(self.auto_delete),\n            )\n        )\n\n    @property\n    def routing(self) -&gt; Optional[str]:\n        return self.routing_key or self.name or None\n\n    def __init__(\n        self,\n        name: str,\n        durable: bool = False,\n        exclusive: bool = False,\n        passive: bool = False,\n        auto_delete: bool = False,\n        arguments: Optional[AnyDict] = None,\n        timeout: TimeoutType = None,\n        robust: bool = True,\n        bind_arguments: Optional[AnyDict] = None,\n        routing_key: str = \"\",\n    ):\n\"\"\"Initialize a class object.\n\n        Args:\n            name (str): The name of the object.\n            durable (bool, optional): Whether the object is durable. Defaults to False.\n            exclusive (bool, optional): Whether the object is exclusive. Defaults to False.\n            passive (bool, optional): Whether the object is passive. Defaults to False.\n            auto_delete (bool, optional): Whether the object is auto delete. Defaults to False.\n            arguments (dict, optional): Additional arguments for the object. Defaults to None.\n            timeout (TimeoutType, optional): Timeout for the object. Defaults to None.\n            robust (bool, optional): Whether the object is robust. Defaults to True.\n            bind_arguments (dict, optional): Bind arguments for the object. Defaults to None.\n            routing_key (str, optional): Routing key for the object. Defaults to \"\".\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        super().__init__(\n            name=name,\n            durable=durable,\n            exclusive=exclusive,\n            bind_arguments=bind_arguments,\n            routing_key=routing_key,\n            robust=robust,\n            passive=passive,\n            auto_delete=auto_delete,\n            arguments=arguments,\n            timeout=timeout,\n        )\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/RabbitQueue/#faststream.rabbit.shared.schemas.RabbitQueue-attributes","title":"Attributes","text":""},{"location":"api/faststream/rabbit/shared/schemas/RabbitQueue/#faststream.rabbit.shared.schemas.RabbitQueue.arguments","title":"arguments  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>arguments: Optional[AnyDict] = None\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/RabbitQueue/#faststream.rabbit.shared.schemas.RabbitQueue.auto_delete","title":"auto_delete  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>auto_delete: bool = False\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/RabbitQueue/#faststream.rabbit.shared.schemas.RabbitQueue.bind_arguments","title":"bind_arguments  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bind_arguments: Optional[AnyDict] = None\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/RabbitQueue/#faststream.rabbit.shared.schemas.RabbitQueue.durable","title":"durable  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>durable: bool = False\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/RabbitQueue/#faststream.rabbit.shared.schemas.RabbitQueue.exclusive","title":"exclusive  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>exclusive: bool = False\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/RabbitQueue/#faststream.rabbit.shared.schemas.RabbitQueue.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str = ''\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/RabbitQueue/#faststream.rabbit.shared.schemas.RabbitQueue.passive","title":"passive  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>passive: bool = False\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/RabbitQueue/#faststream.rabbit.shared.schemas.RabbitQueue.robust","title":"robust  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>robust: bool = True\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/RabbitQueue/#faststream.rabbit.shared.schemas.RabbitQueue.routing","title":"routing  <code>property</code>","text":"<pre><code>routing: Optional[str]\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/RabbitQueue/#faststream.rabbit.shared.schemas.RabbitQueue.routing_key","title":"routing_key  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>routing_key: str = ''\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/RabbitQueue/#faststream.rabbit.shared.schemas.RabbitQueue.timeout","title":"timeout  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>timeout: TimeoutType = None\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/RabbitQueue/#faststream.rabbit.shared.schemas.RabbitQueue-functions","title":"Functions","text":""},{"location":"api/faststream/rabbit/shared/schemas/RabbitQueue/#faststream.rabbit.shared.schemas.RabbitQueue.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/shared/schemas.py</code> <pre><code>def __hash__(self) -&gt; int:\n    return sum(\n        (\n            hash(self.name),\n            int(self.durable),\n            int(self.exclusive),\n            int(self.auto_delete),\n        )\n    )\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/RabbitQueue/#faststream.rabbit.shared.schemas.RabbitQueue.__init__","title":"__init__","text":"<pre><code>__init__(\n    name: str,\n    durable: bool = False,\n    exclusive: bool = False,\n    passive: bool = False,\n    auto_delete: bool = False,\n    arguments: Optional[AnyDict] = None,\n    timeout: TimeoutType = None,\n    robust: bool = True,\n    bind_arguments: Optional[AnyDict] = None,\n    routing_key: str = \"\",\n)\n</code></pre> <p>Initialize a class object.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the object.</p> required <code>durable</code> <code>bool</code> <p>Whether the object is durable. Defaults to False.</p> <code>False</code> <code>exclusive</code> <code>bool</code> <p>Whether the object is exclusive. Defaults to False.</p> <code>False</code> <code>passive</code> <code>bool</code> <p>Whether the object is passive. Defaults to False.</p> <code>False</code> <code>auto_delete</code> <code>bool</code> <p>Whether the object is auto delete. Defaults to False.</p> <code>False</code> <code>arguments</code> <code>dict</code> <p>Additional arguments for the object. Defaults to None.</p> <code>None</code> <code>timeout</code> <code>TimeoutType</code> <p>Timeout for the object. Defaults to None.</p> <code>None</code> <code>robust</code> <code>bool</code> <p>Whether the object is robust. Defaults to True.</p> <code>True</code> <code>bind_arguments</code> <code>dict</code> <p>Bind arguments for the object. Defaults to None.</p> <code>None</code> <code>routing_key</code> <code>str</code> <p>Routing key for the object. Defaults to \"\".</p> <code>''</code> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/shared/schemas.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    durable: bool = False,\n    exclusive: bool = False,\n    passive: bool = False,\n    auto_delete: bool = False,\n    arguments: Optional[AnyDict] = None,\n    timeout: TimeoutType = None,\n    robust: bool = True,\n    bind_arguments: Optional[AnyDict] = None,\n    routing_key: str = \"\",\n):\n\"\"\"Initialize a class object.\n\n    Args:\n        name (str): The name of the object.\n        durable (bool, optional): Whether the object is durable. Defaults to False.\n        exclusive (bool, optional): Whether the object is exclusive. Defaults to False.\n        passive (bool, optional): Whether the object is passive. Defaults to False.\n        auto_delete (bool, optional): Whether the object is auto delete. Defaults to False.\n        arguments (dict, optional): Additional arguments for the object. Defaults to None.\n        timeout (TimeoutType, optional): Timeout for the object. Defaults to None.\n        robust (bool, optional): Whether the object is robust. Defaults to True.\n        bind_arguments (dict, optional): Bind arguments for the object. Defaults to None.\n        routing_key (str, optional): Routing key for the object. Defaults to \"\".\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    super().__init__(\n        name=name,\n        durable=durable,\n        exclusive=exclusive,\n        bind_arguments=bind_arguments,\n        routing_key=routing_key,\n        robust=robust,\n        passive=passive,\n        auto_delete=auto_delete,\n        arguments=arguments,\n        timeout=timeout,\n    )\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/get_routing_hash/","title":"get_routing_hash","text":""},{"location":"api/faststream/rabbit/shared/schemas/get_routing_hash/#faststream.rabbit.shared.schemas.get_routing_hash","title":"faststream.rabbit.shared.schemas.get_routing_hash","text":"<pre><code>get_routing_hash(\n    queue: RabbitQueue,\n    exchange: Optional[RabbitExchange] = None,\n) -&gt; int\n</code></pre> <p>Calculate the routing hash for a RabbitMQ queue and exchange.</p> <p>Parameters:</p> Name Type Description Default <code>queue</code> <code>RabbitQueue</code> <p>The RabbitMQ queue.</p> required <code>exchange</code> <code>Optional[RabbitExchange]</code> <p>The RabbitMQ exchange (optional).</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>The routing hash as an integer.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/shared/schemas.py</code> <pre><code>def get_routing_hash(\n    queue: RabbitQueue,\n    exchange: Optional[RabbitExchange] = None,\n) -&gt; int:\n\"\"\"Calculate the routing hash for a RabbitMQ queue and exchange.\n\n    Args:\n        queue: The RabbitMQ queue.\n        exchange: The RabbitMQ exchange (optional).\n\n    Returns:\n        The routing hash as an integer.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    return hash(queue) + hash(exchange or \"\")\n</code></pre>"},{"location":"api/faststream/rabbit/test/FakeProducer/","title":"FakeProducer","text":""},{"location":"api/faststream/rabbit/test/FakeProducer/#faststream.rabbit.test.FakeProducer","title":"faststream.rabbit.test.FakeProducer","text":"<p>             Bases: <code>AioPikaFastProducer</code></p> <p>A fake RabbitMQ producer for testing purposes.</p> <p>This class extends AioPikaFastProducer and is used to simulate RabbitMQ message publishing during tests.</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/test.py</code> <pre><code>class FakeProducer(AioPikaFastProducer):\n\"\"\"\n    A fake RabbitMQ producer for testing purposes.\n\n    This class extends AioPikaFastProducer and is used to simulate RabbitMQ message publishing during tests.\n    \"\"\"\n\n    def __init__(self, broker: RabbitBroker):\n\"\"\"\n        Initialize a FakeProducer instance.\n\n        Args:\n            broker (RabbitBroker): The RabbitBroker instance to be used for message publishing.\n        \"\"\"\n        self.broker = broker\n\n    async def publish(\n        self,\n        message: AioPikaSendableMessage = \"\",\n        queue: Union[RabbitQueue, str] = \"\",\n        exchange: Union[RabbitExchange, str, None] = None,\n        *,\n        routing_key: str = \"\",\n        mandatory: bool = True,\n        immediate: bool = False,\n        timeout: TimeoutType = None,\n        rpc: bool = False,\n        rpc_timeout: Optional[float] = 30.0,\n        raise_timeout: bool = False,\n        persist: bool = False,\n        reply_to: Optional[str] = None,\n        **message_kwargs: Any,\n    ) -&gt; Optional[SendableMessage]:\n\"\"\"\n        Publish a message to a RabbitMQ queue or exchange.\n\n        Args:\n            message (AioPikaSendableMessage, optional): The message to be published.\n            queue (Union[RabbitQueue, str], optional): The target queue for the message.\n            exchange (Union[RabbitExchange, str, None], optional): The target exchange for the message.\n            routing_key (str, optional): The routing key for the message.\n            mandatory (bool, optional): Whether the message is mandatory.\n            immediate (bool, optional): Whether the message should be sent immediately.\n            timeout (TimeoutType, optional): The timeout for the message.\n            rpc (bool, optional): Whether the message is for RPC.\n            rpc_timeout (float, optional): The RPC timeout.\n            raise_timeout (bool, optional): Whether to raise a timeout exception.\n            persist (bool, optional): Whether to persist the message.\n            reply_to (str, optional): The reply-to address for RPC messages.\n            **message_kwargs (Any): Additional message properties and content.\n\n        Returns:\n            Optional[SendableMessage]: The published message if successful, or None if not.\n        \"\"\"\n        exch = RabbitExchange.validate(exchange)\n\n        incoming = build_message(\n            message=message,\n            queue=queue,\n            exchange=exch,\n            routing_key=routing_key,\n            reply_to=reply_to,\n            **message_kwargs,\n        )\n\n        for handler in self.broker.handlers.values():  # pragma: no branch\n            if handler.exchange == exch:\n                call: bool = False\n\n                if (\n                    handler.exchange is None\n                    or handler.exchange.type == ExchangeType.DIRECT\n                ):\n                    call = handler.queue.name == incoming.routing_key\n\n                elif handler.exchange.type == ExchangeType.FANOUT:\n                    call = True\n\n                elif handler.exchange.type == ExchangeType.TOPIC:\n                    call = bool(\n                        re.match(\n                            handler.queue.name.replace(\".\", r\"\\.\").replace(\"*\", \".*\"),\n                            incoming.routing_key or \"\",\n                        )\n                    )\n\n                elif handler.exchange.type == ExchangeType.HEADERS:  # pramga: no branch\n                    queue_headers = handler.queue.bind_arguments\n                    msg_headers = incoming.headers\n\n                    if not queue_headers:\n                        call = True\n\n                    else:\n                        matcher = queue_headers.pop(\"x-match\", \"all\")\n\n                        full = True\n                        none = True\n                        for k, v in queue_headers.items():\n                            if msg_headers.get(k) != v:\n                                full = False\n                            else:\n                                none = False\n\n                        if not none:\n                            call = (matcher == \"any\") or full\n\n                else:  # pragma: no cover\n                    raise AssertionError(\"unreachable\")\n\n                if call:\n                    r = await call_handler(\n                        handler=handler,\n                        message=incoming,\n                        rpc=rpc,\n                        rpc_timeout=rpc_timeout,\n                        raise_timeout=raise_timeout,\n                    )\n\n                    if rpc:  # pragma: no branch\n                        return r\n\n        return None\n</code></pre>"},{"location":"api/faststream/rabbit/test/FakeProducer/#faststream.rabbit.test.FakeProducer-attributes","title":"Attributes","text":""},{"location":"api/faststream/rabbit/test/FakeProducer/#faststream.rabbit.test.FakeProducer.broker","title":"broker  <code>instance-attribute</code>","text":"<pre><code>broker = broker\n</code></pre>"},{"location":"api/faststream/rabbit/test/FakeProducer/#faststream.rabbit.test.FakeProducer-functions","title":"Functions","text":""},{"location":"api/faststream/rabbit/test/FakeProducer/#faststream.rabbit.test.FakeProducer.__init__","title":"__init__","text":"<pre><code>__init__(broker: RabbitBroker)\n</code></pre> <p>Initialize a FakeProducer instance.</p> <p>Parameters:</p> Name Type Description Default <code>broker</code> <code>RabbitBroker</code> <p>The RabbitBroker instance to be used for message publishing.</p> required Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/test.py</code> <pre><code>def __init__(self, broker: RabbitBroker):\n\"\"\"\n    Initialize a FakeProducer instance.\n\n    Args:\n        broker (RabbitBroker): The RabbitBroker instance to be used for message publishing.\n    \"\"\"\n    self.broker = broker\n</code></pre>"},{"location":"api/faststream/rabbit/test/FakeProducer/#faststream.rabbit.test.FakeProducer.publish","title":"publish  <code>async</code>","text":"<pre><code>publish(\n    message: AioPikaSendableMessage = \"\",\n    queue: Union[RabbitQueue, str] = \"\",\n    exchange: Union[RabbitExchange, str, None] = None,\n    *,\n    routing_key: str = \"\",\n    mandatory: bool = True,\n    immediate: bool = False,\n    timeout: TimeoutType = None,\n    rpc: bool = False,\n    rpc_timeout: Optional[float] = 30.0,\n    raise_timeout: bool = False,\n    persist: bool = False,\n    reply_to: Optional[str] = None,\n    **message_kwargs: Any\n) -&gt; Optional[SendableMessage]\n</code></pre> <p>Publish a message to a RabbitMQ queue or exchange.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>AioPikaSendableMessage</code> <p>The message to be published.</p> <code>''</code> <code>queue</code> <code>Union[RabbitQueue, str]</code> <p>The target queue for the message.</p> <code>''</code> <code>exchange</code> <code>Union[RabbitExchange, str, None]</code> <p>The target exchange for the message.</p> <code>None</code> <code>routing_key</code> <code>str</code> <p>The routing key for the message.</p> <code>''</code> <code>mandatory</code> <code>bool</code> <p>Whether the message is mandatory.</p> <code>True</code> <code>immediate</code> <code>bool</code> <p>Whether the message should be sent immediately.</p> <code>False</code> <code>timeout</code> <code>TimeoutType</code> <p>The timeout for the message.</p> <code>None</code> <code>rpc</code> <code>bool</code> <p>Whether the message is for RPC.</p> <code>False</code> <code>rpc_timeout</code> <code>float</code> <p>The RPC timeout.</p> <code>30.0</code> <code>raise_timeout</code> <code>bool</code> <p>Whether to raise a timeout exception.</p> <code>False</code> <code>persist</code> <code>bool</code> <p>Whether to persist the message.</p> <code>False</code> <code>reply_to</code> <code>str</code> <p>The reply-to address for RPC messages.</p> <code>None</code> <code>**message_kwargs</code> <code>Any</code> <p>Additional message properties and content.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Optional[SendableMessage]</code> <p>Optional[SendableMessage]: The published message if successful, or None if not.</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/test.py</code> <pre><code>async def publish(\n    self,\n    message: AioPikaSendableMessage = \"\",\n    queue: Union[RabbitQueue, str] = \"\",\n    exchange: Union[RabbitExchange, str, None] = None,\n    *,\n    routing_key: str = \"\",\n    mandatory: bool = True,\n    immediate: bool = False,\n    timeout: TimeoutType = None,\n    rpc: bool = False,\n    rpc_timeout: Optional[float] = 30.0,\n    raise_timeout: bool = False,\n    persist: bool = False,\n    reply_to: Optional[str] = None,\n    **message_kwargs: Any,\n) -&gt; Optional[SendableMessage]:\n\"\"\"\n    Publish a message to a RabbitMQ queue or exchange.\n\n    Args:\n        message (AioPikaSendableMessage, optional): The message to be published.\n        queue (Union[RabbitQueue, str], optional): The target queue for the message.\n        exchange (Union[RabbitExchange, str, None], optional): The target exchange for the message.\n        routing_key (str, optional): The routing key for the message.\n        mandatory (bool, optional): Whether the message is mandatory.\n        immediate (bool, optional): Whether the message should be sent immediately.\n        timeout (TimeoutType, optional): The timeout for the message.\n        rpc (bool, optional): Whether the message is for RPC.\n        rpc_timeout (float, optional): The RPC timeout.\n        raise_timeout (bool, optional): Whether to raise a timeout exception.\n        persist (bool, optional): Whether to persist the message.\n        reply_to (str, optional): The reply-to address for RPC messages.\n        **message_kwargs (Any): Additional message properties and content.\n\n    Returns:\n        Optional[SendableMessage]: The published message if successful, or None if not.\n    \"\"\"\n    exch = RabbitExchange.validate(exchange)\n\n    incoming = build_message(\n        message=message,\n        queue=queue,\n        exchange=exch,\n        routing_key=routing_key,\n        reply_to=reply_to,\n        **message_kwargs,\n    )\n\n    for handler in self.broker.handlers.values():  # pragma: no branch\n        if handler.exchange == exch:\n            call: bool = False\n\n            if (\n                handler.exchange is None\n                or handler.exchange.type == ExchangeType.DIRECT\n            ):\n                call = handler.queue.name == incoming.routing_key\n\n            elif handler.exchange.type == ExchangeType.FANOUT:\n                call = True\n\n            elif handler.exchange.type == ExchangeType.TOPIC:\n                call = bool(\n                    re.match(\n                        handler.queue.name.replace(\".\", r\"\\.\").replace(\"*\", \".*\"),\n                        incoming.routing_key or \"\",\n                    )\n                )\n\n            elif handler.exchange.type == ExchangeType.HEADERS:  # pramga: no branch\n                queue_headers = handler.queue.bind_arguments\n                msg_headers = incoming.headers\n\n                if not queue_headers:\n                    call = True\n\n                else:\n                    matcher = queue_headers.pop(\"x-match\", \"all\")\n\n                    full = True\n                    none = True\n                    for k, v in queue_headers.items():\n                        if msg_headers.get(k) != v:\n                            full = False\n                        else:\n                            none = False\n\n                    if not none:\n                        call = (matcher == \"any\") or full\n\n            else:  # pragma: no cover\n                raise AssertionError(\"unreachable\")\n\n            if call:\n                r = await call_handler(\n                    handler=handler,\n                    message=incoming,\n                    rpc=rpc,\n                    rpc_timeout=rpc_timeout,\n                    raise_timeout=raise_timeout,\n                )\n\n                if rpc:  # pragma: no branch\n                    return r\n\n    return None\n</code></pre>"},{"location":"api/faststream/rabbit/test/PatchedMessage/","title":"PatchedMessage","text":""},{"location":"api/faststream/rabbit/test/PatchedMessage/#faststream.rabbit.test.PatchedMessage","title":"faststream.rabbit.test.PatchedMessage","text":"<p>             Bases: <code>IncomingMessage</code></p> <p>Patched message class for testing purposes.</p> <p>This class extends aio_pika's IncomingMessage class and is used to simulate RabbitMQ message handling during tests.</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/test.py</code> <pre><code>class PatchedMessage(IncomingMessage):\n\"\"\"\n    Patched message class for testing purposes.\n\n    This class extends aio_pika's IncomingMessage class and is used to simulate RabbitMQ message handling during tests.\n    \"\"\"\n\n    async def ack(self, multiple: bool = False) -&gt; None:\n\"\"\"Asynchronously acknowledge a message.\n\n        Args:\n            multiple (bool, optional): Whether to acknowledge multiple messages at once. Defaults to False.\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        pass\n\n    async def nack(self, multiple: bool = False, requeue: bool = True) -&gt; None:\n\"\"\"Nack the message.\n\n        Args:\n            multiple: Whether to nack multiple messages. Default is False.\n            requeue: Whether to requeue the message. Default is True.\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        pass\n\n    async def reject(self, requeue: bool = False) -&gt; None:\n\"\"\"Rejects a task.\n\n        Args:\n            requeue: Whether to requeue the task if it fails (default: False)\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/faststream/rabbit/test/PatchedMessage/#faststream.rabbit.test.PatchedMessage-functions","title":"Functions","text":""},{"location":"api/faststream/rabbit/test/PatchedMessage/#faststream.rabbit.test.PatchedMessage.ack","title":"ack  <code>async</code>","text":"<pre><code>ack(multiple: bool = False) -&gt; None\n</code></pre> <p>Asynchronously acknowledge a message.</p> <p>Parameters:</p> Name Type Description Default <code>multiple</code> <code>bool</code> <p>Whether to acknowledge multiple messages at once. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/test.py</code> <pre><code>async def ack(self, multiple: bool = False) -&gt; None:\n\"\"\"Asynchronously acknowledge a message.\n\n    Args:\n        multiple (bool, optional): Whether to acknowledge multiple messages at once. Defaults to False.\n\n    Returns:\n        None\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/faststream/rabbit/test/PatchedMessage/#faststream.rabbit.test.PatchedMessage.nack","title":"nack  <code>async</code>","text":"<pre><code>nack(multiple: bool = False, requeue: bool = True) -&gt; None\n</code></pre> <p>Nack the message.</p> <p>Parameters:</p> Name Type Description Default <code>multiple</code> <code>bool</code> <p>Whether to nack multiple messages. Default is False.</p> <code>False</code> <code>requeue</code> <code>bool</code> <p>Whether to requeue the message. Default is True.</p> <code>True</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/test.py</code> <pre><code>async def nack(self, multiple: bool = False, requeue: bool = True) -&gt; None:\n\"\"\"Nack the message.\n\n    Args:\n        multiple: Whether to nack multiple messages. Default is False.\n        requeue: Whether to requeue the message. Default is True.\n\n    Returns:\n        None\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/faststream/rabbit/test/PatchedMessage/#faststream.rabbit.test.PatchedMessage.reject","title":"reject  <code>async</code>","text":"<pre><code>reject(requeue: bool = False) -&gt; None\n</code></pre> <p>Rejects a task.</p> <p>Parameters:</p> Name Type Description Default <code>requeue</code> <code>bool</code> <p>Whether to requeue the task if it fails (default: False)</p> <code>False</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/test.py</code> <pre><code>async def reject(self, requeue: bool = False) -&gt; None:\n\"\"\"Rejects a task.\n\n    Args:\n        requeue: Whether to requeue the task if it fails (default: False)\n\n    Returns:\n        None\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/faststream/rabbit/test/TestRabbitBroker/","title":"TestRabbitBroker","text":""},{"location":"api/faststream/rabbit/test/TestRabbitBroker/#faststream.rabbit.test.TestRabbitBroker","title":"faststream.rabbit.test.TestRabbitBroker","text":"<p>A context manager for creating a test RabbitBroker instance with optional mocking.</p> <p>This class is designed to be used as a context manager for creating a RabbitBroker instance, optionally replacing some of its components with mocks for testing purposes. If the <code>with_real</code> attribute is set to True, it operates as a pass-through context manager, returning the original RabbitBroker instance without any modifications. If <code>with_real</code> is set to False, it replaces certain components like the channel, declarer, and start/connect/close methods with mock objects to isolate the broker for testing.</p> <p>Parameters:</p> Name Type Description Default <code>broker</code> <code>RabbitBroker</code> <p>The RabbitBroker instance to be used in testing.</p> required <code>with_real</code> <code>bool</code> <p>If True, the original broker is returned; if False, components are replaced with mock objects. Defaults to False.</p> <code>False</code> <p>Attributes:</p> Name Type Description <code>broker</code> <code>RabbitBroker</code> <p>The RabbitBroker instance provided for testing.</p> <code>with_real</code> <code>bool</code> <p>A boolean flag indicating whether to use the original broker (True) or replace components with mocks (False).</p> <p>Methods:</p> Name Description <code>__aenter__</code> <p>Enter the context and return the RabbitBroker instance.</p> <code>__aexit__</code> <p>Any) -&gt; None: Exit the context.</p> <p>Example usage:</p> <pre><code>real_broker = RabbitBroker()\nwith TestRabbitBroker(real_broker, with_real=True) as broker:\n    # Use the real RabbitBroker instance for testing.\n\nwith TestRabbitBroker(real_broker, with_real=False) as broker:\n    # Use a mocked RabbitBroker instance for testing.\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/test.py</code> <pre><code>class TestRabbitBroker:\n\n\"\"\"\n    A context manager for creating a test RabbitBroker instance with optional mocking.\n\n    This class is designed to be used as a context manager for creating a RabbitBroker instance, optionally replacing some\n    of its components with mocks for testing purposes. If the `with_real` attribute is set to True, it operates as a\n    pass-through context manager, returning the original RabbitBroker instance without any modifications. If `with_real`\n    is set to False, it replaces certain components like the channel, declarer, and start/connect/close methods with mock\n    objects to isolate the broker for testing.\n\n    Args:\n        broker (RabbitBroker): The RabbitBroker instance to be used in testing.\n        with_real (bool, optional): If True, the original broker is returned; if False, components are replaced with\n            mock objects. Defaults to False.\n\n    Attributes:\n        broker (RabbitBroker): The RabbitBroker instance provided for testing.\n        with_real (bool): A boolean flag indicating whether to use the original broker (True) or replace components with\n            mocks (False).\n\n    Methods:\n        __aenter__(self) -&gt; RabbitBroker:\n            Enter the context and return the RabbitBroker instance.\n\n        __aexit__(self, *args: Any) -&gt; None:\n            Exit the context.\n\n    Example usage:\n\n    ```python\n    real_broker = RabbitBroker()\n    with TestRabbitBroker(real_broker, with_real=True) as broker:\n        # Use the real RabbitBroker instance for testing.\n\n    with TestRabbitBroker(real_broker, with_real=False) as broker:\n        # Use a mocked RabbitBroker instance for testing.\n    ```\n    \"\"\"\n\n    # This is set so pytest ignores this class\n    __test__ = False\n\n    def __init__(self, broker: RabbitBroker, with_real: bool = False):\n\"\"\"\n        Initialize a TestRabbitBroker instance.\n\n        Args:\n            broker (RabbitBroker): The RabbitBroker instance to be used in testing.\n            with_real (bool, optional): If True, the original broker is returned; if False, components are replaced with\n                mock objects. Defaults to False.\n        \"\"\"\n        self.with_real = with_real\n        self.broker = broker\n\n    @asynccontextmanager\n    async def _create_ctx(self) -&gt; AsyncGenerator[RabbitBroker, None]:\n\"\"\"\n        Create the context for the context manager.\n\n        Yields:\n            RabbitBroker: The RabbitBroker instance for testing, either with or without mocks.\n        \"\"\"\n        if not self.with_real:\n            self.broker._channel = AsyncMock()\n            self.broker.declarer = AsyncMock()\n            self.broker.start = AsyncMock(wraps=partial(_fake_start, self.broker))  # type: ignore[method-assign]\n            self.broker._connect = MethodType(_fake_connect, self.broker)  # type: ignore[method-assign]\n            self.broker.close = MethodType(_fake_close, self.broker)  # type: ignore[method-assign]\n        else:\n            _fake_start(self.broker)\n\n        async with self.broker:\n            try:\n                await self.broker.start()\n                yield self.broker\n            finally:\n                pass\n\n    async def __aenter__(self) -&gt; RabbitBroker:\n\"\"\"\n        Enter the context and return the RabbitBroker instance.\n\n        Returns:\n            RabbitBroker: The RabbitBroker instance for testing, either with or without mocks.\n        \"\"\"\n        self._ctx = self._create_ctx()\n        return await self._ctx.__aenter__()\n\n    async def __aexit__(self, *args: Any) -&gt; None:\n\"\"\"\n        Exit the context.\n\n        Args:\n            *args: Variable-length argument list.\n        \"\"\"\n        await self._ctx.__aexit__(*args)\n</code></pre>"},{"location":"api/faststream/rabbit/test/TestRabbitBroker/#faststream.rabbit.test.TestRabbitBroker-attributes","title":"Attributes","text":""},{"location":"api/faststream/rabbit/test/TestRabbitBroker/#faststream.rabbit.test.TestRabbitBroker.__test__","title":"__test__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__test__ = False\n</code></pre>"},{"location":"api/faststream/rabbit/test/TestRabbitBroker/#faststream.rabbit.test.TestRabbitBroker.broker","title":"broker  <code>instance-attribute</code>","text":"<pre><code>broker = broker\n</code></pre>"},{"location":"api/faststream/rabbit/test/TestRabbitBroker/#faststream.rabbit.test.TestRabbitBroker.with_real","title":"with_real  <code>instance-attribute</code>","text":"<pre><code>with_real = with_real\n</code></pre>"},{"location":"api/faststream/rabbit/test/TestRabbitBroker/#faststream.rabbit.test.TestRabbitBroker-functions","title":"Functions","text":""},{"location":"api/faststream/rabbit/test/TestRabbitBroker/#faststream.rabbit.test.TestRabbitBroker.__aenter__","title":"__aenter__  <code>async</code>","text":"<pre><code>__aenter__() -&gt; RabbitBroker\n</code></pre> <p>Enter the context and return the RabbitBroker instance.</p> <p>Returns:</p> Name Type Description <code>RabbitBroker</code> <code>RabbitBroker</code> <p>The RabbitBroker instance for testing, either with or without mocks.</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/test.py</code> <pre><code>async def __aenter__(self) -&gt; RabbitBroker:\n\"\"\"\n    Enter the context and return the RabbitBroker instance.\n\n    Returns:\n        RabbitBroker: The RabbitBroker instance for testing, either with or without mocks.\n    \"\"\"\n    self._ctx = self._create_ctx()\n    return await self._ctx.__aenter__()\n</code></pre>"},{"location":"api/faststream/rabbit/test/TestRabbitBroker/#faststream.rabbit.test.TestRabbitBroker.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(*args: Any) -&gt; None\n</code></pre> <p>Exit the context.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Any</code> <p>Variable-length argument list.</p> <code>()</code> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/test.py</code> <pre><code>async def __aexit__(self, *args: Any) -&gt; None:\n\"\"\"\n    Exit the context.\n\n    Args:\n        *args: Variable-length argument list.\n    \"\"\"\n    await self._ctx.__aexit__(*args)\n</code></pre>"},{"location":"api/faststream/rabbit/test/TestRabbitBroker/#faststream.rabbit.test.TestRabbitBroker.__init__","title":"__init__","text":"<pre><code>__init__(broker: RabbitBroker, with_real: bool = False)\n</code></pre> <p>Initialize a TestRabbitBroker instance.</p> <p>Parameters:</p> Name Type Description Default <code>broker</code> <code>RabbitBroker</code> <p>The RabbitBroker instance to be used in testing.</p> required <code>with_real</code> <code>bool</code> <p>If True, the original broker is returned; if False, components are replaced with mock objects. Defaults to False.</p> <code>False</code> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/test.py</code> <pre><code>def __init__(self, broker: RabbitBroker, with_real: bool = False):\n\"\"\"\n    Initialize a TestRabbitBroker instance.\n\n    Args:\n        broker (RabbitBroker): The RabbitBroker instance to be used in testing.\n        with_real (bool, optional): If True, the original broker is returned; if False, components are replaced with\n            mock objects. Defaults to False.\n    \"\"\"\n    self.with_real = with_real\n    self.broker = broker\n</code></pre>"},{"location":"api/faststream/rabbit/test/build_message/","title":"build_message","text":""},{"location":"api/faststream/rabbit/test/build_message/#faststream.rabbit.test.build_message","title":"faststream.rabbit.test.build_message","text":"<pre><code>build_message(\n    message: AioPikaSendableMessage = \"\",\n    queue: Union[RabbitQueue, str] = \"\",\n    exchange: Union[RabbitExchange, str, None] = None,\n    *,\n    routing_key: str = \"\",\n    reply_to: Optional[str] = None,\n    **message_kwargs: Any\n) -&gt; PatchedMessage\n</code></pre> <p>Build a patched RabbitMQ message for testing.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>AioPikaSendableMessage</code> <p>The message content.</p> <code>''</code> <code>queue</code> <code>Union[RabbitQueue, str]</code> <p>The message queue.</p> <code>''</code> <code>exchange</code> <code>Union[RabbitExchange, str, None]</code> <p>The message exchange.</p> <code>None</code> <code>routing_key</code> <code>str</code> <p>The message routing key.</p> <code>''</code> <code>reply_to</code> <code>Optional[str]</code> <p>The reply-to queue.</p> <code>None</code> <code>**message_kwargs</code> <code>Any</code> <p>Additional message arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>PatchedMessage</code> <code>PatchedMessage</code> <p>A patched RabbitMQ message.</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/test.py</code> <pre><code>def build_message(\n    message: AioPikaSendableMessage = \"\",\n    queue: Union[RabbitQueue, str] = \"\",\n    exchange: Union[RabbitExchange, str, None] = None,\n    *,\n    routing_key: str = \"\",\n    reply_to: Optional[str] = None,\n    **message_kwargs: Any,\n) -&gt; PatchedMessage:\n\"\"\"\n    Build a patched RabbitMQ message for testing.\n\n    Args:\n        message (AioPikaSendableMessage): The message content.\n        queue (Union[RabbitQueue, str]): The message queue.\n        exchange (Union[RabbitExchange, str, None]): The message exchange.\n        routing_key (str): The message routing key.\n        reply_to (Optional[str]): The reply-to queue.\n        **message_kwargs (Any): Additional message arguments.\n\n    Returns:\n        PatchedMessage: A patched RabbitMQ message.\n    \"\"\"\n    que = RabbitQueue.validate(queue)\n    exch = RabbitExchange.validate(exchange)\n    msg = AioPikaParser.encode_message(\n        message=message,\n        persist=False,\n        reply_to=reply_to,\n        callback_queue=None,\n        **message_kwargs,\n    )\n\n    routing = routing_key or (que.name if que else \"\")\n\n    return PatchedMessage(\n        aiormq.abc.DeliveredMessage(\n            delivery=spec.Basic.Deliver(\n                exchange=exch.name if exch and exch.name else \"\",\n                routing_key=routing,\n            ),\n            header=ContentHeader(\n                properties=spec.Basic.Properties(\n                    content_type=msg.content_type,\n                    message_id=str(uuid4()),\n                    headers=msg.headers,\n                    reply_to=reply_to,\n                )\n            ),\n            body=msg.body,\n            channel=AsyncMock(),\n        )\n    )\n</code></pre>"},{"location":"api/faststream/utils/classes/Singleton/","title":"Singleton","text":""},{"location":"api/faststream/utils/classes/Singleton/#faststream.utils.classes.Singleton","title":"faststream.utils.classes.Singleton","text":"<p>A class to implement the Singleton design pattern.</p> <p>Attributes:</p> Name Type Description <code>_instance</code> <p>the single instance of the class</p> <p>Methods:</p> Name Description <code>__new__ </code> <p>creates a new instance of the class if it doesn't exist, otherwise returns the existing instance</p> <code>_drop </code> <p>sets the instance to None, allowing a new instance to be created</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/utils/classes.py</code> <pre><code>class Singleton:\n\"\"\"A class to implement the Singleton design pattern.\n\n    Attributes:\n        _instance : the single instance of the class\n\n    Methods:\n        __new__ : creates a new instance of the class if it doesn't exist, otherwise returns the existing instance\n        _drop : sets the instance to None, allowing a new instance to be created\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    _instance = None\n\n    def __new__(cls, *args: Any, **kwargs: Any) -&gt; \"Singleton\":\n\"\"\"Create a singleton instance of a class.\n\n        Args:\n            *args: Variable length argument list\n            **kwargs: Arbitrary keyword arguments\n\n        Returns:\n            The singleton instance of the class\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n        return cls._instance\n\n    @classmethod\n    def _drop(cls) -&gt; None:\n\"\"\"Drop the instance of a class.\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        cls._instance = None\n</code></pre>"},{"location":"api/faststream/utils/classes/Singleton/#faststream.utils.classes.Singleton-functions","title":"Functions","text":""},{"location":"api/faststream/utils/classes/Singleton/#faststream.utils.classes.Singleton.__new__","title":"__new__","text":"<pre><code>__new__(*args: Any, **kwargs: Any) -&gt; Singleton\n</code></pre> <p>Create a singleton instance of a class.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Any</code> <p>Variable length argument list</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Arbitrary keyword arguments</p> <code>{}</code> <p>Returns:</p> Type Description <code>Singleton</code> <p>The singleton instance of the class</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/utils/classes.py</code> <pre><code>def __new__(cls, *args: Any, **kwargs: Any) -&gt; \"Singleton\":\n\"\"\"Create a singleton instance of a class.\n\n    Args:\n        *args: Variable length argument list\n        **kwargs: Arbitrary keyword arguments\n\n    Returns:\n        The singleton instance of the class\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    if cls._instance is None:\n        cls._instance = super().__new__(cls)\n    return cls._instance\n</code></pre>"},{"location":"api/faststream/utils/context/main/ContextRepo/","title":"ContextRepo","text":""},{"location":"api/faststream/utils/context/main/ContextRepo/#faststream.utils.context.main.ContextRepo","title":"faststream.utils.context.main.ContextRepo","text":"<p>             Bases: <code>Singleton</code></p> <p>A class to represent a context repository.</p> <p>Attributes:</p> Name Type Description <code>_global_context</code> <p>dictionary representing the global context</p> <code>_scope_context</code> <p>dictionary representing the scope context</p> <p>Methods:</p> Name Description <code>__init__ </code> <p>initializes the ContextRepo object</p> <code>set_global </code> <p>sets a global context variable</p> <code>reset_global </code> <p>resets a global context variable</p> <code>set_local </code> <p>sets a local context variable</p> <code>reset_local </code> <p>resets a local context variable</p> <code>get_local </code> <p>gets the value of a local context variable</p> <code>clear </code> <p>clears the global and scope context</p> <code>get </code> <p>gets the value of a context variable</p> <code>__getattr__ </code> <p>gets the value of a context variable using attribute access</p> <code>context </code> <p>gets the current context as a dictionary</p> <code>scope </code> <p>creates a context scope for a specific key and value</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/utils/context/main.py</code> <pre><code>class ContextRepo(Singleton):\n\"\"\"A class to represent a context repository.\n\n    Attributes:\n        _global_context : dictionary representing the global context\n        _scope_context : dictionary representing the scope context\n\n    Methods:\n        __init__ : initializes the ContextRepo object\n        set_global : sets a global context variable\n        reset_global : resets a global context variable\n        set_local : sets a local context variable\n        reset_local : resets a local context variable\n        get_local : gets the value of a local context variable\n        clear : clears the global and scope context\n        get : gets the value of a context variable\n        __getattr__ : gets the value of a context variable using attribute access\n        context : gets the current context as a dictionary\n        scope : creates a context scope for a specific key and value\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    _global_context: AnyDict\n    _scope_context: Dict[str, ContextVar[Any]]\n\n    def __init__(self) -&gt; None:\n\"\"\"Initialize the class.\n\n        Attributes:\n            _global_context : a dictionary representing the global context\n            _scope_context : a dictionary representing the scope context\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        self._global_context = {\"context\": self}\n        self._scope_context = {}\n\n    def set_global(self, key: str, v: Any) -&gt; None:\n\"\"\"Sets a value in the global context.\n\n        Args:\n            key: The key to set in the global context.\n            v: The value to set.\n\n        Returns:\n            None.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        self._global_context[key] = v\n\n    def reset_global(self, key: str) -&gt; None:\n\"\"\"Resets a key in the global context.\n\n        Args:\n            key (str): The key to reset in the global context.\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        self._global_context.pop(key, None)\n\n    def set_local(self, key: str, value: T) -&gt; \"Token[T]\":\n\"\"\"Set a local context variable.\n\n        Args:\n            key (str): The key for the context variable.\n            value (T): The value to set for the context variable.\n\n        Returns:\n            Token[T]: A token representing the context variable.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        context_var = self._scope_context.get(key)\n        if context_var is None:\n            context_var = ContextVar(key, default=None)\n            self._scope_context[key] = context_var\n        return context_var.set(value)\n\n    def reset_local(self, key: str, tag: \"Token[Any]\") -&gt; None:\n\"\"\"Resets the local context for a given key.\n\n        Args:\n            key (str): The key to reset the local context for.\n            tag (Token[Any]): The tag associated with the local context.\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        self._scope_context[key].reset(tag)\n\n    def get_local(self, key: str) -&gt; Any:\n\"\"\"Get the value of a local variable.\n\n        Args:\n            key: The key of the local variable to retrieve.\n\n        Returns:\n            The value of the local variable.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        context_var = self._scope_context.get(key)\n        if context_var is not None:  # pragma: no branch\n            return context_var.get()\n\n    def clear(self) -&gt; None:\n        self._global_context = {\"context\": self}\n        self._scope_context = {}\n\n    def get(self, key: str) -&gt; Any:\n\"\"\"Get the value associated with a key.\n\n        Args:\n            key: The key to retrieve the value for.\n\n        Returns:\n            The value associated with the key.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        return self._global_context.get(key, self.get_local(key))\n\n    def __getattr__(self, __name: str) -&gt; Any:\n\"\"\"This is a function that is part of a class. It is used to get an attribute value using the `__getattr__` method.\n\n        Args:\n            __name: The name of the attribute to get.\n\n        Returns:\n            The value of the attribute.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        return self.get(__name)\n\n    @property\n    def context(self) -&gt; AnyDict:\n        return {\n            **self._global_context,\n            **{i: j.get() for i, j in self._scope_context.items()},\n        }\n\n    @contextmanager\n    def scope(self, key: str, value: Any) -&gt; Iterator[None]:\n\"\"\"Sets a local variable and yields control to the caller. After the caller is done, the local variable is reset.\n\n        Args:\n            key: The key of the local variable\n            value: The value to set the local variable to\n\n        Yields:\n            None\n\n        Returns:\n            An iterator that yields None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        token = self.set_local(key, value)\n        try:\n            yield\n        finally:\n            self.reset_local(key, token)\n</code></pre>"},{"location":"api/faststream/utils/context/main/ContextRepo/#faststream.utils.context.main.ContextRepo-attributes","title":"Attributes","text":""},{"location":"api/faststream/utils/context/main/ContextRepo/#faststream.utils.context.main.ContextRepo.context","title":"context  <code>property</code>","text":"<pre><code>context: AnyDict\n</code></pre>"},{"location":"api/faststream/utils/context/main/ContextRepo/#faststream.utils.context.main.ContextRepo-functions","title":"Functions","text":""},{"location":"api/faststream/utils/context/main/ContextRepo/#faststream.utils.context.main.ContextRepo.__getattr__","title":"__getattr__","text":"<pre><code>__getattr__(__name: str) -&gt; Any\n</code></pre> <p>This is a function that is part of a class. It is used to get an attribute value using the <code>__getattr__</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>__name</code> <code>str</code> <p>The name of the attribute to get.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The value of the attribute.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/utils/context/main.py</code> <pre><code>def __getattr__(self, __name: str) -&gt; Any:\n\"\"\"This is a function that is part of a class. It is used to get an attribute value using the `__getattr__` method.\n\n    Args:\n        __name: The name of the attribute to get.\n\n    Returns:\n        The value of the attribute.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    return self.get(__name)\n</code></pre>"},{"location":"api/faststream/utils/context/main/ContextRepo/#faststream.utils.context.main.ContextRepo.__init__","title":"__init__","text":"<pre><code>__init__() -&gt; None\n</code></pre> <p>Initialize the class.</p> <p>Attributes:</p> Name Type Description <code>_global_context</code> <p>a dictionary representing the global context</p> <code>_scope_context</code> <p>a dictionary representing the scope context</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/utils/context/main.py</code> <pre><code>def __init__(self) -&gt; None:\n\"\"\"Initialize the class.\n\n    Attributes:\n        _global_context : a dictionary representing the global context\n        _scope_context : a dictionary representing the scope context\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    self._global_context = {\"context\": self}\n    self._scope_context = {}\n</code></pre>"},{"location":"api/faststream/utils/context/main/ContextRepo/#faststream.utils.context.main.ContextRepo.clear","title":"clear","text":"<pre><code>clear() -&gt; None\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/utils/context/main.py</code> <pre><code>def clear(self) -&gt; None:\n    self._global_context = {\"context\": self}\n    self._scope_context = {}\n</code></pre>"},{"location":"api/faststream/utils/context/main/ContextRepo/#faststream.utils.context.main.ContextRepo.get","title":"get","text":"<pre><code>get(key: str) -&gt; Any\n</code></pre> <p>Get the value associated with a key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to retrieve the value for.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The value associated with the key.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/utils/context/main.py</code> <pre><code>def get(self, key: str) -&gt; Any:\n\"\"\"Get the value associated with a key.\n\n    Args:\n        key: The key to retrieve the value for.\n\n    Returns:\n        The value associated with the key.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    return self._global_context.get(key, self.get_local(key))\n</code></pre>"},{"location":"api/faststream/utils/context/main/ContextRepo/#faststream.utils.context.main.ContextRepo.get_local","title":"get_local","text":"<pre><code>get_local(key: str) -&gt; Any\n</code></pre> <p>Get the value of a local variable.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key of the local variable to retrieve.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The value of the local variable.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/utils/context/main.py</code> <pre><code>def get_local(self, key: str) -&gt; Any:\n\"\"\"Get the value of a local variable.\n\n    Args:\n        key: The key of the local variable to retrieve.\n\n    Returns:\n        The value of the local variable.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    context_var = self._scope_context.get(key)\n    if context_var is not None:  # pragma: no branch\n        return context_var.get()\n</code></pre>"},{"location":"api/faststream/utils/context/main/ContextRepo/#faststream.utils.context.main.ContextRepo.reset_global","title":"reset_global","text":"<pre><code>reset_global(key: str) -&gt; None\n</code></pre> <p>Resets a key in the global context.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to reset in the global context.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/utils/context/main.py</code> <pre><code>def reset_global(self, key: str) -&gt; None:\n\"\"\"Resets a key in the global context.\n\n    Args:\n        key (str): The key to reset in the global context.\n\n    Returns:\n        None\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    self._global_context.pop(key, None)\n</code></pre>"},{"location":"api/faststream/utils/context/main/ContextRepo/#faststream.utils.context.main.ContextRepo.reset_local","title":"reset_local","text":"<pre><code>reset_local(key: str, tag: Token[Any]) -&gt; None\n</code></pre> <p>Resets the local context for a given key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to reset the local context for.</p> required <code>tag</code> <code>Token[Any]</code> <p>The tag associated with the local context.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/utils/context/main.py</code> <pre><code>def reset_local(self, key: str, tag: \"Token[Any]\") -&gt; None:\n\"\"\"Resets the local context for a given key.\n\n    Args:\n        key (str): The key to reset the local context for.\n        tag (Token[Any]): The tag associated with the local context.\n\n    Returns:\n        None\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    self._scope_context[key].reset(tag)\n</code></pre>"},{"location":"api/faststream/utils/context/main/ContextRepo/#faststream.utils.context.main.ContextRepo.scope","title":"scope","text":"<pre><code>scope(key: str, value: Any) -&gt; Iterator[None]\n</code></pre> <p>Sets a local variable and yields control to the caller. After the caller is done, the local variable is reset.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key of the local variable</p> required <code>value</code> <code>Any</code> <p>The value to set the local variable to</p> required <p>Yields:</p> Type Description <code>Iterator[None]</code> <p>None</p> <p>Returns:</p> Type Description <code>Iterator[None]</code> <p>An iterator that yields None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/utils/context/main.py</code> <pre><code>@contextmanager\ndef scope(self, key: str, value: Any) -&gt; Iterator[None]:\n\"\"\"Sets a local variable and yields control to the caller. After the caller is done, the local variable is reset.\n\n    Args:\n        key: The key of the local variable\n        value: The value to set the local variable to\n\n    Yields:\n        None\n\n    Returns:\n        An iterator that yields None\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    token = self.set_local(key, value)\n    try:\n        yield\n    finally:\n        self.reset_local(key, token)\n</code></pre>"},{"location":"api/faststream/utils/context/main/ContextRepo/#faststream.utils.context.main.ContextRepo.set_global","title":"set_global","text":"<pre><code>set_global(key: str, v: Any) -&gt; None\n</code></pre> <p>Sets a value in the global context.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to set in the global context.</p> required <code>v</code> <code>Any</code> <p>The value to set.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/utils/context/main.py</code> <pre><code>def set_global(self, key: str, v: Any) -&gt; None:\n\"\"\"Sets a value in the global context.\n\n    Args:\n        key: The key to set in the global context.\n        v: The value to set.\n\n    Returns:\n        None.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    self._global_context[key] = v\n</code></pre>"},{"location":"api/faststream/utils/context/main/ContextRepo/#faststream.utils.context.main.ContextRepo.set_local","title":"set_local","text":"<pre><code>set_local(key: str, value: T) -&gt; Token[T]\n</code></pre> <p>Set a local context variable.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key for the context variable.</p> required <code>value</code> <code>T</code> <p>The value to set for the context variable.</p> required <p>Returns:</p> Type Description <code>Token[T]</code> <p>Token[T]: A token representing the context variable.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/utils/context/main.py</code> <pre><code>def set_local(self, key: str, value: T) -&gt; \"Token[T]\":\n\"\"\"Set a local context variable.\n\n    Args:\n        key (str): The key for the context variable.\n        value (T): The value to set for the context variable.\n\n    Returns:\n        Token[T]: A token representing the context variable.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    context_var = self._scope_context.get(key)\n    if context_var is None:\n        context_var = ContextVar(key, default=None)\n        self._scope_context[key] = context_var\n    return context_var.set(value)\n</code></pre>"},{"location":"api/faststream/utils/context/types/Context/","title":"Context","text":""},{"location":"api/faststream/utils/context/types/Context/#faststream.utils.context.types.Context","title":"faststream.utils.context.types.Context","text":"<p>             Bases: <code>CustomField</code></p> <p>A class to represent a context.</p> <p>Attributes:</p> Name Type Description <code>param_name</code> <p>name of the parameter</p> <p>Methods:</p> Name Description <code>__init__ </code> <p>constructor method</p> <code>use </code> <p>method to use the context</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/utils/context/types.py</code> <pre><code>class Context(CustomField):\n\"\"\"A class to represent a context.\n\n    Attributes:\n        param_name : name of the parameter\n\n    Methods:\n        __init__ : constructor method\n        use : method to use the context\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    param_name: str\n\n    def __init__(\n        self,\n        real_name: str = \"\",\n        *,\n        cast: bool = False,\n        default: Any = _empty,\n    ):\n\"\"\"Initialize the object.\n\n        Args:\n            real_name: The real name of the object.\n            cast: Whether to cast the object.\n            default: The default value of the object.\n\n        Raises:\n            TypeError: If the default value is not provided.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        self.name = real_name\n        self.default = default\n        super().__init__(\n            cast=cast,\n            required=(default is _empty),\n        )\n\n    def use(self, **kwargs: Any) -&gt; AnyDict:\n\"\"\"Use the given keyword arguments.\n\n        Args:\n            **kwargs: Keyword arguments to be used\n\n        Returns:\n            A dictionary containing the updated keyword arguments\n\n        Raises:\n            KeyError: If the parameter name is not found in the keyword arguments\n            AttributeError: If the parameter name is not a valid attribute\n\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        name = self.name or self.param_name\n\n        try:\n            kwargs[self.param_name] = resolve_context(name)\n        except (KeyError, AttributeError):\n            if self.required is False:\n                kwargs[self.param_name] = self.default\n\n        return kwargs\n</code></pre>"},{"location":"api/faststream/utils/context/types/Context/#faststream.utils.context.types.Context-attributes","title":"Attributes","text":""},{"location":"api/faststream/utils/context/types/Context/#faststream.utils.context.types.Context.default","title":"default  <code>instance-attribute</code>","text":"<pre><code>default = default\n</code></pre>"},{"location":"api/faststream/utils/context/types/Context/#faststream.utils.context.types.Context.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name = real_name\n</code></pre>"},{"location":"api/faststream/utils/context/types/Context/#faststream.utils.context.types.Context.param_name","title":"param_name  <code>instance-attribute</code>","text":"<pre><code>param_name: str\n</code></pre>"},{"location":"api/faststream/utils/context/types/Context/#faststream.utils.context.types.Context-functions","title":"Functions","text":""},{"location":"api/faststream/utils/context/types/Context/#faststream.utils.context.types.Context.__init__","title":"__init__","text":"<pre><code>__init__(\n    real_name: str = \"\",\n    *,\n    cast: bool = False,\n    default: Any = _empty\n)\n</code></pre> <p>Initialize the object.</p> <p>Parameters:</p> Name Type Description Default <code>real_name</code> <code>str</code> <p>The real name of the object.</p> <code>''</code> <code>cast</code> <code>bool</code> <p>Whether to cast the object.</p> <code>False</code> <code>default</code> <code>Any</code> <p>The default value of the object.</p> <code>_empty</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the default value is not provided.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/utils/context/types.py</code> <pre><code>def __init__(\n    self,\n    real_name: str = \"\",\n    *,\n    cast: bool = False,\n    default: Any = _empty,\n):\n\"\"\"Initialize the object.\n\n    Args:\n        real_name: The real name of the object.\n        cast: Whether to cast the object.\n        default: The default value of the object.\n\n    Raises:\n        TypeError: If the default value is not provided.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    self.name = real_name\n    self.default = default\n    super().__init__(\n        cast=cast,\n        required=(default is _empty),\n    )\n</code></pre>"},{"location":"api/faststream/utils/context/types/Context/#faststream.utils.context.types.Context.use","title":"use","text":"<pre><code>use(**kwargs: Any) -&gt; AnyDict\n</code></pre> <p>Use the given keyword arguments.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Keyword arguments to be used</p> <code>{}</code> <p>Returns:</p> Type Description <code>AnyDict</code> <p>A dictionary containing the updated keyword arguments</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the parameter name is not found in the keyword arguments</p> <code>AttributeError</code> <p>If the parameter name is not a valid attribute</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/utils/context/types.py</code> <pre><code>def use(self, **kwargs: Any) -&gt; AnyDict:\n\"\"\"Use the given keyword arguments.\n\n    Args:\n        **kwargs: Keyword arguments to be used\n\n    Returns:\n        A dictionary containing the updated keyword arguments\n\n    Raises:\n        KeyError: If the parameter name is not found in the keyword arguments\n        AttributeError: If the parameter name is not a valid attribute\n\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    name = self.name or self.param_name\n\n    try:\n        kwargs[self.param_name] = resolve_context(name)\n    except (KeyError, AttributeError):\n        if self.required is False:\n            kwargs[self.param_name] = self.default\n\n    return kwargs\n</code></pre>"},{"location":"api/faststream/utils/context/types/resolve_context/","title":"resolve_context","text":""},{"location":"api/faststream/utils/context/types/resolve_context/#faststream.utils.context.types.resolve_context","title":"faststream.utils.context.types.resolve_context","text":"<pre><code>resolve_context(argument: str) -&gt; Any\n</code></pre> <p>Resolve the context of an argument.</p> <p>Parameters:</p> Name Type Description Default <code>argument</code> <code>str</code> <p>A string representing the argument.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The resolved context of the argument.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If the attribute does not exist in the context.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/utils/context/types.py</code> <pre><code>def resolve_context(argument: str) -&gt; Any:\n\"\"\"Resolve the context of an argument.\n\n    Args:\n        argument: A string representing the argument.\n\n    Returns:\n        The resolved context of the argument.\n\n    Raises:\n        AttributeError: If the attribute does not exist in the context.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    keys = argument.split(\".\")\n\n    v = context.context[keys[0]]\n    for i in keys[1:]:\n        v = getattr(v, i)\n\n    return v\n</code></pre>"},{"location":"api/faststream/utils/data/filter_by_dict/","title":"filter_by_dict","text":""},{"location":"api/faststream/utils/data/filter_by_dict/#faststream.utils.data.filter_by_dict","title":"faststream.utils.data.filter_by_dict","text":"<pre><code>filter_by_dict(\n    typed_dict: Type[TypedDictCls], data: AnyDict\n) -&gt; TypedDictCls\n</code></pre> <p>Filter a dictionary based on a typed dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>typed_dict</code> <code>Type[TypedDictCls]</code> <p>The typed dictionary to filter by.</p> required <code>data</code> <code>AnyDict</code> <p>The dictionary to filter.</p> required <p>Returns:</p> Type Description <code>TypedDictCls</code> <p>A new instance of the typed dictionary with only the keys present in the data dictionary.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/utils/data.py</code> <pre><code>def filter_by_dict(typed_dict: Type[TypedDictCls], data: AnyDict) -&gt; TypedDictCls:\n\"\"\"Filter a dictionary based on a typed dictionary.\n\n    Args:\n        typed_dict: The typed dictionary to filter by.\n        data: The dictionary to filter.\n\n    Returns:\n        A new instance of the typed dictionary with only the keys present in the data dictionary.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    annotations = typed_dict.__annotations__\n    return typed_dict(  # type: ignore\n        {k: v for k, v in data.items() if k in annotations}\n    )\n</code></pre>"},{"location":"api/faststream/utils/functions/get_function_positional_arguments/","title":"get_function_positional_arguments","text":""},{"location":"api/faststream/utils/functions/get_function_positional_arguments/#faststream.utils.functions.get_function_positional_arguments","title":"faststream.utils.functions.get_function_positional_arguments","text":"<pre><code>get_function_positional_arguments(\n    func: AnyCallable,\n) -&gt; List[str]\n</code></pre> <p>Get the positional arguments of a function.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>AnyCallable</code> <p>The function to get the positional arguments from.</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>A list of strings representing the names of the positional arguments.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/utils/functions.py</code> <pre><code>def get_function_positional_arguments(func: AnyCallable) -&gt; List[str]:\n\"\"\"Get the positional arguments of a function.\n\n    Args:\n        func: The function to get the positional arguments from.\n\n    Returns:\n        A list of strings representing the names of the positional arguments.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    signature = inspect.signature(func)\n\n    arg_kinds = (\n        inspect.Parameter.POSITIONAL_ONLY,\n        inspect.Parameter.POSITIONAL_OR_KEYWORD,\n    )\n\n    return [\n        param.name for param in signature.parameters.values() if param.kind in arg_kinds\n    ]\n</code></pre>"},{"location":"api/faststream/utils/functions/to_async/","title":"to_async","text":""},{"location":"api/faststream/utils/functions/to_async/#faststream.utils.functions.to_async","title":"faststream.utils.functions.to_async","text":"<pre><code>to_async(\n    func: Union[\n        Callable[F_Spec, F_Return],\n        Callable[F_Spec, Awaitable[F_Return]],\n    ]\n) -&gt; Callable[F_Spec, Awaitable[F_Return]]\n</code></pre> <p>Converts a synchronous function to an asynchronous function.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Union[Callable[F_Spec, F_Return], Callable[F_Spec, Awaitable[F_Return]]]</code> <p>The synchronous function to be converted.</p> required <p>Returns:</p> Type Description <code>Callable[F_Spec, Awaitable[F_Return]]</code> <p>The asynchronous version of the input function.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/utils/functions.py</code> <pre><code>def to_async(\n    func: Union[\n        Callable[F_Spec, F_Return],\n        Callable[F_Spec, Awaitable[F_Return]],\n    ]\n) -&gt; Callable[F_Spec, Awaitable[F_Return]]:\n\"\"\"Converts a synchronous function to an asynchronous function.\n\n    Args:\n        func: The synchronous function to be converted.\n\n    Returns:\n        The asynchronous version of the input function.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    @wraps(func)\n    async def to_async_wrapper(*args: F_Spec.args, **kwargs: F_Spec.kwargs) -&gt; F_Return:\n\"\"\"Wraps a function to make it asynchronous.\n\n        Args:\n            func: The function to be wrapped\n            args: Positional arguments to be passed to the function\n            kwargs: Keyword arguments to be passed to the function\n\n        Returns:\n            The result of the wrapped function\n\n        Raises:\n            Any exceptions raised by the wrapped function\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        return await call_or_await(func, *args, **kwargs)\n\n    return to_async_wrapper\n</code></pre>"},{"location":"api/faststream/utils/no_cast/NoCast/","title":"NoCast","text":""},{"location":"api/faststream/utils/no_cast/NoCast/#faststream.utils.no_cast.NoCast","title":"faststream.utils.no_cast.NoCast","text":"<p>             Bases: <code>CustomField</code></p> <p>A class that represents a custom field without casting.</p> <p>Methods:</p> Name Description <code>__init__ </code> <p>Initializes the NoCast object.</p> <code>use </code> <p>Returns the provided keyword arguments as a dictionary.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/utils/no_cast.py</code> <pre><code>class NoCast(CustomField):\n\"\"\"A class that represents a custom field without casting.\n\n    Methods:\n        __init__ : Initializes the NoCast object.\n        use : Returns the provided keyword arguments as a dictionary.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        super().__init__(cast=False)\n\n    def use(self, **kwargs: Any) -&gt; AnyDict:\n\"\"\"Return a dictionary containing the keyword arguments passed to the function.\n\n        Args:\n            **kwargs: Keyword arguments\n\n        Returns:\n            Dictionary containing the keyword arguments\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        return kwargs\n</code></pre>"},{"location":"api/faststream/utils/no_cast/NoCast/#faststream.utils.no_cast.NoCast-functions","title":"Functions","text":""},{"location":"api/faststream/utils/no_cast/NoCast/#faststream.utils.no_cast.NoCast.__init__","title":"__init__","text":"<pre><code>__init__() -&gt; None\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/utils/no_cast.py</code> <pre><code>def __init__(self) -&gt; None:\n    super().__init__(cast=False)\n</code></pre>"},{"location":"api/faststream/utils/no_cast/NoCast/#faststream.utils.no_cast.NoCast.use","title":"use","text":"<pre><code>use(**kwargs: Any) -&gt; AnyDict\n</code></pre> <p>Return a dictionary containing the keyword arguments passed to the function.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Keyword arguments</p> <code>{}</code> <p>Returns:</p> Type Description <code>AnyDict</code> <p>Dictionary containing the keyword arguments</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/utils/no_cast.py</code> <pre><code>def use(self, **kwargs: Any) -&gt; AnyDict:\n\"\"\"Return a dictionary containing the keyword arguments passed to the function.\n\n    Args:\n        **kwargs: Keyword arguments\n\n    Returns:\n        Dictionary containing the keyword arguments\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    return kwargs\n</code></pre>"},{"location":"getting-started/","title":"QUICK START","text":"<p>Install using <code>pip</code>:</p> KafkaRabbitMQ <pre><code>pip install \"faststream[kafka]\"\n</code></pre> <p>Tip</p> <p>To start a new project we need a test broker container <pre><code>docker run -d --rm -p 9092:9092 --name test-mq \\\n-e KAFKA_ENABLE_KRAFT=yes \\\n-e KAFKA_CFG_NODE_ID=1 \\\n-e KAFKA_CFG_PROCESS_ROLES=broker,controller \\\n-e KAFKA_CFG_CONTROLLER_LISTENER_NAMES=CONTROLLER \\\n-e KAFKA_CFG_LISTENERS=PLAINTEXT://:9092,CONTROLLER://:9093 \\\n-e KAFKA_CFG_LISTENER_SECURITY_PROTOCOL_MAP=CONTROLLER:PLAINTEXT,PLAINTEXT:PLAINTEXT \\\n-e KAFKA_CFG_ADVERTISED_LISTENERS=PLAINTEXT://127.0.0.1:9092 \\\n-e KAFKA_BROKER_ID=1 \\\n-e KAFKA_CFG_CONTROLLER_QUORUM_VOTERS=1@kafka:9093 \\\n-e ALLOW_PLAINTEXT_LISTENER=yes \\\nbitnami/kafka:3.5.0\n</code></pre></p> <pre><code>pip install \"faststream[rabbit]\"\n</code></pre> <p>Tip</p> <p>To start a new project we need a test broker container <pre><code>docker run -d --rm -p 5672:5672 --name test-mq rabbitmq:alpine\n</code></pre></p>"},{"location":"getting-started/#basic-usage","title":"Basic usage","text":"<p>To create a basic application, add the following code to a new file (e.g. <code>serve.py</code>):</p> KafkaRabbitMQ serve.py<pre><code>from faststream import FastStream\nfrom faststream.kafka import KafkaBroker\n\nbroker = KafkaBroker(\"localhost:9092\")\n\napp = FastStream(broker)\n\n\n@broker.subscriber(\"test\")\nasync def base_handler(body):\n    print(body)\n</code></pre> serve.py<pre><code>from faststream import FastStream\nfrom faststream.rabbit import RabbitBroker\n\nbroker = RabbitBroker(\"amqp://guest:guest@localhost:5672/\")\n\napp = FastStream(broker)\n\n\n@broker.subscriber(\"test\")\nasync def base_handler(body):\n    print(body)\n</code></pre> <p>And just run this command:</p> <pre><code>faststream run serve:app\n</code></pre> <p>After running the command you should see the following output:</p> <pre><code>INFO     - FastStream app starting...\nINFO     - test |            - `BaseHandler` waiting for messages\nINFO     - FastStream app started successfully! To exit press CTRL+C\n</code></pre> <p>Enjoy your new development experience!</p> Don't forget to stop the test broker container <pre><code>docker container stop test-mq\n</code></pre>"},{"location":"getting-started/logging/","title":"Application and Access Logging","text":"<p>FastStream uses 2 previously configured loggers:</p> <ul> <li><code>faststream</code> - using by <code>FastStream</code> app</li> <li><code>faststream.access</code> - using by broker</li> </ul>"},{"location":"getting-started/logging/#logging-requests","title":"Logging requests","text":"<p>To log requests, it is strongly recommended to use the <code>access_logger</code> of your broker, since it is available from the Context of your application.</p> <pre><code>from faststream import Logger\nfrom faststream.rabbit import RabbitBroker\n\nbroker = RabbitBroker()\n\n@broker.subscriber(\"test\")\nasync def func(logger: Logger):\n    logger.info(\"message received\")\n</code></pre> <p>This approach has several advantages:</p> <ul> <li>the logger already contains the request context: message ID, broker-based params</li> <li>by replacing the <code>logger</code> at broker initializing, you will automatically replace all loggers inside your functions</li> </ul>"},{"location":"getting-started/logging/#logging-levels","title":"Logging levels","text":"<p>If you use the FastStream CLI, you can change the current logging level of the entire application directly from the command line.</p> <p>The <code>--log-level</code> flag sets the current logging level for both a broker and a <code>FastStream</code> app. This way you can configure the levels of not only default loggers, but also your own, if you use them inside FastStream</p> <pre><code>faststream run serve:app --log-level debug\n</code></pre> <p>If you want to completely disable the default logging of <code>Propan</code>, you can set <code>logger=None</code></p> <pre><code>from faststream import FastStream\nfrom faststream.rabbit import RabbitBroker\n\nbroker = RabbitBroker(logger=None) # disables broker logs\napp = FastStream(broker, logger=None) # disables application logs\n</code></pre> <p>Warning</p> <p>Be careful: the <code>logger</code> that you get from the context will also have the value `None' if you turn off the broker logging</p> <p>If you don't want to lose access to the `logger' inside your context, but want to get rid of the default logs FastStream, you can lower the level of logs that the broker publishes itself.</p> <pre><code>import logging\nfrom faststream.rabbit import RabbitBroker\n\n# sets the broker logs to the DEBUG level\nbroker = RabbitBroker(log_level=logging.DEBUG)\n</code></pre>"},{"location":"getting-started/logging/#formatting-logs","title":"Formatting logs","text":"<p>If you are not satisfied with the current format of your application logs, you can change it directly in your broker's constructor</p> <pre><code>from faststream.rabbit import RabbitBroker\nbroker = RabbitBroker(log_fmt=\"%(asctime)s %(levelname)s - %(message)s\")\n</code></pre>"},{"location":"getting-started/logging/#using-your-own-loggers","title":"Using your own loggers","text":"<p>Since FastStream works with the standard <code>logging.Logger</code> object, you can initiate an application and a broker using your own logger</p> <pre><code>import logging\nfrom faststream import FastStream\nfrom faststream.rabbit import RabbitBroker\n\nlogger = logging.getLogger(\"my_logger\")\n\nbroker = RabbitBroker(logger=logger)\napp = FastStream(broker, logger=logger)\n</code></pre> <p>Doing so, you will lose information about the context of the current request. However, you can get it directly from the context anywhere in your code:</p> <pre><code>from faststream import context\nlog_context: dict[str, str] = context.get_local(\"log_context\")\n</code></pre>"},{"location":"getting-started/logging/#logger-access","title":"Logger access","text":"<p>If you want to override default loggers behavior, you can access them directly via <code>logging</code>:</p> <pre><code>import logging\nlogger = logging.getLogger(\"faststream\")\naccess_logger = logging.getLogger(\"faststream.access\")\n</code></pre> <p>Or by importing them from FastStream</p> <pre><code>from faststream.log import access_logger, logger\n</code></pre>"},{"location":"getting-started/asyncapi/custom/","title":"Customize AsyncAPI Schema","text":"<ul> <li>setup custom FastStream app info</li> <li>setup custom broker information</li> <li>setup custom handler information</li> <li>setup payload information via pydantic model</li> <li>generate shema.json, customize manually and serve it instead</li> </ul>"},{"location":"getting-started/asyncapi/export/","title":"How to Generate and Serve AsyncAPI Documentation","text":"<p>In this guide, let's explore how to generate and serve AsyncAPI documentation for our FastStream application.</p>"},{"location":"getting-started/asyncapi/export/#writing-the-faststream-application","title":"Writing the FastStream Application","text":"<p>Here's an example Python application using FastStream that consumes data from a topic, increments the value, and outputs the data to another topic. Save it in a file called <code>basic.py</code>.</p> <pre><code>from pydantic import BaseModel, Field, NonNegativeFloat\n\nfrom faststream import FastStream, Logger\nfrom faststream.kafka import KafkaBroker\n\n\nclass DataBasic(BaseModel):\n    data: NonNegativeFloat = Field(\n        ..., examples=[0.5], description=\"Float data example\"\n    )\n\n\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\n\n\n@broker.publisher(\"output_data\")\n@broker.subscriber(\"input_data\")\nasync def on_input_data(msg: DataBasic, logger: Logger) -&gt; DataBasic:\n    logger.info(msg)\n    return DataBasic(data=msg.data + 1.0)\n</code></pre>"},{"location":"getting-started/asyncapi/export/#generating-the-asyncapi-specification","title":"Generating the AsyncAPI Specification","text":"<p>Now that we have a FastStream application, we can proceed with generating the AsyncAPI specification using a CLI command.</p> <pre><code>faststream docs gen basic:app\n</code></pre> <p>The above command will generate the AsyncAPI specification and save it in a file called <code>asyncapi.json</code>.</p> <p>If you prefer <code>yaml</code> instead of <code>json</code>, please run the following command to generate <code>asyncapi.yaml</code>.</p> <p>Note</p> <p>This case, please install dependency to work with YAML file format at first</p> <pre><code>pip install PyYAML\n</code></pre> <pre><code>faststream docs gen --yaml basic:app\n</code></pre>"},{"location":"getting-started/asyncapi/hosting/","title":"Serving the AsyncAPI Documentation","text":"<p>FastStream provides a separate command to serve the AsyncAPI documentation.</p> <pre><code>faststream docs serve basic:app\n</code></pre> <p>In the above command, we are providing the path in the format of <code>python_module:FastStream</code>. Alternatively, you can also specify <code>asyncapi.json</code> or <code>asyncapi.yaml</code> to serve the AsyncAPI documentation.</p> <pre><code>faststream docs serve asyncapi.json\n# or\nfaststream docs serve asyncapi.yaml\n</code></pre> <p>After running the command, it should serve AsyncAPI documentation on port 8000 and display the following logs in the terminal.</p> <pre><code>INFO:     Started server process [2364992]\nINFO:     Waiting for application startup.\nINFO:     Application startup complete.\nINFO:     Uvicorn running on http://localhost:8000 (Press CTRL+C to quit)\n</code></pre> <p>And see the following page at your browser</p> ShortExpand <p></p> <p></p> <p>Tip</p> <p>The command also offers options to serve the documentation on a different host and port.</p>"},{"location":"getting-started/cli/","title":"CLI","text":"<p>https://lancetnik.github.io/Propan/getting_started/2_cli/</p> <ul> <li>multiprocessing</li> <li>AsyncAPI documentation (with references to asyncapi pages)</li> </ul>"},{"location":"getting-started/config/","title":"Settings and Environment Variables","text":"<p>In many cases your application could need some external settings or configurations, for example Message Broker connection or database credentials.</p> <p>For this reason it's common to provide them in environment variables that are read by the application.</p>"},{"location":"getting-started/config/#pydantic-settings","title":"Pydantic <code>Settings</code>","text":"<p>Fortunately, Pydantic provides a great utility to handle these settings coming from environment variables with Pydantic: Settings management.</p>"},{"location":"getting-started/config/#install-pydantic-settings","title":"Install <code>pydantic-settings</code>","text":"<p>First, install the <code>pydantic-settings</code> package:</p> <pre><code>pip install pydantic-settings\n</code></pre> <p>Info</p> <p>In Pydantic v1 it came included with the main package. Now it is distributed as this independent package so that you can choose to install it or not if you don't need that functionality.</p>"},{"location":"getting-started/config/#create-the-settings-object","title":"Create the <code>Settings</code> object","text":"<p>Import <code>BaseSettings</code> from Pydantic and create a sub-class, very much like with a Pydantic model.</p> <p>The same way as with Pydantic models, you declare class attributes with type annotations, and possibly default values.</p> <p>You can use all the same validation features and tools you use for Pydantic models, like different data types and additional validations with <code>Field()</code>.</p> Pydantic v2Pydantic v1 config.py<pre><code>from pydantic_settings import BaseSettings\nclass Settings(BaseSettings):\nurl: str = \"\"\n    queue: str = \"test-queue\"\n\n\nsettings = Settings()\n</code></pre> <p>Info</p> <p>In Pydantic v1 you would import <code>BaseSettings</code> directly from <code>pydantic</code> instead of from <code>pydantic_settings</code>.</p> config.py<pre><code>from pydantic import BaseSettings\nclass Settings(BaseSettings):\nurl: str = \"\"\n    queue: str = \"test-queue\"\n\n\nsettings = Settings()\n</code></pre> <p>Then, when you create an instance of that <code>Settings</code> class (in this case, in the <code>settings</code> object), Pydantic will read the environment variables in a case-insensitive way, so, an upper-case variable <code>APP_NAME</code> will still be read for the attribute <code>app_name</code>.</p> <p>Next it will convert and validate the data. So, when you use that <code>settings</code> object, you will have data of the types you declared (e.g. <code>items_per_user</code> will be an <code>int</code>).</p>"},{"location":"getting-started/config/#use-the-settings","title":"Use the <code>settings</code>","text":"<p>Then you can use the new <code>settings</code> object in your application:</p> serve.py<pre><code>import os\n\nfrom pydantic_settings import BaseSettings\nfrom faststream import FastStream\nfrom faststream.rabbit import RabbitBroker\n\n\nclass Settings(BaseSettings):\nurl: str\n    queue: str = \"test-queue\"\n\n\nsettings = Settings(_env_file=os.getenv(\"ENV\", \".env\"))\nbroker = RabbitBroker(settings.url)\napp = FastStream(broker)\n\n\n@broker.subscriber(settings.queue)\nasync def handler(msg):\n    ...\n</code></pre>"},{"location":"getting-started/config/#run-the-application","title":"Run the application","text":"<p>Next, you would run the application passing the configurations as environment variables, for example you could set an <code>URL</code>:</p> <pre><code>URL=\"amqp://guest:guest@localhost:5672\" faststream run serve:app\n</code></pre> <p>Tip</p> <p>To set multiple env vars for a single command just separate them with a space, and put them all before the command.</p>"},{"location":"getting-started/config/#reading-a-env-file","title":"Reading a <code>.env</code> file","text":"<p>If you have many settings that possibly change a lot, maybe in different environments, it might be useful to put them on a file and then read them from it as if they were environment variables.</p> <p>This practice is common enough that it has a name, these environment variables are commonly placed in a file <code>.env</code>, and the file is called a \"dotenv\".</p> <p>Tip</p> <p>A file starting with a dot (<code>.</code>) is a hidden file in Unix-like systems, like Linux and macOS.</p> <p>But a dotenv file doesn't really have to have that exact filename.</p> <p>Pydantic has support for reading from these types of files using an external library. You can read more at Pydantic Settings: Dotenv (.env) support.</p> <p>Tip</p> <p>For this to work, you need to <code>pip install python-dotenv</code>.</p>"},{"location":"getting-started/config/#the-env-file","title":"The <code>.env</code> file","text":"<p>You could have a <code>.env</code> file with:</p> <pre><code>URL=\"amqp://guest:guest@localhost:5672\"\nQUEUE=\"test-queue\"\n</code></pre>"},{"location":"getting-started/config/#read-settings-from-env","title":"Read settings from <code>.env</code>","text":"<p>And then update your <code>config.py</code> with:</p> <pre><code>import os\nfrom pydantic import BaseSettings\n\n\nclass Settings(BaseSettings):\n    url: str\n    queue: str = \"test-queue\"\n\n\nsettings = Settings(_env_file=os.getenv(\"ENV\", \".env\"))\n</code></pre> <p>This way you are able to specify different <code>.env</code> files right from your terminal. It can be extremely helpful in testing/production cases.</p> <p>Note</p> <p>By default Pydantic tries to find <code>.env</code> field in this case, but it is OK, if there are no any <code>.env</code> file. Pydantic just use a default fields values.</p>"},{"location":"getting-started/config/#choose-env-file-at-start","title":"Choose <code>.env</code> file at start","text":"<p>Now you can run the apllication with various <code>.env</code> files like:</p> <pre><code>ENV=.local.env faststream run serve:app\n</code></pre> <p>Or, probably, production</p> <pre><code>ENV=.production.env faststream run serve:app\n</code></pre> <p>Or even test environment</p> <pre><code>ENV=.test.env pytest\n</code></pre>"},{"location":"getting-started/context/","title":"Application Context","text":"<p>FastStreams has it's own Dependency Injection container - Context, using to store application runtime object and variables.</p> <p>With this container you are able to get access to application scope or message processing scope objects both. This functional is pretty close to <code>Depends</code> usage.</p> KafkaRabbitMQ <pre><code>from faststream import Context, FastStream\nfrom faststream.kafka import KafkaBroker\n\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\n\n\n@broker.subscriber(\"test\")\nasync def base_handler(\n    body: str,\nmessage=Context(),  # get access to raw message\n):\n    ...\n</code></pre> <pre><code>from faststream import Context, FastStream\nfrom faststream.rabbit import RabbitBroker\n\nbroker = RabbitBroker(\"amqp://guest:guest@localhost:5672/\")\napp = FastStream(broker)\n\n\n@broker.subscriber(\"test\")\nasync def base_handler(\n    body: str,\nmessage=Context(),  # get access to raw message\n):\n    ...\n</code></pre> <p>But, with the <code>Annotated</code> python feature usage it is much closer to <code>pytest.fixture</code>.</p> KafkaRabbitMQ <pre><code>from typing import Annotated\nfrom faststream import Context, FastStream\nfrom faststream.kafka import KafkaBroker, KafkaMessage\n\nMessage = Annotated[KafkaMessage, Context()]\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\n\n\n@broker.subscriber(\"test\")\nasync def base_handler(\n    body: str,\nmessage: Message,  # get access to raw message\n):\n    ...\n</code></pre> <pre><code>from typing import Annotated\nfrom faststream import Context, FastStream\nfrom faststream.rabbit import RabbitBroker, RabbitMessage\n\nMessage = Annotated[RabbitMessage, Context()]\nbroker = RabbitBroker(\"amqp://guest:guest@localhost:5672/\")\napp = FastStream(broker)\n\n\n@broker.subscriber(\"test\")\nasync def base_handler(\n    body: str,\nmessage: Message,  # get access to raw message\n):\n    ...\n</code></pre>"},{"location":"getting-started/context/#usages","title":"Usages","text":"<p>By default, the context is available in the same place as <code>Depends</code>:</p> <ul> <li>at lifespan hooks</li> <li>message subscribers</li> <li>nested dependencies</li> </ul>"},{"location":"getting-started/context/#regular-functions-compatibility","title":"Regular functions compatibility","text":"<p>To use context at other functions use the decorator <code>@apply_types</code>. This case, the called function context will correspond to the context of the event handler from which it was called.</p> <pre><code>from faststream import Context, apply_types\n\n\n@broker.subscriber(\"test\")\nasync def handler(body: dict):\nnested_func()\n@apply_types\ndef nested_func(body: dict, logger=Context()):\nlogger.info(body)\n</code></pre> <p>In the example above, we did not pass the <code>logger</code> function at calling, it was placed out of context.</p>"},{"location":"getting-started/context/custom/","title":"Context fields Declaration","text":"<p>Also, you are able to store your own objects in the <code>Context</code> for sure.</p>"},{"location":"getting-started/context/custom/#global","title":"Global","text":"<p>To declare an Application-level context fields, you need to call the <code>context.set_global</code> method with an indication of the key by which the object will be placed in the context.</p> KafkaRabbitMQ <pre><code>from faststream import FastStream, ContextRepo, Context\nfrom faststream.kafka import KafkaBroker\n\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\n\n\n@app.on_startup\nasync def set_global(context: ContextRepo):\ncontext.set_global(\"secret\", \"my-perfect-secret\")\n</code></pre> <pre><code>from faststream import FastStream, ContextRepo, Context\nfrom faststream.rabbit import RabbitBroker\n\nbroker = RabbitBroker(\"amqp://guest:guest@localhost:5672/\")\napp = FastStream(broker)\n\n\n@app.on_startup\nasync def set_global(context: ContextRepo):\ncontext.set_global(\"secret\", \"my-perfect-secret\")\n</code></pre> <p>After you can get access to your <code>secret</code> fields in a regular way:</p> KafkaRabbitMQ <pre><code>@broker.subscriber(\"test-topic\")\nasync def handle(\n    msg: str,\nsecret: str=Context(),\n):\n    assert secret == \"my-perfect-secret\" # pragma: allowlist secret\n</code></pre> <pre><code>@broker.subscriber(\"test-queue\")\nasync def handle(\n    msg: str,\nsecret: str=Context(),\n):\n    assert secret == \"my-perfect-secret\" # pragma: allowlist secret\n</code></pre> <p>In this case, the field becomes a global context field: it does not depend on the current message handler (unlike <code>message</code>)</p> <p>To remove a field from the context use the <code>reset_global</code> method</p> <pre><code>context.reset_global(\"my_key\")\n</code></pre>"},{"location":"getting-started/context/custom/#local","title":"Local","text":"<p>To set the local context (it will be available at the message processing scope), use the context manager <code>scope</code></p> KafkaRabbitMQ <pre><code>from faststream import Context, FastStream, apply_types\nfrom faststream.kafka import KafkaBroker\nfrom faststream.kafka.annotations import ContextRepo, KafkaMessage\n\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\n\n\n@broker.subscriber(\"test-topic\")\nasync def handle(\n    msg: str,\n    message: KafkaMessage,\n    context: ContextRepo,\n):\nwith context.scope(\"correlation_id\", message.correlation_id):\ncall()\n\n\n@apply_types\ndef call(\nmessage: KafkaMessage,\ncorrelation_id=Context(),\n):\n    assert correlation_id == message.correlation_id\n</code></pre> <pre><code>from faststream import Context, FastStream, apply_types\nfrom faststream.rabbit import RabbitBroker\nfrom faststream.rabbit.annotations import ContextRepo, RabbitMessage\n\nbroker = RabbitBroker(\"amqp://guest:guest@localhost:5672/\")\napp = FastStream(broker)\n\n\n@broker.subscriber(\"test-queue\")\nasync def handle(\n    msg: str,\n    message: RabbitMessage,\n    context: ContextRepo,\n):\nwith context.scope(\"correlation_id\", message.correlation_id):\ncall()\n\n\n@apply_types\ndef call(\nmessage: RabbitMessage,\ncorrelation_id=Context(),\n):\n    assert correlation_id == message.correlation_id\n</code></pre> <p>Also, you can set the context yourself: then it will act within the current call stack until you clear it.</p> KafkaRabbitMQ <pre><code>from faststream import Context, FastStream, apply_types, context\nfrom faststream.kafka import KafkaBroker\nfrom faststream.kafka.annotations import KafkaMessage\n\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\n\n\n@broker.subscriber(\"test-topic\")\nasync def handle(\n    msg: str,\n    message: KafkaMessage,\n):\ncontext.set_local(\"correlation_id\", message.correlation_id)\ncall()\n\n\n@apply_types\ndef call(\n    message: KafkaMessage,\n    correlation_id=Context(),\n):\n    assert correlation_id == message.correlation_id\ncontext.reset_local(\"correlation_id\")\n</code></pre> <pre><code>from faststream import Context, FastStream, apply_types, context\nfrom faststream.rabbit import RabbitBroker\nfrom faststream.rabbit.annotations import RabbitMessage\n\nbroker = RabbitBroker(\"amqp://guest:guest@localhost:5672/\")\napp = FastStream(broker)\n\n\n@broker.subscriber(\"test-queue\")\nasync def handle(\n    msg: str,\n    message: RabbitMessage,\n):\ncontext.set_local(\"correlation_id\", message.correlation_id)\ncall()\n\n\n@apply_types\ndef call(\n    message: RabbitMessage,\n    correlation_id=Context(),\n):\n    assert correlation_id == message.correlation_id\ncontext.reset_local(\"correlation_id\")\n</code></pre>"},{"location":"getting-started/context/existed/","title":"Existing fields","text":"<p>Context already contains some global objects that you can always access:</p> <ul> <li>broker - current broker</li> <li>context - the context itself, in which you can write your own fields</li> <li>logger - logger used for your broker (tags messages with message_id)</li> <li>message - raw message (if you need access to it)</li> </ul> <p>At the same time, thanks to <code>contextlib.ContextVar</code>, message is local for you current consumer scope.</p>"},{"location":"getting-started/context/existed/#access-to-context-fields","title":"Access to context fields","text":"<p>By default the context searches for an object based on the argument name.</p> KafkaRabbitMQ <pre><code>from faststream import Context, FastStream\nfrom faststream.kafka import KafkaBroker\n\n\nbroker_object = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker_object)\n\n\n@broker_object.subscriber(\"test-topic\")\nasync def handle(\n    msg: str,\nlogger=Context(),\nmessage=Context(),\nbroker=Context(),\ncontext=Context(),\n):\n    logger.info(message)\n    await broker.publish(\"test\", \"response\")\n</code></pre> <pre><code>from faststream import Context, FastStream\nfrom faststream.rabbit import RabbitBroker\n\n\nbroker_object = RabbitBroker(\"amqp://guest:guest@localhost:5672/\")\napp = FastStream(broker_object)\n\n\n@broker_object.subscriber(\"test-queue\")\nasync def handle(\n    msg: str,\nlogger=Context(),\nmessage=Context(),\nbroker=Context(),\ncontext=Context(),\n):\n    logger.info(message)\n    await broker.publish(\"test\", \"response\")\n</code></pre>"},{"location":"getting-started/context/existed/#annotated-aliases","title":"Annotated aliases","text":"<p>Also, FastStream has already created <code>Annotated</code> aliases to provide you comfortable access to already existing objects. You can import them right from <code>faststream</code> or your broker-specific modules:</p> <ul> <li>Shared aliases</li> </ul> <pre><code>from faststream import Logger, ContextRepo\n</code></pre> <ul> <li>Kafka aliases</li> </ul> <pre><code>from faststream.kafka.annotations import (\n    Logger, ContextRepo, KafkaMessage, KafkaBroker, KafkaProducer\n)\n</code></pre> <ul> <li>RabbitMQ aliases</li> </ul> <pre><code>from faststream.rabbit.annotations import (\n    Logger, ContextRepo, RabbitMessage, RabbitBroker, RabbitProducer\n)\n</code></pre> <p>To apply them, just import and use as a subscriber argument annotation</p> KafkaRabbitMQ <pre><code>from faststream import Context, FastStream\nfrom faststream.kafka import KafkaBroker\nfrom faststream.kafka.annotations import (\nContextRepo,\nKafkaMessage,\nLogger,\nKafkaBroker as BrokerAnnotation,\n)\nbroker_object = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker_object)\n\n\n@broker_object.subscriber(\"response-topic\")\nasync def handle_response(\n    msg: str,\nlogger: Logger,\nmessage: KafkaMessage,\ncontext: ContextRepo,\nbroker: BrokerAnnotation,\n):\n    logger.info(message)\n    await broker.publish(\"test\", \"response\")\n</code></pre> <pre><code>from faststream import Context, FastStream\nfrom faststream.rabbit import RabbitBroker\nfrom faststream.rabbit.annotations import (\nContextRepo,\nLogger,\nRabbitMessage,\nRabbitBroker as BrokerAnnotation,\n)\nbroker_object = RabbitBroker(\"amqp://guest:guest@localhost:5672/\")\napp = FastStream(broker_object)\n\n\n@broker_object.subscriber(\"response-queue\")\nasync def handle_response(\n    msg: str,\nlogger: Logger,\nmessage: RabbitMessage,\ncontext: ContextRepo,\nbroker: BrokerAnnotation,\n):\n    logger.info(message)\n    await broker.publish(\"test\", \"response\")\n</code></pre>"},{"location":"getting-started/context/extra/","title":"Extra Options","text":"<ul> <li>default</li> <li>cast</li> </ul>"},{"location":"getting-started/context/fields/","title":"Access by name","text":"<p>Sometimes you may need to use a different name for the argument (not the one under which it is stored in the context). Or even get access not to the whole object, but only to its field or method. To do this, just specify by name what you want to get - and the context will provide you with the wished object.</p> KafkaRabbitMQ <pre><code>from faststream import Context, FastStream\nfrom faststream.kafka import KafkaBroker, KafkaMessage\n\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\n\n\n@broker.subscriber(\"test-topic\")\nasync def handle(\nmsg: KafkaMessage = Context(\"message\"),\ncorrelation_id: str = Context(\"message.correlation_id\"),\n):\n    assert msg.correlation_id == correlation_id\n</code></pre> <pre><code>from faststream import Context, FastStream\nfrom faststream.rabbit import RabbitBroker, RabbitMessage\n\nbroker = RabbitBroker(\"amqp://guest:guest@localhost:5672/\")\napp = FastStream(broker)\n\n\n@broker.subscriber(\"test-queue\")\nasync def handle(\nmsg: RabbitMessage = Context(\"message\"),\ncorrelation_id: str = Context(\"message.correlation_id\"),\n):\n    assert msg.correlation_id == correlation_id\n</code></pre> <p>This way you can get access to context object by its' name</p> KafkaRabbitMQ <pre><code>    msg: KafkaMessage = Context(\"message\"),\n</code></pre> <pre><code>    msg: RabbitMessage = Context(\"message\"),\n</code></pre> <p>This way you can get access to context object specific field</p> KafkaRabbitMQ <pre><code>    correlation_id: str = Context(\"message.correlation_id\"),\n</code></pre> <pre><code>    correlation_id: str = Context(\"message.correlation_id\"),\n</code></pre>"},{"location":"getting-started/contributing/CONTRIBUTING/","title":"Development","text":"<p>If you already cloned the repository and you know that you need to deep dive in the code, here are some guidelines to set up your environment.</p>"},{"location":"getting-started/contributing/CONTRIBUTING/#virtual-environment-with-venv","title":"Virtual environment with <code>venv</code>","text":"<p>You can create a virtual environment in a directory using Python's <code>venv</code> module:</p> <pre><code>python -m venv venv\n</code></pre> <p>That will create a directory <code>./venv/</code> with the Python binaries and then you will be able to install packages for that isolated environment.</p>"},{"location":"getting-started/contributing/CONTRIBUTING/#activate-the-environment","title":"Activate the environment","text":"<p>Activate the new environment with:</p> <pre><code>source ./venv/bin/activate\n</code></pre> <p>Make sure you have the latest pip version on your virtual environment to</p> <pre><code>python -m pip install --upgrade pip\n</code></pre>"},{"location":"getting-started/contributing/CONTRIBUTING/#pip","title":"pip","text":"<p>After activating the environment as described above:</p> <pre><code>pip install -e \".[dev]\"\n</code></pre> <p>It will install all the dependencies and your local FastStream in your local environment.</p>"},{"location":"getting-started/contributing/CONTRIBUTING/#using-your-local-faststream","title":"Using your local FastStream","text":"<p>If you create a Python file that imports and uses FastStream, and run it with the Python from your local environment, it will use your local FastStream source code.</p> <p>And if you update that local FastStream source code, as it is installed with <code>-e</code>, when you run that Python file again, it will use the fresh version of FastStream you just edited.</p> <p>That way, you don't have to \"install\" your local version to be able to test every change.</p> <p>To use your local FastStream cli type:</p> <pre><code>python -m faststream ...\n</code></pre>"},{"location":"getting-started/contributing/CONTRIBUTING/#tests","title":"Tests","text":""},{"location":"getting-started/contributing/CONTRIBUTING/#pytest","title":"Pytest","text":"<p>To run tests with your current FastStream application and Python environment use:</p> <pre><code>pytest tests\n# or\n./scripts/test.sh\n# with coverage output\n./scripts/test-cov.sh -m \"all\"\n</code></pre> <p>There are some pytest marks at project:</p> <ul> <li>slow</li> <li>rabbit</li> <li>kafka</li> <li>all</li> </ul> <p>Default pytest calling runs \"not slow\" tests.</p> <p>To run all tests use:</p> <pre><code>pytest -m 'all'\n</code></pre> <p>Also if you didn't up local rabbit or kafka intance, run tests without that dependencies</p> <pre><code>pytest -m 'not rabbit and not kafka'\n</code></pre> <p>To run all tests based on RabbitMQ, Kafka or another dependencies you should run first following docker-compose.yml</p> <pre><code>version: \"3\"\nservices:\n# nosemgrep: yaml.docker-compose.security.writable-filesystem-service.writable-filesystem-service\nrabbitmq:\nimage: rabbitmq:alpine\nports:\n- \"5672:5672\"\n# https://semgrep.dev/r?q=yaml.docker-compose.security.no-new-privileges.no-new-privileges\nsecurity_opt:\n- no-new-privileges:true\n# nosemgrep: yaml.docker-compose.security.writable-filesystem-service.writable-filesystem-service\nkafka:\nimage: bitnami/kafka:3.5.0\nports:\n- \"9092:9092\"\nenvironment:\nKAFKA_ENABLE_KRAFT: \"true\"\nKAFKA_CFG_NODE_ID: \"1\"\nKAFKA_CFG_PROCESS_ROLES: \"broker,controller\"\nKAFKA_CFG_CONTROLLER_LISTENER_NAMES: \"CONTROLLER\"\nKAFKA_CFG_LISTENERS: \"PLAINTEXT://:9092,CONTROLLER://:9093\"\nKAFKA_CFG_LISTENER_SECURITY_PROTOCOL_MAP: \"CONTROLLER:PLAINTEXT,PLAINTEXT:PLAINTEXT\"\nKAFKA_CFG_ADVERTISED_LISTENERS: \"PLAINTEXT://127.0.0.1:9092\"\nKAFKA_BROKER_ID: \"1\"\nKAFKA_CFG_CONTROLLER_QUORUM_VOTERS: \"1@kafka:9093\"\nALLOW_PLAINTEXT_LISTENER: \"true\"\n# https://semgrep.dev/r?q=yaml.docker-compose.security.no-new-privileges.no-new-privileges\nsecurity_opt:\n- no-new-privileges:true\n</code></pre> <pre><code>docker compose up -d\n</code></pre>"},{"location":"getting-started/contributing/docs/","title":"Documentation","text":""},{"location":"getting-started/contributing/docs/#how-to-help","title":"How to help","text":"<p>You will be of invaluable help if you contribute to the documentation.</p> <p>Such a contribution can be:</p> <ul> <li>Indications of inaccuracies, errors, typos</li> <li>Suggestions for editing specific sections</li> <li>Making additions</li> </ul> <p>You can report all this in discussions on GitHub, start issue, or write about it in our discord group.</p> <p>Note</p> <p>Special thanks to those who are ready to offer help with the case and help in developing documentation, as well as translating it into other languages.</p>"},{"location":"getting-started/contributing/docs/#how-to-get-started","title":"How to get started","text":"<p>To develop the documentation, you don't even need to install the entire FastStream project as a whole.</p> <p>Enough:</p> <ol> <li>Clone the project repository</li> <li>Create a virtual environment     <pre><code>python -m venv venv\n</code></pre></li> <li>Activate it     <pre><code>source venv/bin/activate\n</code></pre></li> <li>Install documentation dependencies     <pre><code>pip install \".[devdocs]\"\n</code></pre></li> <li>Go to the <code>docs/</code> directory</li> <li>Start the local documentation server     <pre><code>mkdocs serve\n</code></pre></li> </ol> <p>Now all changes in the documentation files will be reflected on your local version of the site. After making all the changes, you can issue a <code>PR</code> with them - and we will gladly accept it!</p>"},{"location":"getting-started/dependencies/","title":"Dependencies","text":"<p>References:</p> <ul> <li>https://fastapi.tiangolo.com/tutorial/dependencies</li> <li>https://lancetnik.github.io/Propan/getting_started/5_dependency/1_di-index/</li> <li>https://lancetnik.github.io/FastDepends/tutorial</li> </ul>"},{"location":"getting-started/dependencies/global/","title":"Global Dependencies","text":"<ul> <li>Broker-level dependencies</li> <li>Subscriber-level dependencies</li> </ul>"},{"location":"getting-started/dependencies/testing/","title":"Testing","text":"<p>https://lancetnik.github.io/FastDepends/tutorial/overrides/</p>"},{"location":"getting-started/integrations/fastapi/","title":"FastAPI Plugin","text":""},{"location":"getting-started/integrations/fastapi/#handle-messages","title":"Handle messages","text":"<p>FastStream can be used as a part of FastAPI.</p> <p>Just import a StreamRouter you need and declare the message handler using the same with a regular FastStream application way.</p> <p>Tip</p> <p>When used in this way, FastStream does not use its own dependency system, but integrates into FastAPI. That is, you can use <code>Depends</code>, <code>BackgroundTasks</code> and other original FastAPI features as if it were a regular HTTP endpoint, but can't use <code>faststream.Context</code> and <code>faststream.Depends</code>.</p> <p>Note that the code below uses <code>fastapi.Depends</code>, not <code>faststream.Depends</code>.</p> KafkaRabbitMQ <pre><code>from fastapi import Depends, FastAPI\nfrom pydantic import BaseModel\n\nfrom faststream.kafka.fastapi import KafkaRouter\nrouter = KafkaRouter(\"localhost:9092\")\nclass Incoming(BaseModel):\n    m: dict\n\n\ndef call():\n    return True\n\n\n@router.subscriber(\"test\")\n@router.publisher(\"response\")\nasync def hello(m: Incoming, d=Depends(call)):\nreturn {\"response\": \"Hello, world!\"}\n@router.get(\"/\")\nasync def hello_http():\n    return \"Hello, http!\"\n\n\napp = FastAPI(lifespan=router.lifespan_context)\napp.include_router(router)\n</code></pre> <pre><code>from fastapi import Depends, FastAPI\nfrom pydantic import BaseModel\n\nfrom faststream.rabbit.fastapi import RabbitRouter\nrouter = RabbitRouter(\"amqp://guest:guest@localhost:5672/\")\nclass Incoming(BaseModel):\n    m: dict\n\n\ndef call():\n    return True\n\n\n@router.subscriber(\"test\")\n@router.publisher(\"response\")\nasync def hello(m: Incoming, d=Depends(call)):\nreturn {\"response\": \"Hello, world!\"}\n@router.get(\"/\")\nasync def hello_http():\n    return \"Hello, http!\"\n\n\napp = FastAPI(lifespan=router.lifespan_context)\napp.include_router(router)\n</code></pre> <p>When processing a message from a broker, the entire message body is placed simultaneously in both the <code>body</code> and <code>path</code> request parameters: you can get access to them in any way convenient for you. The message header is placed in <code>headers</code>.</p> <p>Also, this router can be fully used as an <code>HttpRouter</code> (of which it is the inheritor). So you can use it to declare any <code>get</code>, <code>post</code>, <code>put</code> and other HTTP methods. For example, this is done at  19 line.</p> <p>Warning</p> <p>If your ASGI server does not support installing state inside lifespan, you can disable this behavior as follows:</p> <pre><code>router = StreamRouter(..., setup_state=False)\n</code></pre> <p>However, after that you will not be able to access the broker from your application's state (but it is still available as the <code>router.broker</code>)</p>"},{"location":"getting-started/integrations/fastapi/#broker-object-access","title":"Broker object access","text":"<p>Inside each router there is a broker. You can easily access it if you need to send a message to MQ.</p> KafkaRabbitMQ <pre><code>from fastapi import FastAPI\n\nfrom faststream.kafka.fastapi import KafkaRouter\n\nrouter = KafkaRouter(\"localhost:9092\")\n\napp = FastAPI(lifespan=router.lifespan_context)\n\n\n@router.get(\"/\")\nasync def hello_http():\n    await router.broker.publish(\"Hello, Kafka!\", \"test\")\n    return \"Hello, HTTP!\"\n\n\napp.include_router(router)\n</code></pre> <pre><code>from fastapi import FastAPI\n\nfrom faststream.rabbit.fastapi import RabbitRouter\n\nrouter = RabbitRouter(\"amqp://guest:guest@localhost:5672/\")\n\napp = FastAPI(lifespan=router.lifespan_context)\n\n\n@router.get(\"/\")\nasync def hello_http():\n    await router.broker.publish(\"Hello, Rabbit!\", \"test\")\n    return \"Hello, HTTP!\"\n\n\napp.include_router(router)\n</code></pre> <p>You can use the following <code>Depends</code> to access the broker if you want to use it at different parts of your program.</p> KafkaRabbitMQ <pre><code>from fastapi import Depends, FastAPI\nfrom typing_extensions import Annotated\n\nfrom faststream.kafka import KafkaBroker, fastapi\n\nrouter = fastapi.KafkaRouter(\"localhost:9092\")\n\napp = FastAPI(lifespan=router.lifespan_context)\n\n\ndef broker():\nreturn router.broker\n@router.get(\"/\")\nasync def hello_http(broker: Annotated[KafkaBroker, Depends(broker)]):\nawait broker.publish(\"Hello, Kafka!\", \"test\")\nreturn \"Hello, HTTP!\"\n\n\napp.include_router(router)\n</code></pre> <pre><code>from fastapi import Depends, FastAPI\nfrom typing_extensions import Annotated\n\nfrom faststream.rabbit import RabbitBroker, fastapi\n\nrouter = fastapi.RabbitRouter(\"amqp://guest:guest@localhost:5672/\")\n\napp = FastAPI(lifespan=router.lifespan_context)\n\n\ndef broker():\nreturn router.broker\n@router.get(\"/\")\nasync def hello_http(broker: Annotated[RabbitBroker, Depends(broker)]):\nawait broker.publish(\"Hello, Rabbit!\", \"test\")\nreturn \"Hello, HTTP!\"\n\n\napp.include_router(router)\n</code></pre> <p>Or you can access broker from a FastAPI application state</p> <pre><code>from fastapi import Request\n\n@app.get(\"/\")\ndef main(request: Request):\n    broker = request.state.broker\n</code></pre>"},{"location":"getting-started/integrations/fastapi/#after_startup","title":"@after_startup","text":"<p>The <code>FastStream</code> application has the <code>after_startup</code> hook, which allows you to perform operations with your message broker after the connection is established. This can be extremely convenient for managing your brokers' objects and/or sending messages. This hook is also available for your FastAPI StreamRouter</p> KafkaRabbitMQ <pre><code>from fastapi import FastAPI\n\nfrom faststream.kafka.fastapi import KafkaRouter\n\nrouter = KafkaRouter(\"localhost:9092\")\n\n\n@router.subscriber(\"test\")\nasync def hello(msg: str):\n    return {\"response\": \"Hello, world!\"}\n\n\n@router.after_startup\nasync def test(app: FastAPI):\nawait router.broker.publish(\"Hello!\", \"test\")\napp = FastAPI(lifespan=router.lifespan_context)\napp.include_router(router)\n</code></pre> <pre><code>from fastapi import FastAPI\n\nfrom faststream.rabbit.fastapi import RabbitRouter\n\nrouter = RabbitRouter(\"amqp://guest:guest@localhost:5672/\")\n\n\n@router.subscriber(\"test\")\nasync def hello(msg: str):\n    return {\"response\": \"Hello, world!\"}\n\n\n@router.after_startup\nasync def test(app: FastAPI):\nawait router.broker.publish(\"Hello!\", \"test\")\napp = FastAPI(lifespan=router.lifespan_context)\napp.include_router(router)\n</code></pre>"},{"location":"getting-started/integrations/fastapi/#documentation","title":"Documentation","text":"<p>When using FastStream as a router for FastAPI, the framework automatically registers endpoints for hosting AsyncAPI documentation into your application with the following default values:</p> KafkaRabbitMQ <pre><code>from faststream.kafka.fastapi import KafkaRouter\n\nrouter = KafkaRouter(\n    ...,\n    schema_url=\"/asyncapi\",\n    include_in_schema=True,\n)\n</code></pre> <pre><code>from faststream.rabbit.fastapi import RabbitRouter\n\nrouter = RabbitRouter(\n    ...,\n    schema_url=\"/asyncapi\",\n    include_in_schema=True,\n)\n</code></pre> <p>This way you will have three routes to interact with your application AsyncAPI schema:</p> <ul> <li><code>/asyncapi</code> - the same with CLI created page</li> <li><code>/asyncapi.json</code> - download JSON schema representation</li> <li><code>/asyncapi.yaml</code> - download YAML schema representation</li> </ul>"},{"location":"getting-started/integrations/fastapi/#testing","title":"Testing","text":"<p>To test your FastAPI StreamRouter, you are still able to use patch it with TestClient</p> KafkaRabbitMQ <pre><code>import pytest\n\nfrom faststream.kafka import TestKafkaBroker, fastapi\nrouter = fastapi.KafkaRouter()\n@router.subscriber(\"test\")\nasync def handler(msg: str):\n    ...\n\n\n@pytest.mark.asyncio\nasync def test_router():\nasync with TestKafkaBroker(router.broker) as br:\nawait br.publish(\"Hi!\", \"test\")\nhandler.mock.assert_called_once_with(\"Hi!\")\n</code></pre> <pre><code>import pytest\n\nfrom faststream.rabbit import TestRabbitBroker, fastapi\nrouter = fastapi.RabbitRouter()\n@router.subscriber(\"test\")\nasync def handler(msg: str):\n    ...\n\n\n@pytest.mark.asyncio\nasync def test_router():\nasync with TestRabbitBroker(router.broker) as br:\nawait br.publish(\"Hi!\", \"test\")\nhandler.mock.assert_called_once_with(\"Hi!\")\n</code></pre>"},{"location":"getting-started/integrations/frameworks/","title":"INTEGRATIONS","text":"<p>FastStream brokers are very easy to integrate with any of your applications: it is enough to initialize the broker at startup and close it correctly at the end of your application.</p> <p>Most HTTP frameworks have built-in lifecycle hooks for this.</p> FastAPIAiohttpBlacksheepFalconQuartSanic <p>Tip</p> <p>If you want to use FastStream in conjunction with FastAPI, perhaps you should use a special plugin</p> <pre><code>from contextlib import asynccontextmanager\n\nfrom fastapi import FastAPI\n\nfrom faststream.kafka import KafkaBroker\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastAPI()\n\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\nawait broker.start()\nyield\nawait broker.close()\n@broker.subscriber(\"test\")\nasync def base_handler(body):\nprint(body)\n@app.get(\"/\")\ndef read_root():\n    return {\"Hello\": \"World\"}\n</code></pre> <pre><code>from aiohttp import web\n\nfrom faststream.kafka import KafkaBroker\nbroker = KafkaBroker(\"localhost:9092\")\n@broker.subscriber(\"test\")\nasync def base_handler(body):\nprint(body)\nasync def start_broker(app):\nawait broker.start()\nasync def stop_broker(app):\nawait broker.close()\nasync def hello(request):\n    return web.Response(text=\"Hello, world\")\n\n\napp = web.Application()\napp.add_routes([web.get(\"/\", hello)])\napp.on_startup.append(start_broker)\napp.on_cleanup.append(stop_broker)\nif __name__ == \"__main__\":\n    web.run_app(app)\n</code></pre> <pre><code>from blacksheep import Application\n\nfrom faststream.kafka import KafkaBroker\nbroker = KafkaBroker(\"localhost:9092\")\napp = Application()\n\n\n@broker.subscriber(\"test\")\nasync def base_handler(body):\nprint(body)\n@app.on_start\nasync def start_broker(application: Application) -&gt; None:\nawait broker.start()\n@app.on_stop\nasync def stop_broker(application: Application) -&gt; None:\nawait broker.close()\n@app.route(\"/\")\nasync def home():\n    return \"Hello, World!\"\n</code></pre> <pre><code>import falcon\nimport falcon.asgi\n\nfrom faststream.kafka import KafkaBroker\nbroker = KafkaBroker(\"localhost:9092\")\n@broker.subscriber(\"test\")\nasync def base_handler(body):\nprint(body)\nclass ThingsResource:\n    async def on_get(self, req, resp):\n        resp.status = falcon.HTTP_200\n        resp.content_type = falcon.MEDIA_TEXT\n        resp.text = (\n            \"\\nTwo things awe me most, the starry sky \"\n            \"above me and the moral law within me.\\n\"\n            \"\\n\"\n            \"    ~ Immanuel Kant\\n\\n\"\n        )\n\n\nclass PropanMiddleware:\nasync def process_startup(self, scope, event):\nawait broker.start()\nasync def process_shutdown(self, scope, event):\nawait broker.close()\napp = falcon.asgi.App()\napp.add_middleware(PropanMiddleware())\napp.add_route(\"/things\", ThingsResource())\n</code></pre> <pre><code>from quart import Quart\n\nfrom faststream.kafka import KafkaBroker\nbroker = KafkaBroker(\"localhost:9092\")\napp = Quart(__name__)\n\n\n@broker.subscriber(\"test\")\nasync def base_handler(body):\nprint(body)\n@app.before_serving\nasync def start_broker():\nawait broker.start()\n@app.after_serving\nasync def stop_broker():\nawait broker.close()\n@app.route(\"/\")\nasync def json():\n    return {\"hello\": \"world\"}\n</code></pre> <pre><code>from sanic import Sanic\nfrom sanic.response import text\n\nfrom faststream.kafka import KafkaBroker\nbroker = KafkaBroker(\"localhost:9092\")\napp = Sanic(\"MyHelloWorldApp\")\n\n\n@broker.subscriber(\"test\")\nasync def base_handler(body):\nprint(body)\n@app.after_server_start\nasync def start_broker(app, loop):\nawait broker.start()\n@app.after_server_stop\nasync def stop_broker(app, loop):\nawait broker.close()\n@app.get(\"/\")\nasync def hello_world(request):\n    return text(\"Hello, world.\")\n</code></pre> <p>However, even if such a hook is not provided, you can do it yourself.</p> Tornado <pre><code>import asyncio\n\nimport tornado.web\n\nfrom faststream.kafka import KafkaBroker\nbroker = KafkaBroker(\"localhost:9092\")\n@broker.subscriber(\"test\")\nasync def base_handler(body):\nprint(body)\nclass MainHandler(tornado.web.RequestHandler):\n    def get(self):\n        self.write(\"Hello, world\")\n\n\ndef make_app():\n    return tornado.web.Application(\n        [\n            (r\"/\", MainHandler),\n        ]\n    )\n\n\nasync def main():\n    app = make_app()\n    app.listen(8888)\n\nawait broker.start()\ntry:\nawait asyncio.Event().wait()\nfinally:\nawait broker.close()\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"getting-started/lifespan/","title":"Lifespan Events","text":"<p>Sometimes you need to define the logic that should be executed before launching the application. This means that the code will be executed once - even before your application starts receiving messages.</p> <p>Also, you may need to terminate some processes after stopping the application. In this case, your code will also be executed exactly once: but after the completion of the main application.</p> <p>Since this code is executed before the application starts and after it stops, it covers the entire lifecycle (lifespan) of the application.</p> <p>This can be very useful for initializing your application settings at startup, raising a pool of connections to a database, or running machine learning models.</p>"},{"location":"getting-started/lifespan/hooks/","title":"Lifespan Hooks","text":""},{"location":"getting-started/lifespan/hooks/#usage-example","title":"Usage example","text":"<p>Let's imagine that your application uses pydantic as your settings manager.</p> <p>I highly recommend using pydantic for these purposes, because this dependency is already used at FastStream and you don't have to install an additional package</p> <p>Also, let's imagine that you have several <code>.env</code>, <code>.env.development</code>, <code>.env.test</code>, <code>.env.production</code> files with your application settings, and you want to switch them at startup without any code changes.</p> <p>By passing optional arguments with the command line to your code FastStream allows you to do this easily.</p>"},{"location":"getting-started/lifespan/hooks/#lifespan","title":"Lifespan","text":"<p>Let's write some code for our example</p> KafkaRabbitMQ <pre><code>from pydantic_settings import BaseSettings\n\nfrom faststream import ContextRepo, FastStream\nfrom faststream.kafka import KafkaBroker\n\nbroker = KafkaBroker()\napp = FastStream(broker)\n\n\nclass Settings(BaseSettings):\n    host: str = \"localhost:9092\"\n\n\n@app.on_startup\nasync def setup(context: ContextRepo, env: str = \".env\"):\nsettings = Settings(_env_file=env)\ncontext.set_global(\"settings\", settings)\nawait broker.connect(settings.host)\n</code></pre> <pre><code>from pydantic_settings import BaseSettings\n\nfrom faststream import ContextRepo, FastStream\nfrom faststream.rabbit import RabbitBroker\n\nbroker = RabbitBroker()\napp = FastStream(broker)\n\n\nclass Settings(BaseSettings):\n    host: str = \"amqp://guest:guest@localhost:5672/\" # pragma: allowlist secret\n\n\n@app.on_startup\nasync def setup(context: ContextRepo, env: str = \".env\"):\nsettings = Settings(_env_file=env)\ncontext.set_global(\"settings\", settings)\nawait broker.connect(settings.host)\n</code></pre> <p>Now this application can be run using the following command to manage the environment:</p> <pre><code>faststream run serve:app --env .env.test\n</code></pre>"},{"location":"getting-started/lifespan/hooks/#details","title":"Details","text":"<p>Now let's look into a little more detail</p> <p>To begin with, we used a decorator</p> KafkaRabbitMQ <pre><code>@app.on_startup\nasync def setup(context: ContextRepo, env: str = \".env\"):\n    settings = Settings(_env_file=env)\n    context.set_global(\"settings\", settings)\n    await broker.connect(settings.host)\n</code></pre> <pre><code>@app.on_startup\nasync def setup(context: ContextRepo, env: str = \".env\"):\n    settings = Settings(_env_file=env)\n    context.set_global(\"settings\", settings)\n    await broker.connect(settings.host)\n</code></pre> <p>to declare a function that should run when our application starts</p> <p>The next step is to declare the arguments that our function will receive</p> KafkaRabbitMQ <pre><code>@app.on_startup\nasync def setup(context: ContextRepo, env: str = \".env\"):\nsettings = Settings(_env_file=env)\n    context.set_global(\"settings\", settings)\n    await broker.connect(settings.host)\n</code></pre> <pre><code>@app.on_startup\nasync def setup(context: ContextRepo, env: str = \".env\"):\nsettings = Settings(_env_file=env)\n    context.set_global(\"settings\", settings)\n    await broker.connect(settings.host)\n</code></pre> <p>In this case, the <code>env</code> field will be passed to the <code>setup</code> function from the arguments with the command line</p> <p>Tip</p> <p>The default lifecycle functions are used with the decorator <code>@apply_types</code>, therefore, all context fields and dependencies are available in them</p> <p>Then, we initialized the settings of our application using the file passed to us from the command line</p> KafkaRabbitMQ <pre><code>@app.on_startup\nasync def setup(context: ContextRepo, env: str = \".env\"):\nsettings = Settings(_env_file=env)\ncontext.set_global(\"settings\", settings)\n    await broker.connect(settings.host)\n</code></pre> <pre><code>@app.on_startup\nasync def setup(context: ContextRepo, env: str = \".env\"):\nsettings = Settings(_env_file=env)\ncontext.set_global(\"settings\", settings)\n    await broker.connect(settings.host)\n</code></pre> <p>And put these settings in a global context</p> KafkaRabbitMQ <pre><code>@app.on_startup\nasync def setup(context: ContextRepo, env: str = \".env\"):\n    settings = Settings(_env_file=env)\ncontext.set_global(\"settings\", settings)\nawait broker.connect(settings.host)\n</code></pre> <pre><code>@app.on_startup\nasync def setup(context: ContextRepo, env: str = \".env\"):\n    settings = Settings(_env_file=env)\ncontext.set_global(\"settings\", settings)\nawait broker.connect(settings.host)\n</code></pre> Note <p>Now we can access our settings anywhere in the application right from the context</p> <pre><code>from faststream import Context, apply_types\n@apply_types\nasync def func(settings = Context()): ...\n</code></pre> <p>The last step we initialized our broker: now, when the application starts, it will be ready to receive messages</p> KafkaRabbitMQ <pre><code>@app.on_startup\nasync def setup(context: ContextRepo, env: str = \".env\"):\n    settings = Settings(_env_file=env)\n    context.set_global(\"settings\", settings)\nawait broker.connect(settings.host)\n</code></pre> <pre><code>@app.on_startup\nasync def setup(context: ContextRepo, env: str = \".env\"):\n    settings = Settings(_env_file=env)\n    context.set_global(\"settings\", settings)\nawait broker.connect(settings.host)\n</code></pre>"},{"location":"getting-started/lifespan/hooks/#another-example","title":"Another example","text":"<p>Now let's imagine that we have a machine learning model that needs to process messages from some broker.</p> <p>Initialization of such models usually takes a long time. It would be wise to do this at the start of the application, and not when processing each message.</p> <p>You can initialize your model somewhere at the top of your module/file. However, in this case, this code will be run even just in case of importing this module, for example, during testing. It is unlikely that you want to run your model on every test run...</p> <p>Therefore, it is worth initializing the model in the <code>@app.on_startup</code> hook.</p> <p>Also, we don't want the model to finish its work incorrectly when the application is stopped. To avoid this, we need the hook <code>@app.on_shutdown</code></p> KafkaRabbitMQ <pre><code>from faststream import Context, ContextRepo, FastStream\nfrom faststream.kafka import KafkaBroker\n\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\n\nml_models = {}  # fake ML model\n\n\ndef fake_answer_to_everything_ml_model(x: float):\n    return x * 42\n\n\n@app.on_startup\nasync def setup_model(context: ContextRepo):\n    # Load the ML model\n    ml_models[\"answer_to_everything\"] = fake_answer_to_everything_ml_model\n    context.set_global(\"model\", ml_models)\n\n\n@app.on_shutdown\nasync def shutdown_model(model: dict = Context()):\n    # Clean up the ML models and release the resources\n    model.clear()\n\n\n@broker.subscriber(\"test\")\nasync def predict(x: float, model=Context()):\n    result = model[\"answer_to_everything\"](x)\n    return {\"result\": result}\n</code></pre> <pre><code>from faststream import Context, ContextRepo, FastStream\nfrom faststream.rabbit import RabbitBroker\n\nbroker = RabbitBroker(\"amqp://guest:guest@localhost:5672/\")\napp = FastStream(broker)\n\nml_models = {}  # fake ML model\n\n\ndef fake_answer_to_everything_ml_model(x: float):\n    return x * 42\n\n\n@app.on_startup\nasync def setup_model(context: ContextRepo):\n    # Load the ML model\n    ml_models[\"answer_to_everything\"] = fake_answer_to_everything_ml_model\n    context.set_global(\"model\", ml_models)\n\n\n@app.on_shutdown\nasync def shutdown_model(model: dict = Context()):\n    # Clean up the ML models and release the resources\n    model.clear()\n\n\n@broker.subscriber(\"test\")\nasync def predict(x: float, model=Context()):\n    result = model[\"answer_to_everything\"](x)\n    return {\"result\": result}\n</code></pre>"},{"location":"getting-started/lifespan/hooks/#multiple-hooks","title":"Multiple hooks","text":"<p>If you want to declare multiple lifecycle hooks, they will be used in the order they are registered:</p> <pre><code>from faststream import Context, ContextRepo, FastStream\n\napp = FastStream()\n\n\n@app.on_startup\nasync def setup(context: ContextRepo):\n    context.set_global(\"field\", 1)\n\n\n@app.on_startup\nasync def setup_later(field: int = Context()):\n    assert field == 1\n</code></pre>"},{"location":"getting-started/lifespan/hooks/#some-more-details","title":"Some more details","text":""},{"location":"getting-started/lifespan/hooks/#async-or-not-async","title":"Async or not async","text":"<p>In the asynchronous version of the application, both asynchronous and synchronous methods can be used as hooks. In the synchronous version, only synchronous methods are available.</p>"},{"location":"getting-started/lifespan/hooks/#command-line-arguments","title":"Command line arguments","text":"<p>Command line arguments are available in all <code>@app.on_startup</code> hooks. To use them in other parts of the application, put them in the <code>ContextRepo</code>.</p>"},{"location":"getting-started/lifespan/hooks/#broker-initialization","title":"Broker initialization","text":"<p>The <code>@app.on_startup</code> hooks are called BEFORE the broker is launched by the application. The <code>@app.after_shutdown</code> hooks are triggered AFTER stopping the broker.</p> <p>If you want to perform some actions AFTER initializing the broker: send messages, initialize objects, etc., you should use the <code>@app.after_startup</code> hook.</p>"},{"location":"getting-started/lifespan/test/","title":"Events Testing","text":"<p>In the most cases you are testing your subsriber/publisher functions, but sometimes you need to trigger some lifespan hooks in your tests too.</p> <p>This reason FastStream has a special TestApp patcher working as a regular async context manager.</p> KafkaRabbitMQ <pre><code>import pytest\n\nfrom faststream import FastStream, TestApp\nfrom faststream.kafka import KafkaBroker, TestKafkaBroker\n\napp = FastStream(KafkaBroker())\n\n\n@app.after_startup\nasync def handle():\n    print(\"Calls in tests too!\")\n\n\n@pytest.mark.asyncio\nasync def test_lifespan():\n    async with TestKafkaBroker(app.broker):\nasync with TestApp(app):\n# test smth\n            pass\n</code></pre> <pre><code>import pytest\n\nfrom faststream import FastStream, TestApp\nfrom faststream.rabbit import RabbitBroker, TestRabbitBroker\n\napp = FastStream(RabbitBroker())\n\n\n@app.after_startup\nasync def handle():\n    print(\"Calls in tests too!\")\n\n\n@pytest.mark.asyncio\nasync def test_lifespan():\n    async with TestRabbitBroker(app.broker):\nasync with TestApp(app):\n# test smth\n            pass\n</code></pre> <p>Tip</p> <p>If you are using connected broker inside your lifespan hooks, you should batch the broker at first (before application patching)</p>"},{"location":"getting-started/middlewares/","title":"Middlewares","text":"<p>Middlewares - is a powerfull mechanizm allows you to add extra logic to any message processing pipeline stage.</p> <p>This way you can extreamly extend your FastStream application by features:</p> <ul> <li>integrate with any logging/metrics systems</li> <li>application-level message serialization logic</li> <li>rich publishing messages with extra information</li> <li>and many other stuff</li> </ul> <p>Middlewares has a several methods to overwride. You can implement some or all of them, use middlewares at broker, router or subscriber level. Thus middlewares is a most flexible FastStream feature.</p>"},{"location":"getting-started/middlewares/#message-receive-wrapper","title":"Message receive wrapper","text":"<p>Unfortunatelly, powerfull feature has a pretty complex signature too.</p> <p>Using middlewares you can wrap total message processing pipeline. In this case you need to specify <code>on_receive</code> and <code>after_processed</code> methods:</p> <pre><code>from faststream import BaseMiddleware:\n\nclass MyMiddleware(BaseMiddleware):\n    async def on_receive(self):\n        print(f\"Received: {self.message}\")\n        return await super().on_receive()\n\n    async def after_processed(self, exc_type, exc_val, exec_tb):\n        return await super().after_processed(exc_type, exc_val, exec_tb)\n</code></pre> <p>These methods should be overwritten only in a Broker-level middlewares.</p> <pre><code>Broker(middlewares=[MyMiddleware])\n</code></pre> <p>In the other cases <code>on_receive</code> will be called at every subscriber filter function calling.</p> <p>Tip</p> <p>Please, always call <code>super()</code> methods at the end of your function - this is important for correct errors processing</p>"},{"location":"getting-started/middlewares/#message-consuming-wrapper","title":"Message consuming wrapper","text":"<p>Also, using middlewares you are able to wrap consumer function calling directly.</p> <p>In this case you need to specify <code>on_receive</code> and <code>after_processed</code> methods:</p> <pre><code>from typing import Optional\n\nfrom faststream import BaseMiddleware:\nfrom faststream.types import DecodedMessage\n\nclass MyMiddleware(BaseMiddleware):\n    async def on_consume(self, msg: DecodedMessage) -&gt; DecodedMessage:\n        return await super().on_consume(msg)\n\n    async def after_consume(self, err: Optional[Exception]) -&gt; None:\n        return await super().after_consume(err)\n</code></pre> <p>This way you can patch incoming message body right before passing it to you consumer subscriber.</p> <p>Also, if you have multiple filters for one subscriber, these methods will be called at once: then the filtering complete success.</p>"},{"location":"getting-started/middlewares/#message-publishing-wrapper","title":"Message publishing wrapper","text":"<p>Finally, using middlewares you are able to patch outcoming message too. This way, (as an example) you can compress/encode outcoming message at Application level.</p> <p>In this case you need to specify <code>on_publish</code> and <code>after_publish</code> methods:</p> <pre><code>from typing import Optional\n\nfrom faststream import BaseMiddleware:\nfrom faststream.types import SendableMessage\n\nclass MyMiddleware(BaseMiddleware):\n    async def on_publish(self, msg: SendableMessage) -&gt; SendableMessage:\n        return await super().on_publish(msg)\n\n    async def after_publish(self, err: Optional[Exception]) -&gt; None:\n        return await super().after_publish(err)\n</code></pre>"},{"location":"getting-started/publishing/","title":"Publishing Basics","text":"<p>Broker agnostic, easy to use (even as a client in the not-FastStream apps)</p> <p>Several usecases</p> <ul> <li>broker.publish</li> <li>decorator</li> <li>publisher object decorator</li> <li>publisher object direct</li> </ul> <p>Allows to publish any JSON-serializable messages (python types, pydantic models, e.t.c.) or raw bytes.</p> <p>Automatically setups all required headers (expecially correlation_id, which using to trace message processing pipeline through all services)</p> <p>Just setup a message and a routing key</p> KafkaRabbitMQ <pre><code>async with KafkaBroker() as br:\n    await br.publish(\"message\", \"topic\")\n</code></pre> <pre><code>async with RabbitBroker() as br:\n    await br.publish(\"message\", \"queue\")\n</code></pre>"},{"location":"getting-started/publishing/broker/","title":"Broker Publishing","text":"<p>Easiest way to publish message</p> <p>Allows use a Broker like a publisher client in any applications.</p> <p>In the FastStream project this call not represented in the AsyncAPI scheme, so you can use it to send rarely-publishing messages (like startup/shutdown event).</p> KafkaRabbitMQ <pre><code>from faststream import FastStream\nfrom faststream.kafka import KafkaBroker\n\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\n\n\n@broker.subscriber(\"test-topic\")\nasync def handle():\n    await broker.publish(\"Hi!\", topic=\"another-topic\")\n\n\n@broker.subscriber(\"another-topic\")\nasync def handle_next(msg: str):\n    assert msg == \"Hi!\"\n\n\n@app.after_startup\nasync def test():\n    await broker.publish(\"\", topic=\"test-topic\")\n</code></pre> <pre><code>from faststream import FastStream\nfrom faststream.rabbit import RabbitBroker\n\nbroker = RabbitBroker(\"amqp://guest:guest@localhost:5672/\")\napp = FastStream(broker)\n\n\n@broker.subscriber(\"test-queue\")\nasync def handle():\n    await broker.publish(\"Hi!\", queue=\"another-queue\")\n\n\n@broker.subscriber(\"another-queue\")\nasync def handle_next(msg: str):\n    assert msg == \"Hi!\"\n\n\n@app.after_startup\nasync def test():\n    await broker.publish(\"\", queue=\"test-queue\")\n</code></pre>"},{"location":"getting-started/publishing/decorator/","title":"Publisher Decorator","text":"<p>The second easy way to publish messages. Has an AsyncAPI representation. Suitable for fast application creation, but doesn't provide all testing features.</p> <p>Creates a structured DataPipeline unit with an input and output</p> <p>Subscriber and publisher decorators order has no matter, but can be used only with a functions decorated by a <code>subscriber</code> too.</p> <p>Uses the handler function return type annotation to cast function return before sending (be accurate with it)</p> KafkaRabbitMQ <pre><code>from faststream import FastStream\nfrom faststream.kafka import KafkaBroker\n\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\n\n\n@broker.subscriber(\"test-topic\")\n@broker.publisher(\"another-topic\")\nasync def handle() -&gt; str:\n    return \"Hi!\"\n\n\n@broker.subscriber(\"another-topic\")\nasync def handle_next(msg: str):\n    assert msg == \"Hi!\"\n\n\n@app.after_startup\nasync def test():\n    await broker.publish(\"\", topic=\"test-topic\")\n</code></pre> <pre><code>from faststream import FastStream\nfrom faststream.rabbit import RabbitBroker\n\nbroker = RabbitBroker(\"amqp://guest:guest@localhost:5672/\")\napp = FastStream(broker)\n\n\n@broker.subscriber(\"test-queue\")\n@broker.publisher(\"another-queue\")\nasync def handle() -&gt; str:\n    return \"Hi!\"\n\n\n@broker.subscriber(\"another-queue\")\nasync def handle_next(msg: str):\n    assert msg == \"Hi!\"\n\n\n@app.after_startup\nasync def test():\n    await broker.publish(\"\", queue=\"test-queue\")\n</code></pre> <p>Can be used multiple times with the one function to broadcast function return</p> <pre><code>@broker.subscriber(\"in\")\n@broker.publisher(\"first-out\")\n@broker.publisher(\"second-out\")\nasync def handle(msg) -&gt; str:\n    return \"Response\"\n</code></pre> <p>Also, it automatically sends a message with the same with incoming message <code>correlation_id</code>. This way you get the same <code>correlation_id</code> for the one message pipeline procces inside all services and able to collect a trace.</p>"},{"location":"getting-started/publishing/direct/","title":"Publisher Direct Usage","text":"<p>Full-featured way to publish messages (has AsyncAPI representation + testable feaures). Creates reusable Publisher object.</p> <p>Can be used directly to publush a message</p> KafkaRabbitMQ <pre><code>from faststream import FastStream\nfrom faststream.kafka import KafkaBroker\n\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\n\npublisher = broker.publisher(\"another-topic\")\n\n\n@broker.subscriber(\"test-topic\")\nasync def handle():\n    await publisher.publish(\"Hi!\")\n\n\n@broker.subscriber(\"another-topic\")\nasync def handle_next(msg: str):\n    assert msg == \"Hi!\"\n\n\n@app.after_startup\nasync def test():\n    await broker.publish(\"\", topic=\"test-topic\")\n</code></pre> <pre><code>from faststream import FastStream\nfrom faststream.rabbit import RabbitBroker\n\nbroker = RabbitBroker(\"amqp://guest:guest@localhost:5672/\")\napp = FastStream(broker)\n\npublisher = broker.publisher(\"another-queue\")\n\n\n@broker.subscriber(\"test-queue\")\nasync def handle():\n    await publisher.publish(\"Hi!\")\n\n\n@broker.subscriber(\"another-queue\")\nasync def handle_next(msg: str):\n    assert msg == \"Hi!\"\n\n\n@app.after_startup\nasync def test():\n    await broker.publish(\"\", queue=\"test-queue\")\n</code></pre> <p>Suitable to publish different messages to different outputes at the same processing function</p> <pre><code>@broker.subscriber(\"in\")\nasync def handle(msg) -&gt; str:\n    await publisher1.publish(\"Response-1\")\n    await publisher2.publish(\"Response-2\")\n</code></pre>"},{"location":"getting-started/publishing/object/","title":"Publisher Object","text":"<p>Full-featured way to publish messages (has AsyncAPI representation + testable feaures). Creates reusable Publisher object.</p> <p>Can be used as a function decorator</p> <p>Subscriber and publisher decorators order has no matter, but can be used only with a functions decorated by a <code>subscriber</code> too.</p> <p>Also uses the handler function return type annotation to cast function return before sending (be accurate with it)</p> KafkaRabbitMQ <pre><code>from faststream import FastStream\nfrom faststream.kafka import KafkaBroker\n\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\n\npublisher = broker.publisher(\"another-topic\")\n\n\n@publisher\n@broker.subscriber(\"test-topic\")\nasync def handle() -&gt; str:\n    return \"Hi!\"\n\n\n@broker.subscriber(\"another-topic\")\nasync def handle_next(msg: str):\n    assert msg == \"Hi!\"\n\n\n@app.after_startup\nasync def test():\n    await broker.publish(\"\", topic=\"test-topic\")\n</code></pre> <pre><code>from faststream import FastStream\nfrom faststream.rabbit import RabbitBroker\n\nbroker = RabbitBroker(\"amqp://guest:guest@localhost:5672/\")\napp = FastStream(broker)\n\npublisher = broker.publisher(\"another-queue\")\n\n\n@publisher\n@broker.subscriber(\"test-queue\")\nasync def handle() -&gt; str:\n    return \"Hi!\"\n\n\n@broker.subscriber(\"another-queue\")\nasync def handle_next(msg: str):\n    assert msg == \"Hi!\"\n\n\n@app.after_startup\nasync def test():\n    await broker.publish(\"\", queue=\"test-queue\")\n</code></pre> <p>Can be used multiple times with the one function to broadcast function return</p> <pre><code>@publisher1\n@publisher2\n@broker.subscriber(\"in\")\nasync def handle(msg) -&gt; str:\n    return \"Response\"\n</code></pre> <p>Also, it automatically sends a message with the same with incoming message <code>correlation_id</code>. This way you get the same <code>correlation_id</code> for the one message pipeline procces inside all services and able to collect a trace.</p>"},{"location":"getting-started/publishing/test/","title":"Publisher Testing","text":"<p>If you are working with Publisher object (decorator/direct), you able to check outcoming message too</p> <ul> <li>in-memory TestClient</li> <li>publishing (show error raising)</li> <li>check incoming message body</li> <li>note about mock clearing after context exit</li> </ul> <p>Base application</p> DecoratorDirect KafkaRabbitMQ <pre><code>publisher = broker.publisher(\"another-topic\")\n\n\n@publisher\n@broker.subscriber(\"test-topic\")\nasync def handle() -&gt; str:\n</code></pre> <pre><code>publisher = broker.publisher(\"another-queue\")\n\n\n@publisher\n@broker.subscriber(\"test-queue\")\nasync def handle() -&gt; str:\n</code></pre> KafkaRabbitMQ <pre><code>publisher = broker.publisher(\"another-topic\")\n\n\n@broker.subscriber(\"test-topic\")\nasync def handle():\n</code></pre> <pre><code>publisher = broker.publisher(\"another-queue\")\n\n\n@broker.subscriber(\"test-queue\")\nasync def handle():\n</code></pre> <p>Testing</p> KafkaRabbitMQ <pre><code>import pytest\n\nfrom faststream.kafka import TestKafkaBroker\n\n\n\n@pytest.mark.asyncio\nasync def test_handle():\n    async with TestKafkaBroker(broker) as br:\n        await br.publish(\"\", topic=\"test-topic\")\n</code></pre> <pre><code>import pytest\n\nfrom faststream.rabbit import TestRabbitBroker\n\n\n\n@pytest.mark.asyncio\nasync def test_handle():\n    async with TestRabbitBroker(broker) as br:\n        await br.publish(\"\", queue=\"test-queue\")\n</code></pre> <ul> <li>test with real broker</li> <li>wait consumer called</li> </ul>"},{"location":"getting-started/routers/","title":"Broker Router","text":"<p>Sometimes you want to:</p> <ul> <li>split an application to includable modules</li> <li>separate business logic from you handler registration</li> <li>apply some decoder/middleware/dependencies to subscribers group</li> </ul> <p>This reason FastStream has a special Broker Router.</p>"},{"location":"getting-started/routers/#router-usage","title":"Router usage","text":"<p>First you need to import Broker Router from the same module from where you imported the broker.</p> <p>When creating, you can specify a prefix that will be automatically applied to all subscribers and publishers of this router.</p> KafkaRabbitMQ <pre><code>from faststream import FastStream\nfrom faststream.kafka import KafkaBroker, KafkaRouter\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\nrouter = KafkaRouter(prefix=\"prefix_\")\n</code></pre> <pre><code>from faststream import FastStream\nfrom faststream.rabbit import RabbitBroker, RabbitRouter\nbroker = RabbitBroker(\"amqp://guest:guest@localhost:5672/\")\napp = FastStream(broker)\nrouter = RabbitRouter(prefix=\"prefix_\")\n</code></pre> <p>Now you can use the created router to register handlers and publishers as if it were a regular broker</p> KafkaRabbitMQ <pre><code>@router.subscriber(\"test-topic\")\n@router.publisher(\"another-topic\")\nasync def handle(name: str, user_id: int) -&gt; str:\n    assert name == \"john\"\n    assert user_id == 1\n    return \"Hi!\"\n\n\n@router.subscriber(\"another-topic\")\nasync def handle_response(msg: str):\n    assert msg == \"Hi!\"\n</code></pre> <pre><code>@router.subscriber(\"test-queue\")\n@router.publisher(\"another-queue\")\nasync def handle(name: str, user_id: int) -&gt; str:\n    assert name == \"john\"\n    assert user_id == 1\n    return \"Hi!\"\n\n\n@router.subscriber(\"another-queue\")\nasync def handle_response(msg: str):\n    assert msg == \"Hi!\"\n</code></pre> <p>Then you can simply include all the handlers declared using the router in your broker</p> KafkaRabbitMQ <pre><code>broker.include_router(router)\n</code></pre> <pre><code>broker.include_router(router)\n</code></pre> <p>Please note that when publishing a message, you now need to specify the same prefix that you used when creating the router</p> KafkaRabbitMQ <pre><code>    await broker.publish(\n        {\"name\": \"john\", \"user_id\": 1},\ntopic=\"prefix_test-topic\",\n)\n</code></pre> <pre><code>    await broker.publish(\n        {\"name\": \"john\", \"user_id\": 1},\nqueue=\"prefix_test-queue\",\n)\n</code></pre> <p>Tip</p> <p>Also, at Broker Router creation you can specify middleware, dependencies, decoder and decoder to apply them to all subscribers, declared via this router.</p>"},{"location":"getting-started/routers/#delay-handler-registration","title":"Delay handler registration","text":"<p>If you want to separate your application core logic from FastStream routing one, you can just write some core functions and use them as a Broker Router <code>handlers</code> lately:</p> KafkaRabbitMQ <pre><code>from faststream import FastStream\nfrom faststream.kafka import KafkaBroker, KafkaRoute, KafkaRouter\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\n\n\nasync def handle(name: str, user_id: int):\nassert name == \"john\"\n    assert user_id == 1\n\n\nrouter = KafkaRouter(handlers=(KafkaRoute(handle, \"test-topic\"),))\nbroker.include_router(router)\n</code></pre> <pre><code>from faststream import FastStream\nfrom faststream.rabbit import RabbitBroker, RabbitRoute, RabbitRouter\nbroker = RabbitBroker(\"amqp://guest:guest@localhost:5672/\")\napp = FastStream(broker)\n\n\nasync def handle(name: str, user_id: int):\nassert name == \"john\"\n    assert user_id == 1\n\n\nrouter = RabbitRouter(handlers=(RabbitRoute(handle, \"test-queue\"),))\nbroker.include_router(router)\n</code></pre> <p>Warning</p> <p>Be careful, this way you have no ability to test you handlers with a <code>mock</code> object.</p>"},{"location":"getting-started/serialization/","title":"Custom Serialization","text":"<p>By default, FastStream uses the JSON format to send and receive messages. However, if you need to handle messages in other formats or with extra serialization steps such as gzip, lz4, Avro, Protobuf or Msgpack, you can easily modify the serialization logic.</p>"},{"location":"getting-started/serialization/#serialization-steps","title":"Serialization Steps","text":"<p>Before the message gets into your subscriber, FastStream applies 2 functions to it sequentially: <code>parse_message</code> and <code>decode_message</code>. You can modify one or both stages depending on your needs.</p>"},{"location":"getting-started/serialization/#message-parsing","title":"Message Parsing","text":"<p>At this stage, FastStream serializes an incoming message of the framework that is used to work with the broker into a general view - StreamMessage. At this stage, the message body remains in the form of raw bytes.</p> <p>This stage is strongly related to the features of the broker used and in most cases, its redefinition is not necessary.</p> <p>The parser declared at the <code>broker</code> level will be applied to all subscribers. The parser declared at the <code>subscriber</code> level is applied only to this subscriber (it ignores the `broker' parser if it was specified earlier).</p>"},{"location":"getting-started/serialization/#message-decoding","title":"Message Decoding","text":"<p>At this stage, the body of StreamMessage is transformed to the form in which it enters your subscriber function. This method you will have to redefine more often.</p>"},{"location":"getting-started/serialization/decoder/","title":"Custom Decoder","text":"<p>At this stage, the body of StreamMessage is transformed to the form in which it enters your handler function. This method you will have to redefine more often.</p>"},{"location":"getting-started/serialization/decoder/#signature","title":"Signature","text":"<p>In the original, its signature is quite simple (this is a simplified version):</p> KafkaRabbitMQ <pre><code>from faststream.types import DecodedMessage\nfrom faststream.kafka import KafkaMessage\n\ndef decoder(msg: KafkaMessage) -&gt; DecodedMessage:\n    ...\n</code></pre> <pre><code>from faststream.types import DecodedMessage\nfrom faststream.rabbit import RabbitMessage\n\ndef decoder(msg: RabbitMessage) -&gt; DecodedMessage:\n    ...\n</code></pre> <p>Also, you are able to reuse the original decoder function by using next signature</p> KafkaRabbitMQ <pre><code>from types import Callable, Awaitable\nfrom faststream.types import DecodedMessage\nfrom faststream.kafka import KafkaMessage\n\nasync def decoder(\n    msg: KafkaMessage,\n    original_decoder: Callable[[KafkaMessage], Awaitable[DecodedMessage]],\n) -&gt; DecodedMessage:\n    return await original_decoder(msg)\n</code></pre> <pre><code>from types import Callable, Awaitable\nfrom faststream.types import DecodedMessage\nfrom faststream.rabbit import RabbitMessage\n\nasync def decoder(\n    msg: RabbitMessage,\n    original_decoder: Callable[[RabbitMessage], Awaitable[DecodedMessage]],\n) -&gt; DecodedMessage:\n    return await original_decoder(msg)\n</code></pre> <p>Note</p> <p>Original decoder is always async function, so your custom one should be an async too</p> <p>After you can set this decoder at broker or subsriber level both.</p>"},{"location":"getting-started/serialization/decoder/#example","title":"Example","text":"<p>You can find Protobuf and Msgpack serialization examples in the next article.</p>"},{"location":"getting-started/serialization/examples/","title":"Serialization examples","text":""},{"location":"getting-started/serialization/examples/#protobuf","title":"Protobuf","text":"<p>In this section, we will look at an example using Protobuf, however, it is also applicable for any other serialization methods.</p> Protobuf <p>Protobuf is an alternative message serialization method commonly used in GRPC. Its main advantage is much smaller <sup>1</sup> message size (compared to JSON), but it requires a message schema (<code>.proto</code> files) both on the client side and on the server side.</p> <p>To begin with, install the dependencies:</p> <pre><code>pip install grpcio-tools\n</code></pre> <p>Then we will describe the scheme of our message</p> message.proto<pre><code>syntax = \"proto3\";\n\nmessage Person {\nstring name = 1;\nfloat age = 2;\n}\n</code></pre> <p>Now we will generate a Python class for working with messages in the Protobuf format</p> <pre><code>python -m grpc_tools.protoc --python_out=. --pyi_out=. -I . message.proto\n</code></pre> <p>At the output, we get 2 files: <code>message_pb2.py</code> and <code>message_pb2.pyi</code>. Now we are ready to use the generated class to serialize our messages.</p> <pre><code>from message_pb2 import Person\nfrom faststream import FastStream, Logger, NoCast\nfrom faststream.rabbit import RabbitBroker, RabbitMessage\n\nbroker = RabbitBroker()\napp = FastStream(broker)\n\n\nasync def decode_message(msg: RabbitMessage) -&gt; Person:\ndecoded = Person()\ndecoded.ParseFromString(msg.body)\nreturn decoded\n@broker.subscriber(\"test\", decoder=decode_message)\nasync def consume(body: NoCast[Person], logger: Logger):\n    logger.info(body)\n\n\n@app.after_startup\nasync def publish():\nbody = Person(name=\"john\", age=25).SerializeToString()\nawait broker.publish(body, \"test\")\n</code></pre> <p>Note that we used the <code>NoCast</code> annotation, which excludes the message from the <code>pydantic</code> representation of our handler.</p> <pre><code>async def consume(body: NoCast[Person], logger: Logger):\n</code></pre>"},{"location":"getting-started/serialization/examples/#msgpack","title":"Msgpack","text":"<p>Msgpack is an alternative binary data format too. Its main advantage is smaller <sup>2</sup> than JSON message size (but a little bigger than Protobuf) and it doesn't require any message schema (Protobuf does). So, you can easily use it in the most cases.</p> <p>First of all, install the dependencies:</p> <pre><code>pip install msgpack\n</code></pre> <p>And, because you need no any schema, you can easely write a Msgpack decoder:</p> <pre><code>import msgpack\nfrom faststream import FastStream, Logger\nfrom faststream.rabbit import RabbitBroker, RabbitMessage\n\nbroker = RabbitBroker()\napp = FastStream(broker)\n\n\nasync def decode_message(msg: RabbitMessage):\nreturn msgpack.loads(msg.body)\n@broker.subscriber(\"test\", decoder=decode_message)\nasync def consume(body, logger: Logger):\n    logger.info(body)\n\n\n@app.after_startup\nasync def publish():\nbody = msgpack.dumps({\"name\": \"john\", \"age\": 25}, use_bin_type=True)\nawait broker.publish(body, \"test\")\n</code></pre> <p>It is much easier than Protobuf schema usage. Thus, if you have no strict msg size limitations, you able to use Msgpack serialization almost everywhere.</p>"},{"location":"getting-started/serialization/examples/#tips","title":"Tips","text":""},{"location":"getting-started/serialization/examples/#data-compression","title":"Data compression","text":"<p>Also, if you are sending a really huge messages, you should try to compress them too. As an example, take a look at lz4 and  algorythms.</p> <p>This way you can reduce message size if it has some repeated blocks, but at the small message body cases data compressing able to extend it. So, you need to check compression effort in your application specific case.</p>"},{"location":"getting-started/serialization/examples/#broker-level-serialization","title":"Broker-level serialization","text":"<p>You are still able to set custom <code>decoder</code> on the Broker or Router level too. But, if you want to encode publishing messages automatically too, you should take a look at Middleware serialization implimentation.</p> <ol> <li> <p>For example, a message like <code>{ \"name\": \"john\", \"age\": 25 }</code> in JSON takes 27 bytes, and in Protobuf - 11. With lists and more complex structures, the savings can be even more significant (up to 20x times).\u00a0\u21a9</p> </li> <li> <p><code>{ \"name\": \"john\", \"age\": 25 }</code> with Msgpack serialization takes 16 bytes.\u00a0\u21a9</p> </li> </ol>"},{"location":"getting-started/serialization/parser/","title":"Custom Parser","text":"<p>At this stage, FastStream serializes an incoming message of the framework that is used to work with the broker into a general view - StreamMessage. At this stage, the message body remains in the form of raw bytes.</p> <p>StreamMessage - is a general FastStream message view. It contains total information about message required inside FastStreams. It is using to represent even a messages batches, so the only one reason to customize it - FastStream message metainformation redefinition.</p> <p>As an example: you can specify your own header with the <code>message_id</code> semantic. So, you can inform FastStream about it by parser customization.</p>"},{"location":"getting-started/serialization/parser/#signature","title":"Signature","text":"<p>To create a custom message parser you should write a regular (sync or async) python function with the following signature:</p> KafkaRabbitMQ <pre><code>from aiokafka import ConsumerRecord\nfrom faststream.kafka import KafkaMessage\n\ndef parser(msg: ConsumerRecord) -&gt; KafkaMessage:\n    ...\n</code></pre> <pre><code>from aio_pika import IncomingMessage\nfrom faststream.rabbit import RabbitMessage\n\ndef parser(msg: IncomingMessage) -&gt; RabbitMessage:\n    ...\n</code></pre> <p>Also, you are able to reuse the original parser function by using next signature</p> KafkaRabbitMQ <pre><code>from types import Callable, Awaitable\nfrom aiokafka import ConsumerRecord\nfrom faststream.kafka import KafkaMessage\n\nasync def parser(\n    msg: ConsumerRecord,\n    original_parser: Callable[[ConsumerRecord], Awaitable[KafkaMessage]],\n) -&gt; KafkaMessage:\n    return await original_parser(msg)\n</code></pre> <pre><code>from types import Callable, Awaitable\nfrom aio_pika import IncomingMessage\nfrom faststream.rabbit import RabbitMessage\n\nasync def parser(\n    msg: IncomingMessage,\n    original_parser: Callable[[IncomingMessage], Awaitable[RabbitMessage]],\n) -&gt; RabbitMessage:\n    return await original_parser(msg)\n</code></pre> <p>All arguments naming has no matter, parser will be always placed to the second one.</p> <p>Note</p> <p>Original parser is always async function, so your custom one should be an async too</p> <p>After you can set this parser at broker or subsriber level both.</p>"},{"location":"getting-started/serialization/parser/#example","title":"Example","text":"<p>As an example, let's redefine <code>message_id</code> to the custom header</p> KafkaRabbitMQ <pre><code>from typing import Awaitable, Callable\n\nfrom aiokafka import ConsumerRecord\n\nfrom faststream import FastStream\nfrom faststream.kafka import KafkaBroker, KafkaMessage\n\nasync def custom_parser(\nmsg: ConsumerRecord,\noriginal_parser: Callable[[ConsumerRecord], Awaitable[KafkaMessage]],\n) -&gt; KafkaMessage:\nparsed_msg = await original_parser(msg)\nparsed_msg.message_id = parsed_msg.headers[\"custom_message_id\"]\nreturn parsed_msg\n\nbroker = KafkaBroker(parser=custom_parser)\napp = FastStream(broker)\n\n\n@broker.subscriber(\"test\")\nasync def handle():\n    ...\n\n\n@app.after_startup\nasync def test():\nawait broker.publish(\"\", \"test\", headers={\"custom_message_id\": \"1\"})\n</code></pre> <pre><code>from typing import Awaitable, Callable\n\nfrom aio_pika import IncomingMessage\n\nfrom faststream import FastStream\nfrom faststream.rabbit import RabbitBroker, RabbitMessage\n\nasync def custom_parser(\nmsg: IncomingMessage,\noriginal_parser: Callable[[IncomingMessage], Awaitable[RabbitMessage]],\n) -&gt; RabbitMessage:\nparsed_msg = await original_parser(msg)\nparsed_msg.message_id = parsed_msg.headers[\"custom_message_id\"]\nreturn parsed_msg\n\nbroker = RabbitBroker(parser=custom_parser)\napp = FastStream(broker)\n\n\n@broker.subscriber(\"test\")\nasync def handle():\n    ...\n\n\n@app.after_startup\nasync def test():\nawait broker.publish(\"\", \"test\", headers={\"custom_message_id\": \"1\"})\n</code></pre>"},{"location":"getting-started/subscription/","title":"Subscription Basics","text":"<p>Topic/queue/subject/etc agnostic. The same syntax in a basic cases for all brokers:</p> KafkaRabbitMQ <p>Hi</p> <p>Hi</p> <p>Consumes a message body in the arguments, serialize it based on type annotations by the Pydantic. Allows to get access to the raw message and specific fields via the Context if it is required.</p> <p>Disable pydantic validation by <code>apply_types=False</code> (disables Context and Depends too)</p>"},{"location":"getting-started/subscription/#multiple-subscriptions","title":"Multiple Subscriptions","text":"<pre><code>@broker.subscriber(\"first_sub\")\n@broker.subscriber(\"second_sub\")\nasync def handler(msg):\n    ...\n</code></pre>"},{"location":"getting-started/subscription/annotation/","title":"Annotation Serialization","text":"<p>Use type annotation to serialize incoming message body</p> <p>Allows use all Pydantic specific fields (like HttpUrl, PositiveInt, e.t.c)</p> <p>Reuse imported block in the different translations</p> KafkaRabbitMQ <pre><code>from faststream import FastStream\nfrom faststream.kafka import KafkaBroker\n\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\n\n\n@broker.subscriber(\"test-topic\")\nasync def handle(name: str, user_id: int):\n    assert name == \"john\"\n    assert user_id == 1\n\n\n@app.after_startup\nasync def test():\n    await broker.publish({\"name\": \"john\", \"user_id\": 1}, topic=\"test-topic\")\n</code></pre> <pre><code>from faststream import FastStream\nfrom faststream.rabbit import RabbitBroker\n\nbroker = RabbitBroker(\"amqp://guest:guest@localhost:5672/\")\napp = FastStream(broker)\n\n\n@broker.subscriber(\"test-queue\")\nasync def handle(name: str, user_id: int):\n    assert name == \"john\"\n    assert user_id == 1\n\n\n@app.after_startup\nasync def test():\n    await broker.publish({\"name\": \"john\", \"user_id\": 1}, queue=\"test-queue\")\n</code></pre>"},{"location":"getting-started/subscription/filtering/","title":"Application-level filtering","text":"<p>Allows to specify message processing way by message headers, body type or smth else</p> <p>Message must be consumed be the ONE consumer (not some of them)</p> <p>Subscriber without filter - default subscriber. Consumes messages, not consumed by other filters.</p> KafkaRabbitMQ <pre><code>from faststream import FastStream\nfrom faststream.kafka import KafkaBroker\n\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\n\n\n@broker.subscriber(\n\"test-topic\", filter=lambda msg: msg.content_type == \"application/json\"\n)\nasync def handle(name: str, user_id: int):\n    assert name == \"john\"\n    assert user_id == 1\n@broker.subscriber(\"test-topic\")\nasync def default_handler(msg: str):\n    assert msg == \"Hello, FastStream!\"\n\n\n@app.after_startup\nasync def test():\n    await broker.publish({\"name\": \"john\", \"user_id\": 1}, topic=\"test-topic\")\n\n    await broker.publish(\n        \"Hello, FastStream!\",\n        topic=\"test-topic\",\n    )\n</code></pre> <pre><code>from faststream import FastStream\nfrom faststream.rabbit import RabbitBroker\n\nbroker = RabbitBroker(\"amqp://guest:guest@localhost:5672/\")\napp = FastStream(broker)\n\n\n@broker.subscriber(\n\"test-queue\", filter=lambda msg: msg.content_type == \"application/json\"\n)\nasync def handle(name: str, user_id: int):\n    assert name == \"john\"\n    assert user_id == 1\n@broker.subscriber(\"test-queue\")\nasync def default_handler(msg: str):\n    assert msg == \"Hello, FastStream!\"\n\n\n@app.after_startup\nasync def test():\n    await broker.publish({\"name\": \"john\", \"user_id\": 1}, queue=\"test-queue\")\n\n    await broker.publish(\n        \"Hello, FastStream!\",\n        queue=\"test-queue\",\n    )\n</code></pre>"},{"location":"getting-started/subscription/pydantic/","title":"Pydantic Serialization","text":"<p>For the most specific cases, where you need to setup extra validations, add something documentation information or smth else</p> <p>Able to use <code>pydantic.Field</code> in a subscriber type annotation</p> KafkaRabbitMQ <pre><code>from pydantic import Field, NonNegativeInt\n\nfrom faststream import FastStream\nfrom faststream.kafka import KafkaBroker\n\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\n\n\n@broker.subscriber(\"test-topic\")\nasync def handle(\nname: str = Field(..., examples=[\"john\"], description=\"Registered user name\"),\nuser_id: NonNegativeInt = Field(\n..., examples=[1], description=\"Registered user id\"\n),\n):\nassert name == \"john\"\n    assert user_id == 1\n\n\n@app.after_startup\nasync def test():\n    await broker.publish({\"name\": \"john\", \"user_id\": 1}, topic=\"test-topic\")\n</code></pre> <pre><code>from pydantic import Field, NonNegativeInt\n\nfrom faststream import FastStream\nfrom faststream.rabbit import RabbitBroker\n\nbroker = RabbitBroker(\"amqp://guest:guest@localhost:5672/\")\napp = FastStream(broker)\n\n\n@broker.subscriber(\"test-queue\")\nasync def handle(\nname: str = Field(..., examples=[\"john\"], description=\"Registered user name\"),\nuser_id: NonNegativeInt = Field(\n..., examples=[1], description=\"Registered user id\"\n),\n):\nassert name == \"john\"\n    assert user_id == 1\n\n\n@app.after_startup\nasync def test():\n    await broker.publish({\"name\": \"john\", \"user_id\": 1}, queue=\"test-queue\")\n</code></pre> <p>Or make this schema reusable with the <code>pydantic.BaseModel</code></p> KafkaRabbitMQ <pre><code>from pydantic import BaseModel, Field, NonNegativeInt\n\nfrom faststream import FastStream\nfrom faststream.kafka import KafkaBroker\n\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\n\n\nclass UserInfo(BaseModel):\nname: str = Field(..., examples=[\"john\"], description=\"Registered user name\")\nuser_id: NonNegativeInt = Field(..., examples=[1], description=\"Registered user id\")\n\n@broker.subscriber(\"test-topic\")\nasync def handle(user: UserInfo):\n    assert user.name == \"john\"\n    assert user.user_id == 1\n\n\n@app.after_startup\nasync def test():\n    await broker.publish({\"name\": \"john\", \"user_id\": 1}, topic=\"test-topic\")\n</code></pre> <pre><code>from pydantic import BaseModel, Field, NonNegativeInt\n\nfrom faststream import FastStream\nfrom faststream.rabbit import RabbitBroker\n\nbroker = RabbitBroker(\"amqp://guest:guest@localhost:5672/\")\napp = FastStream(broker)\n\n\nclass UserInfo(BaseModel):\nname: str = Field(..., examples=[\"john\"], description=\"Registered user name\")\nuser_id: NonNegativeInt = Field(..., examples=[1], description=\"Registered user id\")\n\n@broker.subscriber(\"test-queue\")\nasync def handle(user: UserInfo):\n    assert user.name == \"john\"\n    assert user.user_id == 1\n\n\n@app.after_startup\nasync def test():\n    await broker.publish({\"name\": \"john\", \"user_id\": 1}, queue=\"test-queue\")\n</code></pre>"},{"location":"getting-started/subscription/test/","title":"Subscriber testing","text":"<p>Original application</p> KafkaRabbitMQ <pre><code>@broker.subscriber(\"test-topic\")\nasync def handle(name: str, user_id: int):\n    assert name == \"john\"\n</code></pre> <pre><code>@broker.subscriber(\"test-topic\")\nasync def handle(name: str, user_id: int):\n    assert name == \"john\"\n</code></pre> <ul> <li>in-memory TestClient</li> <li>publishing (show error raising)</li> <li>check incoming message body</li> <li>note about mock clearing after context exit</li> </ul> KafkaRabbitMQ <pre><code>import pytest\nfrom pydantic import ValidationError\n\nfrom faststream.kafka import TestKafkaBroker\n\nfrom .annotation_kafka import broker, handle\n\n\n@pytest.mark.asyncio\nasync def test_handle():\n    async with TestKafkaBroker(broker) as br:\n        await br.publish({\"name\": \"john\", \"user_id\": 1}, topic=\"test-topic\")\n\n        handle.mock.assert_called_once_with({\"name\": \"john\", \"user_id\": 1})\n\n\n@pytest.mark.asyncio\nasync def test_validation_error():\n    async with TestKafkaBroker(broker) as br:\n        with pytest.raises(ValidationError):\n            await br.publish(\"wrong message\", topic=\"test-topic\")\n\n        handle.mock.assert_called_once_with(\"wrong message\")\n</code></pre> <pre><code>import pytest\nfrom pydantic import ValidationError\n\nfrom faststream.rabbit import TestRabbitBroker\n\nfrom .annotation_rabbit import broker, handle\n\n\n@pytest.mark.asyncio\nasync def test_handle():\n    async with TestRabbitBroker(broker) as br:\n        await br.publish({\"name\": \"john\", \"user_id\": 1}, queue=\"test-queue\")\n\n        handle.mock.assert_called_once_with({\"name\": \"john\", \"user_id\": 1})\n\n\n@pytest.mark.asyncio\nasync def test_validation_error():\n    async with TestRabbitBroker(broker) as br:\n        with pytest.raises(ValidationError):\n            await br.publish(\"wrong message\", queue=\"test-queue\")\n\n        handle.mock.assert_called_once_with(\"wrong message\")\n</code></pre> <ul> <li>test with real broker</li> <li>wait consumer called</li> </ul> <p>Show pytests setup toggle example (details in the application config):</p> <pre><code>REAL=True/False pytest tests\n</code></pre>"},{"location":"kafka/batch/","title":"Batch publishing","text":"<p>If you want to send your data in batches <code>broker.publisher</code> makes that possible for you. By returning a tuple of messages you want to send in a batch the publisher will collect the messages and send them in a batch to a Kafka broker.</p> <p>This guide will demonstrate how to use this feature.</p>"},{"location":"kafka/batch/#return-a-batch-from-the-publishing-function","title":"Return a batch from the publishing function","text":"<p>To define a batch that you want to produce to Kafka topic, you need to set the <code>batch</code> parameter of the publisher to <code>True</code> and return a tuple of messages that you want to send in a batch.</p> <pre><code>from pydantic import BaseModel, Field, NonNegativeFloat\nfrom faststream import FastStream, Logger\nfrom faststream.kafka import KafkaBroker\n\n\nclass DataBasic(BaseModel):\ndata: NonNegativeFloat = Field(\n..., examples=[0.5], description=\"Float data example\"\n)\n# Code below omitted \ud83d\udc47\n</code></pre> \ud83d\udc40 Full file preview <pre><code>from pydantic import BaseModel, Field, NonNegativeFloat\n\nfrom faststream import FastStream, Logger\nfrom faststream.kafka import KafkaBroker\n\n\nclass DataBasic(BaseModel):\n    data: NonNegativeFloat = Field(\n        ..., examples=[0.5], description=\"Float data example\"\n    )\n\n\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\n\n\n@broker.publisher(\"output_data\")\n@broker.subscriber(\"input_data\")\nasync def on_input_data(msg: DataBasic, logger: Logger) -&gt; DataBasic:\n    logger.info(msg)\n    return DataBasic(data=msg.data + 1.0)\n</code></pre>"},{"location":"kafka/message/","title":"Access to Message information","text":"<p>As you know, FastStream serializes a message body and provides you access to it by function arguments. But sometimes you want to access to message_id, headers or other meta information.</p>"},{"location":"kafka/message/#message-access","title":"Message access","text":"<p>You can get it in a simple way too: just acces to the message object in the Context!</p> <p>It is an unified FastStream wrapper around native broker library message (<code>aiokafka.ConsumerRecord</code> in the Kafka case). It contains most part of required information like:</p> <ul> <li><code>body: bytes</code></li> <li><code>decoded_body: Any</code></li> <li><code>content_type: str</code></li> <li><code>reply_to: str</code></li> <li><code>headers: dict[str, Any]</code></li> <li><code>message_id: str</code></li> <li><code>correlation_id: str</code></li> </ul> <pre><code>from faststream.kafka import KafkaMessage\n@broker.subscriber(\"test\")\nasync def base_handler(\n    body: str,\nmsg: KafkaMessage,\n):\n    print(msg.correlation_id)\n</code></pre> <p>Also, if you doesn't find information you reqiure, you can get access right to the wrapped <code>aiokafka.ConsumerRecord</code>, contains total message information.</p> <pre><code>from aiokafka import ConsumerRecord\nfrom faststream.kafka import KafkaMessage\n\n@broker.subscriber(\"test\")\nasync def base_handler(body: str, msg: KafkaMessage):\nraw: ConsumerRecord = msg.raw_message\nprint(raw)\n</code></pre>"},{"location":"kafka/message/#message-fields-access","title":"Message Fields access","text":"<p>But in the most cases you don't need all message fields, you need to know just one of them. You can use Context Fields access feature for this reason.</p> <p>Like an example, you can get access to the <code>correlation_id</code> like this:</p> <pre><code>from faststream import Context\n\n@broker.subscriber(\"test\")\nasync def base_handler(\n    body: str,\ncor_id: bytes = Context(\"message.correlation_id\"),\n):\n    print(cor_id)\n</code></pre> <p>Or even directly to the raw message partition key:</p> <pre><code>from faststream import Context\n\n@broker.subscriber(\"test\")\nasync def base_handler(\n    body: str,\nkey: bytes | None = Context(\"message.raw_message.key\"),\n):\n    print(key)\n</code></pre> <p>But this code is a too long to reuse it everywhere. Thus, you can use python <code>Annotated</code> feature:</p> python 3.9+python 3.6+ <pre><code>from types import Annotated\nfrom faststream import Context\n\nPartitionKey = Annotated[bytes | None, Context(\"message.raw_message.key\")]\n@broker.subscriber(\"test\")\nasync def base_handler(\n    body: str,\nkey: PartitionKey,\n):\n    print(key)\n</code></pre> <pre><code>from typing_extensions import Annotated\nfrom faststream import Context\n\nPartitionKey = Annotated[bytes | None, Context(\"message.raw_message.key\")]\n@broker.subscriber(\"test\")\nasync def base_handler(\n    body: str,\nkey: PartitionKey,\n):\n    print(key)\n</code></pre>"},{"location":"rabbit/","title":"Rabbit Routing","text":""},{"location":"rabbit/#advantages","title":"Advantages","text":"<p>The advantage of RabbitMQ is the ability to configure flexible and complex message routing scenarios.</p> <p>RabbitMQ covers the whole range of routing: from one queue - one consumer, to a queue retrieved from several sources, and the prioritization of messages also works.</p> <p>Note</p> <p>For more information about RabbitMQ, please visit the official documentation</p> <p>At the same time, it supports the ability to successfully process messages, mark them as processed with an error, remove them from the queue (it is also impossible to receive more messages processed, unlike Kafka), lock it for the processing duration, and monitor its current status.</p> <p>Having to keep track of the current status of all messages is a cause of the RabbitMQ performance falling. With really large message volumes, RabbitMQ starts to degrade. However, if this was a \"one-time influx\", then as consumers will free it, the \"health\" of RabbitMQ will be restored.</p> <p>If your scenario is not based on processing millions of messages, and also requires building complex routing logic - RabbitMQ you will be right choice.</p>"},{"location":"rabbit/#basic-concepts","title":"Basic concepts","text":"<p>If you want to totally understand how RabbitMQ works, you should visit their official website. Here you will find top-level comments about the basic concepts and usage examples.</p>"},{"location":"rabbit/#entities","title":"Entities","text":"<p>RabbitMQ works with three main entities:</p> <ul> <li><code>Exchange</code> - the point of receiving messages from publisher</li> <li><code>Queue</code> - the point of pushing messages to consumer</li> <li><code>Binding</code> - the relationship between queue-exchange or exchange-exchange</li> </ul>"},{"location":"rabbit/#routing-rules","title":"Routing rules","text":"<p>The rules for delivering messages to consumers depend on the type of exchange and binding parameters. All the main options will be discussed at examples.</p> <p>In general, the message path looks so:</p> <ol> <li>Publisher sends a message to <code>exchange</code>, specify its <code>routing_key</code> and headers according to which routing will take place</li> <li><code>exchange</code>, depending on the message parameters, determines which of the subscribed <code>bindings</code> to send the message to</li> <li><code>binding</code> delivers the message to <code>queue</code> or another <code>exchange</code> (in this case it will send it further by its own rules)</li> <li><code>queue</code>, after receiving a message, sends it to one of subscribed consumers (PUSH API)</li> </ol> <p>Tip</p> <p>By default, all queues have <code>binding</code> to <code>default exchange</code> (Direct type) with routing key corresponding to their name. In FastStream, queues are connected to this <code>exchange</code> and messages are sent by default unless another <code>exchange</code> is explicitly specified.</p> <p>With connecting the queue to any other <code>exchange</code>, it still remains subscribed to the `default exchange'. Be careful with this.</p> <p>At this stage, the message gets into your application - and you start processing it.</p>"},{"location":"rabbit/#message-statuses","title":"Message statuses","text":"<p>RabbitMQ requires confirmation of message processing: only after that it will be removed from a queue.</p> <p>Confirmation can be either positive (<code>Acknowledgment - ack</code>) if the message was successfully processed, or negative (<code>Negative Acknowledgment - nack</code>) if the message was processed with an error.</p> <p>At the same time, in case of an error, the message can also be extracted from the queue (<code>reject</code>), otherwise, after a negative confirmation, it will be requeued for processing again.</p> <p>In most cases, FastStream performs all the necessary actions by itself: however, if you want to manage the message lifecycle directly, you can access the message object itself and call the appropriate methods directly. This can be useful if you want to implement an \"at most once\" policy and you need to confirm receipt of the message before it is actually processed.</p>"},{"location":"rabbit/#faststream-specific","title":"FastStream specific","text":"<p>FastStream omits the ability to create <code>bindings</code> directly, since in most cases you do not need to subscribe one queue to several <code>exchanges</code> or subscribe <code>exchanges</code> to each other. On the contrary, this practice leads to over-complication of the message routing scheme, which makes it difficult to maintain and further develop the entire infrastructure of services.</p> <p>FastStream suggests you adhere to the scheme <code>exchange:queue</code> as <code>1:N</code>, which will greatly simplify the scheme of interaction between your services. It is better to create an additional queue for a new <code>exchange</code> than to subscribe to an existing one.</p> <p>However, if you want to reduce the number of entities in your RabbitMQ, and thereby optimize its performance (or you know exactly what you are doing), FastStream leaves you the option to create <code>bindings</code> directly. In other cases, the connection parameters are an integral part of the entities RabbitQueue and RabbitExchange in FastStream.</p>"},{"location":"rabbit/ack/","title":"Consuming Acknowledgement","text":"<p>As you may know, RabbitMQ uses a pretty reach Acknowledgement policy.</p> <p>In the most cases FastStream acks messages instead of you: when your function was executed correctly (include all responses sending), a message will be acked (and rejected at exception).</p> <p>But, sometimes you want to use a differ ack logic.</p>"},{"location":"rabbit/ack/#retries","title":"Retries","text":"<p>If you want to use nack instead reject at message processing error, you can specify <code>retry</code> flag in the <code>@broker.subscriber</code> method, which is responsible for error handling logic.</p> <p>By default, this flag has the value <code>False</code>, which indicates that if an error has occurred during message processing, it can still be retrieved from the queue:</p> <pre><code>@broker.subscriber(\"test\", retry=False) # don't handle exceptions\nasync def base_handler(body: str):\n    ...\n</code></pre> <p>If this flag is set to <code>True</code>, message will be nacked and placed back in the queue every time an error occurs. In this case, the message can be processed by another consumer (if there are several of them) or by the same one:</p> <pre><code>@broker.subscriber(\"test\", retry=True)  # try again indefinitely\nasync def base_handler(body: str):\n    ...\n</code></pre> <p>If the <code>retry</code> flag is set to <code>int</code>, the message will be placed back in the queue and the number of retries will be limited to this number:</p> <pre><code>@broker.subscriber(\"test\", retry=3)     # make up to 3 attempts\nasync def base_handler(body: str):\n    ...\n</code></pre> <p>Bug</p> <p>At the moment, attempts are counted only by the current consumer. If the message goes to another consumer, it have an own counter. Subsequently, this logic will be reworked.</p> <p>Tip</p> <p>At more complex error handling cases you can use tenacity</p>"},{"location":"rabbit/ack/#manual-ack","title":"Manual Ack","text":"<p>If you want to ack message manually, you can get access direct to the message object via the Context and call the method.</p> <pre><code>from faststream.rabbit import RabbitMessage\n\n@broker.subscriber(\"test\")\nasync def base_handler(body: str, msg: RabbitMessage):\n    await msg.ack()\n    # or\n    await msg.nack()\n    # or\n    await msg.reject()\n</code></pre> <p>FastStream will see that the message was already acked and will do nothing at process end.</p>"},{"location":"rabbit/ack/#interrupt-process","title":"Interrupt Process","text":"<p>If you want to interrup a message processing at any callstack, you can raise <code>faststream.exceptions.AckMessage</code> any your code place.</p> <pre><code>from faststream import FastStream\nfrom faststream.exceptions import AckMessage\nfrom faststream.rabbit import RabbitBroker\n\nbroker = RabbitBroker(\"amqp://guest:guest@localhost:5672/\")\napp = FastStream(broker)\n\n\n@broker.subscriber(\"test-queue\")\nasync def handle(body):\n    smth_processing(body)\n\n\ndef smth_processing(body):\n    if True:\nraise AckMessage()\n@app.after_startup\nasync def test_publishing():\n    await broker.publish(\"Hello!\", \"test-queue\")\n</code></pre> <p>This way FastStream interrupts the current message proccess and ack it immediately. Also, you able to raise <code>NackMessage</code> and <code>RejectMessage</code> too.</p>"},{"location":"rabbit/declare/","title":"RabbitMQ Queue/Exchange Declaration","text":"<p>FastStream declares and validates all using by publishers and subscribers RabbitMQ objects manually, but sometimes you need to declare not-using object manually.</p> <p>This reason RabbitBroker provides you a methods to make it easely.</p> <pre><code>from faststream import FastStream\nfrom faststream.rabbit import (\n    ExchangeType,\n    RabbitBroker,\n    RabbitExchange,\n    RabbitQueue,\n)\n\nbroker = RabbitBroker()\napp = FastStream(broker)\n\n\n@app.after_startup\nasync def declare_smth():\nawait broker.declare_exchange(\nRabbitExchange(\nname=\"some-exchange\",\ntype=ExchangeType.FANOUT,\n)\n)\nawait broker.declare_queue(\nRabbitQueue(\nname=\"some-queue\",\ndurable=True,\n)\n)\n</code></pre> <p>These methods require just a one argument (<code>RabbitQueue</code>/<code>RabbitExchange</code>) containing information about your RabbitMQ required objects. They are declare/validates RabbitMQ objects and returns you low-level aio-pika robust objects to interact with.</p> <p>Tip</p> <p>Also, these methods are indempotence, so you can call them with the same arguments multiple times, but the objects will creates just at once, next times the method will return already stored in memory object. This way you can get access to any queue/exchange created automatically.</p>"},{"location":"rabbit/message/","title":"Access to Message information","text":"<p>As you know, FastStream serializes a message body and provides you access to it by function arguments. But sometimes you want to access to message_id, headers or other meta information.</p>"},{"location":"rabbit/message/#message-access","title":"Message access","text":"<p>You can get it in a simple way too: just acces to the message object in the Context!</p> <p>It is an unified FastStream wrapper around native broker library message (<code>aio_pika.IncomingMessage</code> in the RabbitMQ case). It contains most part of required information like:</p> <ul> <li><code>body: bytes</code></li> <li><code>decoded_body: Any</code></li> <li><code>content_type: str</code></li> <li><code>reply_to: str</code></li> <li><code>headers: dict[str, Any]</code></li> <li><code>message_id: str</code></li> <li><code>correlation_id: str</code></li> </ul> <pre><code>from faststream.rabbit import RabbitMessage\n@broker.subscriber(\"test\")\nasync def base_handler(\n    body: str,\nmsg: RabbitMessage,\n):\n    print(msg.correlation_id)\n</code></pre> <p>Also, if you doesn't find information you reqiure, you can get access right to the wrapped <code>aio_pika.IncomingMessage</code>, contains total message information.</p> <pre><code>from aio_pika import IncomingMessage\nfrom faststream.rabbit import RabbitMessage\n\n@broker.subscriber(\"test\")\nasync def base_handler(body: str, msg: RabbitMessage):\nraw: IncomingMessage = msg.raw_message\nprint(raw)\n</code></pre>"},{"location":"rabbit/message/#message-fields-access","title":"Message Fields access","text":"<p>But in the most cases you don't need all message fields, you need to know just one of them. You can use Context Fields access feature for this reason.</p> <p>Like an example, you can get access to the <code>correlation_id</code> like this:</p> <pre><code>from faststream import Context\n\n@broker.subscriber(\"test\")\nasync def base_handler(\n    body: str,\ncor_id: str = Context(\"message.correlation_id\"),\n):\n    print(cor_id)\n</code></pre> <p>Or even directly from the raw message:</p> <pre><code>from faststream import Context\n\n@broker.subscriber(\"test\")\nasync def base_handler(\n    body: str,\ncor_id: str = Context(\"message.raw_message.correlation_id\"),\n):\n    print(cor_id)\n</code></pre> <p>But this code is a too long to reuse it everywhere. Thus, you can use python <code>Annotated</code> feature:</p> python 3.9+python 3.6+ <pre><code>from types import Annotated\nfrom faststream import Context\n\nCorrelationId = Annotated[str, Context(\"message.correlation_id\")]\n@broker.subscriber(\"test\")\nasync def base_handler(\n    body: str,\ncor_id: CorrelationId,\n):\n    print(cor_id)\n</code></pre> <pre><code>from typing_extensions import Annotated\nfrom faststream import Context\n\nCorrelationId = Annotated[str, Context(\"message.correlation_id\")]\n@broker.subscriber(\"test\")\nasync def base_handler(\n    body: str,\ncor_id: CorrelationId,\n):\n    print(cor_id)\n</code></pre>"},{"location":"rabbit/publishing/","title":"Publishing","text":"<p>FastStream RabbitBroker supports all regular publishing usecases, you can use them without any changes.</p> <p>The only one RMQ specific thing - these methods parameters, so you should know about all of them.</p>"},{"location":"rabbit/publishing/#rabbit-publishing","title":"Rabbit Publishing","text":"<p><code>RabbitBroker</code> also uses the unified <code>publish</code> method (as a <code>publisher</code> object too) to send a message.</p> <p>However, in this case, an object of the <code>aio_pika.Message</code> class (if necessary) can be used as a message (in addition to python primitives and <code>pydantic.BaseModel</code>).</p> <p>You can specify queue (uses as a routing_key) and exchange (optionally) to send by their name.</p> <pre><code>import asyncio\nfrom faststream.rabbit import RabbitBroker\n\nasync def pub():\n    async with RabbitBroker() as broker:\n        await broker.publish(\n            \"Hi!\",\n            queue=\"test\",\n            exchange=\"test\"\n        )\n\nasyncio.run(pub())\n</code></pre> <p>If you don't specify any exchange, message will be send to the default one.</p> <p>Also, you able to use special RabbitQueue and RabbitExchange objects as a <code>queue</code> and <code>exchange</code> arguments:</p> <pre><code>from faststream.rabbit import RabbitExchange, RabbitQueue\n\nawait broker.publish(\n    \"Hi!\",\n    queue=RabbitQueue(\"test\"),\n    exchange=RabbitExchange(\"test\")\n)\n</code></pre> <p>If you specify not-existed exchange, RabbitBroker creates a required one and then publish a message.</p> <p>Tip</p> <p>Be accurate with it: if you have already created Exchange with specific parameters and try to send a message by exchange name to it, FastStream converts your string to RabbitExchange object with default parameters and broker will try to create it. So, Exchange parameters conflict will occure.</p> <p>If you are trying to send a message to specific Exchange - sending with a RabbitExchange object is a preffered way.</p>"},{"location":"rabbit/publishing/#basic-arguments","title":"Basic arguments","text":"<p>The <code>publish</code> method takes the following arguments:</p> <ul> <li><code>message = \"\"</code> - message to send</li> <li><code>exchange: str | RabbitExchange | None = None</code> - the exchange where the message will be sent to. If not specified - default is used</li> <li><code>queue: str | RabbitQueue = \"\"</code> - the queue where the message will be sent (since most queues use their name as the routing key, this is a human-readable version of <code>routing_key</code>)</li> <li><code>routing_key: str = \"\"</code> - also a message routing key, if not specified, the <code>queue</code> argument will be used</li> </ul>"},{"location":"rabbit/publishing/#message-parameters","title":"Message parameters","text":"<p>You can read more about all the flags in the RabbitMQ documentation</p> <ul> <li><code>headers: dict[str, Any] | None = None</code> - message headers (used by consumers)</li> <li><code>content_type: str | None = None</code> - the content_type of the message being sent (setted automatically, used by consumers)</li> <li><code>content_encoding: str | None = None</code> - encoding of the message (used by consumers)</li> <li><code>persist: bool = False</code> - restore messages on RabbitMQ reboot</li> <li><code>priority: int | None = None</code> - the priority of the message</li> <li><code>correlation_id: str | None = None</code> - message id, which helps to match the original message with the reply to it (generated automatically)</li> <li><code>message_id: str | None = None</code> - message ID (generated automatically)</li> <li><code>timestamp: int | float | time delta | datetime | None = None</code> - message sending time (setted automatically)</li> <li><code>expiration: int | float | time delta | datetime | None = None</code> - message lifetime (in seconds)</li> <li><code>type: str | None = None</code> - the type of message (used by consumers)</li> <li><code>user_id: str | None = None</code> - ID of the RabbitMQ user who sent the message</li> <li><code>app_id: str | None = None</code> - ID of the application that sent the message (used by consumers)</li> </ul>"},{"location":"rabbit/publishing/#send-flags","title":"Send flags","text":"<p>Arguments for sending a message:</p> <ul> <li><code>mandatory: bool = True</code> - the client is waiting for confirmation that the message will be placed in some queue (if there are no queues, return it to the sender)</li> <li><code>immediate: bool = False</code> - the client expects that there is a consumer ready to take the message to work \"right now\" (if there is no consumer, return it to the sender)</li> <li><code>timeout: int | float | None = None</code> - send confirmation time from RabbitMQ</li> </ul>"},{"location":"rabbit/rpc/","title":"RPC over RMQ","text":""},{"location":"rabbit/rpc/#blocking-request","title":"Blocking request","text":"<p>FastStream provides you with the ability to send low-cost blocking RPC request over RabbitMQ in a very simple way.</p> <p>It uses the Direct Reply-To RabbitMQ feature, so you need no to create any queues to consume a response.</p> <p>Just send a message like a regular one and get a response synchronously.</p> <p>It is a very close to common requests syntax, so you shouldn't have any problems with it</p> <pre><code>msg = await broker.publish(\n\"Hi!\",\n    queue=\"test\",\nrpc=True,\n)\n</code></pre> <p>Also, you have a two extra options to control this behavior:</p> <ul> <li><code>rpc_timeout: Optional[float] = 30.0</code> - controls how long you are waiting for response</li> <li><code>raise_timeout: bool = False</code> - by default timeout request returns <code>None</code>, but if you need to raise TimeoutException directly, you can specify this option</li> </ul>"},{"location":"rabbit/rpc/#reply-to","title":"Reply-To","text":"<p>Also, if you want to create permanent request-reply data flow, probably, you should create a permanent queue to consume responses.</p> <p>So, if you have a such one, you can specify it with <code>reply_to</code> argument. This way FastStream will send a response in this queue automatically.</p> <pre><code>@broker.subscriber(\"response-queue\")\nasync def consume_responses(msg):\n    ...\n\nmsg = await broker.publish(\n    \"Hi!\",\n    queue=\"test\",\nreply_to=\"response-queue\",\n)\n</code></pre>"},{"location":"rabbit/examples/","title":"Basic Subscriber","text":"<p>If you know nothing about RabbitMQ and how it works you still able to use FastStream RabbitBroker.</p> <p>Just use <code>@broker.subscriber</code> method with a string as a routing key.</p> <pre><code>from faststream import FastStream\nfrom faststream.rabbit import RabbitBroker\n\nbroker = RabbitBroker()\napp = FastStream(broker)\n\n\n@broker.subscriber(\"routing_key\")  # handle messages by routing key\nasync def handle(msg):\n    print(msg)\n\n\n@app.after_startup\nasync def test_publish():\n    await broker.publish(\n        \"message\",\n        \"routing_key\",  # publish message with routing key\n    )\n</code></pre> <p>This way all FastStream brokers are working: you don't need to learn them deeper if you want to just send a message</p>"},{"location":"rabbit/examples/#rabbitmq-details","title":"RabbitMQ details","text":"<p>If you are already known about RabbitMQ logic, you should know about the example above inner logic too. In this case FastStream creates or validates routing_key name queue and bind it to the RabbitMQ default exchange.</p> <p>If you want to specify queue-exchange pair with any arguments, FastStream provides you with we ability to make it too. You can use special <code>RabbitQueue</code> and <code>RabbitExchange</code> objects to setup any RabbitMQ queues, exchanges and bindings properties. The examples of various exchanges usage you can find in the following articles.</p>"},{"location":"rabbit/examples/direct/","title":"Direct Exchange","text":"<p>Direct Exchange is the basic way to route messages in RabbitMQ. Its core is very simple: <code>exchange</code> sends messages to those queues, <code>routing_key</code> which matches the <code>routing_key</code> of the message being sent.</p> <p>Note</p> <p>Default Exchange, to which all queues in RabbitMQ are subscribed, has the Direct type by default</p>"},{"location":"rabbit/examples/direct/#scaling","title":"Scaling","text":"<p>If several consumers are listening to the same queue, messages will go to the one of them (round-robin). This behavior is common for all types of <code>exchange</code>, because it refers to the queue itself. The type of <code>exchange</code> affects which queues the message gets into.</p> <p>Thus, RabbitMQ can independently balance the load on queue consumers. You can increase the processing speed of the message flow from the queue by launching additional instances of a consumer service. You don't need to make changes to the current infrastructure configuration: RabbitMQ will take care of how to distribute messages between your services.</p>"},{"location":"rabbit/examples/direct/#example","title":"Example","text":"<p>Tip</p> <p>Direct Exchange is the type used in FastStream by default: you can simply declare it as follows</p> <pre><code>@broker.subscriber(\"test_queue\", \"test_exchange\")\nasync def handler():\n    ...\n</code></pre> <p>The argument <code>auto_delete=True</code> in this and subsequent examples is used only to clear the state of RabbitMQ after example runs</p> <pre><code>from faststream import FastStream, Logger\nfrom faststream.rabbit import RabbitBroker, RabbitExchange, RabbitQueue\n\nbroker = RabbitBroker()\napp = FastStream(broker)\n\nexch = RabbitExchange(\"exchange\", auto_delete=True)\n\nqueue_1 = RabbitQueue(\"test-q-1\", auto_delete=True)\nqueue_2 = RabbitQueue(\"test-q-2\", auto_delete=True)\n\n\n@broker.subscriber(queue_1, exch)\nasync def base_handler1(logger: Logger):\n    logger.info(\"base_handler1\")\n\n\n@broker.subscriber(queue_1, exch)\nasync def base_handler2(logger: Logger):\n    logger.info(\"base_handler2\")\n\n\n@broker.subscriber(queue_2, exch)\nasync def base_handler3(logger: Logger):\n    logger.info(\"base_handler3\")\n\n\n@app.after_startup\nasync def send_messages():\n    await broker.publish(queue=\"test-q-1\", exchange=exch)  # handlers: 1\n    await broker.publish(queue=\"test-q-1\", exchange=exch)  # handlers: 2\n    await broker.publish(queue=\"test-q-1\", exchange=exch)  # handlers: 1\n    await broker.publish(queue=\"test-q-2\", exchange=exch)  # handlers: 3\n</code></pre>"},{"location":"rabbit/examples/direct/#consumer-announcement","title":"Consumer Announcement","text":"<p>To begin with, we announced our Direct exchange and several queues that will listen to it:</p> <pre><code>exch = RabbitExchange(\"exchange\", auto_delete=True)\n\nqueue_1 = RabbitQueue(\"test-q-1\", auto_delete=True)\nqueue_2 = RabbitQueue(\"test-q-2\", auto_delete=True)\n</code></pre> <p>Then we signed up several consumers using the advertised queues to the <code>exchange</code> we created</p> <pre><code>@broker.subscriber(queue_1, exch)\nasync def base_handler1(logger: Logger):\n    logger.info(\"base_handler1\")\n\n\n@broker.subscriber(queue_1, exch)\nasync def base_handler2(logger: Logger):\n    logger.info(\"base_handler2\")\n\n\n@broker.subscriber(queue_2, exch)\nasync def base_handler3(logger: Logger):\n    logger.info(\"base_handler3\")\n</code></pre> <p>Note</p> <p><code>handler1</code> and <code>handler2</code> are subscribed to the same <code>exchange</code> using the same queue: within a single service, this does not make a sense, since messages will come to these handlers in turn. Here we emulate the work of several consumers and load balancing between them.</p>"},{"location":"rabbit/examples/direct/#message-distribution","title":"Message distribution","text":"<p>Now the distribution of messages between these consumers will look like this:</p> <pre><code>    await broker.publish(queue=\"test-q-1\", exchange=exch)  # handlers: 1\n</code></pre> <p>Message <code>1</code> will be sent to <code>handler1</code> because it listens to <code>exchange</code> using a queue with the routing key <code>test-q-1</code></p> <pre><code>    await broker.publish(queue=\"test-q-1\", exchange=exch)  # handlers: 2\n</code></pre> <p>Message <code>2</code> will be sent to <code>handler2</code> because it listens to <code>exchange</code> using the same queue, but <code>handler1</code> is busy</p> <pre><code>    await broker.publish(queue=\"test-q-1\", exchange=exch)  # handlers: 1\n</code></pre> <p>Message <code>3</code> will be sent to <code>handler1</code> again, because it is currently free</p> <pre><code>    await broker.publish(queue=\"test-q-2\", exchange=exch)  # handlers: 3\n</code></pre> <p>Message <code>4</code> will be sent to <code>handler3</code>, because it is the only one listening to <code>exchange</code> using a queue with the routing key <code>test-q-2</code></p>"},{"location":"rabbit/examples/fanout/","title":"Fanout Exchange","text":"<p>Fanout Exchange is an even simpler, but slightly less popular way of routing in RabbitMQ. This type of <code>exchange</code> sends messages to all queues subscribed to it, ignoring any arguments of the message.</p> <p>At the same time, if the queue listens to several consumers, messages will also be distributed among them.</p>"},{"location":"rabbit/examples/fanout/#example","title":"Example","text":"<pre><code>from faststream import FastStream, Logger\nfrom faststream.rabbit import ExchangeType, RabbitBroker, RabbitExchange, RabbitQueue\n\nbroker = RabbitBroker()\napp = FastStream(broker)\n\nexch = RabbitExchange(\"exchange\", auto_delete=True, type=ExchangeType.FANOUT)\n\nqueue_1 = RabbitQueue(\"test-q-1\", auto_delete=True)\nqueue_2 = RabbitQueue(\"test-q-2\", auto_delete=True)\n\n\n@broker.subscriber(queue_1, exch)\nasync def base_handler1(logger: Logger):\n    logger.info(\"base_handler1\")\n\n\n@broker.subscriber(queue_1, exch)\nasync def base_handler2(logger: Logger):\n    logger.info(\"base_handler2\")\n\n\n@broker.subscriber(queue_2, exch)\nasync def base_handler3(logger: Logger):\n    logger.info(\"base_handler3\")\n\n\n@app.after_startup\nasync def send_messages():\n    await broker.publish(exchange=exch)  # handlers: 1, 3\n    await broker.publish(exchange=exch)  # handlers: 2, 3\n    await broker.publish(exchange=exch)  # handlers: 1, 3\n    await broker.publish(exchange=exch)  # handlers: 2, 3\n</code></pre>"},{"location":"rabbit/examples/fanout/#consumer-announcement","title":"Consumer Announcement","text":"<p>To begin with, we announced our Fanout exchange and several queues that will listen to it:</p> <pre><code>exch = RabbitExchange(\"exchange\", auto_delete=True, type=ExchangeType.FANOUT)\nqueue_1 = RabbitQueue(\"test-q-1\", auto_delete=True)\nqueue_2 = RabbitQueue(\"test-q-2\", auto_delete=True)\n</code></pre> <p>Then we signed up several consumers using the advertised queues to the <code>exchange</code> we created</p> <pre><code>@broker.subscriber(queue_1, exch)\nasync def base_handler1(logger: Logger):\n    logger.info(\"base_handler1\")\n\n\n@broker.subscriber(queue_1, exch)\nasync def base_handler2(logger: Logger):\n    logger.info(\"base_handler2\")\n\n\n@broker.subscriber(queue_2, exch)\nasync def base_handler3(logger: Logger):\n    logger.info(\"base_handler3\")\n</code></pre> <p>Note</p> <p><code>handler1</code> and <code>handler2</code> are subscribed to the same <code>exchange</code> using the same queue: within a single service, this does not make a sense, since messages will come to these handlers in turn. Here we emulate the work of several consumers and load balancing between them.</p>"},{"location":"rabbit/examples/fanout/#message-distribution","title":"Message distribution","text":"<p>Now the distribution of messages between these consumers will look like this:</p> <pre><code>    await broker.publish(exchange=exch)  # handlers: 1, 3\n</code></pre> <p>Message <code>1</code> will be sent to <code>handler1</code> and <code>handler3</code>, because they listen to <code>exchange</code> using different queues</p> <pre><code>    await broker.publish(exchange=exch)  # handlers: 2, 3\n</code></pre> <p>Message <code>2</code> will be sent to <code>handler2</code> and <code>handler3</code>, because <code>handler2</code> listens to <code>exchange</code> using the same queue as <code>handler1</code></p> <pre><code>    await broker.publish(exchange=exch)  # handlers: 1, 3\n</code></pre> <p>Message <code>3</code> will be sent to <code>handler1</code> and <code>handler3</code></p> <pre><code>    await broker.publish(exchange=exch)  # handlers: 2, 3\n</code></pre> <p>Message <code>4</code> will be sent to <code>handler3</code> and <code>handler3</code></p> <p>Note</p> <p>When sending messages to Fanout exchange, it makes no sense to specify the arguments <code>queue</code> or <code>routing_key</code>, because they will be ignored</p>"},{"location":"rabbit/examples/headers/","title":"Header Exchange","text":"<p>Header Exchange is the most complex and flexible way to route messages in RabbitMQ. This <code>exchange</code> type sends messages to queues in according the matching of a queues binding arguments  with message headers.</p> <p>At the same time, if the queue listens to several consumers, messages will also be distributed among them.</p>"},{"location":"rabbit/examples/headers/#example","title":"Example","text":"<pre><code>from faststream import FastStream, Logger\nfrom faststream.rabbit import ExchangeType, RabbitBroker, RabbitExchange, RabbitQueue\n\nbroker = RabbitBroker()\napp = FastStream(broker)\n\nexch = RabbitExchange(\"exchange\", auto_delete=True, type=ExchangeType.HEADERS)\n\nqueue_1 = RabbitQueue(\n    \"test-queue-1\",\n    auto_delete=True,\n    bind_arguments={\"key\": 1},\n)\nqueue_2 = RabbitQueue(\n    \"test-queue-2\",\n    auto_delete=True,\n    bind_arguments={\"key\": 2, \"key2\": 2, \"x-match\": \"any\"},\n)\nqueue_3 = RabbitQueue(\n    \"test-queue-3\",\n    auto_delete=True,\n    bind_arguments={\"key\": 2, \"key2\": 2, \"x-match\": \"all\"},\n)\n\n\n@broker.subscriber(queue_1, exch)\nasync def base_handler1(logger: Logger):\n    logger.info(\"base_handler1\")\n\n\n@broker.subscriber(queue_1, exch)\nasync def base_handler2(logger: Logger):\n    logger.info(\"base_handler2\")\n\n\n@broker.subscriber(queue_2, exch)\nasync def base_handler3(logger: Logger):\n    logger.info(\"base_handler3\")\n\n\n@broker.subscriber(queue_3, exch)\nasync def base_handler4(logger: Logger):\n    logger.info(\"base_handler4\")\n\n\n@app.after_startup\nasync def send_messages():\n    await broker.publish(exchange=exch, headers={\"key\": 1})  # handlers: 1\n    await broker.publish(exchange=exch, headers={\"key\": 1})  # handlers: 2\n    await broker.publish(exchange=exch, headers={\"key\": 1})  # handlers: 1\n    await broker.publish(exchange=exch, headers={\"key\": 2})  # handlers: 3\n    await broker.publish(exchange=exch, headers={\"key2\": 2})  # handlers: 3\n    await broker.publish(\n        exchange=exch, headers={\"key\": 2, \"key2\": 2.0}\n    )  # handlers: 3, 4\n</code></pre>"},{"location":"rabbit/examples/headers/#consumer-announcement","title":"Consumer Announcement","text":"<p>To begin with, we announced our Fanout exchange and several queues that will listen to it:</p> <pre><code>exch = RabbitExchange(\"exchange\", auto_delete=True, type=ExchangeType.HEADERS)\nqueue_1 = RabbitQueue(\n    \"test-queue-1\",\n    auto_delete=True,\nbind_arguments={\"key\": 1},\n)\nqueue_2 = RabbitQueue(\n    \"test-queue-2\",\n    auto_delete=True,\nbind_arguments={\"key\": 2, \"key2\": 2, \"x-match\": \"any\"},\n)\nqueue_3 = RabbitQueue(\n    \"test-queue-3\",\n    auto_delete=True,\nbind_arguments={\"key\": 2, \"key2\": 2, \"x-match\": \"all\"},\n)\n</code></pre> <p>The <code>x-match</code> argument indicates whether the arguments should match the message headers in whole or in part.</p> <p>Then we signed up several consumers using the advertised queues to the <code>exchange</code> we created</p> <pre><code>@broker.subscriber(queue_1, exch)\nasync def base_handler1(logger: Logger):\n    logger.info(\"base_handler1\")\n\n\n@broker.subscriber(queue_1, exch)\nasync def base_handler2(logger: Logger):\n    logger.info(\"base_handler2\")\n\n\n@broker.subscriber(queue_2, exch)\nasync def base_handler3(logger: Logger):\n    logger.info(\"base_handler3\")\n\n\n@broker.subscriber(queue_3, exch)\nasync def base_handler4(logger: Logger):\n    logger.info(\"base_handler4\")\n</code></pre> <p>Note</p> <p><code>handler1</code> and <code>handler2</code> are subscribed to the same <code>exchange</code> using the same queue: within a single service, this does not make a sense, since messages will come to these handlers in turn. Here we emulate the work of several consumers and load balancing between them.</p>"},{"location":"rabbit/examples/headers/#message-distribution","title":"Message distribution","text":"<p>Now the distribution of messages between these consumers will look like this:</p> <pre><code>    await broker.publish(exchange=exch, headers={\"key\": 1})  # handlers: 1\n</code></pre> <p>Message <code>1</code> will be sent to <code>handler1</code>, because it listens to a queue whose <code>key</code> header matches the <code>key</code> header of the message</p> <pre><code>    await broker.publish(exchange=exch, headers={\"key\": 1})  # handlers: 2\n</code></pre> <p>Message <code>2</code> will be sent to <code>handler2</code> because it listens to <code>exchange</code> using the same queue, but <code>handler1</code> is busy</p> <pre><code>    await broker.publish(exchange=exch, headers={\"key\": 1})  # handlers: 1\n</code></pre> <p>Message <code>3</code> will be sent to <code>handler1</code> again, because it is currently free</p> <pre><code>    await broker.publish(exchange=exch, headers={\"key\": 2})  # handlers: 3\n</code></pre> <p>Message <code>4</code> will be sent to <code>handler3</code>, because it listens to a queue whose <code>key</code> header coincided with the <code>key</code> header of the message</p> <pre><code>    await broker.publish(exchange=exch, headers={\"key2\": 2})  # handlers: 3\n</code></pre> <p>Message <code>5</code> will be sent to <code>handler3</code>, because it listens to a queue whose header <code>key2</code> coincided with the header <code>key2</code> of the message</p> <pre><code>    await broker.publish(\n        exchange=exch, headers={\"key\": 2, \"key2\": 2.0}\n    )  # handlers: 3, 4\n</code></pre> <p>Message <code>6</code> will be sent to <code>handler3</code> and <code>handler4</code>, because the message headers completely match the queue keys</p> <p>Note</p> <p>When sending messages to Header exchange, it makes no sense to specify the arguments <code>queue</code> or <code>routing_key</code>, because they will be ignored</p> <p>Warning</p> <p>For incredibly complex routes, you can use the option to bind an <code>exchange</code> to another <code>exchange</code>. In this case, all the same rules apply as for queues subscribed to <code>exchange</code>. The only difference is that the signed <code>exchange</code> can further distribute messages according to its own rules.</p> <p>So, for example, you can combine Topic and Header exchange types.</p>"},{"location":"rabbit/examples/stream/","title":"RabbitMQ Streams","text":"<p>RabbitMQ has a Streams feature, pretty close to Kafka topics.</p> <p>The main difference from regular RabbitMQ queues - messages are not deletes after consuming.</p> <p>And FastStream supports this prefect feature as well!</p> <pre><code>from faststream import FastStream, Logger\nfrom faststream.rabbit import RabbitBroker, RabbitQueue\n\nbroker = RabbitBroker(max_consumers=10)\napp = FastStream(broker)\n\nqueue = RabbitQueue(\n    name=\"test\",\n    durable=True,\narguments={\n\"x-queue-type\": \"stream\",\n},\n)\n\n\n@broker.subscriber(\nqueue,\nconsume_arguments={\"x-stream-offset\": \"first\"},\n)\nasync def handle(msg, logger: Logger):\n    logger.info(msg)\n\n\n@app.after_startup\nasync def test():\n    await broker.publish(\"Hi!\", queue)\n</code></pre>"},{"location":"rabbit/examples/topic/","title":"Topic Exchange","text":"<p>Topic Exchange is a powerful RabbitMQ routing tool. This type of <code>exchange</code> sends messages to the queue in accordance with the pattern specified when they are connected to <code>exchange</code> and the <code>routing_key</code> of the message itself.</p> <p>At the same time, if the queue listens to several consumers, messages will also be distributed among them.</p>"},{"location":"rabbit/examples/topic/#example","title":"Example","text":"<pre><code>from faststream import FastStream, Logger\nfrom faststream.rabbit import ExchangeType, RabbitBroker, RabbitExchange, RabbitQueue\n\nbroker = RabbitBroker()\napp = FastStream(broker)\n\nexch = RabbitExchange(\"exchange\", auto_delete=True, type=ExchangeType.TOPIC)\n\nqueue_1 = RabbitQueue(\"test-queue-1\", auto_delete=True, routing_key=\"*.info\")\nqueue_2 = RabbitQueue(\"test-queue-2\", auto_delete=True, routing_key=\"*.debug\")\n\n\n@broker.subscriber(queue_1, exch)\nasync def base_handler1(logger: Logger):\n    logger.info(\"base_handler1\")\n\n\n@broker.subscriber(queue_1, exch)\nasync def base_handler2(logger: Logger):\n    logger.info(\"base_handler2\")\n\n\n@broker.subscriber(queue_2, exch)\nasync def base_handler3(logger: Logger):\n    logger.info(\"base_handler3\")\n\n\n@app.after_startup\nasync def send_messages():\n    await broker.publish(routing_key=\"logs.info\", exchange=exch)  # handlers: 1\n    await broker.publish(routing_key=\"logs.info\", exchange=exch)  # handlers: 2\n    await broker.publish(routing_key=\"logs.info\", exchange=exch)  # handlers: 1\n    await broker.publish(routing_key=\"logs.debug\", exchange=exch)  # handlers: 3\n</code></pre>"},{"location":"rabbit/examples/topic/#consumer-announcement","title":"Consumer Announcement","text":"<p>To begin with, we announced our Topic exchange and several queues that will listen to it:</p> <pre><code>exch = RabbitExchange(\"exchange\", auto_delete=True, type=ExchangeType.TOPIC)\nqueue_1 = RabbitQueue(\"test-queue-1\", auto_delete=True, routing_key=\"*.info\")\nqueue_2 = RabbitQueue(\"test-queue-2\", auto_delete=True, routing_key=\"*.debug\")\n</code></pre> <p>At the same time, in the <code>routing_key</code> of our queues, we specify the pattern of routing keys that will be processed by this queue.</p> <p>Then we signed up several consumers using the advertised queues to the <code>exchange</code> we created</p> <pre><code>@broker.subscriber(queue_1, exch)\nasync def base_handler1(logger: Logger):\n    logger.info(\"base_handler1\")\n\n\n@broker.subscriber(queue_1, exch)\nasync def base_handler2(logger: Logger):\n    logger.info(\"base_handler2\")\n\n\n@broker.subscriber(queue_2, exch)\nasync def base_handler3(logger: Logger):\n    logger.info(\"base_handler3\")\n</code></pre> <p>Note</p> <p><code>handler1</code> and <code>handler2</code> are subscribed to the same <code>exchange</code> using the same queue: within a single service, this does not make a sense, since messages will come to these handlers in turn. Here we emulate the work of several consumers and load balancing between them.</p>"},{"location":"rabbit/examples/topic/#message-distribution","title":"Message distribution","text":"<p>Now the distribution of messages between these consumers will look like this:</p> <pre><code>    await broker.publish(routing_key=\"logs.info\", exchange=exch)  # handlers: 1\n</code></pre> <p>Message <code>1</code> will be sent to <code>handler1</code> because it listens to <code>exchange</code> using a queue with the routing key <code>*.info</code></p> <pre><code>    await broker.publish(routing_key=\"logs.info\", exchange=exch)  # handlers: 2\n</code></pre> <p>Message <code>2</code> will be sent to <code>handler2</code> because it listens to <code>exchange</code> using the same queue, but <code>handler1</code> is busy</p> <pre><code>    await broker.publish(routing_key=\"logs.info\", exchange=exch)  # handlers: 1\n</code></pre> <p>Message <code>3</code> will be sent to <code>handler1</code> again, because it is currently free</p> <pre><code>    await broker.publish(routing_key=\"logs.debug\", exchange=exch)  # handlers: 3\n</code></pre> <p>Message <code>4</code> will be sent to <code>handler3</code>, because it is the only one listening to <code>exchange</code> using a queue with the routing key <code>*.debug</code></p>"}]}