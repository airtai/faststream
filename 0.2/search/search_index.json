{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>FastStream</li> <li>Tutorial<ul> <li>Getting Started</li> <li>Subscription and Serialization<ul> <li>Annotation Serialization</li> <li>Pydantic Serialization</li> <li>Filtering</li> <li>Testing</li> </ul> </li> <li>Publishing<ul> <li>Broker Publish</li> <li>Decorator</li> <li>Object Decorator</li> <li>Direct Publishing</li> <li>Testing</li> </ul> </li> <li>Routers</li> <li>Dependencies</li> <li>Context<ul> <li>Existing Fields</li> <li>Custom Context</li> <li>Fields Access</li> <li>Extra Options</li> </ul> </li> <li>Custom Serialization<ul> <li>Parser</li> <li>Decoder</li> <li>Examples</li> </ul> </li> <li>Lifespan<ul> <li>Lifespan Hooks</li> <li>Lifespan Testing</li> </ul> </li> <li>Middlewares</li> <li>AsyncAPI<ul> <li>Schema Export</li> <li>Schema Hosting</li> <li>Customize Information</li> </ul> </li> <li>Integrations</li> <li>FastAPI Plugin</li> <li>CLI commands</li> <li>Logging</li> <li>Config Management</li> <li>Using FastStream Template</li> </ul> </li> <li>Kafka<ul> <li>Subscription<ul> <li>Batch Subscriber</li> </ul> </li> <li>Publishing<ul> <li>Batch Publishing</li> <li>Publish With Key</li> </ul> </li> <li>Message Information</li> </ul> </li> <li>RabbitMQ<ul> <li>Subscription<ul> <li>Direct</li> <li>Fanout</li> <li>Topic</li> <li>Headers</li> <li>Stream</li> </ul> </li> <li>Publishing</li> <li>RPC</li> <li>Acknowledgement</li> <li>Declare Queue/Exchange</li> <li>Message Information</li> </ul> </li> <li>NATS<ul> <li>Subscription<ul> <li>Direct</li> <li>Pattern</li> </ul> </li> <li>JetStream<ul> <li>Key-Value Storage</li> <li>Object Storage</li> <li>Acknowledgement</li> </ul> </li> <li>Publishing</li> <li>RPC</li> <li>Message Information</li> </ul> </li> <li>Contributing<ul> <li>Development</li> <li>Documentation</li> </ul> </li> <li>Release Notes</li> </ul>"},{"location":"","title":"FastStream","text":"<p>Effortless event stream integration for your services</p> <p> </p>"},{"location":"#features","title":"Features","text":"<p>FastStream simplifies the process of writing producers and consumers for message queues, handling all the parsing, networking and documentation generation automatically.</p> <p>Making streaming microservices has never been easier. Designed with junior developers in mind, FastStream simplifies your work while keeping the door open for more advanced use-cases. Here's a look at the core features that make FastStream a go-to framework for modern, data-centric microservices.</p> <ul> <li> <p>Multiple Brokers: FastStream provides a unified API to work across multiple message brokers (Kafka, RabbitMQ, NATS support)</p> </li> <li> <p>Pydantic Validation: Leverage Pydantic's validation capabilities to serialize and validates incoming messages</p> </li> <li> <p>Automatic Docs: Stay ahead with automatic AsyncAPI documentation</p> </li> <li> <p>Intuitive: Full-typed editor support makes your development experience smooth, catching errors before they reach runtime</p> </li> <li> <p>Powerful Dependency Injection System: Manage your service dependencies efficiently with FastStream's built-in DI system</p> </li> <li> <p>Testable: Supports in-memory tests, making your CI/CD pipeline faster and more reliable</p> </li> <li> <p>Extendable: Use extensions for lifespans, custom serialization and middlewares</p> </li> <li> <p>Integrations: FastStream is fully compatible with any HTTP framework you want (FastAPI especially)</p> </li> <li> <p>Built for Automatic Code Generation: FastStream is optimized for automatic code generation using advanced models like GPT and Llama</p> </li> </ul> <p>That's FastStream in a nutshell\u2014easy, efficient, and powerful. Whether you're just starting with streaming microservices or looking to scale, FastStream has got you covered.</p>"},{"location":"#history","title":"History","text":"<p>FastStream is a new package based on the ideas and experiences gained from FastKafka and Propan. By joining our forces, we picked up the best from both packages and created a unified way to write services capable of processing streamed data regradless of the underliying protocol. We'll continue to maintain both packages, but new development will be in this project. If you are starting a new service, this package is the recommended way to do it.</p>"},{"location":"#install","title":"Install","text":"<p>FastStream works on Linux, macOS, Windows and most Unix-style operating systems. You can install it with <code>pip</code> as usual:</p> KafkaRabbitMQNATS <pre><code>pip install faststream[kafka]\n</code></pre> <pre><code>pip install faststream[rabbit]\n</code></pre> <pre><code>pip install faststream[nats]\n</code></pre> <p>By default FastStream uses PydanticV2 written in Rust, but you can downgrade it manually, if your platform has no Rust support - FastStream will work correctly with PydanticV1 as well.</p>"},{"location":"#writing-app-code","title":"Writing app code","text":"<p>FastStream brokers provide convenient function decorators <code>@broker.subscriber</code> and <code>@broker.publisher</code> to allow you to delegate the actual process of:</p> <ul> <li> <p>consuming and producing data to Event queues, and</p> </li> <li> <p>decoding and encoding JSON encoded messages</p> </li> </ul> <p>These decorators make it easy to specify the processing logic for your consumers and producers, allowing you to focus on the core business logic of your application without worrying about the underlying integration.</p> <p>Also, FastStream uses Pydantic to parse input JSON-encoded data into Python objects, making it easy to work with structured data in your applications, so you can serialize your input messages just using type annotations.</p> <p>Here is an example python app using FastStream that consumes data from an incoming data stream and outputs the data to another one:</p> KafkaRabbitMQNATS <pre><code>from faststream import FastStream\nfrom faststream.kafka import KafkaBroker\n\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\n\n@broker.subscriber(\"in-topic\")\n@broker.publisher(\"out-topic\")\nasync def handle_msg(user: str, user_id: int) -&gt; str:\n    return f\"User: {user_id} - {user} registered\"\n</code></pre> <pre><code>from faststream import FastStream\nfrom faststream.rabbit import RabbitBroker\n\nbroker = RabbitBroker(\"amqp://guest:guest@localhost:5672/\")\napp = FastStream(broker)\n\n@broker.subscriber(\"in-queue\")\n@broker.publisher(\"out-queue\")\nasync def handle_msg(user: str, user_id: int) -&gt; str:\n    return f\"User: {user_id} - {user} registered\"\n</code></pre> <pre><code>from faststream import FastStream\nfrom faststream.nats import NatsBroker\n\nbroker = NatsBroker(\"nats://localhost:4222\")\napp = FastStream(broker)\n\n@broker.subscriber(\"in-subject\")\n@broker.publisher(\"out-subject\")\nasync def handle_msg(user: str, user_id: int) -&gt; str:\n    return f\"User: {user_id} - {user} registered\"\n</code></pre> <p>Also, Pydantic\u2019s <code>BaseModel</code> class allows you to define messages using a declarative syntax, making it easy to specify the fields and types of your messages.</p> KafkaRabbitMQNATS <pre><code>from pydantic import BaseModel, Field, PositiveInt\nfrom faststream import FastStream\nfrom faststream.kafka import KafkaBroker\n\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\n\nclass User(BaseModel):\n    user: str = Field(..., examples=[\"John\"])\n    user_id: PositiveInt = Field(..., examples=[\"1\"])\n\n@broker.subscriber(\"in-topic\")\n@broker.publisher(\"out-topic\")\nasync def handle_msg(data: User) -&gt; str:\n    return f\"User: {data.user} - {data.user_id} registered\"\n</code></pre> <pre><code>from pydantic import BaseModel, Field, PositiveInt\nfrom faststream import FastStream\nfrom faststream.rabbit import RabbitBroker\n\nbroker = RabbitBroker(\"amqp://guest:guest@localhost:5672/\")\napp = FastStream(broker)\n\nclass User(BaseModel):\n    user: str = Field(..., examples=[\"John\"])\n    user_id: PositiveInt = Field(..., examples=[\"1\"])\n\n@broker.subscriber(\"in-queue\")\n@broker.publisher(\"out-queue\")\nasync def handle_msg(data: User) -&gt; str:\n    return f\"User: {data.user} - {data.user_id} registered\"\n</code></pre> <pre><code>from pydantic import BaseModel, Field, PositiveInt\nfrom faststream import FastStream\nfrom faststream.nats import NatsBroker\n\nbroker = NatsBroker(\"nats://localhost:4222\")\napp = FastStream(broker)\n\nclass User(BaseModel):\n    user: str = Field(..., examples=[\"John\"])\n    user_id: PositiveInt = Field(..., examples=[\"1\"])\n\n@broker.subscriber(\"in-subject\")\n@broker.publisher(\"out-subject\")\nasync def handle_msg(data: User) -&gt; str:\n    return f\"User: {data.user} - {data.user_id} registered\"\n</code></pre>"},{"location":"#testing-the-service","title":"Testing the service","text":"<p>The service can be tested using the <code>TestBroker</code> context managers, which, by default, puts the Broker into \"testing mode\".</p> <p>The Tester will redirect your <code>subscriber</code> and <code>publisher</code> decorated functions to the InMemory brokers, allowing you to quickly test your app without the need for a running broker and all its dependencies.</p> <p>Using pytest, the test for our service would look like this:</p> KafkaRabbitMQNATS <pre><code># Code above omitted \ud83d\udc46\n\nimport pytest\nimport pydantic\nfrom faststream.kafka import TestKafkaBroker\n\n\n@pytest.mark.asyncio\nasync def test_correct():\n    async with TestKafkaBroker(broker) as br:\n        await br.publish({\n            \"user\": \"John\",\n            \"user_id\": 1,\n        }, \"in-topic\")\n\n@pytest.mark.asyncio\nasync def test_invalid():\n    async with TestKafkaBroker(broker) as br:\n        with pytest.raises(pydantic.ValidationError):\n            await br.publish(\"wrong message\", \"in-topic\")\n</code></pre> <pre><code># Code above omitted \ud83d\udc46\n\nimport pytest\nimport pydantic\nfrom faststream.rabbit import TestRabbitBroker\n\n\n@pytest.mark.asyncio\nasync def test_correct():\n    async with TestRabbitBroker(broker) as br:\n        await br.publish({\n            \"user\": \"John\",\n            \"user_id\": 1,\n        }, \"in-queue\")\n\n@pytest.mark.asyncio\nasync def test_invalid():\n    async with TestRabbitBroker(broker) as br:\n        with pytest.raises(pydantic.ValidationError):\n            await br.publish(\"wrong message\", \"in-queue\")\n</code></pre> <pre><code># Code above omitted \ud83d\udc46\n\nimport pytest\nimport pydantic\nfrom faststream.nats import TestNatsBroker\n\n\n@pytest.mark.asyncio\nasync def test_correct():\n    async with TestNatsBroker(broker) as br:\n        await br.publish({\n            \"user\": \"John\",\n            \"user_id\": 1,\n        }, \"in-subject\")\n\n@pytest.mark.asyncio\nasync def test_invalid():\n    async with TestNatsBroker(broker) as br:\n        with pytest.raises(pydantic.ValidationError):\n            await br.publish(\"wrong message\", \"in-subject\")\n</code></pre>"},{"location":"#running-the-application","title":"Running the application","text":"<p>The application can be started using built-in FastStream CLI command.</p> <p>To run the service, use the FastStream CLI command and pass the module (in this case, the file where the app implementation is located) and the app symbol to the command.</p> <pre><code>faststream run basic:app\n</code></pre> <p>After running the command, you should see the following output:</p> <pre><code>INFO     - FastStream app starting...\nINFO     - input_data |            - `HandleMsg` waiting for messages\nINFO     - FastStream app started successfully! To exit press CTRL+C\n</code></pre> <p>Also, FastStream provides you a great hot reload feature to improve your Development Experience</p> <pre><code>faststream run basic:app --reload\n</code></pre> <p>And multiprocessing horizontal scaling feature as well:</p> <pre><code>faststream run basic:app --workers 3\n</code></pre> <p>You can know more about CLI features here</p>"},{"location":"#project-documentation","title":"Project Documentation","text":"<p>FastStream automatically generates documentation for your project according to the AsyncAPI specification. You can work with both generated artifacts and place a web view of your documentation on resources available to related teams.</p> <p>The availability of such documentation significantly simplifies the integration of services: you can immediately see what channels and message formats the application works with. And most importantly, it won't cost anything - FastStream has already created the docs for you!</p> <p></p>"},{"location":"#dependencies","title":"Dependencies","text":"<p>FastStream (thanks to FastDepends) has a dependency management system similar to <code>pytest fixtures</code> and <code>FastAPI Depends</code> at the same time. Function arguments declare which dependencies you want are needed, and a special decorator delivers them from the global Context object.</p> <pre><code>from faststream import Depends, Logger\n\n\nasync def base_dep(user_id: int) -&gt; bool:\n    return True\n\n@broker.subscriber(\"in-test\")\nasync def base_handler(user: str,\n                       logger: Logger,\n                       dep: bool = Depends(base_dep)):\n    assert dep is True\n    logger.info(user)\n</code></pre>"},{"location":"#http-frameworks-integrations","title":"HTTP Frameworks integrations","text":""},{"location":"#any-framework","title":"Any Framework","text":"<p>You can use FastStream <code>MQBrokers</code> without a <code>FastStream</code> application. Just start and stop them according to your application's lifespan.</p> AiohttpBlacksheepFalconQuartSanic <pre><code>from aiohttp import web\n\nfrom faststream.kafka import KafkaBroker\n\nbroker = KafkaBroker(\"localhost:9092\")\n\n\n@broker.subscriber(\"test\")\nasync def base_handler(body):\n    print(body)\n\n\nasync def start_broker(app):\n    await broker.start()\n\n\nasync def stop_broker(app):\n    await broker.close()\n\n\nasync def hello(request):\n    return web.Response(text=\"Hello, world\")\n\n\napp = web.Application()\napp.add_routes([web.get(\"/\", hello)])\napp.on_startup.append(start_broker)\napp.on_cleanup.append(stop_broker)\n\n\nif __name__ == \"__main__\":\n    web.run_app(app)\n</code></pre> <pre><code>from blacksheep import Application\n\nfrom faststream.kafka import KafkaBroker\n\nbroker = KafkaBroker(\"localhost:9092\")\n\napp = Application()\n\n\n@broker.subscriber(\"test\")\nasync def base_handler(body):\n    print(body)\n\n\n@app.on_start\nasync def start_broker(application: Application) -&gt; None:\n    await broker.start()\n\n\n@app.on_stop\nasync def stop_broker(application: Application) -&gt; None:\n    await broker.close()\n\n\n@app.route(\"/\")\nasync def home():\n    return \"Hello, World!\"\n</code></pre> <pre><code>import falcon\nimport falcon.asgi\n\nfrom faststream.kafka import KafkaBroker\n\nbroker = KafkaBroker(\"localhost:9092\")\n\n\n@broker.subscriber(\"test\")\nasync def base_handler(body):\n    print(body)\n\n\nclass ThingsResource:\n    async def on_get(self, req, resp):\n        resp.status = falcon.HTTP_200\n        resp.content_type = falcon.MEDIA_TEXT\n        resp.text = (\n            \"\\nTwo things awe me most, the starry sky \"\n            \"above me and the moral law within me.\\n\"\n            \"\\n\"\n            \"    ~ Immanuel Kant\\n\\n\"\n        )\n\n\nclass PropanMiddleware:\n    async def process_startup(self, scope, event):\n        await broker.start()\n\n    async def process_shutdown(self, scope, event):\n        await broker.close()\n\n\napp = falcon.asgi.App()\napp.add_middleware(PropanMiddleware())\napp.add_route(\"/things\", ThingsResource())\n</code></pre> <pre><code>from quart import Quart\n\nfrom faststream.kafka import KafkaBroker\n\nbroker = KafkaBroker(\"localhost:9092\")\n\napp = Quart(__name__)\n\n\n@broker.subscriber(\"test\")\nasync def base_handler(body):\n    print(body)\n\n\n@app.before_serving\nasync def start_broker():\n    await broker.start()\n\n\n@app.after_serving\nasync def stop_broker():\n    await broker.close()\n\n\n@app.route(\"/\")\nasync def json():\n    return {\"hello\": \"world\"}\n</code></pre> <pre><code>from sanic import Sanic\nfrom sanic.response import text\n\nfrom faststream.kafka import KafkaBroker\n\nbroker = KafkaBroker(\"localhost:9092\")\n\napp = Sanic(\"MyHelloWorldApp\")\n\n\n@broker.subscriber(\"test\")\nasync def base_handler(body):\n    print(body)\n\n\n@app.after_server_start\nasync def start_broker(app, loop):\n    await broker.start()\n\n\n@app.after_server_stop\nasync def stop_broker(app, loop):\n    await broker.close()\n\n\n@app.get(\"/\")\nasync def hello_world(request):\n    return text(\"Hello, world.\")\n</code></pre>"},{"location":"#fastapi-plugin","title":"FastAPI Plugin","text":"<p>Also, FastStream can be used as part of FastAPI.</p> <p>Just import a StreamRouter you need and declare the message handler with the same <code>@router.subscriber(...)</code> and <code>@router.publisher(...)</code> decorators.</p> <p>Tip</p> <p>When used this way, FastStream does not utilize its own dependency and serialization system but integrates seamlessly into FastAPI. This means you can use <code>Depends</code>, <code>BackgroundTasks</code> and other FastAPI tools as if it were a regular HTTP endpoint.</p> KafkaRabbitMQNATS <pre><code>from fastapi import Depends, FastAPI\nfrom pydantic import BaseModel\n\nfrom faststream.kafka.fastapi import KafkaRouter\n\nrouter = KafkaRouter(\"localhost:9092\")\n\n\nclass Incoming(BaseModel):\n    m: dict\n\n\ndef call():\n    return True\n\n\n@router.subscriber(\"test\")\n@router.publisher(\"response\")\nasync def hello(m: Incoming, d=Depends(call)):\n    return {\"response\": \"Hello, Kafka!\"}\n\n\n@router.get(\"/\")\nasync def hello_http():\n    return \"Hello, HTTP!\"\n\n\napp = FastAPI(lifespan=router.lifespan_context)\napp.include_router(router)\n</code></pre> <pre><code>from fastapi import Depends, FastAPI\nfrom pydantic import BaseModel\n\nfrom faststream.rabbit.fastapi import RabbitRouter\n\nrouter = RabbitRouter(\"amqp://guest:guest@localhost:5672/\")\n\n\nclass Incoming(BaseModel):\n    m: dict\n\n\ndef call():\n    return True\n\n\n@router.subscriber(\"test\")\n@router.publisher(\"response\")\nasync def hello(m: Incoming, d=Depends(call)):\n    return {\"response\": \"Hello, Rabbit!\"}\n\n\n@router.get(\"/\")\nasync def hello_http():\n    return \"Hello, HTTP!\"\n\n\napp = FastAPI(lifespan=router.lifespan_context)\napp.include_router(router)\n</code></pre> <pre><code>from fastapi import Depends, FastAPI\nfrom pydantic import BaseModel\n\nfrom faststream.nats.fastapi import NatsRouter\n\nrouter = NatsRouter(\"nats://localhost:4222\")\n\n\nclass Incoming(BaseModel):\n    m: dict\n\n\ndef call():\n    return True\n\n\n@router.subscriber(\"test\")\n@router.publisher(\"response\")\nasync def hello(m: Incoming, d=Depends(call)):\n    return {\"response\": \"Hello, NATS!\"}\n\n\n@router.get(\"/\")\nasync def hello_http():\n    return \"Hello, HTTP!\"\n\n\napp = FastAPI(lifespan=router.lifespan_context)\napp.include_router(router)\n</code></pre> <p>Note</p> <p>More integration features can be found here</p>"},{"location":"#code-generator","title":"Code generator","text":"<p>As evident, FastStream is an incredibly user-friendly framework. However, we've taken it a step further and made it even more user-friendly! Introducing faststream-gen, a Python library that harnesses the power of generative AI to effortlessly generate FastStream applications. Simply describe your application requirements, and faststream-gen will generate a production-grade FastStream project that is ready to deploy in no time.</p> <p>Save application description inside <code>description.txt</code>:</p> <pre><code>Create a FastStream application using localhost broker for testing and use the\ndefault port number.\n\nIt should consume messages from the 'input_data' topic, where each message is a\nJSON encoded object containing a single attribute: 'data'.\n\nWhile consuming from the topic, increment the value of the data attribute by 1.\n\nFinally, send message to the 'output_data' topic.\n</code></pre> <p>and run the following command to create a new FastStream project:</p> <pre><code>faststream_gen -i description.txt\n</code></pre> <pre><code>\u2728  Generating a new FastStream application!\n \u2714 Application description validated.\n \u2714 FastStream app skeleton code generated. akes around 15 to 45 seconds)...\n \u2714 The app and the tests are generated.  around 30 to 90 seconds)...\n \u2714 New FastStream project created.\n \u2714 Integration tests were successfully completed.\n Tokens used: 10768\n Total Cost (USD): $0.03284\n\u2728  All files were successfully generated!\n</code></pre>"},{"location":"#tutorial","title":"Tutorial","text":"<p>We also invite you to explore our tutorial, where we will guide you through the process of utilizing the faststream-gen Python library to effortlessly create FastStream applications:</p> <ul> <li>Cryptocurrency analysis with FastStream</li> </ul>"},{"location":"#stay-in-touch","title":"Stay in touch","text":"<p>Please show your support and stay in touch by:</p> <ul> <li> <p>giving our GitHub repository a star, and</p> </li> <li> <p>joining our Discord server</p> </li> </ul> <p>Your support helps us to stay in touch with you and encourages us to continue developing and improving the framework. Thank you for your support!</p>"},{"location":"#contributors","title":"Contributors","text":"<p>Thanks to all of these amazing people who made the project better!</p> <p> </p>"},{"location":"release/","title":"Release Notes","text":"<p>FastStream is a new package based on the ideas and experiences gained from FastKafka and Propan. By joining our forces, we picked up the best from both packages and created the unified way to write services capable of processing streamed data regradless of the underliying protocol. We'll continue to maintain both packages, but new development will be in this project. If you are starting a new service, this package is the recommended way to do it.</p>"},{"location":"release/#features","title":"Features","text":"<p>FastStream simplifies the process of writing producers and consumers for message queues, handling all the parsing, networking and documentation generation automatically.</p> <p>Making streaming microservices has never been easier. Designed with junior developers in mind, FastStream simplifies your work while keeping the door open for more advanced use-cases. Here's a look at the core features that make FastStream a go-to framework for modern, data-centric microservices.</p> <ul> <li> <p>Multiple Brokers: FastStream provides a unified API to work across multiple message brokers (Kafka, RabbitMQ support)</p> </li> <li> <p>Pydantic Validation: Leverage Pydantic's validation capabilities to serialize and validates incoming messages</p> </li> <li> <p>Automatic Docs: Stay ahead with automatic AsyncAPI documentation.</p> </li> <li> <p>Intuitive: full typed editor support makes your development experience smooth, catching errors before they reach runtime</p> </li> <li> <p>Powerful Dependency Injection System: Manage your service dependencies efficiently with FastStream's built-in DI system.</p> </li> <li> <p>Testable: supports in-memory tests, making your CI/CD pipeline faster and more reliable</p> </li> <li> <p>Extendable: use extensions for lifespans, custom serialization and middlewares</p> </li> <li> <p>Integrations: FastStream is fully compatible with any HTTP framework you want (FastAPI especially)</p> </li> <li> <p>Built for Automatic Code Generation: FastStream is optimized for automatic code generation using advanced models like GPT and Llama</p> </li> </ul> <p>That's FastStream in a nutshell\u2014easy, efficient, and powerful. Whether you're just starting with streaming microservices or looking to scale, FastStream has got you covered.</p>"},{"location":"api/faststream/app/ABCApp/","title":"ABCApp","text":""},{"location":"api/faststream/app/ABCApp/#faststream.app.ABCApp","title":"faststream.app.ABCApp","text":"<p>             Bases: <code>ABC</code></p> <p>A class representing an ABC App.</p> METHOD DESCRIPTION <code>set_broker </code> <p>Set the broker object</p> <code>on_startup </code> <p>Add a hook to be run before the broker is connected</p> <code>on_shutdown </code> <p>Add a hook to be run before the broker is disconnected</p> <code>after_startup </code> <p>Add a hook to be run after the broker is connected</p> <code>after_shutdown </code> <p>Add a hook to be run after the broker is disconnected</p> <code>_log </code> <p>Log a message at a specified</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/app.py</code> <pre><code>class ABCApp(ABC):\n    \"\"\"A class representing an ABC App.\n\n    Attributes:\n        _on_startup_calling : List of callable functions to be called on startup\n        _after_startup_calling : List of callable functions to be called after startup\n        _on_shutdown_calling : List of callable functions to be called on shutdown\n        _after_shutdown_calling : List of callable functions to be called after shutdown\n        broker : Optional broker object\n        logger : Optional logger object\n        title : Title of the app\n        version : Version of the app\n        description : Description of the app\n        terms_of_service : Optional terms of service URL\n        license : Optional license information\n        contact : Optional contact information\n        identifier : Optional identifier\n        asyncapi_tags : Optional list of tags\n        external_docs : Optional external documentation\n\n    Methods:\n        set_broker : Set the broker object\n        on_startup : Add a hook to be run before the broker is connected\n        on_shutdown : Add a hook to be run before the broker is disconnected\n        after_startup : Add a hook to be run after the broker is connected\n        after_shutdown : Add a hook to be run after the broker is disconnected\n        _log : Log a message at a specified\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    _on_startup_calling: List[AnyCallable]\n    _after_startup_calling: List[AnyCallable]\n    _on_shutdown_calling: List[AnyCallable]\n    _after_shutdown_calling: List[AnyCallable]\n\n    def __init__(\n        self,\n        broker: Optional[BrokerAsyncUsecase[Any, Any]] = None,\n        logger: Optional[logging.Logger] = logger,\n        # AsyncAPI information\n        title: str = \"FastStream\",\n        version: str = \"0.1.0\",\n        description: str = \"\",\n        terms_of_service: Optional[AnyHttpUrl] = None,\n        license: Optional[Union[License, LicenseDict, AnyDict]] = None,\n        contact: Optional[Union[Contact, ContactDict, AnyDict]] = None,\n        identifier: Optional[str] = None,\n        tags: Optional[Sequence[Union[Tag, TagDict, AnyDict]]] = None,\n        external_docs: Optional[Union[ExternalDocs, ExternalDocsDict, AnyDict]] = None,\n    ):\n        \"\"\"Initialize an instance of the class.\n\n        Args:\n            broker: An optional instance of the BrokerAsyncUsecase class.\n            logger: An optional instance of the logging.Logger class.\n            title: A string representing the title of the AsyncAPI.\n            version: A string representing the version of the AsyncAPI.\n            description: A string representing the description of the AsyncAPI.\n            terms_of_service: An optional URL representing the terms of service of the AsyncAPI.\n            license: An optional instance of the License class.\n            contact: An optional instance of the Contact class.\n            identifier: An optional string representing the identifier of the AsyncAPI.\n            tags: An optional sequence of Tag instances.\n            external_docs: An optional instance of the ExternalDocs class.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        self.broker = broker\n        self.logger = logger\n        self.context = context\n        context.set_global(\"app\", self)\n\n        self._on_startup_calling = []\n        self._after_startup_calling = []\n        self._on_shutdown_calling = []\n        self._after_shutdown_calling = []\n\n        # AsyncAPI information\n        self.title = title\n        self.version = version\n        self.description = description\n        self.terms_of_service = terms_of_service\n        self.license = license\n        self.contact = contact\n        self.identifier = identifier\n        self.asyncapi_tags = tags\n        self.external_docs = external_docs\n\n    def set_broker(self, broker: BrokerAsyncUsecase[Any, Any]) -&gt; None:\n        \"\"\"Set already existed App object broker\n        Usefull then you create/init broker in `on_startup` hook\"\"\"\n        self.broker = broker\n\n    def on_startup(\n        self,\n        func: Callable[P_HookParams, T_HookReturn],\n    ) -&gt; Callable[P_HookParams, T_HookReturn]:\n        \"\"\"Add hook running BEFORE broker connected\n        This hook also takes an extra CLI options as a kwargs\"\"\"\n        self._on_startup_calling.append(apply_types(func))\n        return func\n\n    def on_shutdown(\n        self,\n        func: Callable[P_HookParams, T_HookReturn],\n    ) -&gt; Callable[P_HookParams, T_HookReturn]:\n        \"\"\"Add hook running BEFORE broker disconnected\"\"\"\n        self._on_shutdown_calling.append(apply_types(func))\n        return func\n\n    def after_startup(\n        self,\n        func: Callable[P_HookParams, T_HookReturn],\n    ) -&gt; Callable[P_HookParams, T_HookReturn]:\n        \"\"\"Add hook running AFTER broker connected\"\"\"\n        self._after_startup_calling.append(apply_types(func))\n        return func\n\n    def after_shutdown(\n        self,\n        func: Callable[P_HookParams, T_HookReturn],\n    ) -&gt; Callable[P_HookParams, T_HookReturn]:\n        \"\"\"Add hook running AFTER broker disconnected\"\"\"\n        self._after_shutdown_calling.append(apply_types(func))\n        return func\n\n    def _log(self, level: int, message: str) -&gt; None:\n        \"\"\"Logs a message with the specified log level.\n\n        Args:\n            level (int): The log level.\n            message (str): The message to be logged.\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        if self.logger is not None:\n            self.logger.log(level, message)\n</code></pre>"},{"location":"api/faststream/app/ABCApp/#faststream.app.ABCApp.asyncapi_tags","title":"asyncapi_tags  <code>instance-attribute</code>","text":"<pre><code>asyncapi_tags = tags\n</code></pre>"},{"location":"api/faststream/app/ABCApp/#faststream.app.ABCApp.broker","title":"broker  <code>instance-attribute</code>","text":"<pre><code>broker = broker\n</code></pre>"},{"location":"api/faststream/app/ABCApp/#faststream.app.ABCApp.contact","title":"contact  <code>instance-attribute</code>","text":"<pre><code>contact = contact\n</code></pre>"},{"location":"api/faststream/app/ABCApp/#faststream.app.ABCApp.context","title":"context  <code>instance-attribute</code>","text":"<pre><code>context = context\n</code></pre>"},{"location":"api/faststream/app/ABCApp/#faststream.app.ABCApp.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description = description\n</code></pre>"},{"location":"api/faststream/app/ABCApp/#faststream.app.ABCApp.external_docs","title":"external_docs  <code>instance-attribute</code>","text":"<pre><code>external_docs = external_docs\n</code></pre>"},{"location":"api/faststream/app/ABCApp/#faststream.app.ABCApp.identifier","title":"identifier  <code>instance-attribute</code>","text":"<pre><code>identifier = identifier\n</code></pre>"},{"location":"api/faststream/app/ABCApp/#faststream.app.ABCApp.license","title":"license  <code>instance-attribute</code>","text":"<pre><code>license = license\n</code></pre>"},{"location":"api/faststream/app/ABCApp/#faststream.app.ABCApp.logger","title":"logger  <code>instance-attribute</code>","text":"<pre><code>logger = logger\n</code></pre>"},{"location":"api/faststream/app/ABCApp/#faststream.app.ABCApp.terms_of_service","title":"terms_of_service  <code>instance-attribute</code>","text":"<pre><code>terms_of_service = terms_of_service\n</code></pre>"},{"location":"api/faststream/app/ABCApp/#faststream.app.ABCApp.title","title":"title  <code>instance-attribute</code>","text":"<pre><code>title = title\n</code></pre>"},{"location":"api/faststream/app/ABCApp/#faststream.app.ABCApp.version","title":"version  <code>instance-attribute</code>","text":"<pre><code>version = version\n</code></pre>"},{"location":"api/faststream/app/ABCApp/#faststream.app.ABCApp.after_shutdown","title":"after_shutdown","text":"<pre><code>after_shutdown(\n    func: Callable[P_HookParams, T_HookReturn]\n) -&gt; Callable[P_HookParams, T_HookReturn]\n</code></pre> <p>Add hook running AFTER broker disconnected</p> Source code in <code>faststream/app.py</code> <pre><code>def after_shutdown(\n    self,\n    func: Callable[P_HookParams, T_HookReturn],\n) -&gt; Callable[P_HookParams, T_HookReturn]:\n    \"\"\"Add hook running AFTER broker disconnected\"\"\"\n    self._after_shutdown_calling.append(apply_types(func))\n    return func\n</code></pre>"},{"location":"api/faststream/app/ABCApp/#faststream.app.ABCApp.after_startup","title":"after_startup","text":"<pre><code>after_startup(\n    func: Callable[P_HookParams, T_HookReturn]\n) -&gt; Callable[P_HookParams, T_HookReturn]\n</code></pre> <p>Add hook running AFTER broker connected</p> Source code in <code>faststream/app.py</code> <pre><code>def after_startup(\n    self,\n    func: Callable[P_HookParams, T_HookReturn],\n) -&gt; Callable[P_HookParams, T_HookReturn]:\n    \"\"\"Add hook running AFTER broker connected\"\"\"\n    self._after_startup_calling.append(apply_types(func))\n    return func\n</code></pre>"},{"location":"api/faststream/app/ABCApp/#faststream.app.ABCApp.on_shutdown","title":"on_shutdown","text":"<pre><code>on_shutdown(\n    func: Callable[P_HookParams, T_HookReturn]\n) -&gt; Callable[P_HookParams, T_HookReturn]\n</code></pre> <p>Add hook running BEFORE broker disconnected</p> Source code in <code>faststream/app.py</code> <pre><code>def on_shutdown(\n    self,\n    func: Callable[P_HookParams, T_HookReturn],\n) -&gt; Callable[P_HookParams, T_HookReturn]:\n    \"\"\"Add hook running BEFORE broker disconnected\"\"\"\n    self._on_shutdown_calling.append(apply_types(func))\n    return func\n</code></pre>"},{"location":"api/faststream/app/ABCApp/#faststream.app.ABCApp.on_startup","title":"on_startup","text":"<pre><code>on_startup(\n    func: Callable[P_HookParams, T_HookReturn]\n) -&gt; Callable[P_HookParams, T_HookReturn]\n</code></pre> <p>Add hook running BEFORE broker connected This hook also takes an extra CLI options as a kwargs</p> Source code in <code>faststream/app.py</code> <pre><code>def on_startup(\n    self,\n    func: Callable[P_HookParams, T_HookReturn],\n) -&gt; Callable[P_HookParams, T_HookReturn]:\n    \"\"\"Add hook running BEFORE broker connected\n    This hook also takes an extra CLI options as a kwargs\"\"\"\n    self._on_startup_calling.append(apply_types(func))\n    return func\n</code></pre>"},{"location":"api/faststream/app/ABCApp/#faststream.app.ABCApp.set_broker","title":"set_broker","text":"<pre><code>set_broker(broker: BrokerAsyncUsecase[Any, Any]) -&gt; None\n</code></pre> <p>Set already existed App object broker Usefull then you create/init broker in <code>on_startup</code> hook</p> Source code in <code>faststream/app.py</code> <pre><code>def set_broker(self, broker: BrokerAsyncUsecase[Any, Any]) -&gt; None:\n    \"\"\"Set already existed App object broker\n    Usefull then you create/init broker in `on_startup` hook\"\"\"\n    self.broker = broker\n</code></pre>"},{"location":"api/faststream/app/FastStream/","title":"FastStream","text":""},{"location":"api/faststream/app/FastStream/#faststream.app.FastStream","title":"faststream.app.FastStream","text":"<p>             Bases: <code>ABCApp</code></p> <p>A class representing a FastStream application.</p> METHOD DESCRIPTION <code>__init__ </code> <p>initializes the FastStream application</p> <code>on_startup </code> <p>adds a hook to run before the broker is connected</p> <code>on_shutdown </code> <p>adds a hook to run before the broker is disconnected</p> <code>after_startup </code> <p>adds a hook to run after the broker is connected</p> <code>after_shutdown </code> <p>adds a hook to run after the broker is disconnected</p> <code>run </code> <p>runs the FastStream application</p> <code>_init_async_cycle </code> <p>initializes the async cycle</p> <code>_start </code> <p>starts the FastStream application</p> <code>_stop </code> <p>stops the FastStream application</p> <code>_startup </code> <p>runs the startup hooks</p> <code>_shutdown </code> <p>runs the shutdown hooks</p> <code>__exit </code> <p>exits the FastStream application</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/app.py</code> <pre><code>class FastStream(ABCApp):\n    \"\"\"A class representing a FastStream application.\n\n    Attributes:\n        _on_startup_calling : list of async functions to be called on startup\n        _after_startup_calling : list of async functions to be called after startup\n        _on_shutdown_calling : list of async functions to be called on shutdown\n        _after_shutdown_calling : list of async functions to be called after shutdown\n        _stop_event : event to stop the application\n\n    Methods:\n        __init__ : initializes the FastStream application\n        on_startup : adds a hook to run before the broker is connected\n        on_shutdown : adds a hook to run before the broker is disconnected\n        after_startup : adds a hook to run after the broker is connected\n        after_shutdown : adds a hook to run after the broker is disconnected\n        run : runs the FastStream application\n        _init_async_cycle : initializes the async cycle\n        _start : starts the FastStream application\n        _stop : stops the FastStream application\n        _startup : runs the startup hooks\n        _shutdown : runs the shutdown hooks\n        __exit : exits the FastStream application\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    _on_startup_calling: List[AsyncFunc]\n    _after_startup_calling: List[AsyncFunc]\n    _on_shutdown_calling: List[AsyncFunc]\n    _after_shutdown_calling: List[AsyncFunc]\n\n    _stop_event: Optional[anyio.Event]\n\n    def __init__(\n        self,\n        broker: Optional[BrokerAsyncUsecase[Any, Any]] = None,\n        logger: Optional[logging.Logger] = logger,\n        # AsyncAPI args,\n        title: str = \"FastStream\",\n        version: str = \"0.1.0\",\n        description: str = \"\",\n        terms_of_service: Optional[AnyHttpUrl] = None,\n        license: Optional[Union[License, LicenseDict, AnyDict]] = None,\n        contact: Optional[Union[Contact, ContactDict, AnyDict]] = None,\n        identifier: Optional[str] = None,\n        tags: Optional[Sequence[Union[Tag, TagDict, AnyDict]]] = None,\n        external_docs: Optional[Union[ExternalDocs, ExternalDocsDict, AnyDict]] = None,\n    ):\n        \"\"\"Asyncronous FastStream Application class\n\n        stores and run broker, control hooks\n\n        Args:\n            broker: async broker to run (may be `None`, then specify by `set_broker`)\n            logger: logger object to log startup/shutdown messages (`None` to disable)\n            title: application title - for AsyncAPI docs\n            version: application version - for AsyncAPI docs\n            description: application description - for AsyncAPI docs\n        \"\"\"\n        super().__init__(\n            broker=broker,\n            logger=logger,\n            title=title,\n            version=version,\n            description=description,\n            terms_of_service=terms_of_service,\n            license=license,\n            contact=contact,\n            identifier=identifier,\n            tags=tags,\n            external_docs=external_docs,\n        )\n\n        self._stop_event = None\n\n        set_exit(lambda *_: self.__exit())\n\n    def on_startup(\n        self,\n        func: Callable[P_HookParams, T_HookReturn],\n    ) -&gt; Callable[P_HookParams, T_HookReturn]:\n        \"\"\"Add hook running BEFORE broker connected\n\n        This hook also takes an extra CLI options as a kwargs\n\n        Args:\n            func: async or sync func to call as a hook\n\n        Returns:\n            Async version of the func argument\n        \"\"\"\n        super().on_startup(to_async(func))\n        return func\n\n    def on_shutdown(\n        self,\n        func: Callable[P_HookParams, T_HookReturn],\n    ) -&gt; Callable[P_HookParams, T_HookReturn]:\n        \"\"\"Add hook running BEFORE broker disconnected\n\n        Args:\n            func: async or sync func to call as a hook\n\n        Returns:\n            Async version of the func argument\n        \"\"\"\n        super().on_shutdown(to_async(func))\n        return func\n\n    def after_startup(\n        self,\n        func: Callable[P_HookParams, T_HookReturn],\n    ) -&gt; Callable[P_HookParams, T_HookReturn]:\n        \"\"\"Add hook running AFTER broker connected\n\n        Args:\n            func: async or sync func to call as a hook\n\n        Returns:\n            Async version of the func argument\n        \"\"\"\n        super().after_startup(to_async(func))\n        return func\n\n    def after_shutdown(\n        self,\n        func: Callable[P_HookParams, T_HookReturn],\n    ) -&gt; Callable[P_HookParams, T_HookReturn]:\n        \"\"\"Add hook running AFTER broker disconnected\n\n        Args:\n            func: async or sync func to call as a hook\n\n        Returns:\n            Async version of the func argument\n        \"\"\"\n        super().after_shutdown(to_async(func))\n        return func\n\n    async def run(\n        self,\n        log_level: int = logging.INFO,\n        run_extra_options: Optional[Dict[str, SettingField]] = None,\n    ) -&gt; None:\n        \"\"\"Run FastStream Application\n\n        Args:\n            log_level: force application log level\n\n        Returns:\n            Block an event loop until stopped\n        \"\"\"\n        assert self.broker, \"You should setup a broker\"  # nosec B101\n\n        self._init_async_cycle()\n        async with anyio.create_task_group() as tg:\n            tg.start_soon(self._start, log_level, run_extra_options)\n            await self._stop(log_level)\n            tg.cancel_scope.cancel()\n\n    def _init_async_cycle(self) -&gt; None:\n        if self._stop_event is None:\n            self._stop_event = anyio.Event()\n\n    async def _start(\n        self,\n        log_level: int = logging.INFO,\n        run_extra_options: Optional[Dict[str, SettingField]] = None,\n    ) -&gt; None:\n        \"\"\"Start the FastStream app.\n\n        Args:\n            log_level (int): log level (default: logging.INFO)\n            run_extra_options (Optional[Dict[str, SettingField]]): extra options for running the app (default: None)\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        self._log(log_level, \"FastStream app starting...\")\n        await self._startup(**(run_extra_options or {}))\n        self._log(\n            log_level, \"FastStream app started successfully! To exit, press CTRL+C\"\n        )\n\n    async def _stop(self, log_level: int = logging.INFO) -&gt; None:\n        \"\"\"Stop the application gracefully.\n\n        Args:\n            log_level (int): log level for logging messages (default: logging.INFO)\n\n        Raises:\n            AssertionError: If `_init_async_cycle` has not been called before calling `_stop`\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        assert (  # nosec B101\n            self._stop_event\n        ), \"You should call `_init_async_cycle` first\"\n        await self._stop_event.wait()\n        self._stop_event = None\n\n        self._log(log_level, \"FastStream app shutting down...\")\n        await self._shutdown()\n        self._log(log_level, \"FastStream app shut down gracefully.\")\n\n    async def _startup(self, **run_extra_options: SettingField) -&gt; None:\n        \"\"\"Executes startup tasks.\n\n        Args:\n            run_extra_options: Additional options to be passed to the startup tasks.\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        for func in self._on_startup_calling:\n            await func(**run_extra_options)\n\n        if self.broker is not None:\n            await self.broker.start()\n\n        for func in self._after_startup_calling:\n            await func()\n\n    async def _shutdown(self) -&gt; None:\n        for func in self._on_shutdown_calling:\n            await func()\n\n        if self.broker is not None:\n            await self.broker.close()\n\n        for func in self._after_shutdown_calling:\n            await func()\n\n    def __exit(self) -&gt; None:\n        if self._stop_event is not None:  # pragma: no branch\n            self._stop_event.set()\n</code></pre>"},{"location":"api/faststream/app/FastStream/#faststream.app.FastStream.after_shutdown","title":"after_shutdown","text":"<pre><code>after_shutdown(\n    func: Callable[P_HookParams, T_HookReturn]\n) -&gt; Callable[P_HookParams, T_HookReturn]\n</code></pre> <p>Add hook running AFTER broker disconnected</p> PARAMETER  DESCRIPTION <code>func</code> <p>async or sync func to call as a hook</p> <p> TYPE: <code>Callable[P_HookParams, T_HookReturn]</code> </p> RETURNS DESCRIPTION <code>Callable[P_HookParams, T_HookReturn]</code> <p>Async version of the func argument</p> Source code in <code>faststream/app.py</code> <pre><code>def after_shutdown(\n    self,\n    func: Callable[P_HookParams, T_HookReturn],\n) -&gt; Callable[P_HookParams, T_HookReturn]:\n    \"\"\"Add hook running AFTER broker disconnected\n\n    Args:\n        func: async or sync func to call as a hook\n\n    Returns:\n        Async version of the func argument\n    \"\"\"\n    super().after_shutdown(to_async(func))\n    return func\n</code></pre>"},{"location":"api/faststream/app/FastStream/#faststream.app.FastStream.after_startup","title":"after_startup","text":"<pre><code>after_startup(\n    func: Callable[P_HookParams, T_HookReturn]\n) -&gt; Callable[P_HookParams, T_HookReturn]\n</code></pre> <p>Add hook running AFTER broker connected</p> PARAMETER  DESCRIPTION <code>func</code> <p>async or sync func to call as a hook</p> <p> TYPE: <code>Callable[P_HookParams, T_HookReturn]</code> </p> RETURNS DESCRIPTION <code>Callable[P_HookParams, T_HookReturn]</code> <p>Async version of the func argument</p> Source code in <code>faststream/app.py</code> <pre><code>def after_startup(\n    self,\n    func: Callable[P_HookParams, T_HookReturn],\n) -&gt; Callable[P_HookParams, T_HookReturn]:\n    \"\"\"Add hook running AFTER broker connected\n\n    Args:\n        func: async or sync func to call as a hook\n\n    Returns:\n        Async version of the func argument\n    \"\"\"\n    super().after_startup(to_async(func))\n    return func\n</code></pre>"},{"location":"api/faststream/app/FastStream/#faststream.app.FastStream.on_shutdown","title":"on_shutdown","text":"<pre><code>on_shutdown(\n    func: Callable[P_HookParams, T_HookReturn]\n) -&gt; Callable[P_HookParams, T_HookReturn]\n</code></pre> <p>Add hook running BEFORE broker disconnected</p> PARAMETER  DESCRIPTION <code>func</code> <p>async or sync func to call as a hook</p> <p> TYPE: <code>Callable[P_HookParams, T_HookReturn]</code> </p> RETURNS DESCRIPTION <code>Callable[P_HookParams, T_HookReturn]</code> <p>Async version of the func argument</p> Source code in <code>faststream/app.py</code> <pre><code>def on_shutdown(\n    self,\n    func: Callable[P_HookParams, T_HookReturn],\n) -&gt; Callable[P_HookParams, T_HookReturn]:\n    \"\"\"Add hook running BEFORE broker disconnected\n\n    Args:\n        func: async or sync func to call as a hook\n\n    Returns:\n        Async version of the func argument\n    \"\"\"\n    super().on_shutdown(to_async(func))\n    return func\n</code></pre>"},{"location":"api/faststream/app/FastStream/#faststream.app.FastStream.on_startup","title":"on_startup","text":"<pre><code>on_startup(\n    func: Callable[P_HookParams, T_HookReturn]\n) -&gt; Callable[P_HookParams, T_HookReturn]\n</code></pre> <p>Add hook running BEFORE broker connected</p> <p>This hook also takes an extra CLI options as a kwargs</p> PARAMETER  DESCRIPTION <code>func</code> <p>async or sync func to call as a hook</p> <p> TYPE: <code>Callable[P_HookParams, T_HookReturn]</code> </p> RETURNS DESCRIPTION <code>Callable[P_HookParams, T_HookReturn]</code> <p>Async version of the func argument</p> Source code in <code>faststream/app.py</code> <pre><code>def on_startup(\n    self,\n    func: Callable[P_HookParams, T_HookReturn],\n) -&gt; Callable[P_HookParams, T_HookReturn]:\n    \"\"\"Add hook running BEFORE broker connected\n\n    This hook also takes an extra CLI options as a kwargs\n\n    Args:\n        func: async or sync func to call as a hook\n\n    Returns:\n        Async version of the func argument\n    \"\"\"\n    super().on_startup(to_async(func))\n    return func\n</code></pre>"},{"location":"api/faststream/app/FastStream/#faststream.app.FastStream.run","title":"run  <code>async</code>","text":"<pre><code>run(\n    log_level: int = logging.INFO,\n    run_extra_options: Optional[\n        Dict[str, SettingField]\n    ] = None,\n) -&gt; None\n</code></pre> <p>Run FastStream Application</p> PARAMETER  DESCRIPTION <code>log_level</code> <p>force application log level</p> <p> TYPE: <code>int</code> DEFAULT: <code>INFO</code> </p> RETURNS DESCRIPTION <code>None</code> <p>Block an event loop until stopped</p> Source code in <code>faststream/app.py</code> <pre><code>async def run(\n    self,\n    log_level: int = logging.INFO,\n    run_extra_options: Optional[Dict[str, SettingField]] = None,\n) -&gt; None:\n    \"\"\"Run FastStream Application\n\n    Args:\n        log_level: force application log level\n\n    Returns:\n        Block an event loop until stopped\n    \"\"\"\n    assert self.broker, \"You should setup a broker\"  # nosec B101\n\n    self._init_async_cycle()\n    async with anyio.create_task_group() as tg:\n        tg.start_soon(self._start, log_level, run_extra_options)\n        await self._stop(log_level)\n        tg.cancel_scope.cancel()\n</code></pre>"},{"location":"api/faststream/asyncapi/base/AsyncAPIOperation/","title":"AsyncAPIOperation","text":""},{"location":"api/faststream/asyncapi/base/AsyncAPIOperation/#faststream.asyncapi.base.AsyncAPIOperation","title":"faststream.asyncapi.base.AsyncAPIOperation","text":"<p>A class representing an asynchronous API operation.</p> METHOD DESCRIPTION <code>schema</code> <p>returns the schema of the API operation as a dictionary of channel names and channel objects</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/asyncapi/base.py</code> <pre><code>class AsyncAPIOperation:\n    \"\"\"A class representing an asynchronous API operation.\n\n    Attributes:\n        name : name of the API operation\n\n    Methods:\n        schema() : returns the schema of the API operation as a dictionary of channel names and channel objects\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    @abstractproperty\n    def name(self) -&gt; str:\n        raise NotImplementedError()\n\n    def schema(self) -&gt; Dict[str, Channel]:  # pragma: no cover\n        return {}\n</code></pre>"},{"location":"api/faststream/asyncapi/base/AsyncAPIOperation/#faststream.asyncapi.base.AsyncAPIOperation.name","title":"name","text":"<pre><code>name() -&gt; str\n</code></pre> Source code in <code>faststream/asyncapi/base.py</code> <pre><code>@abstractproperty\ndef name(self) -&gt; str:\n    raise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/asyncapi/base/AsyncAPIOperation/#faststream.asyncapi.base.AsyncAPIOperation.schema","title":"schema","text":"<pre><code>schema() -&gt; Dict[str, Channel]\n</code></pre> Source code in <code>faststream/asyncapi/base.py</code> <pre><code>def schema(self) -&gt; Dict[str, Channel]:  # pragma: no cover\n    return {}\n</code></pre>"},{"location":"api/faststream/asyncapi/generate/get_app_broker_channels/","title":"Get app broker channels","text":""},{"location":"api/faststream/asyncapi/generate/get_app_broker_channels/#faststream.asyncapi.generate.get_app_broker_channels","title":"faststream.asyncapi.generate.get_app_broker_channels","text":"<pre><code>get_app_broker_channels(\n    app: Union[FastStream, StreamRouter[Any]]\n) -&gt; Dict[str, Channel]\n</code></pre> <p>Get the broker channels for an application.</p> PARAMETER  DESCRIPTION <code>app</code> <p>An instance of FastStream or StreamRouter.</p> <p> TYPE: <code>Union[FastStream, StreamRouter[Any]]</code> </p> RETURNS DESCRIPTION <code>Dict[str, Channel]</code> <p>A dictionary of channel names and their corresponding Channel objects.</p> RAISES DESCRIPTION <code>AssertionError</code> <p>If the app does not have a broker.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/asyncapi/generate.py</code> <pre><code>def get_app_broker_channels(\n    app: Union[FastStream, \"StreamRouter[Any]\"]\n) -&gt; Dict[str, Channel]:\n    \"\"\"Get the broker channels for an application.\n\n    Args:\n        app: An instance of FastStream or StreamRouter.\n\n    Returns:\n        A dictionary of channel names and their corresponding Channel objects.\n\n    Raises:\n        AssertionError: If the app does not have a broker.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    channels = {}\n    assert app.broker  # nosec B101\n\n    for h in app.broker.handlers.values():\n        channels.update(h.schema())\n\n    for p in app.broker._publishers.values():\n        channels.update(p.schema())\n\n    return channels\n</code></pre>"},{"location":"api/faststream/asyncapi/generate/get_app_broker_server/","title":"Get app broker server","text":""},{"location":"api/faststream/asyncapi/generate/get_app_broker_server/#faststream.asyncapi.generate.get_app_broker_server","title":"faststream.asyncapi.generate.get_app_broker_server","text":"<pre><code>get_app_broker_server(\n    app: Union[FastStream, StreamRouter[Any]]\n) -&gt; Dict[str, Server]\n</code></pre> <p>Get the broker server for an application.</p> PARAMETER  DESCRIPTION <code>app</code> <p>An instance of <code>FastStream</code> or <code>StreamRouter</code> representing the application.</p> <p> TYPE: <code>Union[FastStream, StreamRouter[Any]]</code> </p> RETURNS DESCRIPTION <code>Dict[str, Server]</code> <p>A dictionary containing the broker servers. The keys are the server names and the values are instances of <code>Server</code> class.</p> RAISES DESCRIPTION <code>AssertionError</code> <p>If the <code>broker</code> attribute of the app is not present.</p> Note <p>This function is currently incomplete and the following fields in the <code>broker_meta</code> dictionary are not populated: \"security\", \"variables\", \"bindings\".</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/asyncapi/generate.py</code> <pre><code>def get_app_broker_server(\n    app: Union[FastStream, \"StreamRouter[Any]\"]\n) -&gt; Dict[str, Server]:\n    \"\"\"Get the broker server for an application.\n\n    Args:\n        app: An instance of `FastStream` or `StreamRouter` representing the application.\n\n    Returns:\n        A dictionary containing the broker servers. The keys are the server names and the values are instances of `Server` class.\n\n    Raises:\n        AssertionError: If the `broker` attribute of the app is not present.\n\n    Note:\n        This function is currently incomplete and the following fields in the `broker_meta` dictionary are not populated: \"security\", \"variables\", \"bindings\".\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    servers = {}\n\n    broker = app.broker\n    assert broker  # nosec B101\n\n    broker_meta: Dict[str, Any] = {\n        \"protocol\": broker.protocol,\n        \"protocolVersion\": broker.protocol_version,\n        \"description\": broker.description,\n        \"tags\": broker.tags,\n        # TODO\n        # \"variables\": \"\",\n        # \"bindings\": \"\",\n    }\n\n    if broker.security is not None:\n        broker_meta[\"security\"] = broker.security.get_requirement()\n\n    if isinstance(broker.url, str):\n        servers[\"development\"] = Server(\n            url=broker.url,\n            **broker_meta,\n        )\n\n    elif len(broker.url) == 1:\n        servers[\"development\"] = Server(\n            url=broker.url[0],\n            **broker_meta,\n        )\n\n    else:\n        for i, url in enumerate(broker.url, 1):\n            servers[f\"Server{i}\"] = Server(\n                url=url,\n                **broker_meta,\n            )\n\n    return servers\n</code></pre>"},{"location":"api/faststream/asyncapi/generate/get_app_schema/","title":"Get app schema","text":""},{"location":"api/faststream/asyncapi/generate/get_app_schema/#faststream.asyncapi.generate.get_app_schema","title":"faststream.asyncapi.generate.get_app_schema","text":"<pre><code>get_app_schema(\n    app: Union[FastStream, StreamRouter[Any]]\n) -&gt; Schema\n</code></pre> <p>Get the application schema.</p> PARAMETER  DESCRIPTION <code>app</code> <p>An instance of FastStream or StreamRouter.</p> <p> TYPE: <code>Union[FastStream, StreamRouter[Any]]</code> </p> RETURNS DESCRIPTION <code>Schema</code> <p>The schema object.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/asyncapi/generate.py</code> <pre><code>def get_app_schema(app: Union[FastStream, \"StreamRouter[Any]\"]) -&gt; Schema:\n    \"\"\"Get the application schema.\n\n    Args:\n        app: An instance of FastStream or StreamRouter.\n\n    Returns:\n        The schema object.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    servers = get_app_broker_server(app)\n    channels = get_app_broker_channels(app)\n\n    messages: Dict[str, Message] = {}\n    payloads: Dict[str, Dict[str, Any]] = {}\n    for channel_name, ch in channels.items():\n        ch.servers = list(servers.keys())\n\n        if ch.subscribe is not None:\n            m = ch.subscribe.message\n\n            if isinstance(m, Message):\n                ch.subscribe.message = _resolve_msg_payloads(\n                    m,\n                    channel_name,\n                    payloads,\n                    messages,\n                )\n\n        if ch.publish is not None:\n            m = ch.publish.message\n\n            if isinstance(m, Message):\n                ch.publish.message = _resolve_msg_payloads(\n                    m,\n                    channel_name,\n                    payloads,\n                    messages,\n                )\n\n    broker = app.broker\n    if broker is None:\n        raise RuntimeError()\n\n    schema = Schema(\n        info=Info(\n            title=app.title,\n            version=app.version,\n            description=app.description,\n            termsOfService=app.terms_of_service,\n            contact=app.contact,\n            license=app.license,\n        ),\n        defaultContentType=ContentTypes.json.value,\n        id=app.identifier,\n        tags=list(app.asyncapi_tags) if app.asyncapi_tags else None,\n        externalDocs=app.external_docs,\n        servers=servers,\n        channels=channels,\n        components=Components(\n            messages=messages,\n            schemas=payloads,\n            securitySchemes=None\n            if broker.security is None\n            else broker.security.get_schema(),\n        ),\n    )\n    return schema\n</code></pre>"},{"location":"api/faststream/asyncapi/message/get_model_schema/","title":"Get model schema","text":""},{"location":"api/faststream/asyncapi/message/get_model_schema/#faststream.asyncapi.message.get_model_schema","title":"faststream.asyncapi.message.get_model_schema","text":"<pre><code>get_model_schema(\n    call: Optional[Type[BaseModel]],\n    prefix: str = \"\",\n    exclude: Sequence[str] = (),\n) -&gt; Optional[Dict[str, Any]]\n</code></pre> <p>Get the schema of a model.</p> PARAMETER  DESCRIPTION <code>call</code> <p>The model class to get the schema for.</p> <p> TYPE: <code>Optional[Type[BaseModel]]</code> </p> <code>prefix</code> <p>A prefix to add to the schema title.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>exclude</code> <p>A sequence of field names to exclude from the schema.</p> <p> TYPE: <code>Sequence[str]</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>Optional[Dict[str, Any]]</code> <p>The schema of the model as a dictionary, or None if the model has no fields.</p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>If the model is a silent animal.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/asyncapi/message.py</code> <pre><code>def get_model_schema(\n    call: Optional[Type[BaseModel]],\n    prefix: str = \"\",\n    exclude: Sequence[str] = (),\n) -&gt; Optional[Dict[str, Any]]:\n    \"\"\"Get the schema of a model.\n\n    Args:\n        call: The model class to get the schema for.\n        prefix: A prefix to add to the schema title.\n        exclude: A sequence of field names to exclude from the schema.\n\n    Returns:\n        The schema of the model as a dictionary, or None if the model has no fields.\n\n    Raises:\n        NotImplementedError: If the model is a silent animal.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    if call is None:\n        return None\n\n    params = {k: v for k, v in get_model_fields(call).items() if k not in exclude}\n    params_number = len(params)\n\n    if params_number == 0:\n        return None\n\n    model = None\n    use_original_model = False\n    if params_number == 1:\n        name, param = tuple(params.items())[0]\n\n        if (\n            param.annotation\n            and isclass(param.annotation)\n            and issubclass(param.annotation, BaseModel)  # NOTE: 3.7-3.10 compatibility\n        ):\n            model = param.annotation\n            use_original_model = True\n\n    if model is None:\n        model = call\n\n    body = model_schema(model)\n\n    if params_number == 1 and not use_original_model:\n        param_body = body.get(\"properties\", {})\n        param_body = param_body[name]\n\n        if PYDANTIC_V2:\n            original_title = param.title\n        else:\n            original_title = param.field_info.title  # type: ignore[attr-defined]\n\n        if original_title:\n            use_original_model = True\n            param_body[\"title\"] = original_title\n        else:\n            param_body[\"title\"] = name\n\n        body = param_body\n\n    camel_body = to_camelcase(body[\"title\"])\n    if not use_original_model:\n        if prefix.lower() != camel_body.lower():\n            body[\"title\"] = f\"{prefix}{camel_body}Payload\"\n        else:\n            body[\"title\"] = f\"{camel_body}Payload\"\n\n    return body\n</code></pre>"},{"location":"api/faststream/asyncapi/message/get_response_schema/","title":"Get response schema","text":""},{"location":"api/faststream/asyncapi/message/get_response_schema/#faststream.asyncapi.message.get_response_schema","title":"faststream.asyncapi.message.get_response_schema","text":"<pre><code>get_response_schema(\n    call: Optional[CallModel[Any, Any]], prefix: str = \"\"\n) -&gt; Optional[Dict[str, Any]]\n</code></pre> <p>Get the response schema for a given call.</p> PARAMETER  DESCRIPTION <code>call</code> <p>The call model.</p> <p> TYPE: <code>Optional[CallModel[Any, Any]]</code> </p> <code>prefix</code> <p>A prefix to add to the schema keys.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> RETURNS DESCRIPTION <code>Optional[Dict[str, Any]]</code> <p>The response schema as a dictionary.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/asyncapi/message.py</code> <pre><code>def get_response_schema(\n    call: Optional[CallModel[Any, Any]],\n    prefix: str = \"\",\n) -&gt; Optional[Dict[str, Any]]:\n    \"\"\"Get the response schema for a given call.\n\n    Args:\n        call: The call model.\n        prefix: A prefix to add to the schema keys.\n\n    Returns:\n        The response schema as a dictionary.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    return get_model_schema(\n        getattr(\n            call, \"response_model\", None\n        ),  # NOTE: FastAPI Dependant object compatibility\n        prefix=prefix,\n    )\n</code></pre>"},{"location":"api/faststream/asyncapi/message/parse_handler_params/","title":"Parse handler params","text":""},{"location":"api/faststream/asyncapi/message/parse_handler_params/#faststream.asyncapi.message.parse_handler_params","title":"faststream.asyncapi.message.parse_handler_params","text":"<pre><code>parse_handler_params(\n    call: CallModel[Any, Any], prefix: str = \"\"\n) -&gt; Dict[str, Any]\n</code></pre> <p>Parses the handler parameters.</p> PARAMETER  DESCRIPTION <code>call</code> <p>The call model.</p> <p> TYPE: <code>CallModel[Any, Any]</code> </p> <code>prefix</code> <p>The prefix for the model schema.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> RETURNS DESCRIPTION <code>Dict[str, Any]</code> <p>A dictionary containing the parsed parameters.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/asyncapi/message.py</code> <pre><code>def parse_handler_params(call: CallModel[Any, Any], prefix: str = \"\") -&gt; Dict[str, Any]:\n    \"\"\"Parses the handler parameters.\n\n    Args:\n        call: The call model.\n        prefix: The prefix for the model schema.\n\n    Returns:\n        A dictionary containing the parsed parameters.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    body = get_model_schema(\n        call.model, prefix=prefix, exclude=tuple(call.custom_fields.keys())\n    )\n    if body is None:\n        return {\"title\": \"EmptyPayload\", \"type\": \"null\"}\n\n    return body\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/amqp/ChannelBinding/","title":"ChannelBinding","text":""},{"location":"api/faststream/asyncapi/schema/bindings/amqp/ChannelBinding/#faststream.asyncapi.schema.bindings.amqp.ChannelBinding","title":"faststream.asyncapi.schema.bindings.amqp.ChannelBinding","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent channel binding.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/asyncapi/schema/bindings/amqp.py</code> <pre><code>class ChannelBinding(BaseModel):\n    \"\"\"A class to represent channel binding.\n\n    Attributes:\n        is_ : Type of binding, can be \"queue\" or \"routingKey\"\n        bindingVersion : Version of the binding\n        queue : Optional queue object\n        exchange : Optional exchange object\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    is_: Literal[\"queue\", \"routingKey\"] = Field(..., alias=\"is\")\n    bindingVersion: str = \"0.2.0\"\n    queue: Optional[Queue] = None\n    exchange: Optional[Exchange] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/amqp/ChannelBinding/#faststream.asyncapi.schema.bindings.amqp.ChannelBinding.bindingVersion","title":"bindingVersion  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bindingVersion: str = '0.2.0'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/amqp/ChannelBinding/#faststream.asyncapi.schema.bindings.amqp.ChannelBinding.exchange","title":"exchange  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>exchange: Optional[Exchange] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/amqp/ChannelBinding/#faststream.asyncapi.schema.bindings.amqp.ChannelBinding.is_","title":"is_  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>is_: Literal[\"queue\", \"routingKey\"] = Field(..., alias=\"is\")\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/amqp/ChannelBinding/#faststream.asyncapi.schema.bindings.amqp.ChannelBinding.queue","title":"queue  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>queue: Optional[Queue] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/amqp/Exchange/","title":"Exchange","text":""},{"location":"api/faststream/asyncapi/schema/bindings/amqp/Exchange/#faststream.asyncapi.schema.bindings.amqp.Exchange","title":"faststream.asyncapi.schema.bindings.amqp.Exchange","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent an exchange.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/asyncapi/schema/bindings/amqp.py</code> <pre><code>class Exchange(BaseModel):\n    \"\"\"A class to represent an exchange.\n\n    Attributes:\n        name : name of the exchange (optional)\n        type : type of the exchange, can be one of \"default\", \"direct\", \"topic\", \"fanout\", \"headers\"\n        durable : whether the exchange is durable (optional)\n        autoDelete : whether the exchange is automatically deleted (optional)\n        vhost : virtual host of the exchange, default is \"/\"\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    name: Optional[str] = None\n    type: Literal[\"default\", \"direct\", \"topic\", \"fanout\", \"headers\"]\n    durable: Optional[bool] = None\n    autoDelete: Optional[bool] = None\n    vhost: str = \"/\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/amqp/Exchange/#faststream.asyncapi.schema.bindings.amqp.Exchange.autoDelete","title":"autoDelete  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>autoDelete: Optional[bool] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/amqp/Exchange/#faststream.asyncapi.schema.bindings.amqp.Exchange.durable","title":"durable  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>durable: Optional[bool] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/amqp/Exchange/#faststream.asyncapi.schema.bindings.amqp.Exchange.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/amqp/Exchange/#faststream.asyncapi.schema.bindings.amqp.Exchange.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: Literal[\n    \"default\", \"direct\", \"topic\", \"fanout\", \"headers\"\n]\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/amqp/Exchange/#faststream.asyncapi.schema.bindings.amqp.Exchange.vhost","title":"vhost  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>vhost: str = '/'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/amqp/OperationBinding/","title":"OperationBinding","text":""},{"location":"api/faststream/asyncapi/schema/bindings/amqp/OperationBinding/#faststream.asyncapi.schema.bindings.amqp.OperationBinding","title":"faststream.asyncapi.schema.bindings.amqp.OperationBinding","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent an operation binding.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/asyncapi/schema/bindings/amqp.py</code> <pre><code>class OperationBinding(BaseModel):\n    \"\"\"A class to represent an operation binding.\n\n    Attributes:\n        cc : optional string representing the cc\n        ack : boolean indicating if the operation is acknowledged\n        replyTo : optional dictionary representing the replyTo\n        bindingVersion : string representing the binding version\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    cc: Optional[str] = None\n    ack: bool = True\n    replyTo: Optional[Dict[str, Any]] = None\n    bindingVersion: str = \"0.2.0\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/amqp/OperationBinding/#faststream.asyncapi.schema.bindings.amqp.OperationBinding.ack","title":"ack  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ack: bool = True\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/amqp/OperationBinding/#faststream.asyncapi.schema.bindings.amqp.OperationBinding.bindingVersion","title":"bindingVersion  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bindingVersion: str = '0.2.0'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/amqp/OperationBinding/#faststream.asyncapi.schema.bindings.amqp.OperationBinding.cc","title":"cc  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cc: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/amqp/OperationBinding/#faststream.asyncapi.schema.bindings.amqp.OperationBinding.replyTo","title":"replyTo  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>replyTo: Optional[Dict[str, Any]] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/amqp/Queue/","title":"Queue","text":""},{"location":"api/faststream/asyncapi/schema/bindings/amqp/Queue/#faststream.asyncapi.schema.bindings.amqp.Queue","title":"faststream.asyncapi.schema.bindings.amqp.Queue","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent a queue.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/asyncapi/schema/bindings/amqp.py</code> <pre><code>class Queue(BaseModel):\n    \"\"\"A class to represent a queue.\n\n    Attributes:\n        name : name of the queue\n        durable : indicates if the queue is durable\n        exclusive : indicates if the queue is exclusive\n        autoDelete : indicates if the queue should be automatically deleted\n        vhost : virtual host of the queue (default is \"/\")\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    name: str\n    durable: bool\n    exclusive: bool\n    autoDelete: bool\n    vhost: str = \"/\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/amqp/Queue/#faststream.asyncapi.schema.bindings.amqp.Queue.autoDelete","title":"autoDelete  <code>instance-attribute</code>","text":"<pre><code>autoDelete: bool\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/amqp/Queue/#faststream.asyncapi.schema.bindings.amqp.Queue.durable","title":"durable  <code>instance-attribute</code>","text":"<pre><code>durable: bool\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/amqp/Queue/#faststream.asyncapi.schema.bindings.amqp.Queue.exclusive","title":"exclusive  <code>instance-attribute</code>","text":"<pre><code>exclusive: bool\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/amqp/Queue/#faststream.asyncapi.schema.bindings.amqp.Queue.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/amqp/Queue/#faststream.asyncapi.schema.bindings.amqp.Queue.vhost","title":"vhost  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>vhost: str = '/'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/amqp/ServerBinding/","title":"ServerBinding","text":""},{"location":"api/faststream/asyncapi/schema/bindings/amqp/ServerBinding/#faststream.asyncapi.schema.bindings.amqp.ServerBinding","title":"faststream.asyncapi.schema.bindings.amqp.ServerBinding","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent a server binding.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/asyncapi/schema/bindings/amqp.py</code> <pre><code>class ServerBinding(BaseModel):\n    \"\"\"A class to represent a server binding.\n\n    Attributes:\n        bindingVersion : version of the binding (default: \"0.2.0\")\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    bindingVersion: str = \"0.2.0\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/amqp/ServerBinding/#faststream.asyncapi.schema.bindings.amqp.ServerBinding.bindingVersion","title":"bindingVersion  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bindingVersion: str = '0.2.0'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/kafka/ChannelBinding/","title":"ChannelBinding","text":""},{"location":"api/faststream/asyncapi/schema/bindings/kafka/ChannelBinding/#faststream.asyncapi.schema.bindings.kafka.ChannelBinding","title":"faststream.asyncapi.schema.bindings.kafka.ChannelBinding","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent a channel binding.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/asyncapi/schema/bindings/kafka.py</code> <pre><code>class ChannelBinding(BaseModel):\n    \"\"\"A class to represent a channel binding.\n\n    Attributes:\n        topic : optional string representing the topic\n        partitions : optional positive integer representing the number of partitions\n        replicas : optional positive integer representing the number of replicas\n        bindingVersion : string representing the binding version\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    topic: Optional[str] = None\n    partitions: Optional[PositiveInt] = None\n    replicas: Optional[PositiveInt] = None\n    # TODO:\n    # topicConfiguration\n    bindingVersion: str = \"0.4.0\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/kafka/ChannelBinding/#faststream.asyncapi.schema.bindings.kafka.ChannelBinding.bindingVersion","title":"bindingVersion  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bindingVersion: str = '0.4.0'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/kafka/ChannelBinding/#faststream.asyncapi.schema.bindings.kafka.ChannelBinding.partitions","title":"partitions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>partitions: Optional[PositiveInt] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/kafka/ChannelBinding/#faststream.asyncapi.schema.bindings.kafka.ChannelBinding.replicas","title":"replicas  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>replicas: Optional[PositiveInt] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/kafka/ChannelBinding/#faststream.asyncapi.schema.bindings.kafka.ChannelBinding.topic","title":"topic  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>topic: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/kafka/OperationBinding/","title":"OperationBinding","text":""},{"location":"api/faststream/asyncapi/schema/bindings/kafka/OperationBinding/#faststream.asyncapi.schema.bindings.kafka.OperationBinding","title":"faststream.asyncapi.schema.bindings.kafka.OperationBinding","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent an operation binding.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/asyncapi/schema/bindings/kafka.py</code> <pre><code>class OperationBinding(BaseModel):\n    \"\"\"A class to represent an operation binding.\n\n    Attributes:\n        groupId : optional dictionary representing the group ID\n        clientId : optional dictionary representing the client ID\n        replyTo : optional dictionary representing the reply-to\n        bindingVersion : version of the binding (default: \"0.4.0\")\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    groupId: Optional[Dict[str, Any]] = None\n    clientId: Optional[Dict[str, Any]] = None\n    replyTo: Optional[Dict[str, Any]] = None\n    bindingVersion: str = \"0.4.0\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/kafka/OperationBinding/#faststream.asyncapi.schema.bindings.kafka.OperationBinding.bindingVersion","title":"bindingVersion  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bindingVersion: str = '0.4.0'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/kafka/OperationBinding/#faststream.asyncapi.schema.bindings.kafka.OperationBinding.clientId","title":"clientId  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>clientId: Optional[Dict[str, Any]] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/kafka/OperationBinding/#faststream.asyncapi.schema.bindings.kafka.OperationBinding.groupId","title":"groupId  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>groupId: Optional[Dict[str, Any]] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/kafka/OperationBinding/#faststream.asyncapi.schema.bindings.kafka.OperationBinding.replyTo","title":"replyTo  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>replyTo: Optional[Dict[str, Any]] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/kafka/ServerBinding/","title":"ServerBinding","text":""},{"location":"api/faststream/asyncapi/schema/bindings/kafka/ServerBinding/#faststream.asyncapi.schema.bindings.kafka.ServerBinding","title":"faststream.asyncapi.schema.bindings.kafka.ServerBinding","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent a server binding.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/asyncapi/schema/bindings/kafka.py</code> <pre><code>class ServerBinding(BaseModel):\n    \"\"\"A class to represent a server binding.\n\n    Attributes:\n        bindingVersion : version of the binding (default: \"0.4.0\")\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    bindingVersion: str = \"0.4.0\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/kafka/ServerBinding/#faststream.asyncapi.schema.bindings.kafka.ServerBinding.bindingVersion","title":"bindingVersion  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bindingVersion: str = '0.4.0'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/ChannelBinding/","title":"ChannelBinding","text":""},{"location":"api/faststream/asyncapi/schema/bindings/main/ChannelBinding/#faststream.asyncapi.schema.bindings.main.ChannelBinding","title":"faststream.asyncapi.schema.bindings.main.ChannelBinding","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent channel bindings.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/asyncapi/schema/bindings/main.py</code> <pre><code>class ChannelBinding(BaseModel):\n    \"\"\"A class to represent channel bindings.\n\n    Attributes:\n        amqp : AMQP channel binding (optional)\n        kafka : Kafka channel binding (optional)\n        sqs : SQS channel binding (optional)\n        nats : NATS channel binding (optional)\n        redis : Redis channel binding (optional)\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    amqp: Optional[amqp_bindings.ChannelBinding] = None\n    kafka: Optional[kafka_bindings.ChannelBinding] = None\n    sqs: Optional[sqs_bindings.ChannelBinding] = None\n    nats: Optional[nats_bindings.ChannelBinding] = None\n    redis: Optional[redis_bindings.ChannelBinding] = None\n\n    if PYDANTIC_V2:\n        model_config = {\"extra\": \"allow\"}\n\n    else:\n\n        class Config:\n            extra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/ChannelBinding/#faststream.asyncapi.schema.bindings.main.ChannelBinding.amqp","title":"amqp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>amqp: Optional[amqp_bindings.ChannelBinding] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/ChannelBinding/#faststream.asyncapi.schema.bindings.main.ChannelBinding.kafka","title":"kafka  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>kafka: Optional[kafka_bindings.ChannelBinding] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/ChannelBinding/#faststream.asyncapi.schema.bindings.main.ChannelBinding.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = {'extra': 'allow'}\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/ChannelBinding/#faststream.asyncapi.schema.bindings.main.ChannelBinding.nats","title":"nats  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>nats: Optional[nats_bindings.ChannelBinding] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/ChannelBinding/#faststream.asyncapi.schema.bindings.main.ChannelBinding.redis","title":"redis  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>redis: Optional[redis_bindings.ChannelBinding] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/ChannelBinding/#faststream.asyncapi.schema.bindings.main.ChannelBinding.sqs","title":"sqs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sqs: Optional[sqs_bindings.ChannelBinding] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/ChannelBinding/#faststream.asyncapi.schema.bindings.main.ChannelBinding.Config","title":"Config","text":"Source code in <code>faststream/asyncapi/schema/bindings/main.py</code> <pre><code>class Config:\n    extra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/ChannelBinding/#faststream.asyncapi.schema.bindings.main.ChannelBinding.Config.extra","title":"extra  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extra = 'allow'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/OperationBinding/","title":"OperationBinding","text":""},{"location":"api/faststream/asyncapi/schema/bindings/main/OperationBinding/#faststream.asyncapi.schema.bindings.main.OperationBinding","title":"faststream.asyncapi.schema.bindings.main.OperationBinding","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent an operation binding.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/asyncapi/schema/bindings/main.py</code> <pre><code>class OperationBinding(BaseModel):\n    \"\"\"A class to represent an operation binding.\n\n    Attributes:\n        amqp : AMQP operation binding (optional)\n        kafka : Kafka operation binding (optional)\n        sqs : SQS operation binding (optional)\n        nats : NATS operation binding (optional)\n        redis : Redis operation binding (optional)\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    amqp: Optional[amqp_bindings.OperationBinding] = None\n    kafka: Optional[kafka_bindings.OperationBinding] = None\n    sqs: Optional[sqs_bindings.OperationBinding] = None\n    nats: Optional[nats_bindings.OperationBinding] = None\n    redis: Optional[redis_bindings.OperationBinding] = None\n\n    if PYDANTIC_V2:\n        model_config = {\"extra\": \"allow\"}\n\n    else:\n\n        class Config:\n            extra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/OperationBinding/#faststream.asyncapi.schema.bindings.main.OperationBinding.amqp","title":"amqp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>amqp: Optional[amqp_bindings.OperationBinding] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/OperationBinding/#faststream.asyncapi.schema.bindings.main.OperationBinding.kafka","title":"kafka  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>kafka: Optional[kafka_bindings.OperationBinding] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/OperationBinding/#faststream.asyncapi.schema.bindings.main.OperationBinding.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = {'extra': 'allow'}\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/OperationBinding/#faststream.asyncapi.schema.bindings.main.OperationBinding.nats","title":"nats  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>nats: Optional[nats_bindings.OperationBinding] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/OperationBinding/#faststream.asyncapi.schema.bindings.main.OperationBinding.redis","title":"redis  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>redis: Optional[redis_bindings.OperationBinding] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/OperationBinding/#faststream.asyncapi.schema.bindings.main.OperationBinding.sqs","title":"sqs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sqs: Optional[sqs_bindings.OperationBinding] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/OperationBinding/#faststream.asyncapi.schema.bindings.main.OperationBinding.Config","title":"Config","text":"Source code in <code>faststream/asyncapi/schema/bindings/main.py</code> <pre><code>class Config:\n    extra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/OperationBinding/#faststream.asyncapi.schema.bindings.main.OperationBinding.Config.extra","title":"extra  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extra = 'allow'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/ServerBinding/","title":"ServerBinding","text":""},{"location":"api/faststream/asyncapi/schema/bindings/main/ServerBinding/#faststream.asyncapi.schema.bindings.main.ServerBinding","title":"faststream.asyncapi.schema.bindings.main.ServerBinding","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent server bindings.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/asyncapi/schema/bindings/main.py</code> <pre><code>class ServerBinding(BaseModel):\n    \"\"\"A class to represent server bindings.\n\n    Attributes:\n        amqp : AMQP server binding (optional)\n        kafka : Kafka server binding (optional)\n        sqs : SQS server binding (optional)\n        nats : NATS server binding (optional)\n        redis : Redis server binding (optional)\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    amqp: Optional[amqp_bindings.ServerBinding] = None\n    kafka: Optional[kafka_bindings.ServerBinding] = None\n    sqs: Optional[sqs_bindings.ServerBinding] = None\n    nats: Optional[nats_bindings.ServerBinding] = None\n    redis: Optional[redis_bindings.ServerBinding] = None\n\n    if PYDANTIC_V2:\n        model_config = {\"extra\": \"allow\"}\n\n    else:\n\n        class Config:\n            extra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/ServerBinding/#faststream.asyncapi.schema.bindings.main.ServerBinding.amqp","title":"amqp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>amqp: Optional[amqp_bindings.ServerBinding] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/ServerBinding/#faststream.asyncapi.schema.bindings.main.ServerBinding.kafka","title":"kafka  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>kafka: Optional[kafka_bindings.ServerBinding] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/ServerBinding/#faststream.asyncapi.schema.bindings.main.ServerBinding.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = {'extra': 'allow'}\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/ServerBinding/#faststream.asyncapi.schema.bindings.main.ServerBinding.nats","title":"nats  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>nats: Optional[nats_bindings.ServerBinding] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/ServerBinding/#faststream.asyncapi.schema.bindings.main.ServerBinding.redis","title":"redis  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>redis: Optional[redis_bindings.ServerBinding] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/ServerBinding/#faststream.asyncapi.schema.bindings.main.ServerBinding.sqs","title":"sqs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sqs: Optional[sqs_bindings.ServerBinding] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/ServerBinding/#faststream.asyncapi.schema.bindings.main.ServerBinding.Config","title":"Config","text":"Source code in <code>faststream/asyncapi/schema/bindings/main.py</code> <pre><code>class Config:\n    extra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/ServerBinding/#faststream.asyncapi.schema.bindings.main.ServerBinding.Config.extra","title":"extra  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extra = 'allow'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/nats/ChannelBinding/","title":"ChannelBinding","text":""},{"location":"api/faststream/asyncapi/schema/bindings/nats/ChannelBinding/#faststream.asyncapi.schema.bindings.nats.ChannelBinding","title":"faststream.asyncapi.schema.bindings.nats.ChannelBinding","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent channel binding.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/asyncapi/schema/bindings/nats.py</code> <pre><code>class ChannelBinding(BaseModel):\n    \"\"\"A class to represent channel binding.\n\n    Attributes:\n        subject : subject of the channel binding\n        queue : optional queue for the channel binding\n        bindingVersion : version of the channel binding, default is \"custom\"\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    subject: str\n    queue: Optional[str] = None\n    bindingVersion: str = \"custom\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/nats/ChannelBinding/#faststream.asyncapi.schema.bindings.nats.ChannelBinding.bindingVersion","title":"bindingVersion  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bindingVersion: str = 'custom'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/nats/ChannelBinding/#faststream.asyncapi.schema.bindings.nats.ChannelBinding.queue","title":"queue  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>queue: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/nats/ChannelBinding/#faststream.asyncapi.schema.bindings.nats.ChannelBinding.subject","title":"subject  <code>instance-attribute</code>","text":"<pre><code>subject: str\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/nats/OperationBinding/","title":"OperationBinding","text":""},{"location":"api/faststream/asyncapi/schema/bindings/nats/OperationBinding/#faststream.asyncapi.schema.bindings.nats.OperationBinding","title":"faststream.asyncapi.schema.bindings.nats.OperationBinding","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent an operation binding.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/asyncapi/schema/bindings/nats.py</code> <pre><code>class OperationBinding(BaseModel):\n    \"\"\"A class to represent an operation binding.\n\n    Attributes:\n        replyTo : optional dictionary containing reply information\n        bindingVersion : version of the binding (default is \"custom\")\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    replyTo: Optional[Dict[str, Any]] = None\n    bindingVersion: str = \"custom\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/nats/OperationBinding/#faststream.asyncapi.schema.bindings.nats.OperationBinding.bindingVersion","title":"bindingVersion  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bindingVersion: str = 'custom'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/nats/OperationBinding/#faststream.asyncapi.schema.bindings.nats.OperationBinding.replyTo","title":"replyTo  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>replyTo: Optional[Dict[str, Any]] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/nats/ServerBinding/","title":"ServerBinding","text":""},{"location":"api/faststream/asyncapi/schema/bindings/nats/ServerBinding/#faststream.asyncapi.schema.bindings.nats.ServerBinding","title":"faststream.asyncapi.schema.bindings.nats.ServerBinding","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent a server binding.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/asyncapi/schema/bindings/nats.py</code> <pre><code>class ServerBinding(BaseModel):\n    \"\"\"A class to represent a server binding.\n\n    Attributes:\n        bindingVersion : version of the binding (default: \"custom\")\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    bindingVersion: str = \"custom\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/nats/ServerBinding/#faststream.asyncapi.schema.bindings.nats.ServerBinding.bindingVersion","title":"bindingVersion  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bindingVersion: str = 'custom'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/redis/ChannelBinding/","title":"ChannelBinding","text":""},{"location":"api/faststream/asyncapi/schema/bindings/redis/ChannelBinding/#faststream.asyncapi.schema.bindings.redis.ChannelBinding","title":"faststream.asyncapi.schema.bindings.redis.ChannelBinding","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent channel binding.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/asyncapi/schema/bindings/redis.py</code> <pre><code>class ChannelBinding(BaseModel):\n    \"\"\"A class to represent channel binding.\n\n    Attributes:\n        channel : the channel name\n        method : the method used for binding (ssubscribe, psubscribe, subscribe)\n        bindingVersion : the version of the binding\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    channel: str\n    method: Literal[\"ssubscribe\", \"psubscribe\", \"subscribe\"] = \"subscribe\"\n    bindingVersion: str = \"custom\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/redis/ChannelBinding/#faststream.asyncapi.schema.bindings.redis.ChannelBinding.bindingVersion","title":"bindingVersion  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bindingVersion: str = 'custom'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/redis/ChannelBinding/#faststream.asyncapi.schema.bindings.redis.ChannelBinding.channel","title":"channel  <code>instance-attribute</code>","text":"<pre><code>channel: str\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/redis/ChannelBinding/#faststream.asyncapi.schema.bindings.redis.ChannelBinding.method","title":"method  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>method: Literal[\n    \"ssubscribe\", \"psubscribe\", \"subscribe\"\n] = \"subscribe\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/redis/OperationBinding/","title":"OperationBinding","text":""},{"location":"api/faststream/asyncapi/schema/bindings/redis/OperationBinding/#faststream.asyncapi.schema.bindings.redis.OperationBinding","title":"faststream.asyncapi.schema.bindings.redis.OperationBinding","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent an operation binding.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/asyncapi/schema/bindings/redis.py</code> <pre><code>class OperationBinding(BaseModel):\n    \"\"\"A class to represent an operation binding.\n\n    Attributes:\n        replyTo : optional dictionary containing reply information\n        bindingVersion : version of the binding (default is \"custom\")\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    replyTo: Optional[Dict[str, Any]] = None\n    bindingVersion: str = \"custom\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/redis/OperationBinding/#faststream.asyncapi.schema.bindings.redis.OperationBinding.bindingVersion","title":"bindingVersion  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bindingVersion: str = 'custom'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/redis/OperationBinding/#faststream.asyncapi.schema.bindings.redis.OperationBinding.replyTo","title":"replyTo  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>replyTo: Optional[Dict[str, Any]] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/redis/ServerBinding/","title":"ServerBinding","text":""},{"location":"api/faststream/asyncapi/schema/bindings/redis/ServerBinding/#faststream.asyncapi.schema.bindings.redis.ServerBinding","title":"faststream.asyncapi.schema.bindings.redis.ServerBinding","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent a server binding.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/asyncapi/schema/bindings/redis.py</code> <pre><code>class ServerBinding(BaseModel):\n    \"\"\"A class to represent a server binding.\n\n    Attributes:\n        bindingVersion : version of the binding (default: \"custom\")\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    bindingVersion: str = \"custom\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/redis/ServerBinding/#faststream.asyncapi.schema.bindings.redis.ServerBinding.bindingVersion","title":"bindingVersion  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bindingVersion: str = 'custom'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/sqs/ChannelBinding/","title":"ChannelBinding","text":""},{"location":"api/faststream/asyncapi/schema/bindings/sqs/ChannelBinding/#faststream.asyncapi.schema.bindings.sqs.ChannelBinding","title":"faststream.asyncapi.schema.bindings.sqs.ChannelBinding","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent channel binding.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/asyncapi/schema/bindings/sqs.py</code> <pre><code>class ChannelBinding(BaseModel):\n    \"\"\"A class to represent channel binding.\n\n    Attributes:\n        queue : a dictionary representing the queue\n        bindingVersion : a string representing the binding version (default: \"custom\")\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    queue: Dict[str, Any]\n    bindingVersion: str = \"custom\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/sqs/ChannelBinding/#faststream.asyncapi.schema.bindings.sqs.ChannelBinding.bindingVersion","title":"bindingVersion  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bindingVersion: str = 'custom'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/sqs/ChannelBinding/#faststream.asyncapi.schema.bindings.sqs.ChannelBinding.queue","title":"queue  <code>instance-attribute</code>","text":"<pre><code>queue: Dict[str, Any]\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/sqs/OperationBinding/","title":"OperationBinding","text":""},{"location":"api/faststream/asyncapi/schema/bindings/sqs/OperationBinding/#faststream.asyncapi.schema.bindings.sqs.OperationBinding","title":"faststream.asyncapi.schema.bindings.sqs.OperationBinding","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent an operation binding.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/asyncapi/schema/bindings/sqs.py</code> <pre><code>class OperationBinding(BaseModel):\n    \"\"\"A class to represent an operation binding.\n\n    Attributes:\n        replyTo : optional dictionary containing reply information\n        bindingVersion : version of the binding, default is \"custom\"\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    replyTo: Optional[Dict[str, Any]] = None\n    bindingVersion: str = \"custom\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/sqs/OperationBinding/#faststream.asyncapi.schema.bindings.sqs.OperationBinding.bindingVersion","title":"bindingVersion  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bindingVersion: str = 'custom'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/sqs/OperationBinding/#faststream.asyncapi.schema.bindings.sqs.OperationBinding.replyTo","title":"replyTo  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>replyTo: Optional[Dict[str, Any]] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/sqs/ServerBinding/","title":"ServerBinding","text":""},{"location":"api/faststream/asyncapi/schema/bindings/sqs/ServerBinding/#faststream.asyncapi.schema.bindings.sqs.ServerBinding","title":"faststream.asyncapi.schema.bindings.sqs.ServerBinding","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent a server binding.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/asyncapi/schema/bindings/sqs.py</code> <pre><code>class ServerBinding(BaseModel):\n    \"\"\"A class to represent a server binding.\n\n    Attributes:\n        bindingVersion : version of the binding (default: \"custom\")\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    bindingVersion: str = \"custom\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/sqs/ServerBinding/#faststream.asyncapi.schema.bindings.sqs.ServerBinding.bindingVersion","title":"bindingVersion  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bindingVersion: str = 'custom'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/channels/Channel/","title":"Channel","text":""},{"location":"api/faststream/asyncapi/schema/channels/Channel/#faststream.asyncapi.schema.channels.Channel","title":"faststream.asyncapi.schema.channels.Channel","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent a channel.</p> Configurations <p>model_config : configuration for the model (only applicable for Pydantic version 2) Config : configuration for the class (only applicable for Pydantic version 1)</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/asyncapi/schema/channels.py</code> <pre><code>class Channel(BaseModel):\n    \"\"\"A class to represent a channel.\n\n    Attributes:\n        description : optional description of the channel\n        servers : optional list of servers associated with the channel\n        bindings : optional channel binding\n        subscribe : optional operation for subscribing to the channel\n        publish : optional operation for publishing to the channel\n        parameters : optional parameters associated with the channel\n\n    Configurations:\n        model_config : configuration for the model (only applicable for Pydantic version 2)\n        Config : configuration for the class (only applicable for Pydantic version 1)\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    description: Optional[str] = None\n    servers: Optional[List[str]] = None\n    bindings: Optional[ChannelBinding] = None\n    subscribe: Optional[Operation] = None\n    publish: Optional[Operation] = None\n    parameters: Optional[Parameter] = None\n\n    if PYDANTIC_V2:\n        model_config = {\"extra\": \"allow\"}\n\n    else:\n\n        class Config:\n            extra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/channels/Channel/#faststream.asyncapi.schema.channels.Channel.bindings","title":"bindings  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bindings: Optional[ChannelBinding] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/channels/Channel/#faststream.asyncapi.schema.channels.Channel.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/channels/Channel/#faststream.asyncapi.schema.channels.Channel.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = {'extra': 'allow'}\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/channels/Channel/#faststream.asyncapi.schema.channels.Channel.parameters","title":"parameters  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>parameters: Optional[Parameter] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/channels/Channel/#faststream.asyncapi.schema.channels.Channel.publish","title":"publish  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>publish: Optional[Operation] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/channels/Channel/#faststream.asyncapi.schema.channels.Channel.servers","title":"servers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>servers: Optional[List[str]] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/channels/Channel/#faststream.asyncapi.schema.channels.Channel.subscribe","title":"subscribe  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>subscribe: Optional[Operation] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/channels/Channel/#faststream.asyncapi.schema.channels.Channel.Config","title":"Config","text":"Source code in <code>faststream/asyncapi/schema/channels.py</code> <pre><code>class Config:\n    extra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/channels/Channel/#faststream.asyncapi.schema.channels.Channel.Config.extra","title":"extra  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extra = 'allow'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/Contact/","title":"Contact","text":""},{"location":"api/faststream/asyncapi/schema/info/Contact/#faststream.asyncapi.schema.info.Contact","title":"faststream.asyncapi.schema.info.Contact","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent a contact.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/asyncapi/schema/info.py</code> <pre><code>class Contact(BaseModel):\n    \"\"\"A class to represent a contact.\n\n    Attributes:\n        name : name of the contact (str)\n        url : URL of the contact (Optional[AnyHttpUrl])\n        email : email of the contact (Optional[EmailStr])\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    name: str\n    url: Optional[AnyHttpUrl] = None\n    email: Optional[EmailStr] = None\n\n    if PYDANTIC_V2:\n        model_config = {\"extra\": \"allow\"}\n\n    else:\n\n        class Config:\n            extra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/Contact/#faststream.asyncapi.schema.info.Contact.email","title":"email  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>email: Optional[EmailStr] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/Contact/#faststream.asyncapi.schema.info.Contact.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = {'extra': 'allow'}\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/Contact/#faststream.asyncapi.schema.info.Contact.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/Contact/#faststream.asyncapi.schema.info.Contact.url","title":"url  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>url: Optional[AnyHttpUrl] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/Contact/#faststream.asyncapi.schema.info.Contact.Config","title":"Config","text":"Source code in <code>faststream/asyncapi/schema/info.py</code> <pre><code>class Config:\n    extra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/Contact/#faststream.asyncapi.schema.info.Contact.Config.extra","title":"extra  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extra = 'allow'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/ContactDict/","title":"ContactDict","text":""},{"location":"api/faststream/asyncapi/schema/info/ContactDict/#faststream.asyncapi.schema.info.ContactDict","title":"faststream.asyncapi.schema.info.ContactDict","text":"<p>             Bases: <code>TypedDict</code></p> <p>A class to represent a dictionary of contact information.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/asyncapi/schema/info.py</code> <pre><code>class ContactDict(TypedDict, total=False):\n    \"\"\"A class to represent a dictionary of contact information.\n\n    Attributes:\n        name : required name of the contact (type: str)\n        url : URL of the contact (type: AnyHttpUrl)\n        email : email address of the contact (type: EmailStr)\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    name: Required[str]\n    url: AnyHttpUrl\n    email: EmailStr\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/ContactDict/#faststream.asyncapi.schema.info.ContactDict.email","title":"email  <code>instance-attribute</code>","text":"<pre><code>email: EmailStr\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/ContactDict/#faststream.asyncapi.schema.info.ContactDict.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: Required[str]\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/ContactDict/#faststream.asyncapi.schema.info.ContactDict.url","title":"url  <code>instance-attribute</code>","text":"<pre><code>url: AnyHttpUrl\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/EmailStr/","title":"EmailStr","text":""},{"location":"api/faststream/asyncapi/schema/info/EmailStr/#faststream.asyncapi.schema.info.EmailStr","title":"faststream.asyncapi.schema.info.EmailStr","text":"<p>             Bases: <code>str</code></p> Source code in <code>faststream/asyncapi/schema/info.py</code> <pre><code>class EmailStr(str):  # type: ignore\n    @classmethod\n    def __get_validators__(cls) -&gt; Iterable[Callable[..., Any]]:\n        yield cls.validate\n\n    @classmethod\n    def validate(cls, v: Any) -&gt; str:\n        logger.warning(\n            \"email-validator bot installed, email fields will be treated as str.\\n\"\n            \"To install, run: pip install email-validator\"\n        )\n        return str(v)\n\n    @classmethod\n    def _validate(cls, __input_value: Any, _: Any) -&gt; str:\n        logger.warning(\n            \"email-validator bot installed, email fields will be treated as str.\\n\"\n            \"To install, run: pip install email-validator\"\n        )\n        return str(__input_value)\n\n    @classmethod\n    def __get_pydantic_json_schema__(\n        cls,\n        core_schema: CoreSchema,\n        handler: GetJsonSchemaHandler,\n    ) -&gt; JsonSchemaValue:\n        return {\"type\": \"string\", \"format\": \"email\"}\n\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls,\n        source: Type[Any],\n        handler: Callable[[Any], CoreSchema],\n    ) -&gt; JsonSchemaValue:\n        return with_info_plain_validator_function(cls._validate)  # type: ignore[no-any-return]\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/EmailStr/#faststream.asyncapi.schema.info.EmailStr.validate","title":"validate  <code>classmethod</code>","text":"<pre><code>validate(v: Any) -&gt; str\n</code></pre> Source code in <code>faststream/asyncapi/schema/info.py</code> <pre><code>@classmethod\ndef validate(cls, v: Any) -&gt; str:\n    logger.warning(\n        \"email-validator bot installed, email fields will be treated as str.\\n\"\n        \"To install, run: pip install email-validator\"\n    )\n    return str(v)\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/Info/","title":"Info","text":""},{"location":"api/faststream/asyncapi/schema/info/Info/#faststream.asyncapi.schema.info.Info","title":"faststream.asyncapi.schema.info.Info","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent information.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/asyncapi/schema/info.py</code> <pre><code>class Info(BaseModel):\n    \"\"\"A class to represent information.\n\n    Attributes:\n        title : title of the information\n        version : version of the information (default: \"1.0.0\")\n        description : description of the information (default: \"\")\n        termsOfService : terms of service for the information (default: None)\n        contact : contact information for the information (default: None)\n        license : license information for the information (default: None)\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    title: str\n    version: str = \"1.0.0\"\n    description: str = \"\"\n    termsOfService: Optional[AnyHttpUrl] = None\n    contact: Optional[Union[Contact, ContactDict, Dict[str, Any]]] = None\n    license: Optional[Union[License, LicenseDict, Dict[str, Any]]] = None\n\n    if PYDANTIC_V2:\n        model_config = {\"extra\": \"allow\"}\n\n    else:\n\n        class Config:\n            extra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/Info/#faststream.asyncapi.schema.info.Info.contact","title":"contact  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>contact: Optional[\n    Union[Contact, ContactDict, Dict[str, Any]]\n] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/Info/#faststream.asyncapi.schema.info.Info.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: str = ''\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/Info/#faststream.asyncapi.schema.info.Info.license","title":"license  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>license: Optional[\n    Union[License, LicenseDict, Dict[str, Any]]\n] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/Info/#faststream.asyncapi.schema.info.Info.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = {'extra': 'allow'}\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/Info/#faststream.asyncapi.schema.info.Info.termsOfService","title":"termsOfService  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>termsOfService: Optional[AnyHttpUrl] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/Info/#faststream.asyncapi.schema.info.Info.title","title":"title  <code>instance-attribute</code>","text":"<pre><code>title: str\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/Info/#faststream.asyncapi.schema.info.Info.version","title":"version  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>version: str = '1.0.0'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/Info/#faststream.asyncapi.schema.info.Info.Config","title":"Config","text":"Source code in <code>faststream/asyncapi/schema/info.py</code> <pre><code>class Config:\n    extra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/Info/#faststream.asyncapi.schema.info.Info.Config.extra","title":"extra  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extra = 'allow'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/License/","title":"License","text":""},{"location":"api/faststream/asyncapi/schema/info/License/#faststream.asyncapi.schema.info.License","title":"faststream.asyncapi.schema.info.License","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent a license.</p> Config <p>extra : allow additional attributes in the model (PYDANTIC_V2)</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/asyncapi/schema/info.py</code> <pre><code>class License(BaseModel):\n    \"\"\"A class to represent a license.\n\n    Attributes:\n        name : name of the license\n        url : URL of the license (optional)\n\n    Config:\n        extra : allow additional attributes in the model (PYDANTIC_V2)\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    name: str\n    url: Optional[AnyHttpUrl] = None\n\n    if PYDANTIC_V2:\n        model_config = {\"extra\": \"allow\"}\n\n    else:\n\n        class Config:\n            extra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/License/#faststream.asyncapi.schema.info.License.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = {'extra': 'allow'}\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/License/#faststream.asyncapi.schema.info.License.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/License/#faststream.asyncapi.schema.info.License.url","title":"url  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>url: Optional[AnyHttpUrl] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/License/#faststream.asyncapi.schema.info.License.Config","title":"Config","text":"Source code in <code>faststream/asyncapi/schema/info.py</code> <pre><code>class Config:\n    extra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/License/#faststream.asyncapi.schema.info.License.Config.extra","title":"extra  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extra = 'allow'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/LicenseDict/","title":"LicenseDict","text":""},{"location":"api/faststream/asyncapi/schema/info/LicenseDict/#faststream.asyncapi.schema.info.LicenseDict","title":"faststream.asyncapi.schema.info.LicenseDict","text":"<p>             Bases: <code>TypedDict</code></p> <p>A dictionary-like class to represent a license.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/asyncapi/schema/info.py</code> <pre><code>class LicenseDict(TypedDict, total=False):\n    \"\"\"A dictionary-like class to represent a license.\n\n    Attributes:\n        name : required name of the license (type: str)\n        url : URL of the license (type: AnyHttpUrl)\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    name: Required[str]\n    url: AnyHttpUrl\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/LicenseDict/#faststream.asyncapi.schema.info.LicenseDict.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: Required[str]\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/LicenseDict/#faststream.asyncapi.schema.info.LicenseDict.url","title":"url  <code>instance-attribute</code>","text":"<pre><code>url: AnyHttpUrl\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/main/Components/","title":"Components","text":""},{"location":"api/faststream/asyncapi/schema/main/Components/#faststream.asyncapi.schema.main.Components","title":"faststream.asyncapi.schema.main.Components","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent components in a system.</p> Note <p>The following attributes are not implemented yet: - servers - serverVariables - channels - securitySchemes - parameters - correlationIds - operationTraits - messageTraits - serverBindings - channelBindings - operationBindings - messageBindings</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/asyncapi/schema/main.py</code> <pre><code>class Components(BaseModel):\n    # TODO\n    # servers\n    # serverVariables\n    # channels\n    \"\"\"A class to represent components in a system.\n\n    Attributes:\n        messages : Optional dictionary of messages\n        schemas : Optional dictionary of schemas\n\n    Note:\n        The following attributes are not implemented yet:\n        - servers\n        - serverVariables\n        - channels\n        - securitySchemes\n        - parameters\n        - correlationIds\n        - operationTraits\n        - messageTraits\n        - serverBindings\n        - channelBindings\n        - operationBindings\n        - messageBindings\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    messages: Optional[Dict[str, Message]] = None\n    schemas: Optional[Dict[str, Dict[str, Any]]] = None\n    securitySchemes: Optional[Dict[str, Dict[str, Any]]] = None\n    # parameters\n    # correlationIds\n    # operationTraits\n    # messageTraits\n    # serverBindings\n    # channelBindings\n    # operationBindings\n    # messageBindings\n\n    if PYDANTIC_V2:\n        model_config = {\"extra\": \"allow\"}\n\n    else:\n\n        class Config:\n            extra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/main/Components/#faststream.asyncapi.schema.main.Components.messages","title":"messages  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>messages: Optional[Dict[str, Message]] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/main/Components/#faststream.asyncapi.schema.main.Components.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = {'extra': 'allow'}\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/main/Components/#faststream.asyncapi.schema.main.Components.schemas","title":"schemas  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>schemas: Optional[Dict[str, Dict[str, Any]]] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/main/Components/#faststream.asyncapi.schema.main.Components.securitySchemes","title":"securitySchemes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>securitySchemes: Optional[Dict[str, Dict[str, Any]]] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/main/Components/#faststream.asyncapi.schema.main.Components.Config","title":"Config","text":"Source code in <code>faststream/asyncapi/schema/main.py</code> <pre><code>class Config:\n    extra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/main/Components/#faststream.asyncapi.schema.main.Components.Config.extra","title":"extra  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extra = 'allow'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/main/Schema/","title":"Schema","text":""},{"location":"api/faststream/asyncapi/schema/main/Schema/#faststream.asyncapi.schema.main.Schema","title":"faststream.asyncapi.schema.main.Schema","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent a schema.</p> METHOD DESCRIPTION <code>to_jsonable</code> <p>Convert the schema to a JSON-serializable object.</p> <code>to_json</code> <p>Convert the schema to a JSON string.</p> <code>to_yaml</code> <p>Convert the schema to a YAML string.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/asyncapi/schema/main.py</code> <pre><code>class Schema(BaseModel):\n    \"\"\"A class to represent a schema.\n\n    Attributes:\n        asyncapi : version of the async API\n        id : optional ID\n        defaultContentType : optional default content type\n        info : information about the schema\n        servers : optional dictionary of servers\n        channels : dictionary of channels\n        components : optional components of the schema\n        tags : optional list of tags\n        externalDocs : optional external documentation\n\n    Methods:\n        to_jsonable() -&gt; Any: Convert the schema to a JSON-serializable object.\n        to_json() -&gt; str: Convert the schema to a JSON string.\n        to_yaml() -&gt; str: Convert the schema to a YAML string.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    asyncapi: str = ASYNC_API_VERSION\n    id: Optional[str] = None\n    defaultContentType: Optional[str] = None\n    info: Info\n    servers: Optional[Dict[str, Server]] = None\n    channels: Dict[str, Channel]\n    components: Optional[Components] = None\n    tags: Optional[List[Union[Tag, TagDict, Dict[str, Any]]]] = None\n    externalDocs: Optional[Union[ExternalDocs, ExternalDocsDict, Dict[str, Any]]] = None\n\n    def to_jsonable(self) -&gt; Any:\n        return model_to_jsonable(\n            self,\n            by_alias=True,\n            exclude_none=True,\n        )\n\n    def to_json(self) -&gt; str:\n        return model_to_json(\n            self,\n            by_alias=True,\n            exclude_none=True,\n        )\n\n    def to_yaml(self) -&gt; str:\n        from io import StringIO\n\n        import yaml\n\n        io = StringIO(initial_value=\"\", newline=\"\\n\")\n        yaml.dump(self.to_jsonable(), io, sort_keys=False)\n        return io.getvalue()\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/main/Schema/#faststream.asyncapi.schema.main.Schema.asyncapi","title":"asyncapi  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>asyncapi: str = ASYNC_API_VERSION\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/main/Schema/#faststream.asyncapi.schema.main.Schema.channels","title":"channels  <code>instance-attribute</code>","text":"<pre><code>channels: Dict[str, Channel]\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/main/Schema/#faststream.asyncapi.schema.main.Schema.components","title":"components  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>components: Optional[Components] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/main/Schema/#faststream.asyncapi.schema.main.Schema.defaultContentType","title":"defaultContentType  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>defaultContentType: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/main/Schema/#faststream.asyncapi.schema.main.Schema.externalDocs","title":"externalDocs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>externalDocs: Optional[\n    Union[ExternalDocs, ExternalDocsDict, Dict[str, Any]]\n] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/main/Schema/#faststream.asyncapi.schema.main.Schema.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/main/Schema/#faststream.asyncapi.schema.main.Schema.info","title":"info  <code>instance-attribute</code>","text":"<pre><code>info: Info\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/main/Schema/#faststream.asyncapi.schema.main.Schema.servers","title":"servers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>servers: Optional[Dict[str, Server]] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/main/Schema/#faststream.asyncapi.schema.main.Schema.tags","title":"tags  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tags: Optional[\n    List[Union[Tag, TagDict, Dict[str, Any]]]\n] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/main/Schema/#faststream.asyncapi.schema.main.Schema.to_json","title":"to_json","text":"<pre><code>to_json() -&gt; str\n</code></pre> Source code in <code>faststream/asyncapi/schema/main.py</code> <pre><code>def to_json(self) -&gt; str:\n    return model_to_json(\n        self,\n        by_alias=True,\n        exclude_none=True,\n    )\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/main/Schema/#faststream.asyncapi.schema.main.Schema.to_jsonable","title":"to_jsonable","text":"<pre><code>to_jsonable() -&gt; Any\n</code></pre> Source code in <code>faststream/asyncapi/schema/main.py</code> <pre><code>def to_jsonable(self) -&gt; Any:\n    return model_to_jsonable(\n        self,\n        by_alias=True,\n        exclude_none=True,\n    )\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/main/Schema/#faststream.asyncapi.schema.main.Schema.to_yaml","title":"to_yaml","text":"<pre><code>to_yaml() -&gt; str\n</code></pre> Source code in <code>faststream/asyncapi/schema/main.py</code> <pre><code>def to_yaml(self) -&gt; str:\n    from io import StringIO\n\n    import yaml\n\n    io = StringIO(initial_value=\"\", newline=\"\\n\")\n    yaml.dump(self.to_jsonable(), io, sort_keys=False)\n    return io.getvalue()\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/message/CorrelationId/","title":"CorrelationId","text":""},{"location":"api/faststream/asyncapi/schema/message/CorrelationId/#faststream.asyncapi.schema.message.CorrelationId","title":"faststream.asyncapi.schema.message.CorrelationId","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent a correlation ID.</p> Configurations <p>extra : allows extra fields in the correlation ID model</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/asyncapi/schema/message.py</code> <pre><code>class CorrelationId(BaseModel):\n    \"\"\"A class to represent a correlation ID.\n\n    Attributes:\n        description : optional description of the correlation ID\n        location : location of the correlation ID\n\n    Configurations:\n        extra : allows extra fields in the correlation ID model\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    description: Optional[str] = None\n    location: str\n\n    if PYDANTIC_V2:\n        model_config = {\"extra\": \"allow\"}\n\n    else:\n\n        class Config:\n            extra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/message/CorrelationId/#faststream.asyncapi.schema.message.CorrelationId.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/message/CorrelationId/#faststream.asyncapi.schema.message.CorrelationId.location","title":"location  <code>instance-attribute</code>","text":"<pre><code>location: str\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/message/CorrelationId/#faststream.asyncapi.schema.message.CorrelationId.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = {'extra': 'allow'}\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/message/CorrelationId/#faststream.asyncapi.schema.message.CorrelationId.Config","title":"Config","text":"Source code in <code>faststream/asyncapi/schema/message.py</code> <pre><code>class Config:\n    extra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/message/CorrelationId/#faststream.asyncapi.schema.message.CorrelationId.Config.extra","title":"extra  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extra = 'allow'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/message/Message/","title":"Message","text":""},{"location":"api/faststream/asyncapi/schema/message/Message/#faststream.asyncapi.schema.message.Message","title":"faststream.asyncapi.schema.message.Message","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent a message.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/asyncapi/schema/message.py</code> <pre><code>class Message(BaseModel):\n    \"\"\"A class to represent a message.\n\n    Attributes:\n        title : title of the message\n        name : name of the message\n        summary : summary of the message\n        description : description of the message\n        messageId : ID of the message\n        correlationId : correlation ID of the message\n        contentType : content type of the message\n        payload : dictionary representing the payload of the message\n        tags : list of tags associated with the message\n        externalDocs : external documentation associated with the message\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    title: Optional[str] = None\n    name: Optional[str] = None\n    summary: Optional[str] = None\n    description: Optional[str] = None\n    messageId: Optional[str] = None\n    correlationId: Optional[CorrelationId] = None\n    contentType: Optional[str] = None\n\n    payload: Dict[str, Any]\n    # TODO:\n    # headers\n    # schemaFormat\n    # bindings\n    # examples\n    # traits\n\n    tags: Optional[\n        List[Union[Tag, Dict[str, Any]]]\n    ] = None  # TODO: weird TagDict behavior\n    externalDocs: Optional[\n        Union[ExternalDocs, Dict[str, Any]]\n    ] = None  # TODO: weird ExternalDocsDict behavior\n\n    if PYDANTIC_V2:\n        model_config = {\"extra\": \"allow\"}\n\n    else:\n\n        class Config:\n            extra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/message/Message/#faststream.asyncapi.schema.message.Message.contentType","title":"contentType  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>contentType: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/message/Message/#faststream.asyncapi.schema.message.Message.correlationId","title":"correlationId  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>correlationId: Optional[CorrelationId] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/message/Message/#faststream.asyncapi.schema.message.Message.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/message/Message/#faststream.asyncapi.schema.message.Message.externalDocs","title":"externalDocs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>externalDocs: Optional[\n    Union[ExternalDocs, Dict[str, Any]]\n] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/message/Message/#faststream.asyncapi.schema.message.Message.messageId","title":"messageId  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>messageId: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/message/Message/#faststream.asyncapi.schema.message.Message.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = {'extra': 'allow'}\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/message/Message/#faststream.asyncapi.schema.message.Message.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/message/Message/#faststream.asyncapi.schema.message.Message.payload","title":"payload  <code>instance-attribute</code>","text":"<pre><code>payload: Dict[str, Any]\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/message/Message/#faststream.asyncapi.schema.message.Message.summary","title":"summary  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>summary: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/message/Message/#faststream.asyncapi.schema.message.Message.tags","title":"tags  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tags: Optional[List[Union[Tag, Dict[str, Any]]]] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/message/Message/#faststream.asyncapi.schema.message.Message.title","title":"title  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>title: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/message/Message/#faststream.asyncapi.schema.message.Message.Config","title":"Config","text":"Source code in <code>faststream/asyncapi/schema/message.py</code> <pre><code>class Config:\n    extra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/message/Message/#faststream.asyncapi.schema.message.Message.Config.extra","title":"extra  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extra = 'allow'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/operations/Operation/","title":"Operation","text":""},{"location":"api/faststream/asyncapi/schema/operations/Operation/#faststream.asyncapi.schema.operations.Operation","title":"faststream.asyncapi.schema.operations.Operation","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent an operation.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/asyncapi/schema/operations.py</code> <pre><code>class Operation(BaseModel):\n    \"\"\"A class to represent an operation.\n\n    Attributes:\n        operationId : ID of the operation\n        summary : summary of the operation\n        description : description of the operation\n        bindings : bindings of the operation\n        message : message of the operation\n        security : security details of the operation\n        tags : tags associated with the operation\n        externalDocs : external documentation for the operation\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    operationId: Optional[str] = None\n    summary: Optional[str] = None\n    description: Optional[str] = None\n\n    bindings: Optional[OperationBinding] = None\n\n    message: Union[Message, Reference]\n\n    security: Optional[Dict[str, List[str]]] = None\n\n    # TODO\n    # traits\n\n    tags: Optional[List[Union[Tag, TagDict, Dict[str, Any]]]] = None\n    externalDocs: Optional[Union[ExternalDocs, ExternalDocsDict, Dict[str, Any]]] = None\n\n    if PYDANTIC_V2:\n        model_config = {\"extra\": \"allow\"}\n\n    else:\n\n        class Config:\n            extra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/operations/Operation/#faststream.asyncapi.schema.operations.Operation.bindings","title":"bindings  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bindings: Optional[OperationBinding] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/operations/Operation/#faststream.asyncapi.schema.operations.Operation.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/operations/Operation/#faststream.asyncapi.schema.operations.Operation.externalDocs","title":"externalDocs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>externalDocs: Optional[\n    Union[ExternalDocs, ExternalDocsDict, Dict[str, Any]]\n] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/operations/Operation/#faststream.asyncapi.schema.operations.Operation.message","title":"message  <code>instance-attribute</code>","text":"<pre><code>message: Union[Message, Reference]\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/operations/Operation/#faststream.asyncapi.schema.operations.Operation.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = {'extra': 'allow'}\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/operations/Operation/#faststream.asyncapi.schema.operations.Operation.operationId","title":"operationId  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>operationId: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/operations/Operation/#faststream.asyncapi.schema.operations.Operation.security","title":"security  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>security: Optional[Dict[str, List[str]]] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/operations/Operation/#faststream.asyncapi.schema.operations.Operation.summary","title":"summary  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>summary: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/operations/Operation/#faststream.asyncapi.schema.operations.Operation.tags","title":"tags  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tags: Optional[\n    List[Union[Tag, TagDict, Dict[str, Any]]]\n] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/operations/Operation/#faststream.asyncapi.schema.operations.Operation.Config","title":"Config","text":"Source code in <code>faststream/asyncapi/schema/operations.py</code> <pre><code>class Config:\n    extra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/operations/Operation/#faststream.asyncapi.schema.operations.Operation.Config.extra","title":"extra  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extra = 'allow'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/OauthFlowObj/","title":"OauthFlowObj","text":""},{"location":"api/faststream/asyncapi/schema/security/OauthFlowObj/#faststream.asyncapi.schema.security.OauthFlowObj","title":"faststream.asyncapi.schema.security.OauthFlowObj","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent an OAuth flow object.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/asyncapi/schema/security.py</code> <pre><code>class OauthFlowObj(BaseModel):\n    \"\"\"A class to represent an OAuth flow object.\n\n    Attributes:\n        authorizationUrl : Optional[AnyHttpUrl] : The URL for authorization\n        tokenUrl : Optional[AnyHttpUrl] : The URL for token\n        refreshUrl : Optional[AnyHttpUrl] : The URL for refresh\n        scopes : Dict[str, str] : The scopes for the OAuth flow\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    authorizationUrl: Optional[AnyHttpUrl] = None\n    tokenUrl: Optional[AnyHttpUrl] = None\n    refreshUrl: Optional[AnyHttpUrl] = None\n    scopes: Dict[str, str]\n\n    if PYDANTIC_V2:\n        model_config = {\"extra\": \"allow\"}\n\n    else:\n\n        class Config:\n            extra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/OauthFlowObj/#faststream.asyncapi.schema.security.OauthFlowObj.authorizationUrl","title":"authorizationUrl  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>authorizationUrl: Optional[AnyHttpUrl] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/OauthFlowObj/#faststream.asyncapi.schema.security.OauthFlowObj.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = {'extra': 'allow'}\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/OauthFlowObj/#faststream.asyncapi.schema.security.OauthFlowObj.refreshUrl","title":"refreshUrl  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>refreshUrl: Optional[AnyHttpUrl] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/OauthFlowObj/#faststream.asyncapi.schema.security.OauthFlowObj.scopes","title":"scopes  <code>instance-attribute</code>","text":"<pre><code>scopes: Dict[str, str]\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/OauthFlowObj/#faststream.asyncapi.schema.security.OauthFlowObj.tokenUrl","title":"tokenUrl  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tokenUrl: Optional[AnyHttpUrl] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/OauthFlowObj/#faststream.asyncapi.schema.security.OauthFlowObj.Config","title":"Config","text":"Source code in <code>faststream/asyncapi/schema/security.py</code> <pre><code>class Config:\n    extra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/OauthFlowObj/#faststream.asyncapi.schema.security.OauthFlowObj.Config.extra","title":"extra  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extra = 'allow'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/OauthFlows/","title":"OauthFlows","text":""},{"location":"api/faststream/asyncapi/schema/security/OauthFlows/#faststream.asyncapi.schema.security.OauthFlows","title":"faststream.asyncapi.schema.security.OauthFlows","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent OAuth flows.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/asyncapi/schema/security.py</code> <pre><code>class OauthFlows(BaseModel):\n    \"\"\"A class to represent OAuth flows.\n\n    Attributes:\n        implicit : Optional[OauthFlowObj] : Implicit OAuth flow object\n        password : Optional[OauthFlowObj] : Password OAuth flow object\n        clientCredentials : Optional[OauthFlowObj] : Client credentials OAuth flow object\n        authorizationCode : Optional[OauthFlowObj] : Authorization code OAuth flow object\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    implicit: Optional[OauthFlowObj] = None\n    password: Optional[OauthFlowObj] = None\n    clientCredentials: Optional[OauthFlowObj] = None\n    authorizationCode: Optional[OauthFlowObj] = None\n\n    if PYDANTIC_V2:\n        model_config = {\"extra\": \"allow\"}\n\n    else:\n\n        class Config:\n            extra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/OauthFlows/#faststream.asyncapi.schema.security.OauthFlows.authorizationCode","title":"authorizationCode  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>authorizationCode: Optional[OauthFlowObj] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/OauthFlows/#faststream.asyncapi.schema.security.OauthFlows.clientCredentials","title":"clientCredentials  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>clientCredentials: Optional[OauthFlowObj] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/OauthFlows/#faststream.asyncapi.schema.security.OauthFlows.implicit","title":"implicit  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>implicit: Optional[OauthFlowObj] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/OauthFlows/#faststream.asyncapi.schema.security.OauthFlows.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = {'extra': 'allow'}\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/OauthFlows/#faststream.asyncapi.schema.security.OauthFlows.password","title":"password  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>password: Optional[OauthFlowObj] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/OauthFlows/#faststream.asyncapi.schema.security.OauthFlows.Config","title":"Config","text":"Source code in <code>faststream/asyncapi/schema/security.py</code> <pre><code>class Config:\n    extra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/OauthFlows/#faststream.asyncapi.schema.security.OauthFlows.Config.extra","title":"extra  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extra = 'allow'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/SecuritySchemaComponent/","title":"SecuritySchemaComponent","text":""},{"location":"api/faststream/asyncapi/schema/security/SecuritySchemaComponent/#faststream.asyncapi.schema.security.SecuritySchemaComponent","title":"faststream.asyncapi.schema.security.SecuritySchemaComponent","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent a security schema component.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/asyncapi/schema/security.py</code> <pre><code>class SecuritySchemaComponent(BaseModel):\n    \"\"\"A class to represent a security schema component.\n\n    Attributes:\n        type : Literal, the type of the security schema component\n        name : optional name of the security schema component\n        description : optional description of the security schema component\n        in_ : optional location of the security schema component\n        schema_ : optional schema of the security schema component\n        bearerFormat : optional bearer format of the security schema component\n        openIdConnectUrl : optional OpenID Connect URL of the security schema component\n        flows : optional OAuth flows of the security schema component\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    type: Literal[\n        \"userPassword\",\n        \"apikey\",\n        \"X509\",\n        \"symmetricEncryption\",\n        \"asymmetricEncryption\",\n        \"httpApiKey\",\n        \"http\",\n        \"oauth2\",\n        \"openIdConnect\",\n        \"plain\",\n        \"scramSha256\",\n        \"scramSha512\",\n        \"gssapi\",\n    ]\n    name: Optional[str] = None\n    description: Optional[str] = None\n    in_: Optional[str] = Field(\n        default=None,\n        alias=\"in\",\n    )\n    schema_: Optional[str] = Field(\n        default=None,\n        alias=\"schema\",\n    )\n    bearerFormat: Optional[str] = None\n    openIdConnectUrl: Optional[str] = None\n    flows: Optional[OauthFlows] = None\n\n    if PYDANTIC_V2:\n        model_config = {\"extra\": \"allow\"}\n\n    else:\n\n        class Config:\n            extra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/SecuritySchemaComponent/#faststream.asyncapi.schema.security.SecuritySchemaComponent.bearerFormat","title":"bearerFormat  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bearerFormat: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/SecuritySchemaComponent/#faststream.asyncapi.schema.security.SecuritySchemaComponent.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/SecuritySchemaComponent/#faststream.asyncapi.schema.security.SecuritySchemaComponent.flows","title":"flows  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>flows: Optional[OauthFlows] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/SecuritySchemaComponent/#faststream.asyncapi.schema.security.SecuritySchemaComponent.in_","title":"in_  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>in_: Optional[str] = Field(default=None, alias='in')\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/SecuritySchemaComponent/#faststream.asyncapi.schema.security.SecuritySchemaComponent.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = {'extra': 'allow'}\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/SecuritySchemaComponent/#faststream.asyncapi.schema.security.SecuritySchemaComponent.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/SecuritySchemaComponent/#faststream.asyncapi.schema.security.SecuritySchemaComponent.openIdConnectUrl","title":"openIdConnectUrl  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>openIdConnectUrl: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/SecuritySchemaComponent/#faststream.asyncapi.schema.security.SecuritySchemaComponent.schema_","title":"schema_  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>schema_: Optional[str] = Field(default=None, alias=\"schema\")\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/SecuritySchemaComponent/#faststream.asyncapi.schema.security.SecuritySchemaComponent.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: Literal[\n    \"userPassword\",\n    \"apikey\",\n    \"X509\",\n    \"symmetricEncryption\",\n    \"asymmetricEncryption\",\n    \"httpApiKey\",\n    \"http\",\n    \"oauth2\",\n    \"openIdConnect\",\n    \"plain\",\n    \"scramSha256\",\n    \"scramSha512\",\n    \"gssapi\",\n]\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/SecuritySchemaComponent/#faststream.asyncapi.schema.security.SecuritySchemaComponent.Config","title":"Config","text":"Source code in <code>faststream/asyncapi/schema/security.py</code> <pre><code>class Config:\n    extra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/SecuritySchemaComponent/#faststream.asyncapi.schema.security.SecuritySchemaComponent.Config.extra","title":"extra  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extra = 'allow'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/servers/Server/","title":"Server","text":""},{"location":"api/faststream/asyncapi/schema/servers/Server/#faststream.asyncapi.schema.servers.Server","title":"faststream.asyncapi.schema.servers.Server","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent a server.</p> Note <p>The attributes <code>description</code>, <code>protocolVersion</code>, <code>tags</code>, <code>security</code>, <code>variables</code>, and <code>bindings</code> are all optional.</p> Configurations <p>If <code>PYDANTIC_V2</code> is True, the model configuration is set to allow extra attributes. Otherwise, the <code>Config</code> class is defined with the <code>extra</code> attribute set to \"allow\".</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/asyncapi/schema/servers.py</code> <pre><code>class Server(BaseModel):\n    \"\"\"A class to represent a server.\n\n    Attributes:\n        url : URL of the server\n        protocol : protocol used by the server\n        description : optional description of the server\n        protocolVersion : optional version of the protocol used by the server\n        tags : optional list of tags associated with the server\n        security : optional security requirement for the server\n        variables : optional dictionary of server variables\n        bindings : optional server binding\n\n    Note:\n        The attributes `description`, `protocolVersion`, `tags`, `security`, `variables`, and `bindings` are all optional.\n\n    Configurations:\n        If `PYDANTIC_V2` is True, the model configuration is set to allow extra attributes.\n        Otherwise, the `Config` class is defined with the `extra` attribute set to \"allow\".\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    url: str\n    protocol: str\n    description: Optional[str] = None\n    protocolVersion: Optional[str] = None\n    tags: Optional[List[Union[Tag, TagDict, Dict[str, Any]]]] = None\n    security: Optional[SecurityRequirement] = None\n    variables: Optional[Dict[str, Union[ServerVariable, Reference]]] = None\n    bindings: Optional[Union[ServerBinding, Reference]] = None\n\n    if PYDANTIC_V2:\n        model_config = {\"extra\": \"allow\"}\n\n    else:\n\n        class Config:\n            extra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/servers/Server/#faststream.asyncapi.schema.servers.Server.bindings","title":"bindings  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bindings: Optional[Union[ServerBinding, Reference]] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/servers/Server/#faststream.asyncapi.schema.servers.Server.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/servers/Server/#faststream.asyncapi.schema.servers.Server.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = {'extra': 'allow'}\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/servers/Server/#faststream.asyncapi.schema.servers.Server.protocol","title":"protocol  <code>instance-attribute</code>","text":"<pre><code>protocol: str\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/servers/Server/#faststream.asyncapi.schema.servers.Server.protocolVersion","title":"protocolVersion  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>protocolVersion: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/servers/Server/#faststream.asyncapi.schema.servers.Server.security","title":"security  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>security: Optional[SecurityRequirement] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/servers/Server/#faststream.asyncapi.schema.servers.Server.tags","title":"tags  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tags: Optional[\n    List[Union[Tag, TagDict, Dict[str, Any]]]\n] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/servers/Server/#faststream.asyncapi.schema.servers.Server.url","title":"url  <code>instance-attribute</code>","text":"<pre><code>url: str\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/servers/Server/#faststream.asyncapi.schema.servers.Server.variables","title":"variables  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>variables: Optional[\n    Dict[str, Union[ServerVariable, Reference]]\n] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/servers/Server/#faststream.asyncapi.schema.servers.Server.Config","title":"Config","text":"Source code in <code>faststream/asyncapi/schema/servers.py</code> <pre><code>class Config:\n    extra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/servers/Server/#faststream.asyncapi.schema.servers.Server.Config.extra","title":"extra  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extra = 'allow'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/servers/ServerVariable/","title":"ServerVariable","text":""},{"location":"api/faststream/asyncapi/schema/servers/ServerVariable/#faststream.asyncapi.schema.servers.ServerVariable","title":"faststream.asyncapi.schema.servers.ServerVariable","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent a server variable.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/asyncapi/schema/servers.py</code> <pre><code>class ServerVariable(BaseModel):\n    \"\"\"A class to represent a server variable.\n\n    Attributes:\n        enum : list of possible values for the server variable (optional)\n        default : default value for the server variable (optional)\n        description : description of the server variable (optional)\n        examples : list of example values for the server variable (optional)\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    enum: Optional[List[str]] = None\n    default: Optional[str] = None\n    description: Optional[str] = None\n    examples: Optional[List[str]] = None\n\n    if PYDANTIC_V2:\n        model_config = {\"extra\": \"allow\"}\n\n    else:\n\n        class Config:\n            extra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/servers/ServerVariable/#faststream.asyncapi.schema.servers.ServerVariable.default","title":"default  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>default: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/servers/ServerVariable/#faststream.asyncapi.schema.servers.ServerVariable.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/servers/ServerVariable/#faststream.asyncapi.schema.servers.ServerVariable.enum","title":"enum  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>enum: Optional[List[str]] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/servers/ServerVariable/#faststream.asyncapi.schema.servers.ServerVariable.examples","title":"examples  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>examples: Optional[List[str]] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/servers/ServerVariable/#faststream.asyncapi.schema.servers.ServerVariable.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = {'extra': 'allow'}\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/servers/ServerVariable/#faststream.asyncapi.schema.servers.ServerVariable.Config","title":"Config","text":"Source code in <code>faststream/asyncapi/schema/servers.py</code> <pre><code>class Config:\n    extra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/servers/ServerVariable/#faststream.asyncapi.schema.servers.ServerVariable.Config.extra","title":"extra  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extra = 'allow'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/utils/ExternalDocs/","title":"ExternalDocs","text":""},{"location":"api/faststream/asyncapi/schema/utils/ExternalDocs/#faststream.asyncapi.schema.utils.ExternalDocs","title":"faststream.asyncapi.schema.utils.ExternalDocs","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent external documentation.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/asyncapi/schema/utils.py</code> <pre><code>class ExternalDocs(BaseModel):\n    \"\"\"A class to represent external documentation.\n\n    Attributes:\n        url : URL of the external documentation\n        description : optional description of the external documentation\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    url: AnyHttpUrl\n    description: Optional[str] = None\n\n    if PYDANTIC_V2:\n        model_config = {\"extra\": \"allow\"}\n\n    else:\n\n        class Config:\n            extra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/utils/ExternalDocs/#faststream.asyncapi.schema.utils.ExternalDocs.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/utils/ExternalDocs/#faststream.asyncapi.schema.utils.ExternalDocs.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = {'extra': 'allow'}\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/utils/ExternalDocs/#faststream.asyncapi.schema.utils.ExternalDocs.url","title":"url  <code>instance-attribute</code>","text":"<pre><code>url: AnyHttpUrl\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/utils/ExternalDocs/#faststream.asyncapi.schema.utils.ExternalDocs.Config","title":"Config","text":"Source code in <code>faststream/asyncapi/schema/utils.py</code> <pre><code>class Config:\n    extra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/utils/ExternalDocs/#faststream.asyncapi.schema.utils.ExternalDocs.Config.extra","title":"extra  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extra = 'allow'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/utils/ExternalDocsDict/","title":"ExternalDocsDict","text":""},{"location":"api/faststream/asyncapi/schema/utils/ExternalDocsDict/#faststream.asyncapi.schema.utils.ExternalDocsDict","title":"faststream.asyncapi.schema.utils.ExternalDocsDict","text":"<p>             Bases: <code>TypedDict</code></p> <p>A dictionary type for representing external documentation.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/asyncapi/schema/utils.py</code> <pre><code>class ExternalDocsDict(TypedDict, total=False):\n    \"\"\"A dictionary type for representing external documentation.\n\n    Attributes:\n        url : Required URL for the external documentation\n        description : Description of the external documentation\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    url: Required[AnyHttpUrl]\n    description: str\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/utils/ExternalDocsDict/#faststream.asyncapi.schema.utils.ExternalDocsDict.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description: str\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/utils/ExternalDocsDict/#faststream.asyncapi.schema.utils.ExternalDocsDict.url","title":"url  <code>instance-attribute</code>","text":"<pre><code>url: Required[AnyHttpUrl]\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/utils/Parameter/","title":"Parameter","text":""},{"location":"api/faststream/asyncapi/schema/utils/Parameter/#faststream.asyncapi.schema.utils.Parameter","title":"faststream.asyncapi.schema.utils.Parameter","text":"<p>             Bases: <code>BaseModel</code></p> Source code in <code>faststream/asyncapi/schema/utils.py</code> <pre><code>class Parameter(BaseModel):\n    # TODO\n    ...\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/utils/Reference/","title":"Reference","text":""},{"location":"api/faststream/asyncapi/schema/utils/Reference/#faststream.asyncapi.schema.utils.Reference","title":"faststream.asyncapi.schema.utils.Reference","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent a reference.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/asyncapi/schema/utils.py</code> <pre><code>class Reference(BaseModel):\n    \"\"\"A class to represent a reference.\n\n    Attributes:\n        ref : the reference string\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    ref: str = Field(..., alias=\"$ref\")\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/utils/Reference/#faststream.asyncapi.schema.utils.Reference.ref","title":"ref  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ref: str = Field(..., alias='$ref')\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/utils/Tag/","title":"Tag","text":""},{"location":"api/faststream/asyncapi/schema/utils/Tag/#faststream.asyncapi.schema.utils.Tag","title":"faststream.asyncapi.schema.utils.Tag","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent a tag.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/asyncapi/schema/utils.py</code> <pre><code>class Tag(BaseModel):\n    \"\"\"A class to represent a tag.\n\n    Attributes:\n        name : name of the tag\n        description : description of the tag (optional)\n        externalDocs : external documentation for the tag (optional)\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    name: str\n    description: Optional[str] = None\n    externalDocs: Optional[Union[ExternalDocs, ExternalDocsDict]] = None\n\n    if PYDANTIC_V2:\n        model_config = {\"extra\": \"allow\"}\n\n    else:\n\n        class Config:\n            extra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/utils/Tag/#faststream.asyncapi.schema.utils.Tag.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/utils/Tag/#faststream.asyncapi.schema.utils.Tag.externalDocs","title":"externalDocs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>externalDocs: Optional[\n    Union[ExternalDocs, ExternalDocsDict]\n] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/utils/Tag/#faststream.asyncapi.schema.utils.Tag.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = {'extra': 'allow'}\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/utils/Tag/#faststream.asyncapi.schema.utils.Tag.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/utils/Tag/#faststream.asyncapi.schema.utils.Tag.Config","title":"Config","text":"Source code in <code>faststream/asyncapi/schema/utils.py</code> <pre><code>class Config:\n    extra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/utils/Tag/#faststream.asyncapi.schema.utils.Tag.Config.extra","title":"extra  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extra = 'allow'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/utils/TagDict/","title":"TagDict","text":""},{"location":"api/faststream/asyncapi/schema/utils/TagDict/#faststream.asyncapi.schema.utils.TagDict","title":"faststream.asyncapi.schema.utils.TagDict","text":"<p>             Bases: <code>TypedDict</code></p> <p>A dictionary-like class for storing tags.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/asyncapi/schema/utils.py</code> <pre><code>class TagDict(TypedDict, total=False):\n    \"\"\"A dictionary-like class for storing tags.\n\n    Attributes:\n        name : required name of the tag\n        description : description of the tag\n        externalDocs : external documentation for the tag\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    name: Required[str]\n    description: str\n    externalDocs: Union[ExternalDocs, ExternalDocsDict]\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/utils/TagDict/#faststream.asyncapi.schema.utils.TagDict.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description: str\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/utils/TagDict/#faststream.asyncapi.schema.utils.TagDict.externalDocs","title":"externalDocs  <code>instance-attribute</code>","text":"<pre><code>externalDocs: Union[ExternalDocs, ExternalDocsDict]\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/utils/TagDict/#faststream.asyncapi.schema.utils.TagDict.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: Required[str]\n</code></pre>"},{"location":"api/faststream/asyncapi/site/get_asyncapi_html/","title":"Get asyncapi html","text":""},{"location":"api/faststream/asyncapi/site/get_asyncapi_html/#faststream.asyncapi.site.get_asyncapi_html","title":"faststream.asyncapi.site.get_asyncapi_html","text":"<pre><code>get_asyncapi_html(\n    schema: Schema,\n    sidebar: bool = True,\n    info: bool = True,\n    servers: bool = True,\n    operations: bool = True,\n    messages: bool = True,\n    schemas: bool = True,\n    errors: bool = True,\n    expand_message_examples: bool = True,\n    title: str = \"FastStream\",\n) -&gt; str\n</code></pre> <p>Generate HTML for displaying an AsyncAPI document.</p> PARAMETER  DESCRIPTION <code>schema</code> <p>The AsyncAPI schema object.</p> <p> TYPE: <code>Schema</code> </p> <code>sidebar</code> <p>Whether to show the sidebar. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>info</code> <p>Whether to show the info section. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>servers</code> <p>Whether to show the servers section. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>operations</code> <p>Whether to show the operations section. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>messages</code> <p>Whether to show the messages section. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>schemas</code> <p>Whether to show the schemas section. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>errors</code> <p>Whether to show the errors section. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>expand_message_examples</code> <p>Whether to expand message examples. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>title</code> <p>The title of the HTML document. Defaults to \"FastStream\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'FastStream'</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The generated HTML document.</p> <p> TYPE: <code>str</code> </p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>If silent animals are not supported.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/asyncapi/site.py</code> <pre><code>def get_asyncapi_html(\n    schema: \"Schema\",\n    sidebar: bool = True,\n    info: bool = True,\n    servers: bool = True,\n    operations: bool = True,\n    messages: bool = True,\n    schemas: bool = True,\n    errors: bool = True,\n    expand_message_examples: bool = True,\n    title: str = \"FastStream\",\n) -&gt; str:\n    \"\"\"Generate HTML for displaying an AsyncAPI document.\n\n    Args:\n        schema (Schema): The AsyncAPI schema object.\n        sidebar (bool, optional): Whether to show the sidebar. Defaults to True.\n        info (bool, optional): Whether to show the info section. Defaults to True.\n        servers (bool, optional): Whether to show the servers section. Defaults to True.\n        operations (bool, optional): Whether to show the operations section. Defaults to True.\n        messages (bool, optional): Whether to show the messages section. Defaults to True.\n        schemas (bool, optional): Whether to show the schemas section. Defaults to True.\n        errors (bool, optional): Whether to show the errors section. Defaults to True.\n        expand_message_examples (bool, optional): Whether to expand message examples. Defaults to True.\n        title (str, optional): The title of the HTML document. Defaults to \"FastStream\".\n\n    Returns:\n        str: The generated HTML document.\n\n    Raises:\n        NotImplementedError: If silent animals are not supported.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    schema_json = schema.to_json()\n\n    config = {\n        \"schema\": schema_json,\n        \"config\": {\n            \"show\": {\n                \"sidebar\": sidebar,\n                \"info\": info,\n                \"servers\": servers,\n                \"operations\": operations,\n                \"messages\": messages,\n                \"schemas\": schemas,\n                \"errors\": errors,\n            },\n            \"expand\": {\n                \"messageExamples\": expand_message_examples,\n            },\n            \"sidebar\": {\n                \"showServers\": \"byDefault\",\n                \"showOperations\": \"byDefault\",\n            },\n        },\n    }\n\n    return (\n        \"\"\"\n    &lt;!DOCTYPE html&gt;\n    &lt;html&gt;\n        &lt;head&gt;\n    \"\"\"\n        f\"\"\"\n        &lt;title&gt;{title} AsyncAPI&lt;/title&gt;\n    \"\"\"\n        \"\"\"\n        &lt;link rel=\"icon\" href=\"https://www.asyncapi.com/favicon.ico\"&gt;\n        &lt;link rel=\"icon\" type=\"image/png\" sizes=\"16x16\" href=\"https://www.asyncapi.com/favicon-16x16.png\"&gt;\n        &lt;link rel=\"icon\" type=\"image/png\" sizes=\"32x32\" href=\"https://www.asyncapi.com/favicon-32x32.png\"&gt;\n        &lt;link rel=\"icon\" type=\"image/png\" sizes=\"194x194\" href=\"https://www.asyncapi.com/favicon-194x194.png\"&gt;\n        &lt;link rel=\"stylesheet\" href=\"https://unpkg.com/@asyncapi/react-component@1.0.0-next.46/styles/default.min.css\"&gt;\n        &lt;/head&gt;\n\n        &lt;style&gt;\n        html {\n            font-family: ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;\n            line-height: 1.5;\n        }\n        &lt;/style&gt;\n\n        &lt;body&gt;\n        &lt;div id=\"asyncapi\"&gt;&lt;/div&gt;\n\n        &lt;script src=\"https://unpkg.com/@asyncapi/react-component@1.0.0-next.47/browser/standalone/index.js\"&gt;&lt;/script&gt;\n        &lt;script&gt;\n    \"\"\"\n        f\"\"\"\n            AsyncApiStandalone.render({json.dumps(config)}, document.getElementById('asyncapi'));\n    \"\"\"\n        \"\"\"\n        &lt;/script&gt;\n        &lt;/body&gt;\n    &lt;/html&gt;\n    \"\"\"\n    )\n</code></pre>"},{"location":"api/faststream/asyncapi/site/serve_app/","title":"Serve app","text":""},{"location":"api/faststream/asyncapi/site/serve_app/#faststream.asyncapi.site.serve_app","title":"faststream.asyncapi.site.serve_app","text":"<pre><code>serve_app(schema: Schema, host: str, port: int) -&gt; None\n</code></pre> <p>Serve the FastAPI application.</p> PARAMETER  DESCRIPTION <code>schema</code> <p>The schema object representing the API specification.</p> <p> TYPE: <code>Schema</code> </p> <code>host</code> <p>The host address to run the application on.</p> <p> TYPE: <code>str</code> </p> <code>port</code> <p>The port number to run the application on.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/asyncapi/site.py</code> <pre><code>def serve_app(\n    schema: \"Schema\",\n    host: str,\n    port: int,\n) -&gt; None:\n    \"\"\"Serve the FastAPI application.\n\n    Args:\n        schema: The schema object representing the API specification.\n        host: The host address to run the application on.\n        port: The port number to run the application on.\n\n    Returns:\n        None\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    import uvicorn\n    from fastapi import FastAPI\n    from fastapi.responses import HTMLResponse\n\n    app = FastAPI()\n\n    @app.get(\"/\")\n    def asyncapi(\n        sidebar: bool = True,\n        info: bool = True,\n        servers: bool = True,\n        operations: bool = True,\n        messages: bool = True,\n        schemas: bool = True,\n        errors: bool = True,\n        expandMessageExamples: bool = True,\n    ) -&gt; HTMLResponse:\n        \"\"\"Generate an AsyncAPI HTML response.\n\n        Args:\n            sidebar (bool): Whether to include the sidebar. Default is True.\n            info (bool): Whether to include the info section. Default is True.\n            servers (bool): Whether to include the servers section. Default is True.\n            operations (bool): Whether to include the operations section. Default is True.\n            messages (bool): Whether to include the messages section. Default is True.\n            schemas (bool): Whether to include the schemas section. Default is True.\n            errors (bool): Whether to include the errors section. Default is True.\n            expandMessageExamples (bool): Whether to expand message examples. Default is True.\n\n        Returns:\n            HTMLResponse: The generated HTML response.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        return HTMLResponse(\n            content=get_asyncapi_html(\n                schema,\n                sidebar=sidebar,\n                info=info,\n                servers=servers,\n                operations=operations,\n                messages=messages,\n                schemas=schemas,\n                errors=errors,\n                expand_message_examples=expandMessageExamples,\n                title=schema.info.title,\n            )\n        )\n\n    uvicorn.run(app, host=host, port=port)\n</code></pre>"},{"location":"api/faststream/asyncapi/utils/resolve_payloads/","title":"Resolve payloads","text":""},{"location":"api/faststream/asyncapi/utils/resolve_payloads/#faststream.asyncapi.utils.resolve_payloads","title":"faststream.asyncapi.utils.resolve_payloads","text":"<pre><code>resolve_payloads(payloads: List[AnyDict]) -&gt; AnyDict\n</code></pre> <p>Resolve payloads.</p> PARAMETER  DESCRIPTION <code>payloads</code> <p>A list of dictionaries representing payloads.</p> <p> TYPE: <code>List[AnyDict]</code> </p> RETURNS DESCRIPTION <code>AnyDict</code> <p>A dictionary representing the resolved payload.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/asyncapi/utils.py</code> <pre><code>def resolve_payloads(payloads: List[AnyDict]) -&gt; AnyDict:\n    \"\"\"Resolve payloads.\n\n    Args:\n        payloads: A list of dictionaries representing payloads.\n\n    Returns:\n        A dictionary representing the resolved payload.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    ln = len(payloads)\n    payload: AnyDict\n    if ln &gt; 1:\n        payload = {\"oneOf\": {body[\"title\"]: body for body in payloads}}\n    elif ln == 1:\n        payload = payloads[0]\n    else:\n        payload = {}\n    return payload\n</code></pre>"},{"location":"api/faststream/asyncapi/utils/to_camelcase/","title":"To camelcase","text":""},{"location":"api/faststream/asyncapi/utils/to_camelcase/#faststream.asyncapi.utils.to_camelcase","title":"faststream.asyncapi.utils.to_camelcase","text":"<pre><code>to_camelcase(*names: str) -&gt; str\n</code></pre> <p>Converts a list of names to camel case.</p> PARAMETER  DESCRIPTION <code>*names</code> <p>Variable length list of names to be converted to camel case.</p> <p> TYPE: <code>str</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The camel case representation of the names.</p> Example <p>to_camelcase(\"hello_world\") \"HelloWorld\"</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/asyncapi/utils.py</code> <pre><code>def to_camelcase(*names: str) -&gt; str:\n    \"\"\"Converts a list of names to camel case.\n\n    Args:\n        *names: Variable length list of names to be converted to camel case.\n\n    Returns:\n        The camel case representation of the names.\n\n    Example:\n        &gt;&gt;&gt; to_camelcase(\"hello_world\")\n        \"HelloWorld\"\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    return \" \".join(names).replace(\"_\", \" \").title().replace(\" \", \"\")\n</code></pre>"},{"location":"api/faststream/broker/core/abc/BrokerUsecase/","title":"BrokerUsecase","text":""},{"location":"api/faststream/broker/core/abc/BrokerUsecase/#faststream.broker.core.abc.BrokerUsecase","title":"faststream.broker.core.abc.BrokerUsecase","text":"<p>             Bases: <code>ABC</code>, <code>Generic[MsgType, ConnectionType]</code>, <code>LoggingMixin</code></p> <p>A class representing a broker use case.</p> METHOD DESCRIPTION <code>__init__ </code> <p>constructor method</p> <code>include_router </code> <p>include a router in the broker</p> <code>include_routers </code> <p>include multiple routers in the broker</p> <code>_resolve_connection_kwargs </code> <p>resolve connection kwargs</p> <code>_wrap_handler </code> <p>wrap a handler function</p> <code>_abc_start </code> <p>start the broker</p> <code>_abc_close </code> <p>close the broker</p> <code>_abc__close </code> <p>close the broker connection</p> <code>_process_message </code> <p>process a message</p> <code>subscriber </code> <p>decorator to register a subscriber</p> <code>publisher </code> <p>register a publisher</p> <code>_wrap_decode_message </code> <p>wrap a message decoding function</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/core/abc.py</code> <pre><code>class BrokerUsecase(\n    ABC,\n    Generic[MsgType, ConnectionType],\n    LoggingMixin,\n):\n    \"\"\"A class representing a broker use case.\n\n    Attributes:\n        logger : optional logger object\n        log_level : log level\n        handlers : dictionary of handlers\n        _publishers : dictionary of publishers\n        dependencies : sequence of dependencies\n        started : boolean indicating if the broker has started\n        middlewares : sequence of middleware functions\n        _global_parser : optional custom parser object\n        _global_decoder : optional custom decoder object\n        _connection : optional connection object\n        _fmt : optional string format\n\n    Methods:\n        __init__ : constructor method\n        include_router : include a router in the broker\n        include_routers : include multiple routers in the broker\n        _resolve_connection_kwargs : resolve connection kwargs\n        _wrap_handler : wrap a handler function\n        _abc_start : start the broker\n        _abc_close : close the broker\n        _abc__close : close the broker connection\n        _process_message : process a message\n        subscriber : decorator to register a subscriber\n        publisher : register a publisher\n        _wrap_decode_message : wrap a message decoding function\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    logger: Optional[logging.Logger]\n    log_level: int\n    handlers: Dict[Any, BaseHandler[MsgType]]\n    _publishers: Dict[Any, BasePublisher[MsgType]]\n\n    dependencies: Sequence[Depends]\n    started: bool\n    middlewares: Sequence[Callable[[Any], BaseMiddleware]]\n    _global_parser: Optional[CustomParser[MsgType, StreamMessage[MsgType]]]\n    _global_decoder: Optional[CustomDecoder[StreamMessage[MsgType]]]\n    _connection: Optional[ConnectionType]\n    _fmt: Optional[str]\n\n    def __init__(\n        self,\n        url: Union[str, List[str]],\n        *args: Any,\n        # AsyncAPI kwargs\n        protocol: str,\n        protocol_version: Optional[str] = None,\n        description: Optional[str] = None,\n        tags: Optional[Sequence[Union[asyncapi.Tag, asyncapi.TagDict]]] = None,\n        # broker kwargs\n        apply_types: bool = True,\n        logger: Optional[logging.Logger] = access_logger,\n        log_level: int = logging.INFO,\n        log_fmt: Optional[str] = \"%(asctime)s %(levelname)s - %(message)s\",\n        dependencies: Sequence[Depends] = (),\n        middlewares: Optional[Sequence[Callable[[MsgType], BaseMiddleware]]] = None,\n        decoder: Optional[CustomDecoder[StreamMessage[MsgType]]] = None,\n        parser: Optional[CustomParser[MsgType, StreamMessage[MsgType]]] = None,\n        security: Optional[BaseSecurity] = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"Initialize a broker.\n\n        Args:\n            url: The URL or list of URLs to connect to.\n            *args: Additional arguments.\n            protocol: The protocol to use for the connection.\n            protocol_version: The version of the protocol.\n            description: A description of the broker.\n            tags: Tags associated with the broker.\n            apply_types: Whether to apply types to messages.\n            logger: The logger to use.\n            log_level: The log level to use.\n            log_fmt: The log format to use.\n            dependencies: Dependencies of the broker.\n            middlewares: Middlewares to use.\n            decoder: Custom decoder for messages.\n            parser: Custom parser for messages.\n            **kwargs: Additional keyword arguments.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        super().__init__(\n            logger=logger,\n            log_level=log_level,\n            log_fmt=log_fmt,\n        )\n\n        self._connection = None\n        self._is_apply_types = apply_types\n        self.handlers = {}\n        self._publishers = {}\n        empty_middleware: Sequence[Callable[[MsgType], BaseMiddleware]] = ()\n        midd_args: Sequence[Callable[[MsgType], BaseMiddleware]] = (\n            middlewares or empty_middleware\n        )\n        self.middlewares = [CriticalLogMiddleware(logger, log_level), *midd_args]\n        self.dependencies = dependencies\n\n        self._connection_args = (url, *args)\n        self._connection_kwargs = kwargs\n\n        self._global_parser = parser\n        self._global_decoder = decoder\n\n        context.set_global(\"logger\", logger)\n        context.set_global(\"broker\", self)\n\n        self.started = False\n\n        # AsyncAPI information\n        self.url = url\n        self.protocol = protocol\n        self.protocol_version = protocol_version\n        self.description = description\n        self.tags = tags\n        self.security = security\n\n    def include_router(self, router: BrokerRouter[Any, MsgType]) -&gt; None:\n        \"\"\"Includes a router in the current object.\n\n        Args:\n            router: The router to be included.\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        for r in router._handlers:\n            self.subscriber(*r.args, **r.kwargs)(r.call)\n\n        self._publishers.update(router._publishers)\n\n    def include_routers(self, *routers: BrokerRouter[Any, MsgType]) -&gt; None:\n        \"\"\"Includes routers in the current object.\n\n        Args:\n            *routers: Variable length argument list of routers to include.\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        for r in routers:\n            self.include_router(r)\n\n    def _resolve_connection_kwargs(self, *args: Any, **kwargs: Any) -&gt; AnyDict:\n        \"\"\"Resolve connection keyword arguments.\n\n        Args:\n            *args: Positional arguments passed to the function.\n            **kwargs: Keyword arguments passed to the function.\n\n        Returns:\n            A dictionary containing the resolved connection keyword arguments.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        arguments = get_function_positional_arguments(self.__init__)  # type: ignore\n        init_kwargs = {\n            **self._connection_kwargs,\n            **dict(zip(arguments, self._connection_args)),\n        }\n\n        connect_kwargs = {\n            **kwargs,\n            **dict(zip(arguments, args)),\n        }\n        return {**init_kwargs, **connect_kwargs}\n\n    def _wrap_handler(\n        self,\n        func: Union[\n            HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn],\n            Callable[P_HandlerParams, T_HandlerReturn],\n        ],\n        *,\n        retry: Union[bool, int] = False,\n        extra_dependencies: Sequence[Depends] = (),\n        _raw: bool = False,\n        _get_dependant: Optional[Any] = None,\n    ) -&gt; Tuple[\n        HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn],\n        Union[\n            CallModel[P_HandlerParams, T_HandlerReturn],\n            CallModel[P_HandlerParams, Awaitable[T_HandlerReturn]],\n        ],\n    ]:\n        \"\"\"Wrap a handler function.\n\n        Args:\n            func: The handler function to wrap.\n            retry: Whether to retry the handler function if it fails. Can be a boolean or an integer specifying the number of retries.\n            extra_dependencies: Additional dependencies for the handler function.\n            _raw: Whether to use the raw handler function.\n            _get_dependant: The dependant function to use.\n            **broker_log_context_kwargs: Additional keyword arguments for the broker log context.\n\n        Returns:\n            A tuple containing the wrapped handler function and the call model.\n\n        Raises:\n            NotImplementedError: If silent animals are not supported.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        build_dep = cast(\n            Callable[[Callable[F_Spec, F_Return]], CallModel[F_Spec, F_Return]],\n            _get_dependant or build_call_model,\n        )\n\n        if isinstance(func, HandlerCallWrapper):\n            handler_call, func = func, func._original_call\n            if handler_call._wrapped_call is not None:\n                return handler_call, build_dep(func)\n        else:\n            handler_call = HandlerCallWrapper(func)\n\n        f = to_async(func)\n\n        dependant = build_dep(f)\n\n        extra = [\n            build_dep(d.dependency)\n            for d in chain(extra_dependencies, self.dependencies)\n        ]\n\n        extend_dependencies(extra, dependant)\n\n        if getattr(dependant, \"flat_params\", None) is None:  # handle FastAPI Dependant\n            dependant = _patch_fastapi_dependant(dependant)\n\n        if self._is_apply_types is True:\n            apply_wrapper: _InjectWrapper[\n                P_HandlerParams, Awaitable[T_HandlerReturn]\n            ] = apply_types(None)\n            f = apply_wrapper(f, dependant)\n\n        decode_f = self._wrap_decode_message(\n            func=f,\n            _raw=_raw,\n            params=set(\n                chain(\n                    dependant.flat_params.keys(), *(d.flat_params.keys() for d in extra)\n                )\n            ),\n        )\n\n        process_f = self._process_message(\n            func=decode_f,\n            watcher=get_watcher(self.logger, retry),\n        )\n\n        process_f = set_message_context(process_f)\n\n        handler_call.set_wrapped(process_f)\n        return handler_call, dependant\n\n    def _abc_start(self) -&gt; None:\n        self.started = True\n\n        for h in self.handlers.values():\n            h.global_middlewares = (*self.middlewares, *h.global_middlewares)\n\n        if self.logger is not None:\n            change_logger_handlers(self.logger, self.fmt)\n\n    def _abc_close(\n        self,\n        exc_type: Optional[Type[BaseException]] = None,\n        exc_val: Optional[BaseException] = None,\n        exec_tb: Optional[TracebackType] = None,\n    ) -&gt; None:\n        \"\"\"Closes the ABC.\n\n        Args:\n            exc_type: The exception type\n            exc_val: The exception value\n            exec_tb: The traceback\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        self.started = False\n\n    def _abc__close(\n        self,\n        exc_type: Optional[Type[BaseException]] = None,\n        exc_val: Optional[BaseException] = None,\n        exec_tb: Optional[TracebackType] = None,\n    ) -&gt; None:\n        \"\"\"Closes the connection.\n\n        Args:\n            exc_type: The type of the exception being handled (optional)\n            exc_val: The exception instance being handled (optional)\n            exec_tb: The traceback for the exception being handled (optional)\n\n        Returns:\n            None\n\n        Note:\n            This is an abstract method and must be implemented by subclasses.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        self._connection = None\n\n    @abstractmethod\n    def _process_message(\n        self,\n        func: Callable[[StreamMessage[MsgType]], Awaitable[T_HandlerReturn]],\n        watcher: BaseWatcher,\n    ) -&gt; Callable[[StreamMessage[MsgType]], Awaitable[WrappedReturn[T_HandlerReturn]],]:\n        \"\"\"Processes a message using a given function and watcher.\n\n        Args:\n            func: A callable that takes a StreamMessage of type MsgType and returns an Awaitable of type T_HandlerReturn.\n            watcher: An instance of BaseWatcher.\n\n        Returns:\n            A callable that takes a StreamMessage of type MsgType and returns an Awaitable of type WrappedReturn[T_HandlerReturn].\n\n        Raises:\n            NotImplementedError: If the method is not implemented.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        raise NotImplementedError()\n\n    @abstractmethod\n    def subscriber(  # type: ignore[return]\n        self,\n        *broker_args: Any,\n        retry: Union[bool, int] = False,\n        dependencies: Sequence[Depends] = (),\n        decoder: Optional[CustomDecoder[StreamMessage[MsgType]]] = None,\n        parser: Optional[CustomParser[MsgType, StreamMessage[MsgType]]] = None,\n        middlewares: Optional[\n            Sequence[\n                Callable[\n                    [StreamMessage[MsgType]],\n                    BaseMiddleware,\n                ]\n            ]\n        ] = None,\n        filter: Filter[StreamMessage[MsgType]] = lambda m: not m.processed,\n        _raw: bool = False,\n        _get_dependant: Optional[Any] = None,\n        **broker_kwargs: Any,\n    ) -&gt; Callable[\n        [\n            Union[\n                Callable[P_HandlerParams, T_HandlerReturn],\n                HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn],\n            ]\n        ],\n        HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn],\n    ]:\n        \"\"\"This is a function decorator for subscribing to a message broker.\n\n        Args:\n            *broker_args: Positional arguments to be passed to the broker.\n            retry: Whether to retry the subscription if it fails. Can be a boolean or an integer specifying the number of retries.\n            dependencies: Sequence of dependencies to be injected into the handler function.\n            decoder: Custom decoder function to decode the message.\n            parser: Custom parser function to parse the decoded message.\n            middlewares: Sequence of middleware functions to be applied to the message.\n            filter: Filter function to filter the messages to be processed.\n            _raw: Whether to return the raw message instead of the processed message.\n            _get_dependant: Optional parameter to get the dependant object.\n            **broker_kwargs: Keyword arguments to be passed to the broker.\n\n        Returns:\n            A callable object that can be used as a decorator for a handler function.\n\n        Raises:\n            RuntimeWarning: If the broker is already running.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        if self.started:\n            warnings.warn(\n                \"You are trying to register `handler` with already running broker\\n\"  # noqa: E501\n                \"It has no effect until broker restarting.\",  # noqa: E501\n                category=RuntimeWarning,\n                stacklevel=1,\n            )\n\n    @abstractmethod\n    def publisher(\n        self,\n        key: Any,\n        publisher: BasePublisher[MsgType],\n    ) -&gt; BasePublisher[MsgType]:\n        \"\"\"Publishes a publisher.\n\n        Args:\n            key: The key associated with the publisher.\n            publisher: The publisher to be published.\n\n        Returns:\n            The published publisher.\n\n        Raises:\n            NotImplementedError: If the method is not implemented.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        self._publishers[key] = publisher\n        return publisher\n\n    @abstractmethod\n    def _wrap_decode_message(\n        self,\n        func: Callable[..., Awaitable[T_HandlerReturn]],\n        params: Sized = (),\n        _raw: bool = False,\n    ) -&gt; Callable[[StreamMessage[MsgType]], Awaitable[T_HandlerReturn]]:\n        \"\"\"Wrap a decoding message function.\n\n        Args:\n            func: The function to wrap.\n            params: The parameters to pass to the function.\n            _raw: Whether to return the raw message or not.\n\n        Returns:\n            The wrapped function.\n\n        Raises:\n            NotImplementedError: If the method is not implemented.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        raise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/broker/core/abc/BrokerUsecase/#faststream.broker.core.abc.BrokerUsecase.dependencies","title":"dependencies  <code>instance-attribute</code>","text":"<pre><code>dependencies: Sequence[Depends] = dependencies\n</code></pre>"},{"location":"api/faststream/broker/core/abc/BrokerUsecase/#faststream.broker.core.abc.BrokerUsecase.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description = description\n</code></pre>"},{"location":"api/faststream/broker/core/abc/BrokerUsecase/#faststream.broker.core.abc.BrokerUsecase.handlers","title":"handlers  <code>instance-attribute</code>","text":"<pre><code>handlers: Dict[Any, BaseHandler[MsgType]] = {}\n</code></pre>"},{"location":"api/faststream/broker/core/abc/BrokerUsecase/#faststream.broker.core.abc.BrokerUsecase.log_level","title":"log_level  <code>instance-attribute</code>","text":"<pre><code>log_level: int\n</code></pre>"},{"location":"api/faststream/broker/core/abc/BrokerUsecase/#faststream.broker.core.abc.BrokerUsecase.logger","title":"logger  <code>instance-attribute</code>","text":"<pre><code>logger: Optional[logging.Logger]\n</code></pre>"},{"location":"api/faststream/broker/core/abc/BrokerUsecase/#faststream.broker.core.abc.BrokerUsecase.middlewares","title":"middlewares  <code>instance-attribute</code>","text":"<pre><code>middlewares: Sequence[Callable[[Any], BaseMiddleware]] = [\n    CriticalLogMiddleware(logger, log_level),\n    *midd_args,\n]\n</code></pre>"},{"location":"api/faststream/broker/core/abc/BrokerUsecase/#faststream.broker.core.abc.BrokerUsecase.protocol","title":"protocol  <code>instance-attribute</code>","text":"<pre><code>protocol = protocol\n</code></pre>"},{"location":"api/faststream/broker/core/abc/BrokerUsecase/#faststream.broker.core.abc.BrokerUsecase.protocol_version","title":"protocol_version  <code>instance-attribute</code>","text":"<pre><code>protocol_version = protocol_version\n</code></pre>"},{"location":"api/faststream/broker/core/abc/BrokerUsecase/#faststream.broker.core.abc.BrokerUsecase.security","title":"security  <code>instance-attribute</code>","text":"<pre><code>security = security\n</code></pre>"},{"location":"api/faststream/broker/core/abc/BrokerUsecase/#faststream.broker.core.abc.BrokerUsecase.started","title":"started  <code>instance-attribute</code>","text":"<pre><code>started: bool = False\n</code></pre>"},{"location":"api/faststream/broker/core/abc/BrokerUsecase/#faststream.broker.core.abc.BrokerUsecase.tags","title":"tags  <code>instance-attribute</code>","text":"<pre><code>tags = tags\n</code></pre>"},{"location":"api/faststream/broker/core/abc/BrokerUsecase/#faststream.broker.core.abc.BrokerUsecase.url","title":"url  <code>instance-attribute</code>","text":"<pre><code>url = url\n</code></pre>"},{"location":"api/faststream/broker/core/abc/BrokerUsecase/#faststream.broker.core.abc.BrokerUsecase.include_router","title":"include_router","text":"<pre><code>include_router(router: BrokerRouter[Any, MsgType]) -&gt; None\n</code></pre> <p>Includes a router in the current object.</p> PARAMETER  DESCRIPTION <code>router</code> <p>The router to be included.</p> <p> TYPE: <code>BrokerRouter[Any, MsgType]</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/core/abc.py</code> <pre><code>def include_router(self, router: BrokerRouter[Any, MsgType]) -&gt; None:\n    \"\"\"Includes a router in the current object.\n\n    Args:\n        router: The router to be included.\n\n    Returns:\n        None\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    for r in router._handlers:\n        self.subscriber(*r.args, **r.kwargs)(r.call)\n\n    self._publishers.update(router._publishers)\n</code></pre>"},{"location":"api/faststream/broker/core/abc/BrokerUsecase/#faststream.broker.core.abc.BrokerUsecase.include_routers","title":"include_routers","text":"<pre><code>include_routers(\n    *routers: BrokerRouter[Any, MsgType]\n) -&gt; None\n</code></pre> <p>Includes routers in the current object.</p> PARAMETER  DESCRIPTION <code>*routers</code> <p>Variable length argument list of routers to include.</p> <p> TYPE: <code>BrokerRouter[Any, MsgType]</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/core/abc.py</code> <pre><code>def include_routers(self, *routers: BrokerRouter[Any, MsgType]) -&gt; None:\n    \"\"\"Includes routers in the current object.\n\n    Args:\n        *routers: Variable length argument list of routers to include.\n\n    Returns:\n        None\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    for r in routers:\n        self.include_router(r)\n</code></pre>"},{"location":"api/faststream/broker/core/abc/BrokerUsecase/#faststream.broker.core.abc.BrokerUsecase.publisher","title":"publisher  <code>abstractmethod</code>","text":"<pre><code>publisher(\n    key: Any, publisher: BasePublisher[MsgType]\n) -&gt; BasePublisher[MsgType]\n</code></pre> <p>Publishes a publisher.</p> PARAMETER  DESCRIPTION <code>key</code> <p>The key associated with the publisher.</p> <p> TYPE: <code>Any</code> </p> <code>publisher</code> <p>The publisher to be published.</p> <p> TYPE: <code>BasePublisher[MsgType]</code> </p> RETURNS DESCRIPTION <code>BasePublisher[MsgType]</code> <p>The published publisher.</p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>If the method is not implemented.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/core/abc.py</code> <pre><code>@abstractmethod\ndef publisher(\n    self,\n    key: Any,\n    publisher: BasePublisher[MsgType],\n) -&gt; BasePublisher[MsgType]:\n    \"\"\"Publishes a publisher.\n\n    Args:\n        key: The key associated with the publisher.\n        publisher: The publisher to be published.\n\n    Returns:\n        The published publisher.\n\n    Raises:\n        NotImplementedError: If the method is not implemented.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    self._publishers[key] = publisher\n    return publisher\n</code></pre>"},{"location":"api/faststream/broker/core/abc/BrokerUsecase/#faststream.broker.core.abc.BrokerUsecase.subscriber","title":"subscriber  <code>abstractmethod</code>","text":"<pre><code>subscriber(\n    *broker_args: Any,\n    retry: Union[bool, int] = False,\n    dependencies: Sequence[Depends] = (),\n    decoder: Optional[\n        CustomDecoder[StreamMessage[MsgType]]\n    ] = None,\n    parser: Optional[\n        CustomParser[MsgType, StreamMessage[MsgType]]\n    ] = None,\n    middlewares: Optional[\n        Sequence[\n            Callable[\n                [StreamMessage[MsgType]], BaseMiddleware\n            ]\n        ]\n    ] = None,\n    filter: Filter[\n        StreamMessage[MsgType]\n    ] = lambda: not m.processed,\n    _raw: bool = False,\n    _get_dependant: Optional[Any] = None,\n    **broker_kwargs: Any\n) -&gt; Callable[\n    [\n        Union[\n            Callable[P_HandlerParams, T_HandlerReturn],\n            HandlerCallWrapper[\n                MsgType, P_HandlerParams, T_HandlerReturn\n            ],\n        ]\n    ],\n    HandlerCallWrapper[\n        MsgType, P_HandlerParams, T_HandlerReturn\n    ],\n]\n</code></pre> <p>This is a function decorator for subscribing to a message broker.</p> PARAMETER  DESCRIPTION <code>*broker_args</code> <p>Positional arguments to be passed to the broker.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>()</code> </p> <code>retry</code> <p>Whether to retry the subscription if it fails. Can be a boolean or an integer specifying the number of retries.</p> <p> TYPE: <code>Union[bool, int]</code> DEFAULT: <code>False</code> </p> <code>dependencies</code> <p>Sequence of dependencies to be injected into the handler function.</p> <p> TYPE: <code>Sequence[Depends]</code> DEFAULT: <code>()</code> </p> <code>decoder</code> <p>Custom decoder function to decode the message.</p> <p> TYPE: <code>Optional[CustomDecoder[StreamMessage[MsgType]]]</code> DEFAULT: <code>None</code> </p> <code>parser</code> <p>Custom parser function to parse the decoded message.</p> <p> TYPE: <code>Optional[CustomParser[MsgType, StreamMessage[MsgType]]]</code> DEFAULT: <code>None</code> </p> <code>middlewares</code> <p>Sequence of middleware functions to be applied to the message.</p> <p> TYPE: <code>Optional[Sequence[Callable[[StreamMessage[MsgType]], BaseMiddleware]]]</code> DEFAULT: <code>None</code> </p> <code>filter</code> <p>Filter function to filter the messages to be processed.</p> <p> TYPE: <code>Filter[StreamMessage[MsgType]]</code> DEFAULT: <code>lambda : not processed</code> </p> <code>_raw</code> <p>Whether to return the raw message instead of the processed message.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>_get_dependant</code> <p>Optional parameter to get the dependant object.</p> <p> TYPE: <code>Optional[Any]</code> DEFAULT: <code>None</code> </p> <code>**broker_kwargs</code> <p>Keyword arguments to be passed to the broker.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Callable[[Union[Callable[P_HandlerParams, T_HandlerReturn], HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn]]], HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn]]</code> <p>A callable object that can be used as a decorator for a handler function.</p> RAISES DESCRIPTION <code>RuntimeWarning</code> <p>If the broker is already running.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/core/abc.py</code> <pre><code>@abstractmethod\ndef subscriber(  # type: ignore[return]\n    self,\n    *broker_args: Any,\n    retry: Union[bool, int] = False,\n    dependencies: Sequence[Depends] = (),\n    decoder: Optional[CustomDecoder[StreamMessage[MsgType]]] = None,\n    parser: Optional[CustomParser[MsgType, StreamMessage[MsgType]]] = None,\n    middlewares: Optional[\n        Sequence[\n            Callable[\n                [StreamMessage[MsgType]],\n                BaseMiddleware,\n            ]\n        ]\n    ] = None,\n    filter: Filter[StreamMessage[MsgType]] = lambda m: not m.processed,\n    _raw: bool = False,\n    _get_dependant: Optional[Any] = None,\n    **broker_kwargs: Any,\n) -&gt; Callable[\n    [\n        Union[\n            Callable[P_HandlerParams, T_HandlerReturn],\n            HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn],\n        ]\n    ],\n    HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn],\n]:\n    \"\"\"This is a function decorator for subscribing to a message broker.\n\n    Args:\n        *broker_args: Positional arguments to be passed to the broker.\n        retry: Whether to retry the subscription if it fails. Can be a boolean or an integer specifying the number of retries.\n        dependencies: Sequence of dependencies to be injected into the handler function.\n        decoder: Custom decoder function to decode the message.\n        parser: Custom parser function to parse the decoded message.\n        middlewares: Sequence of middleware functions to be applied to the message.\n        filter: Filter function to filter the messages to be processed.\n        _raw: Whether to return the raw message instead of the processed message.\n        _get_dependant: Optional parameter to get the dependant object.\n        **broker_kwargs: Keyword arguments to be passed to the broker.\n\n    Returns:\n        A callable object that can be used as a decorator for a handler function.\n\n    Raises:\n        RuntimeWarning: If the broker is already running.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    if self.started:\n        warnings.warn(\n            \"You are trying to register `handler` with already running broker\\n\"  # noqa: E501\n            \"It has no effect until broker restarting.\",  # noqa: E501\n            category=RuntimeWarning,\n            stacklevel=1,\n        )\n</code></pre>"},{"location":"api/faststream/broker/core/abc/extend_dependencies/","title":"Extend dependencies","text":""},{"location":"api/faststream/broker/core/abc/extend_dependencies/#faststream.broker.core.abc.extend_dependencies","title":"faststream.broker.core.abc.extend_dependencies","text":"<pre><code>extend_dependencies(\n    extra: Sequence[CallModel[Any, Any]],\n    dependant: CallModel[Any, Any],\n) -&gt; CallModel[Any, Any]\n</code></pre> <p>Extends the dependencies of a function or FastAPI dependency.</p> PARAMETER  DESCRIPTION <code>extra</code> <p>Additional dependencies to be added.</p> <p> TYPE: <code>Sequence[CallModel[Any, Any]]</code> </p> <code>dependant</code> <p>The function or FastAPI dependency whose dependencies will be extended.</p> <p> TYPE: <code>CallModel[Any, Any]</code> </p> RETURNS DESCRIPTION <code>CallModel[Any, Any]</code> <p>The updated function or FastAPI dependency.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/core/abc.py</code> <pre><code>def extend_dependencies(\n    extra: Sequence[CallModel[Any, Any]], dependant: CallModel[Any, Any]\n) -&gt; CallModel[Any, Any]:\n    \"\"\"Extends the dependencies of a function or FastAPI dependency.\n\n    Args:\n        extra: Additional dependencies to be added.\n        dependant: The function or FastAPI dependency whose dependencies will be extended.\n\n    Returns:\n        The updated function or FastAPI dependency.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    if isinstance(dependant, CallModel):\n        dependant.extra_dependencies = (*dependant.extra_dependencies, *extra)\n    else:  # FastAPI dependencies\n        dependant.dependencies.extend(extra)\n    return dependant\n</code></pre>"},{"location":"api/faststream/broker/core/asyncronous/BrokerAsyncUsecase/","title":"BrokerAsyncUsecase","text":""},{"location":"api/faststream/broker/core/asyncronous/BrokerAsyncUsecase/#faststream.broker.core.asyncronous.BrokerAsyncUsecase","title":"faststream.broker.core.asyncronous.BrokerAsyncUsecase","text":"<p>             Bases: <code>BrokerUsecase[MsgType, ConnectionType]</code></p> <p>A class representing a broker async usecase.</p> METHOD DESCRIPTION <code>start</code> <p>Abstract method to start the broker async usecase.</p> <code>_connect</code> <p>Any) : Abstract method to connect to the broker.</p> <code>_close</code> <p>Optional[Type[BaseException]] = None, exc_val: Optional[BaseException] = None, exec_tb: Optional[TracebackType] = None) : Abstract method to close the connection to the broker.</p> <code>close</code> <p>Optional[Type[BaseException]] = None, exc_val: Optional[BaseException] = None, exec_tb: Optional[TracebackType] = None) : Close the connection to the broker.</p> <code>_process_message</code> <p>Callable[[StreamMessage[MsgType]], Awaitable[T_HandlerReturn]], watcher: BaseWatcher) : Abstract method to process a message.</p> <code>publish</code> <p>SendableMessage, *args: Any, reply_to: str = \"\", rpc: bool = False, rpc_timeout: Optional[float]</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/core/asyncronous.py</code> <pre><code>class BrokerAsyncUsecase(BrokerUsecase[MsgType, ConnectionType]):\n    \"\"\"A class representing a broker async usecase.\n\n    Attributes:\n        handlers : A dictionary of handlers for different message types.\n        middlewares : A sequence of middleware functions.\n        _global_parser : An optional global parser for messages.\n        _global_decoder : An optional global decoder for messages.\n\n    Methods:\n        start() : Abstract method to start the broker async usecase.\n        _connect(**kwargs: Any) : Abstract method to connect to the broker.\n        _close(exc_type: Optional[Type[BaseException]] = None, exc_val: Optional[BaseException] = None, exec_tb: Optional[TracebackType] = None) : Abstract method to close the connection to the broker.\n        close(exc_type: Optional[Type[BaseException]] = None, exc_val: Optional[BaseException] = None, exec_tb: Optional[TracebackType] = None) : Close the connection to the broker.\n        _process_message(func: Callable[[StreamMessage[MsgType]], Awaitable[T_HandlerReturn]], watcher: BaseWatcher) : Abstract method to process a message.\n        publish(message: SendableMessage, *args: Any, reply_to: str = \"\", rpc: bool = False, rpc_timeout: Optional[float]\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    handlers: Dict[Any, AsyncHandler[MsgType]]  # type: ignore[assignment]\n    middlewares: Sequence[Callable[[MsgType], BaseMiddleware]]\n    _global_parser: Optional[AsyncCustomParser[MsgType, StreamMessage[MsgType]]]\n    _global_decoder: Optional[AsyncCustomDecoder[StreamMessage[MsgType]]]\n\n    @abstractmethod\n    async def start(self) -&gt; None:\n        super()._abc_start()\n        for h in self.handlers.values():\n            for f, _, _, _, _, _ in h.calls:\n                f.refresh(with_mock=False)\n        await self.connect()\n\n    @abstractmethod\n    async def _connect(self, **kwargs: Any) -&gt; ConnectionType:\n        \"\"\"Connect to a resource.\n\n        Args:\n            **kwargs: Additional keyword arguments for the connection.\n\n        Returns:\n            The connection object.\n\n        Raises:\n            NotImplementedError: If the method is not implemented.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        raise NotImplementedError()\n\n    @abstractmethod\n    async def _close(\n        self,\n        exc_type: Optional[Type[BaseException]] = None,\n        exc_val: Optional[BaseException] = None,\n        exec_tb: Optional[TracebackType] = None,\n    ) -&gt; None:\n        \"\"\"Close the object.\n\n        Args:\n            exc_type: Optional. The type of the exception.\n            exc_val: Optional. The exception value.\n            exec_tb: Optional. The traceback of the exception.\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        super()._abc__close(exc_type, exc_val, exec_tb)\n\n    async def close(\n        self,\n        exc_type: Optional[Type[BaseException]] = None,\n        exc_val: Optional[BaseException] = None,\n        exec_tb: Optional[TracebackType] = None,\n    ) -&gt; None:\n        \"\"\"Closes the object.\n\n        Args:\n            exc_type: The type of the exception being handled, if any.\n            exc_val: The exception instance being handled, if any.\n            exec_tb: The traceback of the exception being handled, if any.\n\n        Returns:\n            None\n\n        Raises:\n            NotImplementedError: If the method is not implemented.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        super()._abc_close(exc_type, exc_val, exec_tb)\n\n        for h in self.handlers.values():\n            await h.close()\n\n        if self._connection is not None:\n            await self._close(exc_type, exc_val, exec_tb)\n\n    @override\n    @abstractmethod\n    def _process_message(\n        self,\n        func: Callable[[StreamMessage[MsgType]], Awaitable[T_HandlerReturn]],\n        watcher: BaseWatcher,\n    ) -&gt; Callable[[StreamMessage[MsgType]], Awaitable[WrappedReturn[T_HandlerReturn]],]:\n        \"\"\"Process a message.\n\n        Args:\n            func: A callable function that takes a StreamMessage and returns an Awaitable\n            watcher: An instance of BaseWatcher\n\n        Returns:\n            A callable function that takes a StreamMessage and returns an Awaitable\n\n        Raises:\n            NotImplementedError: If the method is not implemented\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        raise NotImplementedError()\n\n    @abstractmethod\n    async def publish(\n        self,\n        message: SendableMessage,\n        *args: Any,\n        reply_to: str = \"\",\n        rpc: bool = False,\n        rpc_timeout: Optional[float] = None,\n        raise_timeout: bool = False,\n        **kwargs: Any,\n    ) -&gt; Optional[SendableMessage]:\n        \"\"\"Publish a message.\n\n        Args:\n            message: The message to be published.\n            *args: Additional arguments.\n            reply_to: The reply-to address for the message.\n            rpc: Whether the message is for RPC.\n            rpc_timeout: The timeout for RPC.\n            raise_timeout: Whether to raise an exception on timeout.\n            **kwargs: Additional keyword arguments.\n\n        Returns:\n            The published message.\n\n        Raises:\n            NotImplementedError: If the method is not implemented.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        raise NotImplementedError()\n\n    @override\n    @abstractmethod\n    def subscriber(  # type: ignore[override,return]\n        self,\n        *broker_args: Any,\n        retry: Union[bool, int] = False,\n        dependencies: Sequence[Depends] = (),\n        decoder: Optional[CustomDecoder[StreamMessage[MsgType]]] = None,\n        parser: Optional[CustomParser[MsgType, StreamMessage[MsgType]]] = None,\n        middlewares: Optional[Sequence[Callable[[MsgType], BaseMiddleware]]] = None,\n        filter: Filter[StreamMessage[MsgType]] = default_filter,\n        _raw: bool = False,\n        _get_dependant: Optional[Any] = None,\n        **broker_kwargs: Any,\n    ) -&gt; Callable[\n        [\n            Union[\n                Callable[P_HandlerParams, T_HandlerReturn],\n                HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn],\n            ]\n        ],\n        HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn],\n    ]:\n        \"\"\"A function decorator for subscribing to a message broker.\n\n        Args:\n            *broker_args: Positional arguments to be passed to the message broker.\n            retry: Whether to retry the subscription if it fails. Can be a boolean or an integer specifying the number of retries.\n            dependencies: Sequence of dependencies to be injected into the decorated function.\n            decoder: Custom decoder function for decoding the message.\n            parser: Custom parser function for parsing the decoded message.\n            middlewares: Sequence of middleware functions to be applied to the message.\n            filter: Filter function for filtering the messages to be processed.\n            _raw: Whether to return the raw message instead of the processed result.\n            _get_dependant: Optional argument to get the dependant object.\n\n        Returns:\n            A callable decorator that wraps the decorated function and handles the subscription.\n\n        Raises:\n            NotImplementedError: If silent animals are not supported.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        super().subscriber()\n\n    def __init__(\n        self,\n        *args: Any,\n        apply_types: bool = True,\n        logger: Optional[logging.Logger] = access_logger,\n        log_level: int = logging.INFO,\n        log_fmt: Optional[str] = \"%(asctime)s %(levelname)s - %(message)s\",\n        dependencies: Sequence[Depends] = (),\n        decoder: Optional[CustomDecoder[StreamMessage[MsgType]]] = None,\n        parser: Optional[CustomParser[MsgType, StreamMessage[MsgType]]] = None,\n        middlewares: Optional[Sequence[Callable[[MsgType], BaseMiddleware]]] = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"Initialize the class.\n\n        Args:\n            *args: Variable length arguments\n            apply_types: Whether to apply types or not\n            logger: Logger object for logging\n            log_level: Log level for logging\n            log_fmt: Log format for logging\n            dependencies: Sequence of dependencies\n            decoder: Custom decoder object\n            parser: Custom parser object\n            middlewares: Sequence of middlewares\n            **kwargs: Keyword arguments\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        super().__init__(\n            *args,\n            apply_types=apply_types,\n            logger=logger,\n            log_level=log_level,\n            log_fmt=log_fmt,\n            dependencies=dependencies,\n            decoder=cast(\n                Optional[AsyncCustomDecoder[StreamMessage[MsgType]]],\n                to_async(decoder) if decoder else None,\n            ),\n            parser=cast(\n                Optional[AsyncCustomParser[MsgType, StreamMessage[MsgType]]],\n                to_async(parser) if parser else None,\n            ),\n            middlewares=middlewares,\n            **kwargs,\n        )\n\n    async def connect(self, *args: Any, **kwargs: Any) -&gt; ConnectionType:\n        \"\"\"Connect to a remote server.\n\n        Args:\n            *args: Variable length argument list.\n            **kwargs: Arbitrary keyword arguments.\n\n        Returns:\n            The connection object.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        if self._connection is None:\n            _kwargs = self._resolve_connection_kwargs(*args, **kwargs)\n            self._connection = await self._connect(**_kwargs)\n        return self._connection\n\n    async def __aenter__(self) -&gt; Self:\n        await self.connect()\n        return self\n\n    async def __aexit__(\n        self,\n        exc_type: Optional[Type[BaseException]],\n        exc_val: Optional[BaseException],\n        exec_tb: Optional[TracebackType],\n    ) -&gt; None:\n        \"\"\"Exit the context manager.\n\n        Args:\n            exc_type: The type of the exception raised, if any.\n            exc_val: The exception raised, if any.\n            exec_tb: The traceback of the exception raised, if any.\n\n        Returns:\n            None\n\n        Overrides:\n            This method overrides the __aexit__ method of the base class.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        await self.close(exc_type, exc_val, exec_tb)\n\n    @override\n    def _wrap_decode_message(\n        self,\n        func: Callable[..., Awaitable[T_HandlerReturn]],\n        params: Sized = (),\n        _raw: bool = False,\n    ) -&gt; Callable[[StreamMessage[MsgType]], Awaitable[T_HandlerReturn]]:\n        \"\"\"Wraps a function to decode a message and pass it as an argument to the wrapped function.\n\n        Args:\n            func: The function to be wrapped.\n            params: The parameters to be passed to the wrapped function.\n            _raw: Whether to return the raw message or not.\n\n        Returns:\n            The wrapped function.\n\n        Raises:\n            AssertionError: If the code reaches an unreachable state.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        params_ln = len(params)\n\n        @wraps(func)\n        async def decode_wrapper(message: StreamMessage[MsgType]) -&gt; T_HandlerReturn:\n            \"\"\"A wrapper function to decode and handle a message.\n\n            Args:\n                message : The message to be decoded and handled\n\n            Returns:\n                The return value of the handler function\n\n            Raises:\n                AssertionError: If the code reaches an unreachable state\n            !!! note\n\n                The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n            \"\"\"\n            if _raw is True:\n                return await func(message)\n\n            msg = message.decoded_body\n            if params_ln &gt; 1:\n                if isinstance(msg, Mapping):\n                    return await func(**msg)\n                elif isinstance(msg, Sequence):\n                    return await func(*msg)\n            else:\n                return await func(msg)\n\n            raise AssertionError(\"unreachable\")\n\n        return decode_wrapper\n\n    @override\n    def _wrap_handler(\n        self,\n        func: Callable[P_HandlerParams, T_HandlerReturn],\n        *,\n        retry: Union[bool, int] = False,\n        extra_dependencies: Sequence[Depends] = (),\n        _raw: bool = False,\n        _get_dependant: Optional[Any] = None,\n    ) -&gt; Tuple[\n        HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn],\n        CallModel[P_HandlerParams, T_HandlerReturn],\n    ]:\n        \"\"\"Wrap a handler function.\n\n        Args:\n            func: The handler function to wrap.\n            retry: Whether to retry the handler function if it fails. Can be a boolean or an integer specifying the number of retries.\n            extra_dependencies: Additional dependencies to inject into the handler function.\n            _raw: Whether to return the raw response from the handler function.\n            _get_dependant: An optional object to use as the dependant for the handler function.\n            **broker_log_context_kwargs: Additional keyword arguments to pass to the broker log context.\n\n        Returns:\n            A tuple containing the wrapped handler function and the call model.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        return super()._wrap_handler(  # type: ignore[return-value]\n            func,\n            retry=retry,\n            extra_dependencies=extra_dependencies,\n            _raw=_raw,\n            _get_dependant=_get_dependant,\n        )\n\n    async def _execute_handler(\n        self,\n        func: Callable[[StreamMessage[MsgType]], Awaitable[T_HandlerReturn]],\n        message: StreamMessage[MsgType],\n    ) -&gt; T_HandlerReturn:\n        \"\"\"Executes a handler function asynchronously.\n\n        Args:\n            func: The handler function to be executed.\n            message: The message to be passed to the handler function.\n\n        Returns:\n            The return value of the handler function.\n\n        Raises:\n            AckMessage: If the handler function raises an AckMessage exception.\n            NackMessage: If the handler function raises a NackMessage exception.\n            RejectMessage: If the handler function raises a RejectMessage exception.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        try:\n            return await func(message)\n        except AckMessage as e:\n            await message.ack()\n            raise e\n        except NackMessage as e:\n            await message.nack()\n            raise e\n        except RejectMessage as e:\n            await message.reject()\n            raise e\n</code></pre>"},{"location":"api/faststream/broker/core/asyncronous/BrokerAsyncUsecase/#faststream.broker.core.asyncronous.BrokerAsyncUsecase.handlers","title":"handlers  <code>instance-attribute</code>","text":"<pre><code>handlers: Dict[Any, AsyncHandler[MsgType]]\n</code></pre>"},{"location":"api/faststream/broker/core/asyncronous/BrokerAsyncUsecase/#faststream.broker.core.asyncronous.BrokerAsyncUsecase.middlewares","title":"middlewares  <code>instance-attribute</code>","text":"<pre><code>middlewares: Sequence[Callable[[MsgType], BaseMiddleware]]\n</code></pre>"},{"location":"api/faststream/broker/core/asyncronous/BrokerAsyncUsecase/#faststream.broker.core.asyncronous.BrokerAsyncUsecase.close","title":"close  <code>async</code>","text":"<pre><code>close(\n    exc_type: Optional[Type[BaseException]] = None,\n    exc_val: Optional[BaseException] = None,\n    exec_tb: Optional[TracebackType] = None,\n) -&gt; None\n</code></pre> <p>Closes the object.</p> PARAMETER  DESCRIPTION <code>exc_type</code> <p>The type of the exception being handled, if any.</p> <p> TYPE: <code>Optional[Type[BaseException]]</code> DEFAULT: <code>None</code> </p> <code>exc_val</code> <p>The exception instance being handled, if any.</p> <p> TYPE: <code>Optional[BaseException]</code> DEFAULT: <code>None</code> </p> <code>exec_tb</code> <p>The traceback of the exception being handled, if any.</p> <p> TYPE: <code>Optional[TracebackType]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>If the method is not implemented.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/core/asyncronous.py</code> <pre><code>async def close(\n    self,\n    exc_type: Optional[Type[BaseException]] = None,\n    exc_val: Optional[BaseException] = None,\n    exec_tb: Optional[TracebackType] = None,\n) -&gt; None:\n    \"\"\"Closes the object.\n\n    Args:\n        exc_type: The type of the exception being handled, if any.\n        exc_val: The exception instance being handled, if any.\n        exec_tb: The traceback of the exception being handled, if any.\n\n    Returns:\n        None\n\n    Raises:\n        NotImplementedError: If the method is not implemented.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    super()._abc_close(exc_type, exc_val, exec_tb)\n\n    for h in self.handlers.values():\n        await h.close()\n\n    if self._connection is not None:\n        await self._close(exc_type, exc_val, exec_tb)\n</code></pre>"},{"location":"api/faststream/broker/core/asyncronous/BrokerAsyncUsecase/#faststream.broker.core.asyncronous.BrokerAsyncUsecase.connect","title":"connect  <code>async</code>","text":"<pre><code>connect(*args: Any, **kwargs: Any) -&gt; ConnectionType\n</code></pre> <p>Connect to a remote server.</p> PARAMETER  DESCRIPTION <code>*args</code> <p>Variable length argument list.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>()</code> </p> <code>**kwargs</code> <p>Arbitrary keyword arguments.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>ConnectionType</code> <p>The connection object.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/core/asyncronous.py</code> <pre><code>async def connect(self, *args: Any, **kwargs: Any) -&gt; ConnectionType:\n    \"\"\"Connect to a remote server.\n\n    Args:\n        *args: Variable length argument list.\n        **kwargs: Arbitrary keyword arguments.\n\n    Returns:\n        The connection object.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    if self._connection is None:\n        _kwargs = self._resolve_connection_kwargs(*args, **kwargs)\n        self._connection = await self._connect(**_kwargs)\n    return self._connection\n</code></pre>"},{"location":"api/faststream/broker/core/asyncronous/BrokerAsyncUsecase/#faststream.broker.core.asyncronous.BrokerAsyncUsecase.publish","title":"publish  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>publish(\n    message: SendableMessage,\n    *args: Any,\n    reply_to: str = \"\",\n    rpc: bool = False,\n    rpc_timeout: Optional[float] = None,\n    raise_timeout: bool = False,\n    **kwargs: Any\n) -&gt; Optional[SendableMessage]\n</code></pre> <p>Publish a message.</p> PARAMETER  DESCRIPTION <code>message</code> <p>The message to be published.</p> <p> TYPE: <code>SendableMessage</code> </p> <code>*args</code> <p>Additional arguments.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>()</code> </p> <code>reply_to</code> <p>The reply-to address for the message.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>rpc</code> <p>Whether the message is for RPC.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>rpc_timeout</code> <p>The timeout for RPC.</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>raise_timeout</code> <p>Whether to raise an exception on timeout.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>**kwargs</code> <p>Additional keyword arguments.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Optional[SendableMessage]</code> <p>The published message.</p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>If the method is not implemented.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/core/asyncronous.py</code> <pre><code>@abstractmethod\nasync def publish(\n    self,\n    message: SendableMessage,\n    *args: Any,\n    reply_to: str = \"\",\n    rpc: bool = False,\n    rpc_timeout: Optional[float] = None,\n    raise_timeout: bool = False,\n    **kwargs: Any,\n) -&gt; Optional[SendableMessage]:\n    \"\"\"Publish a message.\n\n    Args:\n        message: The message to be published.\n        *args: Additional arguments.\n        reply_to: The reply-to address for the message.\n        rpc: Whether the message is for RPC.\n        rpc_timeout: The timeout for RPC.\n        raise_timeout: Whether to raise an exception on timeout.\n        **kwargs: Additional keyword arguments.\n\n    Returns:\n        The published message.\n\n    Raises:\n        NotImplementedError: If the method is not implemented.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/broker/core/asyncronous/BrokerAsyncUsecase/#faststream.broker.core.asyncronous.BrokerAsyncUsecase.start","title":"start  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>start() -&gt; None\n</code></pre> Source code in <code>faststream/broker/core/asyncronous.py</code> <pre><code>@abstractmethod\nasync def start(self) -&gt; None:\n    super()._abc_start()\n    for h in self.handlers.values():\n        for f, _, _, _, _, _ in h.calls:\n            f.refresh(with_mock=False)\n    await self.connect()\n</code></pre>"},{"location":"api/faststream/broker/core/asyncronous/BrokerAsyncUsecase/#faststream.broker.core.asyncronous.BrokerAsyncUsecase.subscriber","title":"subscriber  <code>abstractmethod</code>","text":"<pre><code>subscriber(\n    *broker_args: Any,\n    retry: Union[bool, int] = False,\n    dependencies: Sequence[Depends] = (),\n    decoder: Optional[\n        CustomDecoder[StreamMessage[MsgType]]\n    ] = None,\n    parser: Optional[\n        CustomParser[MsgType, StreamMessage[MsgType]]\n    ] = None,\n    middlewares: Optional[\n        Sequence[Callable[[MsgType], BaseMiddleware]]\n    ] = None,\n    filter: Filter[StreamMessage[MsgType]] = default_filter,\n    _raw: bool = False,\n    _get_dependant: Optional[Any] = None,\n    **broker_kwargs: Any\n) -&gt; Callable[\n    [\n        Union[\n            Callable[P_HandlerParams, T_HandlerReturn],\n            HandlerCallWrapper[\n                MsgType, P_HandlerParams, T_HandlerReturn\n            ],\n        ]\n    ],\n    HandlerCallWrapper[\n        MsgType, P_HandlerParams, T_HandlerReturn\n    ],\n]\n</code></pre> <p>A function decorator for subscribing to a message broker.</p> PARAMETER  DESCRIPTION <code>*broker_args</code> <p>Positional arguments to be passed to the message broker.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>()</code> </p> <code>retry</code> <p>Whether to retry the subscription if it fails. Can be a boolean or an integer specifying the number of retries.</p> <p> TYPE: <code>Union[bool, int]</code> DEFAULT: <code>False</code> </p> <code>dependencies</code> <p>Sequence of dependencies to be injected into the decorated function.</p> <p> TYPE: <code>Sequence[Depends]</code> DEFAULT: <code>()</code> </p> <code>decoder</code> <p>Custom decoder function for decoding the message.</p> <p> TYPE: <code>Optional[CustomDecoder[StreamMessage[MsgType]]]</code> DEFAULT: <code>None</code> </p> <code>parser</code> <p>Custom parser function for parsing the decoded message.</p> <p> TYPE: <code>Optional[CustomParser[MsgType, StreamMessage[MsgType]]]</code> DEFAULT: <code>None</code> </p> <code>middlewares</code> <p>Sequence of middleware functions to be applied to the message.</p> <p> TYPE: <code>Optional[Sequence[Callable[[MsgType], BaseMiddleware]]]</code> DEFAULT: <code>None</code> </p> <code>filter</code> <p>Filter function for filtering the messages to be processed.</p> <p> TYPE: <code>Filter[StreamMessage[MsgType]]</code> DEFAULT: <code>default_filter</code> </p> <code>_raw</code> <p>Whether to return the raw message instead of the processed result.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>_get_dependant</code> <p>Optional argument to get the dependant object.</p> <p> TYPE: <code>Optional[Any]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Callable[[Union[Callable[P_HandlerParams, T_HandlerReturn], HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn]]], HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn]]</code> <p>A callable decorator that wraps the decorated function and handles the subscription.</p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>If silent animals are not supported.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/core/asyncronous.py</code> <pre><code>@override\n@abstractmethod\ndef subscriber(  # type: ignore[override,return]\n    self,\n    *broker_args: Any,\n    retry: Union[bool, int] = False,\n    dependencies: Sequence[Depends] = (),\n    decoder: Optional[CustomDecoder[StreamMessage[MsgType]]] = None,\n    parser: Optional[CustomParser[MsgType, StreamMessage[MsgType]]] = None,\n    middlewares: Optional[Sequence[Callable[[MsgType], BaseMiddleware]]] = None,\n    filter: Filter[StreamMessage[MsgType]] = default_filter,\n    _raw: bool = False,\n    _get_dependant: Optional[Any] = None,\n    **broker_kwargs: Any,\n) -&gt; Callable[\n    [\n        Union[\n            Callable[P_HandlerParams, T_HandlerReturn],\n            HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn],\n        ]\n    ],\n    HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn],\n]:\n    \"\"\"A function decorator for subscribing to a message broker.\n\n    Args:\n        *broker_args: Positional arguments to be passed to the message broker.\n        retry: Whether to retry the subscription if it fails. Can be a boolean or an integer specifying the number of retries.\n        dependencies: Sequence of dependencies to be injected into the decorated function.\n        decoder: Custom decoder function for decoding the message.\n        parser: Custom parser function for parsing the decoded message.\n        middlewares: Sequence of middleware functions to be applied to the message.\n        filter: Filter function for filtering the messages to be processed.\n        _raw: Whether to return the raw message instead of the processed result.\n        _get_dependant: Optional argument to get the dependant object.\n\n    Returns:\n        A callable decorator that wraps the decorated function and handles the subscription.\n\n    Raises:\n        NotImplementedError: If silent animals are not supported.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    super().subscriber()\n</code></pre>"},{"location":"api/faststream/broker/core/asyncronous/default_filter/","title":"Default filter","text":""},{"location":"api/faststream/broker/core/asyncronous/default_filter/#faststream.broker.core.asyncronous.default_filter","title":"faststream.broker.core.asyncronous.default_filter  <code>async</code>","text":"<pre><code>default_filter(msg: StreamMessage[Any]) -&gt; bool\n</code></pre> <p>A function to filter stream messages.</p> PARAMETER  DESCRIPTION <code>msg</code> <p>A stream message object</p> <p> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the message has not been processed, False otherwise</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/core/asyncronous.py</code> <pre><code>async def default_filter(msg: StreamMessage[Any]) -&gt; bool:\n    \"\"\"A function to filter stream messages.\n\n    Args:\n        msg : A stream message object\n\n    Returns:\n        True if the message has not been processed, False otherwise\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    return not msg.processed\n</code></pre>"},{"location":"api/faststream/broker/core/mixins/LoggingMixin/","title":"LoggingMixin","text":""},{"location":"api/faststream/broker/core/mixins/LoggingMixin/#faststream.broker.core.mixins.LoggingMixin","title":"faststream.broker.core.mixins.LoggingMixin","text":"<p>A mixin class for logging.</p> METHOD DESCRIPTION <code>fmt </code> <p>getter method for _fmt attribute</p> <code>_get_log_context </code> <p>returns a dictionary with log context information</p> <code>_log </code> <p>logs a message with optional log level, extra data, and exception info</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/core/mixins.py</code> <pre><code>class LoggingMixin:\n    \"\"\"A mixin class for logging.\n\n    Attributes:\n        logger : logger object used for logging\n        log_level : log level for logging\n        _fmt : format string for log messages\n\n    Methods:\n        fmt : getter method for _fmt attribute\n        _get_log_context : returns a dictionary with log context information\n        _log : logs a message with optional log level, extra data, and exception info\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    def __init__(\n        self,\n        *args: Any,\n        logger: Optional[logging.Logger] = access_logger,\n        log_level: int = logging.INFO,\n        log_fmt: Optional[str] = \"%(asctime)s %(levelname)s - %(message)s\",\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"Initialize the class.\n\n        Args:\n            *args: Variable length argument list\n            logger: Optional logger object\n            log_level: Log level (default: logging.INFO)\n            log_fmt: Log format (default: \"%(asctime)s %(levelname)s - %(message)s\")\n            **kwargs: Arbitrary keyword arguments\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        self.logger = logger\n        self.log_level = log_level\n        self._fmt = log_fmt\n\n    @property\n    def fmt(self) -&gt; str:  # pragma: no cover\n        return self._fmt or \"\"\n\n    def _get_log_context(\n        self,\n        message: Optional[StreamMessage[MsgType]],\n        **kwargs: str,\n    ) -&gt; AnyDict:\n        \"\"\"Get the log context.\n\n        Args:\n            message: Optional stream message\n            **kwargs: Additional keyword arguments\n\n        Returns:\n            A dictionary containing the log context with the following keys:\n                - message_id: The first 10 characters of the message_id if message is not None, otherwise an empty string\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        return {\n            \"message_id\": message.message_id[:10] if message else \"\",\n        }\n\n    def _log(\n        self,\n        message: str,\n        log_level: Optional[int] = None,\n        extra: Optional[AnyDict] = None,\n        exc_info: Optional[Exception] = None,\n    ) -&gt; None:\n        \"\"\"Logs a message.\n\n        Args:\n            message: The message to be logged.\n            log_level: The log level of the message. If not provided, the default log level of the logger will be used.\n            extra: Additional information to be logged along with the message. This should be a dictionary.\n            exc_info: An exception to be logged along with the message.\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        if self.logger is not None:\n            self.logger.log(\n                (log_level or self.log_level),\n                message,\n                extra=extra,\n                exc_info=exc_info,\n            )\n</code></pre>"},{"location":"api/faststream/broker/core/mixins/LoggingMixin/#faststream.broker.core.mixins.LoggingMixin.fmt","title":"fmt  <code>property</code>","text":"<pre><code>fmt: str\n</code></pre>"},{"location":"api/faststream/broker/core/mixins/LoggingMixin/#faststream.broker.core.mixins.LoggingMixin.log_level","title":"log_level  <code>instance-attribute</code>","text":"<pre><code>log_level = log_level\n</code></pre>"},{"location":"api/faststream/broker/core/mixins/LoggingMixin/#faststream.broker.core.mixins.LoggingMixin.logger","title":"logger  <code>instance-attribute</code>","text":"<pre><code>logger = logger\n</code></pre>"},{"location":"api/faststream/broker/fastapi/route/StreamMessage/","title":"StreamMessage","text":""},{"location":"api/faststream/broker/fastapi/route/StreamMessage/#faststream.broker.fastapi.route.StreamMessage","title":"faststream.broker.fastapi.route.StreamMessage","text":"<p>             Bases: <code>Request</code></p> <p>A class to represent a stream message.</p> METHOD DESCRIPTION <code>__init__ </code> <p>initializes the StreamMessage object</p> <code>get_session </code> <p>returns a callable function that handles the session of the message</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/fastapi/route.py</code> <pre><code>class StreamMessage(Request):\n    \"\"\"A class to represent a stream message.\n\n    Attributes:\n        scope : dictionary representing the scope of the message\n        _cookies : dictionary representing the cookies of the message\n        _headers : dictionary representing the headers of the message\n        _body : dictionary representing the body of the message\n        _query_params : dictionary representing the query parameters of the message\n\n    Methods:\n        __init__ : initializes the StreamMessage object\n        get_session : returns a callable function that handles the session of the message\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    scope: AnyDict\n    _cookies: AnyDict\n    _headers: AnyDict  # type: ignore\n    _body: AnyDict  # type: ignore\n    _query_params: AnyDict  # type: ignore\n\n    def __init__(\n        self,\n        body: Optional[AnyDict] = None,\n        headers: Optional[AnyDict] = None,\n    ):\n        \"\"\"Initialize a class instance.\n\n        Args:\n            body: The body of the request as a dictionary. Default is None.\n            headers: The headers of the request as a dictionary. Default is None.\n\n        Attributes:\n            scope: A dictionary to store the scope of the request.\n            _cookies: A dictionary to store the cookies of the request.\n            _headers: A dictionary to store the headers of the request.\n            _body: A dictionary to store the body of the request.\n            _query_params: A dictionary to store the query parameters of the request.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        self.scope = {}\n        self._cookies = {}\n        self._headers = headers or {}\n        self._body = body or {}\n        self._query_params = self._body\n\n    @classmethod\n    def get_session(\n        cls,\n        dependant: Dependant,\n        dependency_overrides_provider: Optional[Any] = None,\n    ) -&gt; Callable[[NativeMessage[Any]], Awaitable[SendableMessage]]:\n        \"\"\"Creates a session for handling requests.\n\n        Args:\n            dependant: The dependant object representing the session.\n            dependency_overrides_provider: Optional provider for dependency overrides.\n\n        Returns:\n            A callable that takes a native message and returns an awaitable sendable message.\n\n        Raises:\n            AssertionError: If the dependant call is not defined.\n\n        Note:\n            This function is used to create a session for handling requests. It takes a dependant object, which represents the session, and a dependency overrides provider, which allows for overriding dependencies. It returns a callable that takes a native message and returns an awaitable sendable message. The session is created based on the dependant object and the message passed to the callable. The session is then used to call the function obtained from the dependant object, and the result is returned.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        assert dependant.call  # nosec B101\n\n        func = get_app(dependant, dependency_overrides_provider)\n\n        dependencies_names = tuple(i.name for i in dependant.dependencies)\n\n        first_arg = next(\n            dropwhile(\n                lambda i: i in dependencies_names,\n                inspect.signature(dependant.call).parameters,\n            ),\n            None,\n        )\n\n        async def app(message: NativeMessage[Any]) -&gt; SendableMessage:\n            \"\"\"An asynchronous function that processes an incoming message and returns a sendable message.\n\n            Args:\n                message : The incoming message to be processed\n\n            Returns:\n                The sendable message\n\n            Raises:\n                TypeError: If the body of the message is not a dictionary\n            !!! note\n\n                The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n            \"\"\"\n            body = message.decoded_body\n            if first_arg is not None:\n                if not isinstance(body, dict) and not isinstance(body, list):\n                    fastapi_body: Any = {first_arg: body}\n                else:\n                    fastapi_body = body\n\n                session = cls(fastapi_body, message.headers)\n            else:\n                session = cls()\n            return await func(session)\n\n        return app\n</code></pre>"},{"location":"api/faststream/broker/fastapi/route/StreamMessage/#faststream.broker.fastapi.route.StreamMessage.scope","title":"scope  <code>instance-attribute</code>","text":"<pre><code>scope: AnyDict = {}\n</code></pre>"},{"location":"api/faststream/broker/fastapi/route/StreamMessage/#faststream.broker.fastapi.route.StreamMessage.get_session","title":"get_session  <code>classmethod</code>","text":"<pre><code>get_session(\n    dependant: Dependant,\n    dependency_overrides_provider: Optional[Any] = None,\n) -&gt; Callable[\n    [NativeMessage[Any]], Awaitable[SendableMessage]\n]\n</code></pre> <p>Creates a session for handling requests.</p> PARAMETER  DESCRIPTION <code>dependant</code> <p>The dependant object representing the session.</p> <p> TYPE: <code>Dependant</code> </p> <code>dependency_overrides_provider</code> <p>Optional provider for dependency overrides.</p> <p> TYPE: <code>Optional[Any]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Callable[[StreamMessage[Any]], Awaitable[SendableMessage]]</code> <p>A callable that takes a native message and returns an awaitable sendable message.</p> RAISES DESCRIPTION <code>AssertionError</code> <p>If the dependant call is not defined.</p> Note <p>This function is used to create a session for handling requests. It takes a dependant object, which represents the session, and a dependency overrides provider, which allows for overriding dependencies. It returns a callable that takes a native message and returns an awaitable sendable message. The session is created based on the dependant object and the message passed to the callable. The session is then used to call the function obtained from the dependant object, and the result is returned.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/fastapi/route.py</code> <pre><code>@classmethod\ndef get_session(\n    cls,\n    dependant: Dependant,\n    dependency_overrides_provider: Optional[Any] = None,\n) -&gt; Callable[[NativeMessage[Any]], Awaitable[SendableMessage]]:\n    \"\"\"Creates a session for handling requests.\n\n    Args:\n        dependant: The dependant object representing the session.\n        dependency_overrides_provider: Optional provider for dependency overrides.\n\n    Returns:\n        A callable that takes a native message and returns an awaitable sendable message.\n\n    Raises:\n        AssertionError: If the dependant call is not defined.\n\n    Note:\n        This function is used to create a session for handling requests. It takes a dependant object, which represents the session, and a dependency overrides provider, which allows for overriding dependencies. It returns a callable that takes a native message and returns an awaitable sendable message. The session is created based on the dependant object and the message passed to the callable. The session is then used to call the function obtained from the dependant object, and the result is returned.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    assert dependant.call  # nosec B101\n\n    func = get_app(dependant, dependency_overrides_provider)\n\n    dependencies_names = tuple(i.name for i in dependant.dependencies)\n\n    first_arg = next(\n        dropwhile(\n            lambda i: i in dependencies_names,\n            inspect.signature(dependant.call).parameters,\n        ),\n        None,\n    )\n\n    async def app(message: NativeMessage[Any]) -&gt; SendableMessage:\n        \"\"\"An asynchronous function that processes an incoming message and returns a sendable message.\n\n        Args:\n            message : The incoming message to be processed\n\n        Returns:\n            The sendable message\n\n        Raises:\n            TypeError: If the body of the message is not a dictionary\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        body = message.decoded_body\n        if first_arg is not None:\n            if not isinstance(body, dict) and not isinstance(body, list):\n                fastapi_body: Any = {first_arg: body}\n            else:\n                fastapi_body = body\n\n            session = cls(fastapi_body, message.headers)\n        else:\n            session = cls()\n        return await func(session)\n\n    return app\n</code></pre>"},{"location":"api/faststream/broker/fastapi/route/StreamRoute/","title":"StreamRoute","text":""},{"location":"api/faststream/broker/fastapi/route/StreamRoute/#faststream.broker.fastapi.route.StreamRoute","title":"faststream.broker.fastapi.route.StreamRoute","text":"<p>             Bases: <code>BaseRoute</code>, <code>Generic[MsgType, P_HandlerParams, T_HandlerReturn]</code></p> <p>A class representing a stream route.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/fastapi/route.py</code> <pre><code>class StreamRoute(BaseRoute, Generic[MsgType, P_HandlerParams, T_HandlerReturn]):\n    \"\"\"A class representing a stream route.\n\n    Attributes:\n        handler : HandlerCallWrapper object representing the handler for the route\n        path : path of the route\n        broker : BrokerAsyncUsecase object representing the broker for the route\n        dependant : Dependable object representing the dependencies for the route\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    handler: HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn]\n\n    def __init__(\n        self,\n        path: Union[NameRequired, str],\n        *extra: Union[NameRequired, str],\n        endpoint: Union[\n            Callable[P_HandlerParams, T_HandlerReturn],\n            HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn],\n        ],\n        broker: BrokerAsyncUsecase[MsgType, Any],\n        dependencies: Sequence[params.Depends] = (),\n        dependency_overrides_provider: Optional[Any] = None,\n        **handle_kwargs: Any,\n    ) -&gt; None:\n        \"\"\"Initialize a class instance.\n\n        Args:\n            path: The path of the instance.\n            *extra: Additional arguments.\n            endpoint: The endpoint of the instance.\n            broker: The broker of the instance.\n            dependencies: The dependencies of the instance.\n            dependency_overrides_provider: The provider for dependency overrides.\n            **handle_kwargs: Additional keyword arguments.\n\n        Returns:\n            None.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        self.path = path\n        self.broker = broker\n\n        path_name = (path if isinstance(path, str) else path.name) or \"\"\n\n        if isinstance(endpoint, HandlerCallWrapper):\n            orig_call = endpoint._original_call\n        else:\n            orig_call = endpoint\n\n        dependant = get_dependant(\n            path=path_name,\n            call=orig_call,\n        )\n        for depends in dependencies[::-1]:\n            dependant.dependencies.insert(\n                0,\n                get_parameterless_sub_dependant(depends=depends, path=path_name),\n            )\n        self.dependant = dependant\n\n        call = wraps(orig_call)(\n            StreamMessage.get_session(\n                dependant,\n                dependency_overrides_provider,\n            )\n        )\n\n        if isinstance(endpoint, HandlerCallWrapper):\n            endpoint._original_call = call\n            handler = endpoint\n\n        else:\n            handler = call\n\n        self.handler = broker.subscriber(\n            path,\n            *extra,\n            _raw=True,\n            _get_dependant=lambda call: dependant,\n            **handle_kwargs,\n        )(\n            handler  # type: ignore[arg-type]\n        )\n</code></pre>"},{"location":"api/faststream/broker/fastapi/route/StreamRoute/#faststream.broker.fastapi.route.StreamRoute.broker","title":"broker  <code>instance-attribute</code>","text":"<pre><code>broker = broker\n</code></pre>"},{"location":"api/faststream/broker/fastapi/route/StreamRoute/#faststream.broker.fastapi.route.StreamRoute.dependant","title":"dependant  <code>instance-attribute</code>","text":"<pre><code>dependant = dependant\n</code></pre>"},{"location":"api/faststream/broker/fastapi/route/StreamRoute/#faststream.broker.fastapi.route.StreamRoute.handler","title":"handler  <code>instance-attribute</code>","text":"<pre><code>handler: HandlerCallWrapper[\n    MsgType, P_HandlerParams, T_HandlerReturn\n] = broker.subscriber(\n    path,\n    *extra,\n    _raw=True,\n    _get_dependant=lambda: dependant,\n    **handle_kwargs\n)(\n    handler\n)\n</code></pre>"},{"location":"api/faststream/broker/fastapi/route/StreamRoute/#faststream.broker.fastapi.route.StreamRoute.path","title":"path  <code>instance-attribute</code>","text":"<pre><code>path = path\n</code></pre>"},{"location":"api/faststream/broker/fastapi/route/get_app/","title":"Get app","text":""},{"location":"api/faststream/broker/fastapi/route/get_app/#faststream.broker.fastapi.route.get_app","title":"faststream.broker.fastapi.route.get_app","text":"<pre><code>get_app(\n    dependant: Dependant,\n    dependency_overrides_provider: Optional[Any] = None,\n) -&gt; Callable[\n    [StreamMessage], Coroutine[Any, Any, SendableMessage]\n]\n</code></pre> <p>Creates a FastAPI application.</p> PARAMETER  DESCRIPTION <code>dependant</code> <p>The dependant object that defines the endpoint function and its dependencies.</p> <p> TYPE: <code>Dependant</code> </p> <code>dependency_overrides_provider</code> <p>Optional provider for dependency overrides.</p> <p> TYPE: <code>Optional[Any]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Callable[[StreamMessage], Coroutine[Any, Any, SendableMessage]]</code> <p>The FastAPI application as a callable that takes a StreamMessage object as input and returns a SendableMessage coroutine.</p> RAISES DESCRIPTION <code>AssertionError</code> <p>If the code reaches an unreachable state.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/fastapi/route.py</code> <pre><code>def get_app(\n    dependant: Dependant,\n    dependency_overrides_provider: Optional[Any] = None,\n) -&gt; Callable[[StreamMessage], Coroutine[Any, Any, SendableMessage]]:\n    \"\"\"Creates a FastAPI application.\n\n    Args:\n        dependant: The dependant object that defines the endpoint function and its dependencies.\n        dependency_overrides_provider: Optional provider for dependency overrides.\n\n    Returns:\n        The FastAPI application as a callable that takes a StreamMessage object as input and returns a SendableMessage coroutine.\n\n    Raises:\n        AssertionError: If the code reaches an unreachable state.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    async def app(request: StreamMessage) -&gt; SendableMessage:\n        \"\"\"Handle an HTTP request and return a response.\n\n        Args:\n            request: The incoming HTTP request.\n\n        Returns:\n            The response to be sent back to the client.\n\n        Raises:\n            AssertionError: If the code reaches an unreachable point.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        async with AsyncExitStack() as stack:\n            request.scope[\"fastapi_astack\"] = stack\n\n            solved_result = await solve_dependencies(\n                request=request,\n                body=request._body,\n                dependant=dependant,\n                dependency_overrides_provider=dependency_overrides_provider,\n            )\n\n            values, errors, _, _2, _3 = solved_result\n            if errors:\n                raise_fastapi_validation_error(errors, request._body)\n\n            return cast(\n                SendableMessage,\n                await run_endpoint_function(\n                    dependant=dependant,\n                    values=values,\n                    is_coroutine=asyncio.iscoroutinefunction(dependant.call),\n                ),\n            )\n\n        raise AssertionError(\"unreachable\")\n\n    return app\n</code></pre>"},{"location":"api/faststream/broker/fastapi/router/StreamRouter/","title":"StreamRouter","text":""},{"location":"api/faststream/broker/fastapi/router/StreamRouter/#faststream.broker.fastapi.router.StreamRouter","title":"faststream.broker.fastapi.router.StreamRouter","text":"<p>             Bases: <code>APIRouter</code>, <code>Generic[MsgType]</code></p> <p>A class to route streams.</p> METHOD DESCRIPTION <code>__init__ </code> <p>initialize the StreamRouter</p> <code>add_api_mq_route </code> <p>add a route for API and message queue</p> <code>subscriber </code> <p>decorator to define a subscriber</p> <code>wrap_lifespan </code> <p>wrap the lifespan of the router</p> <code>after_startup </code> <p>decorator to define a function to be executed after startup</p> <code>publisher </code> <p>create a publisher for the broker</p> <code>asyncapi_router </code> <p>create an APIRouter for AsyncAPI documentation</p> <code>include_router </code> <p>include another router in the StreamRouter</p> <code>_setup_log_context </code> <p>setup log context for the broker</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/fastapi/router.py</code> <pre><code>class StreamRouter(APIRouter, Generic[MsgType]):\n    \"\"\"A class to route streams.\n\n    Attributes:\n        broker_class : type of the broker\n        broker : instance of the broker\n        docs_router : optional APIRouter for documentation\n        _after_startup_hooks : list of functions to be executed after startup\n        schema : optional schema\n\n        title : title of the router\n        description : description of the router\n        version : version of the router\n        license : optional license information\n        contact : optional contact information\n\n    Methods:\n        __init__ : initialize the StreamRouter\n        add_api_mq_route : add a route for API and message queue\n        subscriber : decorator to define a subscriber\n        wrap_lifespan : wrap the lifespan of the router\n        after_startup : decorator to define a function to be executed after startup\n        publisher : create a publisher for the broker\n        asyncapi_router : create an APIRouter for AsyncAPI documentation\n        include_router : include another router in the StreamRouter\n        _setup_log_context : setup log context for the broker\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    broker_class: Type[BrokerAsyncUsecase[MsgType, Any]]\n    broker: BrokerAsyncUsecase[MsgType, Any]\n    docs_router: Optional[APIRouter]\n    _after_startup_hooks: List[\n        Callable[[AppType], Awaitable[Optional[Mapping[str, Any]]]]\n    ]\n    schema: Optional[Schema]\n\n    title: str\n    description: str\n    version: str\n    license: Optional[AnyDict]\n    contact: Optional[AnyDict]\n\n    def __init__(\n        self,\n        *connection_args: Tuple[Any, ...],\n        prefix: str = \"\",\n        tags: Optional[List[Union[str, Enum]]] = None,\n        dependencies: Optional[Sequence[params.Depends]] = None,\n        default_response_class: Type[Response] = Default(JSONResponse),\n        responses: Optional[Dict[Union[int, str], AnyDict]] = None,\n        callbacks: Optional[List[routing.BaseRoute]] = None,\n        routes: Optional[List[routing.BaseRoute]] = None,\n        redirect_slashes: bool = True,\n        default: Optional[ASGIApp] = None,\n        dependency_overrides_provider: Optional[Any] = None,\n        route_class: Type[APIRoute] = APIRoute,\n        on_startup: Optional[Sequence[Callable[[], Any]]] = None,\n        on_shutdown: Optional[Sequence[Callable[[], Any]]] = None,\n        deprecated: Optional[bool] = None,\n        include_in_schema: bool = True,\n        setup_state: bool = True,\n        lifespan: Optional[Lifespan[Any]] = None,\n        generate_unique_id_function: Callable[[APIRoute], str] = Default(\n            generate_unique_id\n        ),\n        # AsyncAPI information\n        asyncapi_tags: Optional[Sequence[Union[asyncapi.Tag, asyncapi.TagDict]]] = None,\n        schema_url: Optional[str] = \"/asyncapi\",\n        **connection_kwars: Any,\n    ) -&gt; None:\n        \"\"\"Initialize an instance of a class.\n\n        Args:\n            *connection_args: Variable length arguments for the connection\n            prefix: Prefix for the class\n            tags: Optional list of tags for the class\n            dependencies: Optional sequence of dependencies for the class\n            default_response_class: Default response class for the class\n            responses: Optional dictionary of responses for the class\n            callbacks: Optional list of callbacks for the class\n            routes: Optional list of routes for the class\n            redirect_slashes: Boolean value indicating whether to redirect slashes\n            default: Optional default value for the class\n            dependency_overrides_provider: Optional provider for dependency overrides\n            route_class: Route class for the class\n            on_startup: Optional sequence of functions to run on startup\n            on_shutdown: Optional sequence of functions to run on shutdown\n            deprecated: Optional boolean value indicating whether the class is deprecated\n            include_in_schema: Boolean value indicating whether to include the class in the schema\n            setup_state: Boolean value indicating whether to setup state\n            lifespan: Optional lifespan for the class\n            generate_unique_id_function: Function to generate unique ID for the class\n            asyncapi_tags: Optional sequence of asyncapi tags for the class schema\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        assert (  # nosec B101\n            self.broker_class\n        ), \"You should specify `broker_class` at your implementation\"\n\n        self.broker = self.broker_class(\n            *connection_args,\n            apply_types=False,\n            tags=asyncapi_tags,\n            **connection_kwars,\n        )\n\n        self.setup_state = setup_state\n\n        # AsyncAPI information\n        # Empty\n        self.terms_of_service = None\n        self.identifier = None\n        self.asyncapi_tags = None\n        self.external_docs = None\n        # parse from FastAPI app on startup\n        self.title = \"\"\n        self.version = \"\"\n        self.description = \"\"\n        self.license = None\n        self.contact = None\n\n        self.schema = None\n\n        super().__init__(\n            prefix=prefix,\n            tags=tags,\n            dependencies=dependencies,\n            default_response_class=default_response_class,\n            responses=responses,\n            callbacks=callbacks,\n            routes=routes,\n            redirect_slashes=redirect_slashes,\n            default=default,\n            dependency_overrides_provider=dependency_overrides_provider,\n            route_class=route_class,\n            deprecated=deprecated,\n            include_in_schema=include_in_schema,\n            generate_unique_id_function=generate_unique_id_function,\n            lifespan=self.wrap_lifespan(lifespan),\n            on_startup=on_startup,\n            on_shutdown=on_shutdown,\n        )\n\n        self.docs_router = self.asyncapi_router(schema_url)\n\n        self._after_startup_hooks = []\n\n    def add_api_mq_route(\n        self,\n        path: Union[NameRequired, str],\n        *extra: Union[NameRequired, str],\n        endpoint: Callable[P_HandlerParams, T_HandlerReturn],\n        dependencies: Sequence[params.Depends],\n        **broker_kwargs: Any,\n    ) -&gt; HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn]:\n        \"\"\"Add an API message queue route.\n\n        Args:\n            path: The path of the route.\n            *extra: Additional path segments.\n            endpoint: The endpoint function to be called for this route.\n            dependencies: The dependencies required by the endpoint function.\n            **broker_kwargs: Additional keyword arguments to be passed to the broker.\n\n        Returns:\n            The handler call wrapper for the route.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        route: StreamRoute[MsgType, P_HandlerParams, T_HandlerReturn] = StreamRoute(\n            path,\n            *extra,\n            endpoint=endpoint,\n            dependencies=dependencies,\n            dependency_overrides_provider=self.dependency_overrides_provider,\n            broker=self.broker,\n            **broker_kwargs,\n        )\n        self.routes.append(route)\n        return route.handler\n\n    def subscriber(\n        self,\n        path: Union[str, NameRequired],\n        *extra: Union[NameRequired, str],\n        dependencies: Optional[Sequence[params.Depends]] = None,\n        **broker_kwargs: Any,\n    ) -&gt; Callable[\n        [Callable[P_HandlerParams, T_HandlerReturn]],\n        HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn],\n    ]:\n        \"\"\"A function decorator for subscribing to a message queue.\n\n        Args:\n            path : The path to subscribe to. Can be a string or a `NameRequired` object.\n            *extra : Additional path segments. Can be a `NameRequired` object or a string.\n            dependencies : Optional sequence of dependencies.\n            **broker_kwargs : Additional keyword arguments for the broker.\n\n        Returns:\n            A callable decorator that adds the decorated function as an endpoint for the specified path.\n\n        Raises:\n            NotImplementedError: If silent animals are not supported.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        current_dependencies = self.dependencies.copy()\n        if dependencies:\n            current_dependencies.extend(dependencies)\n\n        def decorator(\n            func: Callable[P_HandlerParams, T_HandlerReturn],\n        ) -&gt; HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn]:\n            \"\"\"A decorator function.\n\n            Args:\n                func: The function to be decorated.\n\n            Returns:\n                The decorated function.\n            !!! note\n\n                The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n            \"\"\"\n            return self.add_api_mq_route(\n                path,\n                *extra,\n                endpoint=func,\n                dependencies=current_dependencies,\n                **broker_kwargs,\n            )\n\n        return decorator\n\n    def wrap_lifespan(self, lifespan: Optional[Lifespan[Any]] = None) -&gt; Lifespan[Any]:\n        \"\"\"Wrap the lifespan of the application.\n\n        Args:\n            lifespan: Optional lifespan object.\n\n        Returns:\n            The wrapped lifespan object.\n\n        Raises:\n            NotImplementedError: If silent animals are not supported.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        if lifespan is not None:\n            lifespan_context = lifespan\n        else:\n            lifespan_context = _DefaultLifespan(self)\n\n        @asynccontextmanager\n        async def start_broker_lifespan(\n            app: FastAPI,\n        ) -&gt; AsyncIterator[Mapping[str, Any]]:\n            \"\"\"Starts the lifespan of a broker.\n\n            Args:\n                app (FastAPI): The FastAPI application.\n\n            Yields:\n                AsyncIterator[Mapping[str, Any]]: A mapping of context information during the lifespan of the broker.\n\n            Raises:\n                NotImplementedError: If silent animals are not supported.\n            !!! note\n\n                The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n            \"\"\"\n            from faststream.asyncapi.generate import get_app_schema\n\n            self.title = app.title\n            self.description = app.description\n            self.version = app.version\n            self.contact = app.contact\n            self.license = app.license_info\n\n            self.schema = get_app_schema(self)\n            if self.docs_router:\n                app.include_router(self.docs_router)\n\n            async with lifespan_context(app) as maybe_context:\n                if maybe_context is None:\n                    context: AnyDict = {}\n                else:\n                    context = dict(maybe_context)\n\n                context.update({\"broker\": self.broker})\n                await self.broker.start()\n\n                for h in self._after_startup_hooks:\n                    h_context = await h(app)\n                    if h_context:  # pragma: no branch\n                        context.update(h_context)\n\n                try:\n                    if self.setup_state:\n                        yield context\n                    else:\n                        # NOTE: old asgi compatibility\n                        yield  # type: ignore\n\n                finally:\n                    await self.broker.close()\n\n        return start_broker_lifespan\n\n    @overload\n    def after_startup(\n        self,\n        func: Callable[[AppType], Mapping[str, Any]],\n    ) -&gt; Callable[[AppType], Mapping[str, Any]]:\n        \"\"\"A function decorator to be used for executing a function after startup.\n\n        Args:\n            func: A function that takes an `AppType` argument and returns a mapping of strings to any type.\n\n        Returns:\n            A decorated function that takes an `AppType` argument and returns a mapping of strings to any type.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        ...\n\n    @overload\n    def after_startup(\n        self,\n        func: Callable[[AppType], Awaitable[Mapping[str, Any]]],\n    ) -&gt; Callable[[AppType], Awaitable[Mapping[str, Any]]]:\n        \"\"\"A function decorator to be used for running a function after the startup of an application.\n\n        Args:\n            func: The function to be decorated. It should take an argument of type AppType and return an awaitable mapping of strings to any type.\n\n        Returns:\n            The decorated function.\n\n        Note:\n            This function can be used as a decorator for other functions.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        ...\n\n    @overload\n    def after_startup(\n        self,\n        func: Callable[[AppType], None],\n    ) -&gt; Callable[[AppType], None]:\n        \"\"\"A function decorator to be used for running a function after the startup of an application.\n\n        Args:\n            func: The function to be executed after startup.\n\n        Returns:\n            A decorated function that will be executed after startup.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        ...\n\n    @overload\n    def after_startup(\n        self,\n        func: Callable[[AppType], Awaitable[None]],\n    ) -&gt; Callable[[AppType], Awaitable[None]]:\n        \"\"\"Decorator to register a function to be executed after the application startup.\n\n        Args:\n            func: A callable that takes an `AppType` argument and returns an awaitable `None`.\n\n        Returns:\n            A decorated function that takes an `AppType` argument and returns an awaitable `None`.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        ...\n\n    def after_startup(\n        self,\n        func: Union[\n            Callable[[AppType], Mapping[str, Any]],\n            Callable[[AppType], Awaitable[Mapping[str, Any]]],\n            Callable[[AppType], None],\n            Callable[[AppType], Awaitable[None]],\n        ],\n    ) -&gt; Union[\n        Callable[[AppType], Mapping[str, Any]],\n        Callable[[AppType], Awaitable[Mapping[str, Any]]],\n        Callable[[AppType], None],\n        Callable[[AppType], Awaitable[None]],\n    ]:\n        \"\"\"Register a function to be executed after startup.\n\n        Args:\n            func: A function to be executed after startup. It can take an `AppType` argument and return a mapping of strings to any values, or it can take an `AppType` argument and return an awaitable that resolves to a mapping of strings to any values, or it can take an `AppType` argument and return nothing, or it can take an `AppType` argument and return an awaitable that resolves to nothing.\n\n        Returns:\n            The registered function.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        self._after_startup_hooks.append(to_async(func))  # type: ignore\n        return func\n\n    def publisher(\n        self,\n        queue: Union[NameRequired, str],\n        *publisher_args: Any,\n        **publisher_kwargs: Any,\n    ) -&gt; BasePublisher[MsgType]:\n        \"\"\"Publishes messages to a queue.\n\n        Args:\n            queue: The queue to publish the messages to. Can be either a `NameRequired` object or a string.\n            *publisher_args: Additional arguments to be passed to the publisher.\n            **publisher_kwargs: Additional keyword arguments to be passed to the publisher.\n\n        Returns:\n            An instance of `BasePublisher` that can be used to publish messages to the specified queue.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        return self.broker.publisher(\n            queue,\n            *publisher_args,\n            **publisher_kwargs,\n        )\n\n    def asyncapi_router(self, schema_url: Optional[str]) -&gt; Optional[APIRouter]:\n        \"\"\"Creates an API router for serving AsyncAPI documentation.\n\n        Args:\n            schema_url: The URL where the AsyncAPI schema will be served.\n\n        Returns:\n            An instance of APIRouter if include_in_schema and schema_url are both True, otherwise returns None.\n\n        Raises:\n            AssertionError: If self.schema is not set.\n\n        Notes:\n            This function defines three nested functions: download_app_json_schema, download_app_yaml_schema, and serve_asyncapi_schema. These functions are used to handle different routes for serving the AsyncAPI schema and documentation.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        if not self.include_in_schema or not schema_url:\n            return None\n\n        def download_app_json_schema() -&gt; Response:\n            assert (  # nosec B101\n                self.schema\n            ), \"You need to run application lifespan at first\"\n\n            return Response(\n                content=json.dumps(self.schema.to_jsonable(), indent=4),\n                headers={\"Content-Type\": \"application/octet-stream\"},\n            )\n\n        def download_app_yaml_schema() -&gt; Response:\n            assert (  # nosec B101\n                self.schema\n            ), \"You need to run application lifespan at first\"\n\n            return Response(\n                content=self.schema.to_yaml(),\n                headers={\n                    \"Content-Type\": \"application/octet-stream\",\n                },\n            )\n\n        def serve_asyncapi_schema(\n            sidebar: bool = True,\n            info: bool = True,\n            servers: bool = True,\n            operations: bool = True,\n            messages: bool = True,\n            schemas: bool = True,\n            errors: bool = True,\n            expandMessageExamples: bool = True,\n        ) -&gt; HTMLResponse:\n            \"\"\"Serve the AsyncAPI schema as an HTML response.\n\n            Args:\n                sidebar (bool, optional): Whether to include the sidebar in the HTML. Defaults to True.\n                info (bool, optional): Whether to include the info section in the HTML. Defaults to True.\n                servers (bool, optional): Whether to include the servers section in the HTML. Defaults to True.\n                operations (bool, optional): Whether to include the operations section in the HTML. Defaults to True.\n                messages (bool, optional): Whether to include the messages section in the HTML. Defaults to True.\n                schemas (bool, optional): Whether to include the schemas section in the HTML. Defaults to True.\n                errors (bool, optional): Whether to include the errors section in the HTML. Defaults to True.\n                expandMessageExamples (bool, optional): Whether to expand message examples in the HTML. Defaults to True.\n\n            Returns:\n                HTMLResponse: The HTML response containing the AsyncAPI schema.\n\n            Raises:\n                AssertionError: If the schema is not available.\n            !!! note\n\n                The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n            \"\"\"\n            assert (  # nosec B101\n                self.schema\n            ), \"You need to run application lifespan at first\"\n\n            return HTMLResponse(\n                content=get_asyncapi_html(\n                    self.schema,\n                    sidebar=sidebar,\n                    info=info,\n                    servers=servers,\n                    operations=operations,\n                    messages=messages,\n                    schemas=schemas,\n                    errors=errors,\n                    expand_message_examples=expandMessageExamples,\n                    title=self.schema.info.title,\n                )\n            )\n\n        docs_router = APIRouter(\n            prefix=self.prefix,\n            tags=[\"asyncapi\"],\n            redirect_slashes=self.redirect_slashes,\n            default=self.default,\n            deprecated=self.deprecated,\n        )\n        docs_router.get(schema_url)(serve_asyncapi_schema)\n        docs_router.get(f\"{schema_url}.json\")(download_app_json_schema)\n        docs_router.get(f\"{schema_url}.yaml\")(download_app_yaml_schema)\n        return docs_router\n\n    def include_router(\n        self,\n        router: \"APIRouter\",\n        *,\n        prefix: str = \"\",\n        tags: Optional[List[Union[str, Enum]]] = None,\n        dependencies: Optional[Sequence[params.Depends]] = None,\n        default_response_class: Type[Response] = Default(JSONResponse),\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        callbacks: Optional[List[BaseRoute]] = None,\n        deprecated: Optional[bool] = None,\n        include_in_schema: bool = True,\n        generate_unique_id_function: Callable[[APIRoute], str] = Default(\n            generate_unique_id\n        ),\n    ) -&gt; None:\n        \"\"\"Includes a router in the API.\n\n        Args:\n            router (APIRouter): The router to include.\n            prefix (str, optional): The prefix to prepend to all paths defined in the router. Defaults to \"\".\n            tags (List[Union[str, Enum]], optional): The tags to assign to all paths defined in the router. Defaults to None.\n            dependencies (Sequence[params.Depends], optional): The dependencies to apply to all paths defined in the router. Defaults to None.\n            default_response_class (Type[Response], optional): The default response class to use for all paths defined in the router. Defaults to Default(JSONResponse).\n            responses (Dict[Union[int, str], Dict[str, Any]], optional): The responses to define for all paths defined in the router. Defaults to None.\n            callbacks (List[BaseRoute], optional): The callbacks to apply to all paths defined in the router. Defaults to None.\n            deprecated (bool, optional): Whether the router is deprecated. Defaults to None.\n            include_in_schema (bool, optional): Whether to include the router in the API schema. Defaults to True.\n            generate_unique_id_function (Callable[[APIRoute], str], optional): The function to generate unique IDs for\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        if isinstance(router, StreamRouter):\n            self._setup_log_context(self.broker, router.broker)\n            self.broker.handlers.update(router.broker.handlers)\n            self.broker._publishers.update(router.broker._publishers)\n\n        super().include_router(\n            router=router,\n            prefix=prefix,\n            tags=tags,\n            dependencies=dependencies,\n            default_response_class=default_response_class,\n            responses=responses,\n            callbacks=callbacks,\n            deprecated=deprecated,\n            include_in_schema=include_in_schema,\n            generate_unique_id_function=generate_unique_id_function,\n        )\n\n    @staticmethod\n    @abstractmethod\n    def _setup_log_context(\n        main_broker: BrokerAsyncUsecase[MsgType, Any],\n        including_broker: BrokerAsyncUsecase[MsgType, Any],\n    ) -&gt; None:\n        \"\"\"Set up log context.\n\n        Args:\n            main_broker: The main broker.\n            including_broker: The including broker.\n\n        Returns:\n            None\n\n        Raises:\n            NotImplementedError: If the function is not implemented.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        raise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/broker/fastapi/router/StreamRouter/#faststream.broker.fastapi.router.StreamRouter.asyncapi_tags","title":"asyncapi_tags  <code>instance-attribute</code>","text":"<pre><code>asyncapi_tags = None\n</code></pre>"},{"location":"api/faststream/broker/fastapi/router/StreamRouter/#faststream.broker.fastapi.router.StreamRouter.broker","title":"broker  <code>instance-attribute</code>","text":"<pre><code>broker: BrokerAsyncUsecase[\n    MsgType, Any\n] = self.broker_class(\n    *connection_args,\n    apply_types=False,\n    tags=asyncapi_tags,\n    **connection_kwars\n)\n</code></pre>"},{"location":"api/faststream/broker/fastapi/router/StreamRouter/#faststream.broker.fastapi.router.StreamRouter.broker_class","title":"broker_class  <code>instance-attribute</code>","text":"<pre><code>broker_class: Type[BrokerAsyncUsecase[MsgType, Any]]\n</code></pre>"},{"location":"api/faststream/broker/fastapi/router/StreamRouter/#faststream.broker.fastapi.router.StreamRouter.contact","title":"contact  <code>instance-attribute</code>","text":"<pre><code>contact: Optional[AnyDict] = None\n</code></pre>"},{"location":"api/faststream/broker/fastapi/router/StreamRouter/#faststream.broker.fastapi.router.StreamRouter.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description: str = ''\n</code></pre>"},{"location":"api/faststream/broker/fastapi/router/StreamRouter/#faststream.broker.fastapi.router.StreamRouter.docs_router","title":"docs_router  <code>instance-attribute</code>","text":"<pre><code>docs_router: Optional[APIRouter] = self.asyncapi_router(\n    schema_url\n)\n</code></pre>"},{"location":"api/faststream/broker/fastapi/router/StreamRouter/#faststream.broker.fastapi.router.StreamRouter.external_docs","title":"external_docs  <code>instance-attribute</code>","text":"<pre><code>external_docs = None\n</code></pre>"},{"location":"api/faststream/broker/fastapi/router/StreamRouter/#faststream.broker.fastapi.router.StreamRouter.identifier","title":"identifier  <code>instance-attribute</code>","text":"<pre><code>identifier = None\n</code></pre>"},{"location":"api/faststream/broker/fastapi/router/StreamRouter/#faststream.broker.fastapi.router.StreamRouter.license","title":"license  <code>instance-attribute</code>","text":"<pre><code>license: Optional[AnyDict] = None\n</code></pre>"},{"location":"api/faststream/broker/fastapi/router/StreamRouter/#faststream.broker.fastapi.router.StreamRouter.schema","title":"schema  <code>instance-attribute</code>","text":"<pre><code>schema: Optional[Schema] = None\n</code></pre>"},{"location":"api/faststream/broker/fastapi/router/StreamRouter/#faststream.broker.fastapi.router.StreamRouter.setup_state","title":"setup_state  <code>instance-attribute</code>","text":"<pre><code>setup_state = setup_state\n</code></pre>"},{"location":"api/faststream/broker/fastapi/router/StreamRouter/#faststream.broker.fastapi.router.StreamRouter.terms_of_service","title":"terms_of_service  <code>instance-attribute</code>","text":"<pre><code>terms_of_service = None\n</code></pre>"},{"location":"api/faststream/broker/fastapi/router/StreamRouter/#faststream.broker.fastapi.router.StreamRouter.title","title":"title  <code>instance-attribute</code>","text":"<pre><code>title: str = ''\n</code></pre>"},{"location":"api/faststream/broker/fastapi/router/StreamRouter/#faststream.broker.fastapi.router.StreamRouter.version","title":"version  <code>instance-attribute</code>","text":"<pre><code>version: str = ''\n</code></pre>"},{"location":"api/faststream/broker/fastapi/router/StreamRouter/#faststream.broker.fastapi.router.StreamRouter.add_api_mq_route","title":"add_api_mq_route","text":"<pre><code>add_api_mq_route(\n    path: Union[NameRequired, str],\n    *extra: Union[NameRequired, str],\n    endpoint: Callable[P_HandlerParams, T_HandlerReturn],\n    dependencies: Sequence[params.Depends],\n    **broker_kwargs: Any\n) -&gt; HandlerCallWrapper[\n    MsgType, P_HandlerParams, T_HandlerReturn\n]\n</code></pre> <p>Add an API message queue route.</p> PARAMETER  DESCRIPTION <code>path</code> <p>The path of the route.</p> <p> TYPE: <code>Union[NameRequired, str]</code> </p> <code>*extra</code> <p>Additional path segments.</p> <p> TYPE: <code>Union[NameRequired, str]</code> DEFAULT: <code>()</code> </p> <code>endpoint</code> <p>The endpoint function to be called for this route.</p> <p> TYPE: <code>Callable[P_HandlerParams, T_HandlerReturn]</code> </p> <code>dependencies</code> <p>The dependencies required by the endpoint function.</p> <p> TYPE: <code>Sequence[Depends]</code> </p> <code>**broker_kwargs</code> <p>Additional keyword arguments to be passed to the broker.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn]</code> <p>The handler call wrapper for the route.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/fastapi/router.py</code> <pre><code>def add_api_mq_route(\n    self,\n    path: Union[NameRequired, str],\n    *extra: Union[NameRequired, str],\n    endpoint: Callable[P_HandlerParams, T_HandlerReturn],\n    dependencies: Sequence[params.Depends],\n    **broker_kwargs: Any,\n) -&gt; HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn]:\n    \"\"\"Add an API message queue route.\n\n    Args:\n        path: The path of the route.\n        *extra: Additional path segments.\n        endpoint: The endpoint function to be called for this route.\n        dependencies: The dependencies required by the endpoint function.\n        **broker_kwargs: Additional keyword arguments to be passed to the broker.\n\n    Returns:\n        The handler call wrapper for the route.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    route: StreamRoute[MsgType, P_HandlerParams, T_HandlerReturn] = StreamRoute(\n        path,\n        *extra,\n        endpoint=endpoint,\n        dependencies=dependencies,\n        dependency_overrides_provider=self.dependency_overrides_provider,\n        broker=self.broker,\n        **broker_kwargs,\n    )\n    self.routes.append(route)\n    return route.handler\n</code></pre>"},{"location":"api/faststream/broker/fastapi/router/StreamRouter/#faststream.broker.fastapi.router.StreamRouter.after_startup","title":"after_startup","text":"<pre><code>after_startup(\n    func: Union[\n        Callable[[AppType], Mapping[str, Any]],\n        Callable[[AppType], Awaitable[Mapping[str, Any]]],\n        Callable[[AppType], None],\n        Callable[[AppType], Awaitable[None]],\n    ]\n) -&gt; Union[\n    Callable[[AppType], Mapping[str, Any]],\n    Callable[[AppType], Awaitable[Mapping[str, Any]]],\n    Callable[[AppType], None],\n    Callable[[AppType], Awaitable[None]],\n]\n</code></pre> <p>Register a function to be executed after startup.</p> PARAMETER  DESCRIPTION <code>func</code> <p>A function to be executed after startup. It can take an <code>AppType</code> argument and return a mapping of strings to any values, or it can take an <code>AppType</code> argument and return an awaitable that resolves to a mapping of strings to any values, or it can take an <code>AppType</code> argument and return nothing, or it can take an <code>AppType</code> argument and return an awaitable that resolves to nothing.</p> <p> TYPE: <code>Union[Callable[[AppType], Mapping[str, Any]], Callable[[AppType], Awaitable[Mapping[str, Any]]], Callable[[AppType], None], Callable[[AppType], Awaitable[None]]]</code> </p> RETURNS DESCRIPTION <code>Union[Callable[[AppType], Mapping[str, Any]], Callable[[AppType], Awaitable[Mapping[str, Any]]], Callable[[AppType], None], Callable[[AppType], Awaitable[None]]]</code> <p>The registered function.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/fastapi/router.py</code> <pre><code>def after_startup(\n    self,\n    func: Union[\n        Callable[[AppType], Mapping[str, Any]],\n        Callable[[AppType], Awaitable[Mapping[str, Any]]],\n        Callable[[AppType], None],\n        Callable[[AppType], Awaitable[None]],\n    ],\n) -&gt; Union[\n    Callable[[AppType], Mapping[str, Any]],\n    Callable[[AppType], Awaitable[Mapping[str, Any]]],\n    Callable[[AppType], None],\n    Callable[[AppType], Awaitable[None]],\n]:\n    \"\"\"Register a function to be executed after startup.\n\n    Args:\n        func: A function to be executed after startup. It can take an `AppType` argument and return a mapping of strings to any values, or it can take an `AppType` argument and return an awaitable that resolves to a mapping of strings to any values, or it can take an `AppType` argument and return nothing, or it can take an `AppType` argument and return an awaitable that resolves to nothing.\n\n    Returns:\n        The registered function.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    self._after_startup_hooks.append(to_async(func))  # type: ignore\n    return func\n</code></pre>"},{"location":"api/faststream/broker/fastapi/router/StreamRouter/#faststream.broker.fastapi.router.StreamRouter.asyncapi_router","title":"asyncapi_router","text":"<pre><code>asyncapi_router(\n    schema_url: Optional[str],\n) -&gt; Optional[APIRouter]\n</code></pre> <p>Creates an API router for serving AsyncAPI documentation.</p> PARAMETER  DESCRIPTION <code>schema_url</code> <p>The URL where the AsyncAPI schema will be served.</p> <p> TYPE: <code>Optional[str]</code> </p> RETURNS DESCRIPTION <code>Optional[APIRouter]</code> <p>An instance of APIRouter if include_in_schema and schema_url are both True, otherwise returns None.</p> RAISES DESCRIPTION <code>AssertionError</code> <p>If self.schema is not set.</p> Notes <p>This function defines three nested functions: download_app_json_schema, download_app_yaml_schema, and serve_asyncapi_schema. These functions are used to handle different routes for serving the AsyncAPI schema and documentation.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/fastapi/router.py</code> <pre><code>def asyncapi_router(self, schema_url: Optional[str]) -&gt; Optional[APIRouter]:\n    \"\"\"Creates an API router for serving AsyncAPI documentation.\n\n    Args:\n        schema_url: The URL where the AsyncAPI schema will be served.\n\n    Returns:\n        An instance of APIRouter if include_in_schema and schema_url are both True, otherwise returns None.\n\n    Raises:\n        AssertionError: If self.schema is not set.\n\n    Notes:\n        This function defines three nested functions: download_app_json_schema, download_app_yaml_schema, and serve_asyncapi_schema. These functions are used to handle different routes for serving the AsyncAPI schema and documentation.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    if not self.include_in_schema or not schema_url:\n        return None\n\n    def download_app_json_schema() -&gt; Response:\n        assert (  # nosec B101\n            self.schema\n        ), \"You need to run application lifespan at first\"\n\n        return Response(\n            content=json.dumps(self.schema.to_jsonable(), indent=4),\n            headers={\"Content-Type\": \"application/octet-stream\"},\n        )\n\n    def download_app_yaml_schema() -&gt; Response:\n        assert (  # nosec B101\n            self.schema\n        ), \"You need to run application lifespan at first\"\n\n        return Response(\n            content=self.schema.to_yaml(),\n            headers={\n                \"Content-Type\": \"application/octet-stream\",\n            },\n        )\n\n    def serve_asyncapi_schema(\n        sidebar: bool = True,\n        info: bool = True,\n        servers: bool = True,\n        operations: bool = True,\n        messages: bool = True,\n        schemas: bool = True,\n        errors: bool = True,\n        expandMessageExamples: bool = True,\n    ) -&gt; HTMLResponse:\n        \"\"\"Serve the AsyncAPI schema as an HTML response.\n\n        Args:\n            sidebar (bool, optional): Whether to include the sidebar in the HTML. Defaults to True.\n            info (bool, optional): Whether to include the info section in the HTML. Defaults to True.\n            servers (bool, optional): Whether to include the servers section in the HTML. Defaults to True.\n            operations (bool, optional): Whether to include the operations section in the HTML. Defaults to True.\n            messages (bool, optional): Whether to include the messages section in the HTML. Defaults to True.\n            schemas (bool, optional): Whether to include the schemas section in the HTML. Defaults to True.\n            errors (bool, optional): Whether to include the errors section in the HTML. Defaults to True.\n            expandMessageExamples (bool, optional): Whether to expand message examples in the HTML. Defaults to True.\n\n        Returns:\n            HTMLResponse: The HTML response containing the AsyncAPI schema.\n\n        Raises:\n            AssertionError: If the schema is not available.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        assert (  # nosec B101\n            self.schema\n        ), \"You need to run application lifespan at first\"\n\n        return HTMLResponse(\n            content=get_asyncapi_html(\n                self.schema,\n                sidebar=sidebar,\n                info=info,\n                servers=servers,\n                operations=operations,\n                messages=messages,\n                schemas=schemas,\n                errors=errors,\n                expand_message_examples=expandMessageExamples,\n                title=self.schema.info.title,\n            )\n        )\n\n    docs_router = APIRouter(\n        prefix=self.prefix,\n        tags=[\"asyncapi\"],\n        redirect_slashes=self.redirect_slashes,\n        default=self.default,\n        deprecated=self.deprecated,\n    )\n    docs_router.get(schema_url)(serve_asyncapi_schema)\n    docs_router.get(f\"{schema_url}.json\")(download_app_json_schema)\n    docs_router.get(f\"{schema_url}.yaml\")(download_app_yaml_schema)\n    return docs_router\n</code></pre>"},{"location":"api/faststream/broker/fastapi/router/StreamRouter/#faststream.broker.fastapi.router.StreamRouter.include_router","title":"include_router","text":"<pre><code>include_router(\n    router: APIRouter,\n    *,\n    prefix: str = \"\",\n    tags: Optional[List[Union[str, Enum]]] = None,\n    dependencies: Optional[Sequence[params.Depends]] = None,\n    default_response_class: Type[Response] = Default(\n        JSONResponse\n    ),\n    responses: Optional[\n        Dict[Union[int, str], Dict[str, Any]]\n    ] = None,\n    callbacks: Optional[List[BaseRoute]] = None,\n    deprecated: Optional[bool] = None,\n    include_in_schema: bool = True,\n    generate_unique_id_function: Callable[\n        [APIRoute], str\n    ] = Default(generate_unique_id)\n) -&gt; None\n</code></pre> <p>Includes a router in the API.</p> PARAMETER  DESCRIPTION <code>router</code> <p>The router to include.</p> <p> TYPE: <code>APIRouter</code> </p> <code>prefix</code> <p>The prefix to prepend to all paths defined in the router. Defaults to \"\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>tags</code> <p>The tags to assign to all paths defined in the router. Defaults to None.</p> <p> TYPE: <code>List[Union[str, Enum]]</code> DEFAULT: <code>None</code> </p> <code>dependencies</code> <p>The dependencies to apply to all paths defined in the router. Defaults to None.</p> <p> TYPE: <code>Sequence[Depends]</code> DEFAULT: <code>None</code> </p> <code>default_response_class</code> <p>The default response class to use for all paths defined in the router. Defaults to Default(JSONResponse).</p> <p> TYPE: <code>Type[Response]</code> DEFAULT: <code>Default(JSONResponse)</code> </p> <code>responses</code> <p>The responses to define for all paths defined in the router. Defaults to None.</p> <p> TYPE: <code>Dict[Union[int, str], Dict[str, Any]]</code> DEFAULT: <code>None</code> </p> <code>callbacks</code> <p>The callbacks to apply to all paths defined in the router. Defaults to None.</p> <p> TYPE: <code>List[BaseRoute]</code> DEFAULT: <code>None</code> </p> <code>deprecated</code> <p>Whether the router is deprecated. Defaults to None.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>None</code> </p> <code>include_in_schema</code> <p>Whether to include the router in the API schema. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>generate_unique_id_function</code> <p>The function to generate unique IDs for</p> <p> TYPE: <code>Callable[[APIRoute], str]</code> DEFAULT: <code>Default(generate_unique_id)</code> </p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/fastapi/router.py</code> <pre><code>def include_router(\n    self,\n    router: \"APIRouter\",\n    *,\n    prefix: str = \"\",\n    tags: Optional[List[Union[str, Enum]]] = None,\n    dependencies: Optional[Sequence[params.Depends]] = None,\n    default_response_class: Type[Response] = Default(JSONResponse),\n    responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n    callbacks: Optional[List[BaseRoute]] = None,\n    deprecated: Optional[bool] = None,\n    include_in_schema: bool = True,\n    generate_unique_id_function: Callable[[APIRoute], str] = Default(\n        generate_unique_id\n    ),\n) -&gt; None:\n    \"\"\"Includes a router in the API.\n\n    Args:\n        router (APIRouter): The router to include.\n        prefix (str, optional): The prefix to prepend to all paths defined in the router. Defaults to \"\".\n        tags (List[Union[str, Enum]], optional): The tags to assign to all paths defined in the router. Defaults to None.\n        dependencies (Sequence[params.Depends], optional): The dependencies to apply to all paths defined in the router. Defaults to None.\n        default_response_class (Type[Response], optional): The default response class to use for all paths defined in the router. Defaults to Default(JSONResponse).\n        responses (Dict[Union[int, str], Dict[str, Any]], optional): The responses to define for all paths defined in the router. Defaults to None.\n        callbacks (List[BaseRoute], optional): The callbacks to apply to all paths defined in the router. Defaults to None.\n        deprecated (bool, optional): Whether the router is deprecated. Defaults to None.\n        include_in_schema (bool, optional): Whether to include the router in the API schema. Defaults to True.\n        generate_unique_id_function (Callable[[APIRoute], str], optional): The function to generate unique IDs for\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    if isinstance(router, StreamRouter):\n        self._setup_log_context(self.broker, router.broker)\n        self.broker.handlers.update(router.broker.handlers)\n        self.broker._publishers.update(router.broker._publishers)\n\n    super().include_router(\n        router=router,\n        prefix=prefix,\n        tags=tags,\n        dependencies=dependencies,\n        default_response_class=default_response_class,\n        responses=responses,\n        callbacks=callbacks,\n        deprecated=deprecated,\n        include_in_schema=include_in_schema,\n        generate_unique_id_function=generate_unique_id_function,\n    )\n</code></pre>"},{"location":"api/faststream/broker/fastapi/router/StreamRouter/#faststream.broker.fastapi.router.StreamRouter.publisher","title":"publisher","text":"<pre><code>publisher(\n    queue: Union[NameRequired, str],\n    *publisher_args: Any,\n    **publisher_kwargs: Any\n) -&gt; BasePublisher[MsgType]\n</code></pre> <p>Publishes messages to a queue.</p> PARAMETER  DESCRIPTION <code>queue</code> <p>The queue to publish the messages to. Can be either a <code>NameRequired</code> object or a string.</p> <p> TYPE: <code>Union[NameRequired, str]</code> </p> <code>*publisher_args</code> <p>Additional arguments to be passed to the publisher.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>()</code> </p> <code>**publisher_kwargs</code> <p>Additional keyword arguments to be passed to the publisher.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>BasePublisher[MsgType]</code> <p>An instance of <code>BasePublisher</code> that can be used to publish messages to the specified queue.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/fastapi/router.py</code> <pre><code>def publisher(\n    self,\n    queue: Union[NameRequired, str],\n    *publisher_args: Any,\n    **publisher_kwargs: Any,\n) -&gt; BasePublisher[MsgType]:\n    \"\"\"Publishes messages to a queue.\n\n    Args:\n        queue: The queue to publish the messages to. Can be either a `NameRequired` object or a string.\n        *publisher_args: Additional arguments to be passed to the publisher.\n        **publisher_kwargs: Additional keyword arguments to be passed to the publisher.\n\n    Returns:\n        An instance of `BasePublisher` that can be used to publish messages to the specified queue.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    return self.broker.publisher(\n        queue,\n        *publisher_args,\n        **publisher_kwargs,\n    )\n</code></pre>"},{"location":"api/faststream/broker/fastapi/router/StreamRouter/#faststream.broker.fastapi.router.StreamRouter.subscriber","title":"subscriber","text":"<pre><code>subscriber(\n    path: Union[str, NameRequired],\n    *extra: Union[NameRequired, str],\n    dependencies: Optional[Sequence[params.Depends]] = None,\n    **broker_kwargs: Any\n) -&gt; Callable[\n    [Callable[P_HandlerParams, T_HandlerReturn]],\n    HandlerCallWrapper[\n        MsgType, P_HandlerParams, T_HandlerReturn\n    ],\n]\n</code></pre> <p>A function decorator for subscribing to a message queue.</p> PARAMETER  DESCRIPTION <code>path</code> <p>The path to subscribe to. Can be a string or a <code>NameRequired</code> object.</p> <p> </p> <code>*extra</code> <p>Additional path segments. Can be a <code>NameRequired</code> object or a string.</p> <p> DEFAULT: <code>()</code> </p> <code>dependencies</code> <p>Optional sequence of dependencies.</p> <p> DEFAULT: <code>None</code> </p> <code>**broker_kwargs</code> <p>Additional keyword arguments for the broker.</p> <p> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Callable[[Callable[P_HandlerParams, T_HandlerReturn]], HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn]]</code> <p>A callable decorator that adds the decorated function as an endpoint for the specified path.</p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>If silent animals are not supported.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/fastapi/router.py</code> <pre><code>def subscriber(\n    self,\n    path: Union[str, NameRequired],\n    *extra: Union[NameRequired, str],\n    dependencies: Optional[Sequence[params.Depends]] = None,\n    **broker_kwargs: Any,\n) -&gt; Callable[\n    [Callable[P_HandlerParams, T_HandlerReturn]],\n    HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn],\n]:\n    \"\"\"A function decorator for subscribing to a message queue.\n\n    Args:\n        path : The path to subscribe to. Can be a string or a `NameRequired` object.\n        *extra : Additional path segments. Can be a `NameRequired` object or a string.\n        dependencies : Optional sequence of dependencies.\n        **broker_kwargs : Additional keyword arguments for the broker.\n\n    Returns:\n        A callable decorator that adds the decorated function as an endpoint for the specified path.\n\n    Raises:\n        NotImplementedError: If silent animals are not supported.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    current_dependencies = self.dependencies.copy()\n    if dependencies:\n        current_dependencies.extend(dependencies)\n\n    def decorator(\n        func: Callable[P_HandlerParams, T_HandlerReturn],\n    ) -&gt; HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn]:\n        \"\"\"A decorator function.\n\n        Args:\n            func: The function to be decorated.\n\n        Returns:\n            The decorated function.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        return self.add_api_mq_route(\n            path,\n            *extra,\n            endpoint=func,\n            dependencies=current_dependencies,\n            **broker_kwargs,\n        )\n\n    return decorator\n</code></pre>"},{"location":"api/faststream/broker/fastapi/router/StreamRouter/#faststream.broker.fastapi.router.StreamRouter.wrap_lifespan","title":"wrap_lifespan","text":"<pre><code>wrap_lifespan(\n    lifespan: Optional[Lifespan[Any]] = None,\n) -&gt; Lifespan[Any]\n</code></pre> <p>Wrap the lifespan of the application.</p> PARAMETER  DESCRIPTION <code>lifespan</code> <p>Optional lifespan object.</p> <p> TYPE: <code>Optional[Lifespan[Any]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Lifespan[Any]</code> <p>The wrapped lifespan object.</p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>If silent animals are not supported.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/fastapi/router.py</code> <pre><code>def wrap_lifespan(self, lifespan: Optional[Lifespan[Any]] = None) -&gt; Lifespan[Any]:\n    \"\"\"Wrap the lifespan of the application.\n\n    Args:\n        lifespan: Optional lifespan object.\n\n    Returns:\n        The wrapped lifespan object.\n\n    Raises:\n        NotImplementedError: If silent animals are not supported.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    if lifespan is not None:\n        lifespan_context = lifespan\n    else:\n        lifespan_context = _DefaultLifespan(self)\n\n    @asynccontextmanager\n    async def start_broker_lifespan(\n        app: FastAPI,\n    ) -&gt; AsyncIterator[Mapping[str, Any]]:\n        \"\"\"Starts the lifespan of a broker.\n\n        Args:\n            app (FastAPI): The FastAPI application.\n\n        Yields:\n            AsyncIterator[Mapping[str, Any]]: A mapping of context information during the lifespan of the broker.\n\n        Raises:\n            NotImplementedError: If silent animals are not supported.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        from faststream.asyncapi.generate import get_app_schema\n\n        self.title = app.title\n        self.description = app.description\n        self.version = app.version\n        self.contact = app.contact\n        self.license = app.license_info\n\n        self.schema = get_app_schema(self)\n        if self.docs_router:\n            app.include_router(self.docs_router)\n\n        async with lifespan_context(app) as maybe_context:\n            if maybe_context is None:\n                context: AnyDict = {}\n            else:\n                context = dict(maybe_context)\n\n            context.update({\"broker\": self.broker})\n            await self.broker.start()\n\n            for h in self._after_startup_hooks:\n                h_context = await h(app)\n                if h_context:  # pragma: no branch\n                    context.update(h_context)\n\n            try:\n                if self.setup_state:\n                    yield context\n                else:\n                    # NOTE: old asgi compatibility\n                    yield  # type: ignore\n\n            finally:\n                await self.broker.close()\n\n    return start_broker_lifespan\n</code></pre>"},{"location":"api/faststream/broker/handler/AsyncHandler/","title":"AsyncHandler","text":""},{"location":"api/faststream/broker/handler/AsyncHandler/#faststream.broker.handler.AsyncHandler","title":"faststream.broker.handler.AsyncHandler","text":"<p>             Bases: <code>BaseHandler[MsgType]</code></p> <p>A class representing an asynchronous handler.</p> METHOD DESCRIPTION <code>add_call </code> <p>adds a new call to the list of calls</p> <code>consume </code> <p>consumes a message and returns a sendable message</p> <code>start </code> <p>starts the handler</p> <code>close </code> <p>closes the handler</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/handler.py</code> <pre><code>class AsyncHandler(BaseHandler[MsgType]):\n    \"\"\"A class representing an asynchronous handler.\n\n    Attributes:\n        calls : a list of tuples containing the following information:\n            - handler : the handler function\n            - filter : a callable that filters the stream message\n            - parser : an async parser for the message\n            - decoder : an async decoder for the message\n            - middlewares : a sequence of middlewares\n            - dependant : a call model for the handler\n\n    Methods:\n        add_call : adds a new call to the list of calls\n        consume : consumes a message and returns a sendable message\n        start : starts the handler\n        close : closes the handler\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    calls: List[\n        Tuple[\n            HandlerCallWrapper[MsgType, Any, SendableMessage],  # handler\n            Callable[[StreamMessage[MsgType]], Awaitable[bool]],  # filter\n            AsyncParser[MsgType, Any],  # parser\n            AsyncDecoder[StreamMessage[MsgType]],  # decoder\n            Sequence[Callable[[Any], BaseMiddleware]],  # middlewares\n            CallModel[Any, SendableMessage],  # dependant\n        ]\n    ]\n\n    def add_call(\n        self,\n        *,\n        handler: HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn],\n        parser: CustomParser[MsgType, Any],\n        decoder: CustomDecoder[Any],\n        dependant: CallModel[P_HandlerParams, T_HandlerReturn],\n        filter: Filter[StreamMessage[MsgType]],\n        middlewares: Optional[Sequence[Callable[[Any], BaseMiddleware]]],\n    ) -&gt; None:\n        \"\"\"Adds a call to the handler.\n\n        Args:\n            handler: The handler call wrapper.\n            parser: The custom parser.\n            decoder: The custom decoder.\n            dependant: The call model.\n            filter: The filter for stream messages.\n            middlewares: Optional sequence of middlewares.\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        self.calls.append(\n            (  # type: ignore[arg-type]\n                handler,\n                to_async(filter),\n                to_async(parser) if parser else None,\n                to_async(decoder) if decoder else None,\n                middlewares or (),\n                dependant,\n            )\n        )\n\n    @override\n    async def consume(self, msg: MsgType) -&gt; SendableMessage:  # type: ignore[override]\n        \"\"\"Consume a message asynchronously.\n\n        Args:\n            msg: The message to be consumed.\n\n        Returns:\n            The sendable message.\n\n        Raises:\n            StopConsume: If the consumption needs to be stopped.\n\n        Raises:\n            Exception: If an error occurs during consumption.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        result: Optional[WrappedReturn[SendableMessage]] = None\n        result_msg: SendableMessage = None\n\n        async with AsyncExitStack() as stack:\n            gl_middlewares: List[BaseMiddleware] = []\n\n            for m in self.global_middlewares:\n                gl_middlewares.append(await stack.enter_async_context(m(msg)))\n\n            logged = False\n            processed = False\n            for handler, filter_, parser, decoder, middlewares, _ in self.calls:\n                local_middlewares: List[BaseMiddleware] = []\n                for local_m in middlewares:\n                    local_middlewares.append(\n                        await stack.enter_async_context(local_m(msg))\n                    )\n\n                all_middlewares = gl_middlewares + local_middlewares\n\n                # TODO: add parser &amp; decoder cashes\n                message = await parser(msg)\n\n                if not logged:\n                    log_context_tag = context.set_local(\n                        \"log_context\", self.log_context_builder(message)\n                    )\n\n                message.decoded_body = await decoder(message)\n                message.processed = processed\n\n                if await filter_(message):\n                    assert (  # nosec B101\n                        not processed\n                    ), \"You can't proccess a message with multiple consumers\"\n\n                    try:\n                        async with AsyncExitStack() as consume_stack:\n                            for m_consume in all_middlewares:\n                                message.decoded_body = (\n                                    await consume_stack.enter_async_context(\n                                        m_consume.consume_scope(message.decoded_body)\n                                    )\n                                )\n\n                            result = await cast(\n                                Awaitable[Optional[WrappedReturn[SendableMessage]]],\n                                handler.call_wrapped(message),\n                            )\n\n                        if result is not None:\n                            result_msg, pub_response = result\n\n                            # TODO: suppress all publishing errors and raise them after all publishers will be tried\n                            for publisher in (pub_response, *handler._publishers):\n                                if publisher is not None:\n                                    async with AsyncExitStack() as pub_stack:\n                                        result_to_send = result_msg\n\n                                        for m_pub in all_middlewares:\n                                            result_to_send = (\n                                                await pub_stack.enter_async_context(\n                                                    m_pub.publish_scope(result_msg)\n                                                )\n                                            )\n\n                                        await publisher.publish(\n                                            message=result_to_send,\n                                            correlation_id=message.correlation_id,\n                                        )\n\n                    except StopConsume:\n                        await self.close()\n                        handler.trigger()\n\n                    except HandlerException as e:\n                        handler.trigger()\n                        raise e\n\n                    except Exception as e:\n                        handler.trigger(error=e)\n                        raise e\n\n                    else:\n                        handler.trigger(result=result[0] if result else None)\n                        message.processed = processed = True\n                        if IS_OPTIMIZED:  # pragma: no cover\n                            break\n\n            assert processed, \"You have to consume message\"  # nosec B101\n\n        context.reset_local(\"log_context\", log_context_tag)\n        return result_msg\n\n    @abstractmethod\n    async def start(self) -&gt; None:\n        raise NotImplementedError()\n\n    @abstractmethod\n    async def close(self) -&gt; None:\n        raise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/broker/handler/AsyncHandler/#faststream.broker.handler.AsyncHandler.calls","title":"calls  <code>instance-attribute</code>","text":"<pre><code>calls: List[\n    Tuple[\n        HandlerCallWrapper[MsgType, Any, SendableMessage],\n        Callable[[StreamMessage[MsgType]], Awaitable[bool]],\n        AsyncParser[MsgType, Any],\n        AsyncDecoder[StreamMessage[MsgType]],\n        Sequence[Callable[[Any], BaseMiddleware]],\n        CallModel[Any, SendableMessage],\n    ]\n]\n</code></pre>"},{"location":"api/faststream/broker/handler/AsyncHandler/#faststream.broker.handler.AsyncHandler.add_call","title":"add_call","text":"<pre><code>add_call(\n    *,\n    handler: HandlerCallWrapper[\n        MsgType, P_HandlerParams, T_HandlerReturn\n    ],\n    parser: CustomParser[MsgType, Any],\n    decoder: CustomDecoder[Any],\n    dependant: CallModel[P_HandlerParams, T_HandlerReturn],\n    filter: Filter[StreamMessage[MsgType]],\n    middlewares: Optional[\n        Sequence[Callable[[Any], BaseMiddleware]]\n    ]\n) -&gt; None\n</code></pre> <p>Adds a call to the handler.</p> PARAMETER  DESCRIPTION <code>handler</code> <p>The handler call wrapper.</p> <p> TYPE: <code>HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn]</code> </p> <code>parser</code> <p>The custom parser.</p> <p> TYPE: <code>CustomParser[MsgType, Any]</code> </p> <code>decoder</code> <p>The custom decoder.</p> <p> TYPE: <code>CustomDecoder[Any]</code> </p> <code>dependant</code> <p>The call model.</p> <p> TYPE: <code>CallModel[P_HandlerParams, T_HandlerReturn]</code> </p> <code>filter</code> <p>The filter for stream messages.</p> <p> TYPE: <code>Filter[StreamMessage[MsgType]]</code> </p> <code>middlewares</code> <p>Optional sequence of middlewares.</p> <p> TYPE: <code>Optional[Sequence[Callable[[Any], BaseMiddleware]]]</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/handler.py</code> <pre><code>def add_call(\n    self,\n    *,\n    handler: HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn],\n    parser: CustomParser[MsgType, Any],\n    decoder: CustomDecoder[Any],\n    dependant: CallModel[P_HandlerParams, T_HandlerReturn],\n    filter: Filter[StreamMessage[MsgType]],\n    middlewares: Optional[Sequence[Callable[[Any], BaseMiddleware]]],\n) -&gt; None:\n    \"\"\"Adds a call to the handler.\n\n    Args:\n        handler: The handler call wrapper.\n        parser: The custom parser.\n        decoder: The custom decoder.\n        dependant: The call model.\n        filter: The filter for stream messages.\n        middlewares: Optional sequence of middlewares.\n\n    Returns:\n        None\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    self.calls.append(\n        (  # type: ignore[arg-type]\n            handler,\n            to_async(filter),\n            to_async(parser) if parser else None,\n            to_async(decoder) if decoder else None,\n            middlewares or (),\n            dependant,\n        )\n    )\n</code></pre>"},{"location":"api/faststream/broker/handler/AsyncHandler/#faststream.broker.handler.AsyncHandler.close","title":"close  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>close() -&gt; None\n</code></pre> Source code in <code>faststream/broker/handler.py</code> <pre><code>@abstractmethod\nasync def close(self) -&gt; None:\n    raise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/broker/handler/AsyncHandler/#faststream.broker.handler.AsyncHandler.consume","title":"consume  <code>async</code>","text":"<pre><code>consume(msg: MsgType) -&gt; SendableMessage\n</code></pre> <p>Consume a message asynchronously.</p> PARAMETER  DESCRIPTION <code>msg</code> <p>The message to be consumed.</p> <p> TYPE: <code>MsgType</code> </p> RETURNS DESCRIPTION <code>SendableMessage</code> <p>The sendable message.</p> RAISES DESCRIPTION <code>StopConsume</code> <p>If the consumption needs to be stopped.</p> RAISES DESCRIPTION <code>Exception</code> <p>If an error occurs during consumption.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/handler.py</code> <pre><code>@override\nasync def consume(self, msg: MsgType) -&gt; SendableMessage:  # type: ignore[override]\n    \"\"\"Consume a message asynchronously.\n\n    Args:\n        msg: The message to be consumed.\n\n    Returns:\n        The sendable message.\n\n    Raises:\n        StopConsume: If the consumption needs to be stopped.\n\n    Raises:\n        Exception: If an error occurs during consumption.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    result: Optional[WrappedReturn[SendableMessage]] = None\n    result_msg: SendableMessage = None\n\n    async with AsyncExitStack() as stack:\n        gl_middlewares: List[BaseMiddleware] = []\n\n        for m in self.global_middlewares:\n            gl_middlewares.append(await stack.enter_async_context(m(msg)))\n\n        logged = False\n        processed = False\n        for handler, filter_, parser, decoder, middlewares, _ in self.calls:\n            local_middlewares: List[BaseMiddleware] = []\n            for local_m in middlewares:\n                local_middlewares.append(\n                    await stack.enter_async_context(local_m(msg))\n                )\n\n            all_middlewares = gl_middlewares + local_middlewares\n\n            # TODO: add parser &amp; decoder cashes\n            message = await parser(msg)\n\n            if not logged:\n                log_context_tag = context.set_local(\n                    \"log_context\", self.log_context_builder(message)\n                )\n\n            message.decoded_body = await decoder(message)\n            message.processed = processed\n\n            if await filter_(message):\n                assert (  # nosec B101\n                    not processed\n                ), \"You can't proccess a message with multiple consumers\"\n\n                try:\n                    async with AsyncExitStack() as consume_stack:\n                        for m_consume in all_middlewares:\n                            message.decoded_body = (\n                                await consume_stack.enter_async_context(\n                                    m_consume.consume_scope(message.decoded_body)\n                                )\n                            )\n\n                        result = await cast(\n                            Awaitable[Optional[WrappedReturn[SendableMessage]]],\n                            handler.call_wrapped(message),\n                        )\n\n                    if result is not None:\n                        result_msg, pub_response = result\n\n                        # TODO: suppress all publishing errors and raise them after all publishers will be tried\n                        for publisher in (pub_response, *handler._publishers):\n                            if publisher is not None:\n                                async with AsyncExitStack() as pub_stack:\n                                    result_to_send = result_msg\n\n                                    for m_pub in all_middlewares:\n                                        result_to_send = (\n                                            await pub_stack.enter_async_context(\n                                                m_pub.publish_scope(result_msg)\n                                            )\n                                        )\n\n                                    await publisher.publish(\n                                        message=result_to_send,\n                                        correlation_id=message.correlation_id,\n                                    )\n\n                except StopConsume:\n                    await self.close()\n                    handler.trigger()\n\n                except HandlerException as e:\n                    handler.trigger()\n                    raise e\n\n                except Exception as e:\n                    handler.trigger(error=e)\n                    raise e\n\n                else:\n                    handler.trigger(result=result[0] if result else None)\n                    message.processed = processed = True\n                    if IS_OPTIMIZED:  # pragma: no cover\n                        break\n\n        assert processed, \"You have to consume message\"  # nosec B101\n\n    context.reset_local(\"log_context\", log_context_tag)\n    return result_msg\n</code></pre>"},{"location":"api/faststream/broker/handler/AsyncHandler/#faststream.broker.handler.AsyncHandler.start","title":"start  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>start() -&gt; None\n</code></pre> Source code in <code>faststream/broker/handler.py</code> <pre><code>@abstractmethod\nasync def start(self) -&gt; None:\n    raise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/broker/handler/BaseHandler/","title":"BaseHandler","text":""},{"location":"api/faststream/broker/handler/BaseHandler/#faststream.broker.handler.BaseHandler","title":"faststream.broker.handler.BaseHandler","text":"<p>             Bases: <code>AsyncAPIOperation</code>, <code>Generic[MsgType]</code></p> <p>A base handler class for asynchronous API operations.</p> METHOD DESCRIPTION <code>__init__ </code> <p>Initializes the BaseHandler object.</p> <code>name </code> <p>Returns the name of the handler.</p> <code>call_name </code> <p>Returns the name of the handler call.</p> <code>description </code> <p>Returns the description of the handler.</p> <code>consume </code> <p>Abstract method to consume a message.</p> <p>Note: This class inherits from AsyncAPIOperation and is a generic class with type parameter MsgType.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/handler.py</code> <pre><code>class BaseHandler(AsyncAPIOperation, Generic[MsgType]):\n    \"\"\"A base handler class for asynchronous API operations.\n\n    Attributes:\n        calls : List of tuples representing handler calls, filters, parsers, decoders, middlewares, and dependants.\n        global_middlewares : Sequence of global middlewares.\n\n    Methods:\n        __init__ : Initializes the BaseHandler object.\n        name : Returns the name of the handler.\n        call_name : Returns the name of the handler call.\n        description : Returns the description of the handler.\n        consume : Abstract method to consume a message.\n\n    Note: This class inherits from AsyncAPIOperation and is a generic class with type parameter MsgType.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    calls: Union[\n        List[\n            Tuple[\n                HandlerCallWrapper[MsgType, Any, SendableMessage],  # handler\n                Callable[[StreamMessage[MsgType]], bool],  # filter\n                SyncParser[MsgType, StreamMessage[MsgType]],  # parser\n                SyncDecoder[StreamMessage[MsgType]],  # decoder\n                Sequence[Callable[[Any], BaseMiddleware]],  # middlewares\n                CallModel[Any, SendableMessage],  # dependant\n            ]\n        ],\n        List[\n            Tuple[\n                HandlerCallWrapper[MsgType, Any, SendableMessage],  # handler\n                Callable[[StreamMessage[MsgType]], Awaitable[bool]],  # filter\n                AsyncParser[MsgType, StreamMessage[MsgType]],  # parser\n                AsyncDecoder[StreamMessage[MsgType]],  # decoder\n                Sequence[Callable[[Any], BaseMiddleware]],  # middlewares\n                CallModel[Any, SendableMessage],  # dependant\n            ]\n        ],\n    ]\n\n    global_middlewares: Sequence[Callable[[Any], BaseMiddleware]]\n\n    def __init__(\n        self,\n        *,\n        log_context_builder: Callable[[StreamMessage[Any]], Dict[str, str]],\n        description: Optional[str] = None,\n        title: Optional[str] = None,\n    ):\n        \"\"\"Initialize a new instance of the class.\n\n        Args:\n            description: Optional description of the instance.\n            title: Optional title of the instance.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        self.calls = []  # type: ignore[assignment]\n        self.global_middlewares = []\n        # AsyncAPI information\n        self._description = description\n        self._title = title\n        self.log_context_builder = log_context_builder\n\n    @override\n    @property\n    def name(self) -&gt; Union[str, bool]:  # type: ignore[override]\n        if self._title:\n            return self._title\n\n        if not self.calls:  # pragma: no cover\n            return False\n\n        else:\n            return True\n\n    @property\n    def call_name(self) -&gt; str:\n        caller = self.calls[0][0]._original_call\n        name = getattr(caller, \"__name__\", str(caller))\n        return to_camelcase(name)\n\n    @property\n    def description(self) -&gt; Optional[str]:\n        if not self.calls:  # pragma: no cover\n            description = None\n\n        else:\n            caller = self.calls[0][0]._original_call\n            description = getattr(caller, \"__doc__\", None)\n\n        return self._description or description\n\n    @abstractmethod\n    def consume(self, msg: MsgType) -&gt; SendableMessage:\n        \"\"\"Consume a message.\n\n        Args:\n            msg: The message to be consumed.\n\n        Returns:\n            The sendable message.\n\n        Raises:\n            NotImplementedError: If the method is not implemented.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        raise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/broker/handler/BaseHandler/#faststream.broker.handler.BaseHandler.call_name","title":"call_name  <code>property</code>","text":"<pre><code>call_name: str\n</code></pre>"},{"location":"api/faststream/broker/handler/BaseHandler/#faststream.broker.handler.BaseHandler.calls","title":"calls  <code>instance-attribute</code>","text":"<pre><code>calls: Union[\n    List[\n        Tuple[\n            HandlerCallWrapper[\n                MsgType, Any, SendableMessage\n            ],\n            Callable[[StreamMessage[MsgType]], bool],\n            SyncParser[MsgType, StreamMessage[MsgType]],\n            SyncDecoder[StreamMessage[MsgType]],\n            Sequence[Callable[[Any], BaseMiddleware]],\n            CallModel[Any, SendableMessage],\n        ]\n    ],\n    List[\n        Tuple[\n            HandlerCallWrapper[\n                MsgType, Any, SendableMessage\n            ],\n            Callable[\n                [StreamMessage[MsgType]], Awaitable[bool]\n            ],\n            AsyncParser[MsgType, StreamMessage[MsgType]],\n            AsyncDecoder[StreamMessage[MsgType]],\n            Sequence[Callable[[Any], BaseMiddleware]],\n            CallModel[Any, SendableMessage],\n        ]\n    ],\n] = []\n</code></pre>"},{"location":"api/faststream/broker/handler/BaseHandler/#faststream.broker.handler.BaseHandler.description","title":"description  <code>property</code>","text":"<pre><code>description: Optional[str]\n</code></pre>"},{"location":"api/faststream/broker/handler/BaseHandler/#faststream.broker.handler.BaseHandler.global_middlewares","title":"global_middlewares  <code>instance-attribute</code>","text":"<pre><code>global_middlewares: Sequence[\n    Callable[[Any], BaseMiddleware]\n] = []\n</code></pre>"},{"location":"api/faststream/broker/handler/BaseHandler/#faststream.broker.handler.BaseHandler.log_context_builder","title":"log_context_builder  <code>instance-attribute</code>","text":"<pre><code>log_context_builder = log_context_builder\n</code></pre>"},{"location":"api/faststream/broker/handler/BaseHandler/#faststream.broker.handler.BaseHandler.name","title":"name  <code>property</code>","text":"<pre><code>name: Union[str, bool]\n</code></pre>"},{"location":"api/faststream/broker/handler/BaseHandler/#faststream.broker.handler.BaseHandler.consume","title":"consume  <code>abstractmethod</code>","text":"<pre><code>consume(msg: MsgType) -&gt; SendableMessage\n</code></pre> <p>Consume a message.</p> PARAMETER  DESCRIPTION <code>msg</code> <p>The message to be consumed.</p> <p> TYPE: <code>MsgType</code> </p> RETURNS DESCRIPTION <code>SendableMessage</code> <p>The sendable message.</p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>If the method is not implemented.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/handler.py</code> <pre><code>@abstractmethod\ndef consume(self, msg: MsgType) -&gt; SendableMessage:\n    \"\"\"Consume a message.\n\n    Args:\n        msg: The message to be consumed.\n\n    Returns:\n        The sendable message.\n\n    Raises:\n        NotImplementedError: If the method is not implemented.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/broker/message/ABCStreamMessage/","title":"ABCStreamMessage","text":""},{"location":"api/faststream/broker/message/ABCStreamMessage/#faststream.broker.message.ABCStreamMessage","title":"faststream.broker.message.ABCStreamMessage  <code>dataclass</code>","text":"<p>             Bases: <code>Generic[Msg]</code></p> <p>A generic class to represent a stream message.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/message.py</code> <pre><code>@dataclass\nclass ABCStreamMessage(Generic[Msg]):\n    \"\"\"A generic class to represent a stream message.\n\n    Attributes:\n        raw_message : the raw message\n        body : the body of the message, can be bytes or any other type\n        decoded_body : the decoded message body, if applicable\n        content_type : the content type of the message\n        reply_to : the reply-to address of the message\n        headers : additional headers of the message\n        message_id : the unique identifier of the message\n        correlation_id : the correlation identifier of the message\n        processed : a flag indicating whether the message has been processed or not\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    raw_message: Msg\n\n    body: Union[bytes, Any]\n    decoded_body: Optional[DecodedMessage] = None\n\n    content_type: Optional[str] = None\n    reply_to: str = \"\"\n    headers: AnyDict = field(default_factory=dict)\n    message_id: str = field(default_factory=lambda: str(uuid4()))  # pragma: no cover\n    correlation_id: str = field(\n        default_factory=lambda: str(uuid4())\n    )  # pragma: no cover\n\n    processed: bool = False\n</code></pre>"},{"location":"api/faststream/broker/message/ABCStreamMessage/#faststream.broker.message.ABCStreamMessage.body","title":"body  <code>instance-attribute</code>","text":"<pre><code>body: Union[bytes, Any]\n</code></pre>"},{"location":"api/faststream/broker/message/ABCStreamMessage/#faststream.broker.message.ABCStreamMessage.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>content_type: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/broker/message/ABCStreamMessage/#faststream.broker.message.ABCStreamMessage.correlation_id","title":"correlation_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>correlation_id: str = field(\n    default_factory=lambda: str(uuid4())\n)\n</code></pre>"},{"location":"api/faststream/broker/message/ABCStreamMessage/#faststream.broker.message.ABCStreamMessage.decoded_body","title":"decoded_body  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>decoded_body: Optional[DecodedMessage] = None\n</code></pre>"},{"location":"api/faststream/broker/message/ABCStreamMessage/#faststream.broker.message.ABCStreamMessage.headers","title":"headers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>headers: AnyDict = field(default_factory=dict)\n</code></pre>"},{"location":"api/faststream/broker/message/ABCStreamMessage/#faststream.broker.message.ABCStreamMessage.message_id","title":"message_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>message_id: str = field(\n    default_factory=lambda: str(uuid4())\n)\n</code></pre>"},{"location":"api/faststream/broker/message/ABCStreamMessage/#faststream.broker.message.ABCStreamMessage.processed","title":"processed  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>processed: bool = False\n</code></pre>"},{"location":"api/faststream/broker/message/ABCStreamMessage/#faststream.broker.message.ABCStreamMessage.raw_message","title":"raw_message  <code>instance-attribute</code>","text":"<pre><code>raw_message: Msg\n</code></pre>"},{"location":"api/faststream/broker/message/ABCStreamMessage/#faststream.broker.message.ABCStreamMessage.reply_to","title":"reply_to  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>reply_to: str = ''\n</code></pre>"},{"location":"api/faststream/broker/message/StreamMessage/","title":"StreamMessage","text":""},{"location":"api/faststream/broker/message/StreamMessage/#faststream.broker.message.StreamMessage","title":"faststream.broker.message.StreamMessage","text":"<p>             Bases: <code>ABCStreamMessage[Msg]</code></p> Source code in <code>faststream/broker/message.py</code> <pre><code>class StreamMessage(ABCStreamMessage[Msg]):\n    @abstractmethod\n    async def ack(self, **kwargs: Any) -&gt; None:\n        \"\"\"Acknowledge method.\n\n        Args:\n            **kwargs: Additional keyword arguments\n\n        Raises:\n            NotImplementedError: If the method is not implemented.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        raise NotImplementedError()\n\n    @abstractmethod\n    async def nack(self, **kwargs: Any) -&gt; None:\n        \"\"\"A function to handle a nack.\n\n        Args:\n            **kwargs: Additional arguments\n\n        Returns:\n            None\n\n        Raises:\n            NotImplementedError: If the function is not implemented.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        raise NotImplementedError()\n\n    @abstractmethod\n    async def reject(self, **kwargs: Any) -&gt; None:\n        \"\"\"Rejects the operation.\n\n        Args:\n            **kwargs: Additional keyword arguments\n\n        Returns:\n            None\n\n        Raises:\n            NotImplementedError: Always raises NotImplementedError\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        raise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/broker/message/StreamMessage/#faststream.broker.message.StreamMessage.ack","title":"ack  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>ack(**kwargs: Any) -&gt; None\n</code></pre> <p>Acknowledge method.</p> PARAMETER  DESCRIPTION <code>**kwargs</code> <p>Additional keyword arguments</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>If the method is not implemented.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/message.py</code> <pre><code>@abstractmethod\nasync def ack(self, **kwargs: Any) -&gt; None:\n    \"\"\"Acknowledge method.\n\n    Args:\n        **kwargs: Additional keyword arguments\n\n    Raises:\n        NotImplementedError: If the method is not implemented.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/broker/message/StreamMessage/#faststream.broker.message.StreamMessage.nack","title":"nack  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>nack(**kwargs: Any) -&gt; None\n</code></pre> <p>A function to handle a nack.</p> PARAMETER  DESCRIPTION <code>**kwargs</code> <p>Additional arguments</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>If the function is not implemented.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/message.py</code> <pre><code>@abstractmethod\nasync def nack(self, **kwargs: Any) -&gt; None:\n    \"\"\"A function to handle a nack.\n\n    Args:\n        **kwargs: Additional arguments\n\n    Returns:\n        None\n\n    Raises:\n        NotImplementedError: If the function is not implemented.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/broker/message/StreamMessage/#faststream.broker.message.StreamMessage.reject","title":"reject  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>reject(**kwargs: Any) -&gt; None\n</code></pre> <p>Rejects the operation.</p> PARAMETER  DESCRIPTION <code>**kwargs</code> <p>Additional keyword arguments</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>Always raises NotImplementedError</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/message.py</code> <pre><code>@abstractmethod\nasync def reject(self, **kwargs: Any) -&gt; None:\n    \"\"\"Rejects the operation.\n\n    Args:\n        **kwargs: Additional keyword arguments\n\n    Returns:\n        None\n\n    Raises:\n        NotImplementedError: Always raises NotImplementedError\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/broker/message/SyncStreamMessage/","title":"SyncStreamMessage","text":""},{"location":"api/faststream/broker/message/SyncStreamMessage/#faststream.broker.message.SyncStreamMessage","title":"faststream.broker.message.SyncStreamMessage","text":"<p>             Bases: <code>ABCStreamMessage[Msg]</code></p> Source code in <code>faststream/broker/message.py</code> <pre><code>class SyncStreamMessage(ABCStreamMessage[Msg]):\n    @abstractmethod\n    def ack(self, **kwargs: Any) -&gt; None:\n        raise NotImplementedError()\n\n    @abstractmethod\n    def nack(self, **kwargs: Any) -&gt; None:\n        \"\"\"A function to raise a NotImplementedError.\n\n        Args:\n            kwargs: Additional keyword arguments\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        raise NotImplementedError()\n\n    @abstractmethod\n    def reject(self, **kwargs: Any) -&gt; None:\n        \"\"\"Reject function.\n\n        Args:\n            **kwargs: Arbitrary keyword arguments\n\n        Returns:\n            None\n\n        Raises:\n            NotImplementedError: Always raises NotImplementedError\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        raise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/broker/message/SyncStreamMessage/#faststream.broker.message.SyncStreamMessage.ack","title":"ack  <code>abstractmethod</code>","text":"<pre><code>ack(**kwargs: Any) -&gt; None\n</code></pre> Source code in <code>faststream/broker/message.py</code> <pre><code>@abstractmethod\ndef ack(self, **kwargs: Any) -&gt; None:\n    raise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/broker/message/SyncStreamMessage/#faststream.broker.message.SyncStreamMessage.nack","title":"nack  <code>abstractmethod</code>","text":"<pre><code>nack(**kwargs: Any) -&gt; None\n</code></pre> <p>A function to raise a NotImplementedError.</p> PARAMETER  DESCRIPTION <code>kwargs</code> <p>Additional keyword arguments</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/message.py</code> <pre><code>@abstractmethod\ndef nack(self, **kwargs: Any) -&gt; None:\n    \"\"\"A function to raise a NotImplementedError.\n\n    Args:\n        kwargs: Additional keyword arguments\n\n    Returns:\n        None\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/broker/message/SyncStreamMessage/#faststream.broker.message.SyncStreamMessage.reject","title":"reject  <code>abstractmethod</code>","text":"<pre><code>reject(**kwargs: Any) -&gt; None\n</code></pre> <p>Reject function.</p> PARAMETER  DESCRIPTION <code>**kwargs</code> <p>Arbitrary keyword arguments</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>Always raises NotImplementedError</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/message.py</code> <pre><code>@abstractmethod\ndef reject(self, **kwargs: Any) -&gt; None:\n    \"\"\"Reject function.\n\n    Args:\n        **kwargs: Arbitrary keyword arguments\n\n    Returns:\n        None\n\n    Raises:\n        NotImplementedError: Always raises NotImplementedError\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/broker/middlewares/BaseMiddleware/","title":"BaseMiddleware","text":""},{"location":"api/faststream/broker/middlewares/BaseMiddleware/#faststream.broker.middlewares.BaseMiddleware","title":"faststream.broker.middlewares.BaseMiddleware","text":"<p>A base middleware class.</p> METHOD DESCRIPTION <code>on_receive</code> <p>Called when a message is received.</p> <code>after_processed</code> <p>Optional[Type[BaseException]] = None, exc_val: Optional[BaseException] = None, exec_tb: Optional[TracebackType] = None) -&gt; Optional[bool]: Called after processing a message.</p> <code>__aenter__</code> <p>Called when entering a context.</p> <code>__aexit__</code> <p>Optional[Type[BaseException]] = None, exc_val: Optional[BaseException] = None, exec_tb: Optional[TracebackType] = None) -&gt; Optional[bool]: Called when exiting a context.</p> <code>on_consume</code> <p>DecodedMessage) -&gt; DecodedMessage: Called before consuming a message.</p> <code>after_consume</code> <p>Optional[Exception]) -&gt; None: Called after consuming a message.</p> <code>consume_scope</code> <p>DecodedMessage) -&gt; AsyncIterator[DecodedMessage]: Context manager for consuming a message.</p> <code>on_publish</code> <p>SendableMessage) -&gt; SendableMessage: Called before publishing a message.</p> <code>after_publish</code> <p>Optional[Exception]) -&gt; None: Asynchronous function to handle the after publish event.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/middlewares.py</code> <pre><code>class BaseMiddleware:\n    \"\"\"A base middleware class.\n\n    Attributes:\n        msg: Any - a message\n\n    Methods:\n        on_receive() -&gt; None:\n            Called when a message is received.\n\n        after_processed(exc_type: Optional[Type[BaseException]] = None, exc_val: Optional[BaseException] = None, exec_tb: Optional[TracebackType] = None) -&gt; Optional[bool]:\n            Called after processing a message.\n\n        __aenter__() -&gt; Self:\n            Called when entering a context.\n\n        __aexit__(exc_type: Optional[Type[BaseException]] = None, exc_val: Optional[BaseException] = None, exec_tb: Optional[TracebackType] = None) -&gt; Optional[bool]:\n            Called when exiting a context.\n\n        on_consume(msg: DecodedMessage) -&gt; DecodedMessage:\n            Called before consuming a message.\n\n        after_consume(err: Optional[Exception]) -&gt; None:\n            Called after consuming a message.\n\n        consume_scope(msg: DecodedMessage) -&gt; AsyncIterator[DecodedMessage]:\n            Context manager for consuming a message.\n\n        on_publish(msg: SendableMessage) -&gt; SendableMessage:\n            Called before publishing a message.\n\n        after_publish(err: Optional[Exception]) -&gt; None:\n            Asynchronous function to handle the after publish event.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    def __init__(self, msg: Any) -&gt; None:\n        \"\"\"Initialize the class.\n\n        Args:\n            msg: Any message to be stored.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        self.msg = msg\n\n    async def on_receive(self) -&gt; None:\n        pass\n\n    async def after_processed(\n        self,\n        exc_type: Optional[Type[BaseException]] = None,\n        exc_val: Optional[BaseException] = None,\n        exec_tb: Optional[TracebackType] = None,\n    ) -&gt; Optional[bool]:\n        \"\"\"Asynchronously called after processing.\n\n        Args:\n            exc_type: Optional exception type\n            exc_val: Optional exception value\n            exec_tb: Optional traceback\n\n        Returns:\n            Optional boolean value indicating whether the processing was successful or not.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        return False\n\n    async def __aenter__(self) -&gt; Self:\n        await self.on_receive()\n        return self\n\n    async def __aexit__(\n        self,\n        exc_type: Optional[Type[BaseException]] = None,\n        exc_val: Optional[BaseException] = None,\n        exec_tb: Optional[TracebackType] = None,\n    ) -&gt; Optional[bool]:\n        \"\"\"Exit the asynchronous context manager.\n\n        Args:\n            exc_type: The type of the exception raised, if any.\n            exc_val: The exception instance raised, if any.\n            exec_tb: The traceback for the exception raised, if any.\n\n        Returns:\n            A boolean indicating whether the exception was handled or not.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        return await self.after_processed(exc_type, exc_val, exec_tb)\n\n    async def on_consume(self, msg: DecodedMessage) -&gt; DecodedMessage:\n        \"\"\"Asynchronously consumes a message.\n\n        Args:\n            msg: The message to be consumed.\n\n        Returns:\n            The consumed message.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        return msg\n\n    async def after_consume(self, err: Optional[Exception]) -&gt; None:\n        \"\"\"A function to handle the result of consuming a resource asynchronously.\n\n        Args:\n            err : Optional exception that occurred during consumption\n\n        Raises:\n            err : If an exception occurred during consumption\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        if err is not None:\n            raise err\n\n    @asynccontextmanager\n    async def consume_scope(self, msg: DecodedMessage) -&gt; AsyncIterator[DecodedMessage]:\n        \"\"\"Asynchronously consumes a message and returns an asynchronous iterator of decoded messages.\n\n        Args:\n            msg: The decoded message to consume.\n\n        Yields:\n            An asynchronous iterator of decoded messages.\n\n        Returns:\n            An asynchronous iterator of decoded messages.\n\n        Raises:\n            Exception: If an error occurs while consuming the message.\n\n        AsyncIterator:\n            An asynchronous iterator that yields decoded messages.\n\n        Note:\n            This function is an async function.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        err: Optional[Exception]\n        try:\n            yield await self.on_consume(msg)\n        except Exception as e:\n            err = e\n        else:\n            err = None\n        await self.after_consume(err)\n\n    async def on_publish(self, msg: SendableMessage) -&gt; SendableMessage:\n        \"\"\"Asynchronously handle a publish event.\n\n        Args:\n            msg: The message to be published.\n\n        Returns:\n            The published message.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        return msg\n\n    async def after_publish(self, err: Optional[Exception]) -&gt; None:\n        \"\"\"Asynchronous function to handle the after publish event.\n\n        Args:\n            err: Optional exception that occurred during the publish\n\n        Returns:\n            None\n\n        Raises:\n            Exception: If an error occurred during the publish\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        if err is not None:\n            raise err\n\n    @asynccontextmanager\n    async def publish_scope(\n        self, msg: SendableMessage\n    ) -&gt; AsyncIterator[SendableMessage]:\n        \"\"\"Publish a message and return an async iterator.\n\n        Args:\n            msg: The message to be published.\n\n        Yields:\n            A sendable message.\n\n        Returns:\n            An async iterator of sendable messages.\n\n        Raises:\n            Exception: If an error occurs during publishing.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        err: Optional[Exception]\n        try:\n            yield await self.on_publish(msg)\n        except Exception as e:\n            err = e\n        else:\n            err = None\n        await self.after_publish(err)\n</code></pre>"},{"location":"api/faststream/broker/middlewares/BaseMiddleware/#faststream.broker.middlewares.BaseMiddleware.msg","title":"msg  <code>instance-attribute</code>","text":"<pre><code>msg = msg\n</code></pre>"},{"location":"api/faststream/broker/middlewares/BaseMiddleware/#faststream.broker.middlewares.BaseMiddleware.after_consume","title":"after_consume  <code>async</code>","text":"<pre><code>after_consume(err: Optional[Exception]) -&gt; None\n</code></pre> <p>A function to handle the result of consuming a resource asynchronously.</p> PARAMETER  DESCRIPTION <code>err</code> <p>Optional exception that occurred during consumption</p> <p> </p> RAISES DESCRIPTION <code>err</code> <p>If an exception occurred during consumption</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/middlewares.py</code> <pre><code>async def after_consume(self, err: Optional[Exception]) -&gt; None:\n    \"\"\"A function to handle the result of consuming a resource asynchronously.\n\n    Args:\n        err : Optional exception that occurred during consumption\n\n    Raises:\n        err : If an exception occurred during consumption\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    if err is not None:\n        raise err\n</code></pre>"},{"location":"api/faststream/broker/middlewares/BaseMiddleware/#faststream.broker.middlewares.BaseMiddleware.after_processed","title":"after_processed  <code>async</code>","text":"<pre><code>after_processed(\n    exc_type: Optional[Type[BaseException]] = None,\n    exc_val: Optional[BaseException] = None,\n    exec_tb: Optional[TracebackType] = None,\n) -&gt; Optional[bool]\n</code></pre> <p>Asynchronously called after processing.</p> PARAMETER  DESCRIPTION <code>exc_type</code> <p>Optional exception type</p> <p> TYPE: <code>Optional[Type[BaseException]]</code> DEFAULT: <code>None</code> </p> <code>exc_val</code> <p>Optional exception value</p> <p> TYPE: <code>Optional[BaseException]</code> DEFAULT: <code>None</code> </p> <code>exec_tb</code> <p>Optional traceback</p> <p> TYPE: <code>Optional[TracebackType]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Optional[bool]</code> <p>Optional boolean value indicating whether the processing was successful or not.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/middlewares.py</code> <pre><code>async def after_processed(\n    self,\n    exc_type: Optional[Type[BaseException]] = None,\n    exc_val: Optional[BaseException] = None,\n    exec_tb: Optional[TracebackType] = None,\n) -&gt; Optional[bool]:\n    \"\"\"Asynchronously called after processing.\n\n    Args:\n        exc_type: Optional exception type\n        exc_val: Optional exception value\n        exec_tb: Optional traceback\n\n    Returns:\n        Optional boolean value indicating whether the processing was successful or not.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    return False\n</code></pre>"},{"location":"api/faststream/broker/middlewares/BaseMiddleware/#faststream.broker.middlewares.BaseMiddleware.after_publish","title":"after_publish  <code>async</code>","text":"<pre><code>after_publish(err: Optional[Exception]) -&gt; None\n</code></pre> <p>Asynchronous function to handle the after publish event.</p> PARAMETER  DESCRIPTION <code>err</code> <p>Optional exception that occurred during the publish</p> <p> TYPE: <code>Optional[Exception]</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> RAISES DESCRIPTION <code>Exception</code> <p>If an error occurred during the publish</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/middlewares.py</code> <pre><code>async def after_publish(self, err: Optional[Exception]) -&gt; None:\n    \"\"\"Asynchronous function to handle the after publish event.\n\n    Args:\n        err: Optional exception that occurred during the publish\n\n    Returns:\n        None\n\n    Raises:\n        Exception: If an error occurred during the publish\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    if err is not None:\n        raise err\n</code></pre>"},{"location":"api/faststream/broker/middlewares/BaseMiddleware/#faststream.broker.middlewares.BaseMiddleware.consume_scope","title":"consume_scope  <code>async</code>","text":"<pre><code>consume_scope(\n    msg: DecodedMessage,\n) -&gt; AsyncIterator[DecodedMessage]\n</code></pre> <p>Asynchronously consumes a message and returns an asynchronous iterator of decoded messages.</p> PARAMETER  DESCRIPTION <code>msg</code> <p>The decoded message to consume.</p> <p> TYPE: <code>DecodedMessage</code> </p> YIELDS DESCRIPTION <code>AsyncIterator[DecodedMessage]</code> <p>An asynchronous iterator of decoded messages.</p> RETURNS DESCRIPTION <code>AsyncIterator[DecodedMessage]</code> <p>An asynchronous iterator of decoded messages.</p> RAISES DESCRIPTION <code>Exception</code> <p>If an error occurs while consuming the message.</p> AsyncIterator <p>An asynchronous iterator that yields decoded messages.</p> Note <p>This function is an async function.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/middlewares.py</code> <pre><code>@asynccontextmanager\nasync def consume_scope(self, msg: DecodedMessage) -&gt; AsyncIterator[DecodedMessage]:\n    \"\"\"Asynchronously consumes a message and returns an asynchronous iterator of decoded messages.\n\n    Args:\n        msg: The decoded message to consume.\n\n    Yields:\n        An asynchronous iterator of decoded messages.\n\n    Returns:\n        An asynchronous iterator of decoded messages.\n\n    Raises:\n        Exception: If an error occurs while consuming the message.\n\n    AsyncIterator:\n        An asynchronous iterator that yields decoded messages.\n\n    Note:\n        This function is an async function.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    err: Optional[Exception]\n    try:\n        yield await self.on_consume(msg)\n    except Exception as e:\n        err = e\n    else:\n        err = None\n    await self.after_consume(err)\n</code></pre>"},{"location":"api/faststream/broker/middlewares/BaseMiddleware/#faststream.broker.middlewares.BaseMiddleware.on_consume","title":"on_consume  <code>async</code>","text":"<pre><code>on_consume(msg: DecodedMessage) -&gt; DecodedMessage\n</code></pre> <p>Asynchronously consumes a message.</p> PARAMETER  DESCRIPTION <code>msg</code> <p>The message to be consumed.</p> <p> TYPE: <code>DecodedMessage</code> </p> RETURNS DESCRIPTION <code>DecodedMessage</code> <p>The consumed message.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/middlewares.py</code> <pre><code>async def on_consume(self, msg: DecodedMessage) -&gt; DecodedMessage:\n    \"\"\"Asynchronously consumes a message.\n\n    Args:\n        msg: The message to be consumed.\n\n    Returns:\n        The consumed message.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    return msg\n</code></pre>"},{"location":"api/faststream/broker/middlewares/BaseMiddleware/#faststream.broker.middlewares.BaseMiddleware.on_publish","title":"on_publish  <code>async</code>","text":"<pre><code>on_publish(msg: SendableMessage) -&gt; SendableMessage\n</code></pre> <p>Asynchronously handle a publish event.</p> PARAMETER  DESCRIPTION <code>msg</code> <p>The message to be published.</p> <p> TYPE: <code>SendableMessage</code> </p> RETURNS DESCRIPTION <code>SendableMessage</code> <p>The published message.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/middlewares.py</code> <pre><code>async def on_publish(self, msg: SendableMessage) -&gt; SendableMessage:\n    \"\"\"Asynchronously handle a publish event.\n\n    Args:\n        msg: The message to be published.\n\n    Returns:\n        The published message.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    return msg\n</code></pre>"},{"location":"api/faststream/broker/middlewares/BaseMiddleware/#faststream.broker.middlewares.BaseMiddleware.on_receive","title":"on_receive  <code>async</code>","text":"<pre><code>on_receive() -&gt; None\n</code></pre> Source code in <code>faststream/broker/middlewares.py</code> <pre><code>async def on_receive(self) -&gt; None:\n    pass\n</code></pre>"},{"location":"api/faststream/broker/middlewares/BaseMiddleware/#faststream.broker.middlewares.BaseMiddleware.publish_scope","title":"publish_scope  <code>async</code>","text":"<pre><code>publish_scope(\n    msg: SendableMessage,\n) -&gt; AsyncIterator[SendableMessage]\n</code></pre> <p>Publish a message and return an async iterator.</p> PARAMETER  DESCRIPTION <code>msg</code> <p>The message to be published.</p> <p> TYPE: <code>SendableMessage</code> </p> YIELDS DESCRIPTION <code>AsyncIterator[SendableMessage]</code> <p>A sendable message.</p> RETURNS DESCRIPTION <code>AsyncIterator[SendableMessage]</code> <p>An async iterator of sendable messages.</p> RAISES DESCRIPTION <code>Exception</code> <p>If an error occurs during publishing.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/middlewares.py</code> <pre><code>@asynccontextmanager\nasync def publish_scope(\n    self, msg: SendableMessage\n) -&gt; AsyncIterator[SendableMessage]:\n    \"\"\"Publish a message and return an async iterator.\n\n    Args:\n        msg: The message to be published.\n\n    Yields:\n        A sendable message.\n\n    Returns:\n        An async iterator of sendable messages.\n\n    Raises:\n        Exception: If an error occurs during publishing.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    err: Optional[Exception]\n    try:\n        yield await self.on_publish(msg)\n    except Exception as e:\n        err = e\n    else:\n        err = None\n    await self.after_publish(err)\n</code></pre>"},{"location":"api/faststream/broker/middlewares/CriticalLogMiddleware/","title":"CriticalLogMiddleware","text":""},{"location":"api/faststream/broker/middlewares/CriticalLogMiddleware/#faststream.broker.middlewares.CriticalLogMiddleware","title":"faststream.broker.middlewares.CriticalLogMiddleware","text":"<p>             Bases: <code>BaseMiddleware</code></p> <p>A middleware class for logging critical errors.</p> PARAMETER  DESCRIPTION <code>logger</code> <p>The logger object to use for logging</p> <p> TYPE: <code>Optional[Logger]</code> </p> METHOD DESCRIPTION <code>__call__</code> <p>Any) -&gt; Self: Returns the middleware instance</p> <code>after_processed</code> <p>Optional[Type[BaseException]] = None, exc_val: Optional[BaseException] = None, exec_tb: Optional[TracebackType] = None) -&gt; bool: Logs critical errors if they occur and returns True</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/middlewares.py</code> <pre><code>class CriticalLogMiddleware(BaseMiddleware):\n    \"\"\"A middleware class for logging critical errors.\n\n    Args:\n        logger: The logger object to use for logging\n\n    Methods:\n        __call__(msg: Any) -&gt; Self: Returns the middleware instance\n        after_processed(exc_type: Optional[Type[BaseException]] = None, exc_val: Optional[BaseException] = None, exec_tb: Optional[TracebackType] = None) -&gt; bool: Logs critical errors if they occur and returns True\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    def __init__(self, logger: Optional[logging.Logger], log_level: int) -&gt; None:\n        \"\"\"Initialize the class.\n\n        Args:\n            logger: an instance of the logging.Logger class\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        self.logger = logger\n        self.log_level = log_level\n\n    def __call__(self, msg: Any) -&gt; Self:\n        \"\"\"Call the object with a message.\n\n        Args:\n            msg: Any message to be passed to the object.\n\n        Returns:\n            The object itself.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        return self\n\n    async def on_consume(self, msg: DecodedMessage) -&gt; DecodedMessage:\n        if self.logger is not None:\n            c = context.get(\"log_context\")\n            self.logger.log(self.log_level, \"Received\", extra=c)\n\n        return await super().on_consume(msg)\n\n    async def after_processed(\n        self,\n        exc_type: Optional[Type[BaseException]] = None,\n        exc_val: Optional[BaseException] = None,\n        exec_tb: Optional[TracebackType] = None,\n    ) -&gt; bool:\n        \"\"\"Asynchronously called after processing.\n\n        Args:\n            exc_type (Optional[Type[BaseException]]): Type of the exception raised during processing.\n            exc_val (Optional[BaseException]): Value of the exception raised during processing.\n            exec_tb (Optional[TracebackType]): Traceback of the exception raised during processing.\n\n        Returns:\n            bool: True if the method is successfully executed.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        if self.logger is not None:\n            c = context.get(\"log_context\")\n\n            if exc_type and exc_val:\n                self.logger.error(\n                    f\"{exc_type.__name__}: {exc_val}\",\n                    exc_info=exc_val,\n                    extra=c,\n                )\n\n            self.logger.log(self.log_level, \"Processed\", extra=c)\n        return True\n</code></pre>"},{"location":"api/faststream/broker/middlewares/CriticalLogMiddleware/#faststream.broker.middlewares.CriticalLogMiddleware.log_level","title":"log_level  <code>instance-attribute</code>","text":"<pre><code>log_level = log_level\n</code></pre>"},{"location":"api/faststream/broker/middlewares/CriticalLogMiddleware/#faststream.broker.middlewares.CriticalLogMiddleware.logger","title":"logger  <code>instance-attribute</code>","text":"<pre><code>logger = logger\n</code></pre>"},{"location":"api/faststream/broker/middlewares/CriticalLogMiddleware/#faststream.broker.middlewares.CriticalLogMiddleware.after_processed","title":"after_processed  <code>async</code>","text":"<pre><code>after_processed(\n    exc_type: Optional[Type[BaseException]] = None,\n    exc_val: Optional[BaseException] = None,\n    exec_tb: Optional[TracebackType] = None,\n) -&gt; bool\n</code></pre> <p>Asynchronously called after processing.</p> PARAMETER  DESCRIPTION <code>exc_type</code> <p>Type of the exception raised during processing.</p> <p> TYPE: <code>Optional[Type[BaseException]]</code> DEFAULT: <code>None</code> </p> <code>exc_val</code> <p>Value of the exception raised during processing.</p> <p> TYPE: <code>Optional[BaseException]</code> DEFAULT: <code>None</code> </p> <code>exec_tb</code> <p>Traceback of the exception raised during processing.</p> <p> TYPE: <code>Optional[TracebackType]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the method is successfully executed.</p> <p> TYPE: <code>bool</code> </p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/middlewares.py</code> <pre><code>async def after_processed(\n    self,\n    exc_type: Optional[Type[BaseException]] = None,\n    exc_val: Optional[BaseException] = None,\n    exec_tb: Optional[TracebackType] = None,\n) -&gt; bool:\n    \"\"\"Asynchronously called after processing.\n\n    Args:\n        exc_type (Optional[Type[BaseException]]): Type of the exception raised during processing.\n        exc_val (Optional[BaseException]): Value of the exception raised during processing.\n        exec_tb (Optional[TracebackType]): Traceback of the exception raised during processing.\n\n    Returns:\n        bool: True if the method is successfully executed.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    if self.logger is not None:\n        c = context.get(\"log_context\")\n\n        if exc_type and exc_val:\n            self.logger.error(\n                f\"{exc_type.__name__}: {exc_val}\",\n                exc_info=exc_val,\n                extra=c,\n            )\n\n        self.logger.log(self.log_level, \"Processed\", extra=c)\n    return True\n</code></pre>"},{"location":"api/faststream/broker/middlewares/CriticalLogMiddleware/#faststream.broker.middlewares.CriticalLogMiddleware.on_consume","title":"on_consume  <code>async</code>","text":"<pre><code>on_consume(msg: DecodedMessage) -&gt; DecodedMessage\n</code></pre> Source code in <code>faststream/broker/middlewares.py</code> <pre><code>async def on_consume(self, msg: DecodedMessage) -&gt; DecodedMessage:\n    if self.logger is not None:\n        c = context.get(\"log_context\")\n        self.logger.log(self.log_level, \"Received\", extra=c)\n\n    return await super().on_consume(msg)\n</code></pre>"},{"location":"api/faststream/broker/parsers/decode_message/","title":"Decode message","text":""},{"location":"api/faststream/broker/parsers/decode_message/#faststream.broker.parsers.decode_message","title":"faststream.broker.parsers.decode_message","text":"<pre><code>decode_message(\n    message: StreamMessage[Any],\n) -&gt; DecodedMessage\n</code></pre> <p>Decodes a message.</p> PARAMETER  DESCRIPTION <code>message</code> <p>The message to decode.</p> <p> TYPE: <code>StreamMessage[Any]</code> </p> RETURNS DESCRIPTION <code>DecodedMessage</code> <p>The decoded message.</p> RAISES DESCRIPTION <code>JSONDecodeError</code> <p>If the message body cannot be decoded as JSON.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/parsers.py</code> <pre><code>def decode_message(message: StreamMessage[Any]) -&gt; DecodedMessage:\n    \"\"\"Decodes a message.\n\n    Args:\n        message: The message to decode.\n\n    Returns:\n        The decoded message.\n\n    Raises:\n        JSONDecodeError: If the message body cannot be decoded as JSON.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    body = message.body\n    m: DecodedMessage = body\n\n    if message.content_type:\n        if ContentTypes.text.value in message.content_type:\n            m = body.decode()\n        elif ContentTypes.json.value in message.content_type:  # pragma: no branch\n            m = json.loads(body)\n\n    else:\n        with suppress(json.JSONDecodeError):\n            m = json.loads(body)\n\n    return m\n</code></pre>"},{"location":"api/faststream/broker/parsers/encode_message/","title":"Encode message","text":""},{"location":"api/faststream/broker/parsers/encode_message/#faststream.broker.parsers.encode_message","title":"faststream.broker.parsers.encode_message","text":"<pre><code>encode_message(\n    msg: SendableMessage,\n) -&gt; Tuple[bytes, Optional[ContentType]]\n</code></pre> <p>Encodes a message.</p> PARAMETER  DESCRIPTION <code>msg</code> <p>The message to be encoded.</p> <p> TYPE: <code>SendableMessage</code> </p> RETURNS DESCRIPTION <code>Tuple[bytes, Optional[ContentType]]</code> <p>A tuple containing the encoded message as bytes and the content type of the message.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/parsers.py</code> <pre><code>def encode_message(msg: SendableMessage) -&gt; Tuple[bytes, Optional[ContentType]]:\n    \"\"\"Encodes a message.\n\n    Args:\n        msg: The message to be encoded.\n\n    Returns:\n        A tuple containing the encoded message as bytes and the content type of the message.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    if msg is None:\n        return b\"\", None\n\n    if isinstance(msg, bytes):\n        return msg, None\n\n    if isinstance(msg, str):\n        return msg.encode(), ContentTypes.text.value\n\n    return (\n        dump_json(msg).encode(),\n        ContentTypes.json.value,\n    )\n</code></pre>"},{"location":"api/faststream/broker/parsers/resolve_custom_func/","title":"Resolve custom func","text":""},{"location":"api/faststream/broker/parsers/resolve_custom_func/#faststream.broker.parsers.resolve_custom_func","title":"faststream.broker.parsers.resolve_custom_func","text":"<pre><code>resolve_custom_func(\n    custom_func: Optional[\n        Union[\n            CustomDecoder[StreamMsg],\n            CustomParser[MsgType, StreamMsg],\n        ]\n    ],\n    default_func: Union[\n        Decoder[StreamMsg], Parser[MsgType, StreamMsg]\n    ],\n) -&gt; Union[Decoder[StreamMsg], Parser[MsgType, StreamMsg]]\n</code></pre> <p>Resolve a custom function.</p> PARAMETER  DESCRIPTION <code>custom_func</code> <p>Optional custom function of type CustomDecoder or CustomParser.</p> <p> TYPE: <code>Optional[Union[CustomDecoder[StreamMsg], CustomParser[MsgType, StreamMsg]]]</code> </p> <code>default_func</code> <p>Default function of type Decoder or Parser.</p> <p> TYPE: <code>Union[Decoder[StreamMsg], Parser[MsgType, StreamMsg]]</code> </p> RETURNS DESCRIPTION <code>Union[Decoder[StreamMsg], Parser[MsgType, StreamMsg]]</code> <p>The resolved function of type Decoder or Parser.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/parsers.py</code> <pre><code>def resolve_custom_func(  # type: ignore[misc]\n    custom_func: Optional[\n        Union[CustomDecoder[StreamMsg], CustomParser[MsgType, StreamMsg]]\n    ],\n    default_func: Union[Decoder[StreamMsg], Parser[MsgType, StreamMsg]],\n) -&gt; Union[Decoder[StreamMsg], Parser[MsgType, StreamMsg]]:\n    \"\"\"Resolve a custom function.\n\n    Args:\n        custom_func: Optional custom function of type CustomDecoder or CustomParser.\n        default_func: Default function of type Decoder or Parser.\n\n    Returns:\n        The resolved function of type Decoder or Parser.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    if custom_func is None:\n        return default_func\n\n    original_params = inspect.signature(custom_func).parameters\n    if len(original_params) == 1:\n        return cast(Union[Decoder[StreamMsg], Parser[MsgType, StreamMsg]], custom_func)\n\n    else:\n        name = tuple(original_params.items())[1][0]\n        return partial(custom_func, **{name: default_func})  # type: ignore\n</code></pre>"},{"location":"api/faststream/broker/publisher/BasePublisher/","title":"BasePublisher","text":""},{"location":"api/faststream/broker/publisher/BasePublisher/#faststream.broker.publisher.BasePublisher","title":"faststream.broker.publisher.BasePublisher  <code>dataclass</code>","text":"<p>             Bases: <code>AsyncAPIOperation</code>, <code>Generic[MsgType]</code></p> <p>A base class for publishers in an asynchronous API.</p> METHOD DESCRIPTION <code>description</code> <p>returns the description of the publisher</p> <code>__call__</code> <p>decorator to register a function as a handler for the publisher</p> <code>publish</code> <p>publishes a message with optional correlation ID</p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>if the publish method is not implemented.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/publisher.py</code> <pre><code>@dataclass\nclass BasePublisher(AsyncAPIOperation, Generic[MsgType]):\n    \"\"\"A base class for publishers in an asynchronous API.\n\n    Attributes:\n        title : optional title of the publisher\n        _description : optional description of the publisher\n        _fake_handler : boolean indicating if a fake handler is used\n        calls : list of callable objects\n        mock : MagicMock object for mocking purposes\n\n    Methods:\n        description() : returns the description of the publisher\n        __call__(func) : decorator to register a function as a handler for the publisher\n        publish(message, correlation_id, **kwargs) : publishes a message with optional correlation ID\n\n    Raises:\n        NotImplementedError: if the publish method is not implemented.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    title: Optional[str] = field(default=None)\n    _description: Optional[str] = field(default=None)\n    _fake_handler: bool = field(default=False)\n\n    calls: List[Callable[..., Any]] = field(\n        init=False, default_factory=list, repr=False\n    )\n    mock: MagicMock = field(init=False, default_factory=MagicMock, repr=False)\n\n    @property\n    def description(self) -&gt; Optional[str]:\n        return self._description\n\n    def __call__(\n        self,\n        func: Callable[P_HandlerParams, T_HandlerReturn],\n    ) -&gt; HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn]:\n        \"\"\"This is a Python function.\n\n        Args:\n            func: A callable object that takes `P_HandlerParams` as input and returns `T_HandlerReturn`.\n\n        Returns:\n            An instance of `HandlerCallWrapper` class.\n\n        Raises:\n            TypeError: If `func` is not callable.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        handler_call: HandlerCallWrapper[\n            MsgType, P_HandlerParams, T_HandlerReturn\n        ] = HandlerCallWrapper(func)\n        handler_call._publishers.append(self)\n        self.calls.append(handler_call._original_call)\n        return handler_call\n\n    @abstractmethod\n    async def publish(\n        self,\n        message: SendableMessage,\n        correlation_id: Optional[str] = None,\n        **kwargs: Any,\n    ) -&gt; Optional[SendableMessage]:\n        \"\"\"Publish a message.\n\n        Args:\n            message: The message to be published.\n            correlation_id: Optional correlation ID for the message.\n            **kwargs: Additional keyword arguments.\n\n        Returns:\n            The published message.\n\n        Raises:\n            NotImplementedError: If the method is not implemented.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        raise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/broker/publisher/BasePublisher/#faststream.broker.publisher.BasePublisher.calls","title":"calls  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>calls: List[Callable[..., Any]] = field(\n    init=False, default_factory=list, repr=False\n)\n</code></pre>"},{"location":"api/faststream/broker/publisher/BasePublisher/#faststream.broker.publisher.BasePublisher.description","title":"description  <code>property</code>","text":"<pre><code>description: Optional[str]\n</code></pre>"},{"location":"api/faststream/broker/publisher/BasePublisher/#faststream.broker.publisher.BasePublisher.mock","title":"mock  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mock: MagicMock = field(\n    init=False, default_factory=MagicMock, repr=False\n)\n</code></pre>"},{"location":"api/faststream/broker/publisher/BasePublisher/#faststream.broker.publisher.BasePublisher.title","title":"title  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>title: Optional[str] = field(default=None)\n</code></pre>"},{"location":"api/faststream/broker/publisher/BasePublisher/#faststream.broker.publisher.BasePublisher.publish","title":"publish  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>publish(\n    message: SendableMessage,\n    correlation_id: Optional[str] = None,\n    **kwargs: Any\n) -&gt; Optional[SendableMessage]\n</code></pre> <p>Publish a message.</p> PARAMETER  DESCRIPTION <code>message</code> <p>The message to be published.</p> <p> TYPE: <code>SendableMessage</code> </p> <code>correlation_id</code> <p>Optional correlation ID for the message.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>**kwargs</code> <p>Additional keyword arguments.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Optional[SendableMessage]</code> <p>The published message.</p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>If the method is not implemented.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/publisher.py</code> <pre><code>@abstractmethod\nasync def publish(\n    self,\n    message: SendableMessage,\n    correlation_id: Optional[str] = None,\n    **kwargs: Any,\n) -&gt; Optional[SendableMessage]:\n    \"\"\"Publish a message.\n\n    Args:\n        message: The message to be published.\n        correlation_id: Optional correlation ID for the message.\n        **kwargs: Additional keyword arguments.\n\n    Returns:\n        The published message.\n\n    Raises:\n        NotImplementedError: If the method is not implemented.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/broker/push_back_watcher/BaseWatcher/","title":"BaseWatcher","text":""},{"location":"api/faststream/broker/push_back_watcher/BaseWatcher/#faststream.broker.push_back_watcher.BaseWatcher","title":"faststream.broker.push_back_watcher.BaseWatcher","text":"<p>             Bases: <code>ABC</code></p> <p>A base class for a watcher.</p> PARAMETER  DESCRIPTION <code>max_tries</code> <p>maximum number of tries allowed (default=0)</p> <p> DEFAULT: <code>0</code> </p> <code>logger</code> <p>logger object (optional)</p> <p> DEFAULT: <code>None</code> </p> METHOD DESCRIPTION <code>add </code> <p>add a message to the watcher</p> <code>is_max </code> <p>check if the maximum number of tries has been reached for a message</p> <code>remove </code> <p>remove a message from the watcher</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/push_back_watcher.py</code> <pre><code>class BaseWatcher(ABC):\n    \"\"\"A base class for a watcher.\n\n    Attributes:\n        max_tries : maximum number of tries allowed\n\n    Args:\n        max_tries : maximum number of tries allowed (default=0)\n        logger : logger object (optional)\n\n    Methods:\n        add : add a message to the watcher\n        is_max : check if the maximum number of tries has been reached for a message\n        remove : remove a message from the watcher\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    max_tries: int\n\n    def __init__(\n        self,\n        max_tries: int = 0,\n        logger: Optional[Logger] = None,\n    ):\n        \"\"\"Initialize the class.\n\n        Args:\n            max_tries: Maximum number of tries allowed\n            logger: Optional logger object\n\n        Raises:\n            NotImplementedError: If the method is not implemented in the subclass.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        self.logger = logger\n        self.max_tries = max_tries\n\n    @abstractmethod\n    def add(self, message_id: str) -&gt; None:\n        \"\"\"Add a message.\n\n        Args:\n            message_id: ID of the message to be added\n\n        Returns:\n            None\n\n        Raises:\n            NotImplementedError: If the method is not implemented\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        raise NotImplementedError()\n\n    @abstractmethod\n    def is_max(self, message_id: str) -&gt; bool:\n        \"\"\"Check if the given message ID is the maximum.\n\n        Args:\n            message_id: The ID of the message to check.\n\n        Returns:\n            True if the given message ID is the maximum, False otherwise.\n\n        Raises:\n            NotImplementedError: This method is meant to be overridden by subclasses.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        raise NotImplementedError()\n\n    @abstractmethod\n    def remove(self, message_id: str) -&gt; None:\n        \"\"\"Remove a message.\n\n        Args:\n            message_id: ID of the message to be removed\n\n        Returns:\n            None\n\n        Raises:\n            NotImplementedError: If the method is not implemented\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        raise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/broker/push_back_watcher/BaseWatcher/#faststream.broker.push_back_watcher.BaseWatcher.logger","title":"logger  <code>instance-attribute</code>","text":"<pre><code>logger = logger\n</code></pre>"},{"location":"api/faststream/broker/push_back_watcher/BaseWatcher/#faststream.broker.push_back_watcher.BaseWatcher.max_tries","title":"max_tries  <code>instance-attribute</code>","text":"<pre><code>max_tries: int = max_tries\n</code></pre>"},{"location":"api/faststream/broker/push_back_watcher/BaseWatcher/#faststream.broker.push_back_watcher.BaseWatcher.add","title":"add  <code>abstractmethod</code>","text":"<pre><code>add(message_id: str) -&gt; None\n</code></pre> <p>Add a message.</p> PARAMETER  DESCRIPTION <code>message_id</code> <p>ID of the message to be added</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>If the method is not implemented</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/push_back_watcher.py</code> <pre><code>@abstractmethod\ndef add(self, message_id: str) -&gt; None:\n    \"\"\"Add a message.\n\n    Args:\n        message_id: ID of the message to be added\n\n    Returns:\n        None\n\n    Raises:\n        NotImplementedError: If the method is not implemented\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/broker/push_back_watcher/BaseWatcher/#faststream.broker.push_back_watcher.BaseWatcher.is_max","title":"is_max  <code>abstractmethod</code>","text":"<pre><code>is_max(message_id: str) -&gt; bool\n</code></pre> <p>Check if the given message ID is the maximum.</p> PARAMETER  DESCRIPTION <code>message_id</code> <p>The ID of the message to check.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the given message ID is the maximum, False otherwise.</p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>This method is meant to be overridden by subclasses.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/push_back_watcher.py</code> <pre><code>@abstractmethod\ndef is_max(self, message_id: str) -&gt; bool:\n    \"\"\"Check if the given message ID is the maximum.\n\n    Args:\n        message_id: The ID of the message to check.\n\n    Returns:\n        True if the given message ID is the maximum, False otherwise.\n\n    Raises:\n        NotImplementedError: This method is meant to be overridden by subclasses.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/broker/push_back_watcher/BaseWatcher/#faststream.broker.push_back_watcher.BaseWatcher.remove","title":"remove  <code>abstractmethod</code>","text":"<pre><code>remove(message_id: str) -&gt; None\n</code></pre> <p>Remove a message.</p> PARAMETER  DESCRIPTION <code>message_id</code> <p>ID of the message to be removed</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>If the method is not implemented</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/push_back_watcher.py</code> <pre><code>@abstractmethod\ndef remove(self, message_id: str) -&gt; None:\n    \"\"\"Remove a message.\n\n    Args:\n        message_id: ID of the message to be removed\n\n    Returns:\n        None\n\n    Raises:\n        NotImplementedError: If the method is not implemented\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/broker/push_back_watcher/CounterWatcher/","title":"CounterWatcher","text":""},{"location":"api/faststream/broker/push_back_watcher/CounterWatcher/#faststream.broker.push_back_watcher.CounterWatcher","title":"faststream.broker.push_back_watcher.CounterWatcher","text":"<p>             Bases: <code>BaseWatcher</code></p> <p>A class to watch and track the count of messages.</p> PARAMETER  DESCRIPTION <code>max_tries</code> <p>int - maximum number of tries allowed</p> <p> DEFAULT: <code>3</code> </p> <code>logger</code> <p>Optional[Logger] - logger object for logging messages</p> <p> DEFAULT: <code>None</code> </p> METHOD DESCRIPTION <code>__init__</code> <p>int = 3, logger: Optional[Logger] = None) - initializes the CounterWatcher object</p> <code>add</code> <p>str) -&gt; None - adds a message to the counter</p> <code>is_max</code> <p>str) -&gt; bool - checks if the count of a message has reached the maximum tries</p> <code>remove</code> <p>str) -&gt; None - removes a message from the counter</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/push_back_watcher.py</code> <pre><code>class CounterWatcher(BaseWatcher):\n    \"\"\"A class to watch and track the count of messages.\n\n    Attributes:\n        memory : CounterType[str] - a counter to store the count of each message\n\n    Args:\n        max_tries : int - maximum number of tries allowed\n        logger : Optional[Logger] - logger object for logging messages\n\n    Methods:\n        __init__(self, max_tries: int = 3, logger: Optional[Logger] = None) - initializes the CounterWatcher object\n        add(self, message_id: str) -&gt; None - adds a message to the counter\n        is_max(self, message_id: str) -&gt; bool - checks if the count of a message has reached the maximum tries\n        remove(self, message: str) -&gt; None - removes a message from the counter\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    memory: CounterType[str]\n\n    def __init__(\n        self,\n        max_tries: int = 3,\n        logger: Optional[Logger] = None,\n    ):\n        \"\"\"Initialize the class.\n\n        Args:\n            max_tries (int): maximum number of tries\n            logger (Optional[Logger]): logger object (default: None)\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        super().__init__(logger=logger, max_tries=max_tries)\n        self.memory = Counter()\n\n    def add(self, message_id: str) -&gt; None:\n        \"\"\"Increments the count of a message in the memory.\n\n        Args:\n            message_id: The ID of the message to be incremented.\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        self.memory[message_id] += 1\n\n    def is_max(self, message_id: str) -&gt; bool:\n        \"\"\"Check if the number of tries for a message has exceeded the maximum allowed tries.\n\n        Args:\n            message_id: The ID of the message\n\n        Returns:\n            True if the number of tries has exceeded the maximum allowed tries, False otherwise\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        is_max = self.memory[message_id] &gt; self.max_tries\n        if self.logger is not None:\n            if is_max:\n                self.logger.error(f\"Already retried {self.max_tries} times. Skipped.\")\n            else:\n                self.logger.error(\"Error is occured. Pushing back to queue.\")\n        return is_max\n\n    def remove(self, message: str) -&gt; None:\n        \"\"\"Remove a message from memory.\n\n        Args:\n            message: The message to be removed.\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        self.memory[message] = 0\n        self.memory += Counter()\n</code></pre>"},{"location":"api/faststream/broker/push_back_watcher/CounterWatcher/#faststream.broker.push_back_watcher.CounterWatcher.memory","title":"memory  <code>instance-attribute</code>","text":"<pre><code>memory: CounterType[str] = Counter()\n</code></pre>"},{"location":"api/faststream/broker/push_back_watcher/CounterWatcher/#faststream.broker.push_back_watcher.CounterWatcher.add","title":"add","text":"<pre><code>add(message_id: str) -&gt; None\n</code></pre> <p>Increments the count of a message in the memory.</p> PARAMETER  DESCRIPTION <code>message_id</code> <p>The ID of the message to be incremented.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/push_back_watcher.py</code> <pre><code>def add(self, message_id: str) -&gt; None:\n    \"\"\"Increments the count of a message in the memory.\n\n    Args:\n        message_id: The ID of the message to be incremented.\n\n    Returns:\n        None\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    self.memory[message_id] += 1\n</code></pre>"},{"location":"api/faststream/broker/push_back_watcher/CounterWatcher/#faststream.broker.push_back_watcher.CounterWatcher.is_max","title":"is_max","text":"<pre><code>is_max(message_id: str) -&gt; bool\n</code></pre> <p>Check if the number of tries for a message has exceeded the maximum allowed tries.</p> PARAMETER  DESCRIPTION <code>message_id</code> <p>The ID of the message</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the number of tries has exceeded the maximum allowed tries, False otherwise</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/push_back_watcher.py</code> <pre><code>def is_max(self, message_id: str) -&gt; bool:\n    \"\"\"Check if the number of tries for a message has exceeded the maximum allowed tries.\n\n    Args:\n        message_id: The ID of the message\n\n    Returns:\n        True if the number of tries has exceeded the maximum allowed tries, False otherwise\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    is_max = self.memory[message_id] &gt; self.max_tries\n    if self.logger is not None:\n        if is_max:\n            self.logger.error(f\"Already retried {self.max_tries} times. Skipped.\")\n        else:\n            self.logger.error(\"Error is occured. Pushing back to queue.\")\n    return is_max\n</code></pre>"},{"location":"api/faststream/broker/push_back_watcher/CounterWatcher/#faststream.broker.push_back_watcher.CounterWatcher.remove","title":"remove","text":"<pre><code>remove(message: str) -&gt; None\n</code></pre> <p>Remove a message from memory.</p> PARAMETER  DESCRIPTION <code>message</code> <p>The message to be removed.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/push_back_watcher.py</code> <pre><code>def remove(self, message: str) -&gt; None:\n    \"\"\"Remove a message from memory.\n\n    Args:\n        message: The message to be removed.\n\n    Returns:\n        None\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    self.memory[message] = 0\n    self.memory += Counter()\n</code></pre>"},{"location":"api/faststream/broker/push_back_watcher/EndlessWatcher/","title":"EndlessWatcher","text":""},{"location":"api/faststream/broker/push_back_watcher/EndlessWatcher/#faststream.broker.push_back_watcher.EndlessWatcher","title":"faststream.broker.push_back_watcher.EndlessWatcher","text":"<p>             Bases: <code>BaseWatcher</code></p> Source code in <code>faststream/broker/push_back_watcher.py</code> <pre><code>class EndlessWatcher(BaseWatcher):\n    def add(self, message_id: str) -&gt; None:\n        \"\"\"Add a message to the list.\n\n        Args:\n            message_id: ID of the message to be added\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        pass\n\n    def is_max(self, message_id: str) -&gt; bool:\n        \"\"\"Check if a message is the maximum.\n\n        Args:\n            message_id: ID of the message to check\n\n        Returns:\n            True if the message is the maximum, False otherwise\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        return False\n\n    def remove(self, message_id: str) -&gt; None:\n        \"\"\"Remove a message.\n\n        Args:\n            message_id: The ID of the message to be removed.\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/faststream/broker/push_back_watcher/EndlessWatcher/#faststream.broker.push_back_watcher.EndlessWatcher.add","title":"add","text":"<pre><code>add(message_id: str) -&gt; None\n</code></pre> <p>Add a message to the list.</p> PARAMETER  DESCRIPTION <code>message_id</code> <p>ID of the message to be added</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/push_back_watcher.py</code> <pre><code>def add(self, message_id: str) -&gt; None:\n    \"\"\"Add a message to the list.\n\n    Args:\n        message_id: ID of the message to be added\n\n    Returns:\n        None\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/faststream/broker/push_back_watcher/EndlessWatcher/#faststream.broker.push_back_watcher.EndlessWatcher.is_max","title":"is_max","text":"<pre><code>is_max(message_id: str) -&gt; bool\n</code></pre> <p>Check if a message is the maximum.</p> PARAMETER  DESCRIPTION <code>message_id</code> <p>ID of the message to check</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the message is the maximum, False otherwise</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/push_back_watcher.py</code> <pre><code>def is_max(self, message_id: str) -&gt; bool:\n    \"\"\"Check if a message is the maximum.\n\n    Args:\n        message_id: ID of the message to check\n\n    Returns:\n        True if the message is the maximum, False otherwise\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    return False\n</code></pre>"},{"location":"api/faststream/broker/push_back_watcher/EndlessWatcher/#faststream.broker.push_back_watcher.EndlessWatcher.remove","title":"remove","text":"<pre><code>remove(message_id: str) -&gt; None\n</code></pre> <p>Remove a message.</p> PARAMETER  DESCRIPTION <code>message_id</code> <p>The ID of the message to be removed.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/push_back_watcher.py</code> <pre><code>def remove(self, message_id: str) -&gt; None:\n    \"\"\"Remove a message.\n\n    Args:\n        message_id: The ID of the message to be removed.\n\n    Returns:\n        None\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/faststream/broker/push_back_watcher/OneTryWatcher/","title":"OneTryWatcher","text":""},{"location":"api/faststream/broker/push_back_watcher/OneTryWatcher/#faststream.broker.push_back_watcher.OneTryWatcher","title":"faststream.broker.push_back_watcher.OneTryWatcher","text":"<p>             Bases: <code>BaseWatcher</code></p> Source code in <code>faststream/broker/push_back_watcher.py</code> <pre><code>class OneTryWatcher(BaseWatcher):\n    def add(self, message_id: str) -&gt; None:\n        \"\"\"Add a message.\n\n        Args:\n            message_id: ID of the message to be added\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        pass\n\n    def is_max(self, message_id: str) -&gt; bool:\n        \"\"\"Check if the given message ID is the maximum.\n\n        Args:\n            message_id: The ID of the message to check.\n\n        Returns:\n            True if the given message ID is the maximum, False otherwise.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        return True\n\n    def remove(self, message_id: str) -&gt; None:\n        \"\"\"Remove a message.\n\n        Args:\n            message_id: ID of the message to be removed\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/faststream/broker/push_back_watcher/OneTryWatcher/#faststream.broker.push_back_watcher.OneTryWatcher.add","title":"add","text":"<pre><code>add(message_id: str) -&gt; None\n</code></pre> <p>Add a message.</p> PARAMETER  DESCRIPTION <code>message_id</code> <p>ID of the message to be added</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/push_back_watcher.py</code> <pre><code>def add(self, message_id: str) -&gt; None:\n    \"\"\"Add a message.\n\n    Args:\n        message_id: ID of the message to be added\n\n    Returns:\n        None\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/faststream/broker/push_back_watcher/OneTryWatcher/#faststream.broker.push_back_watcher.OneTryWatcher.is_max","title":"is_max","text":"<pre><code>is_max(message_id: str) -&gt; bool\n</code></pre> <p>Check if the given message ID is the maximum.</p> PARAMETER  DESCRIPTION <code>message_id</code> <p>The ID of the message to check.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the given message ID is the maximum, False otherwise.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/push_back_watcher.py</code> <pre><code>def is_max(self, message_id: str) -&gt; bool:\n    \"\"\"Check if the given message ID is the maximum.\n\n    Args:\n        message_id: The ID of the message to check.\n\n    Returns:\n        True if the given message ID is the maximum, False otherwise.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    return True\n</code></pre>"},{"location":"api/faststream/broker/push_back_watcher/OneTryWatcher/#faststream.broker.push_back_watcher.OneTryWatcher.remove","title":"remove","text":"<pre><code>remove(message_id: str) -&gt; None\n</code></pre> <p>Remove a message.</p> PARAMETER  DESCRIPTION <code>message_id</code> <p>ID of the message to be removed</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/push_back_watcher.py</code> <pre><code>def remove(self, message_id: str) -&gt; None:\n    \"\"\"Remove a message.\n\n    Args:\n        message_id: ID of the message to be removed\n\n    Returns:\n        None\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/faststream/broker/push_back_watcher/WatcherContext/","title":"WatcherContext","text":""},{"location":"api/faststream/broker/push_back_watcher/WatcherContext/#faststream.broker.push_back_watcher.WatcherContext","title":"faststream.broker.push_back_watcher.WatcherContext","text":"<p>A class representing a context for a watcher.</p> METHOD DESCRIPTION <code>__aenter__ </code> <p>called when entering the context</p> <code>__aexit__ </code> <p>called when exiting the context</p> <code>__ack </code> <p>acknowledges the message</p> <code>__nack </code> <p>negatively acknowledges the message</p> <code>__reject </code> <p>rejects the message</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/push_back_watcher.py</code> <pre><code>class WatcherContext:\n    \"\"\"A class representing a context for a watcher.\n\n    Attributes:\n        watcher : the watcher object\n        message : the message being watched\n        extra_ack_args : additional arguments for acknowledging the message\n\n    Methods:\n        __aenter__ : called when entering the context\n        __aexit__ : called when exiting the context\n        __ack : acknowledges the message\n        __nack : negatively acknowledges the message\n        __reject : rejects the message\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    def __init__(\n        self,\n        watcher: BaseWatcher,\n        message: Union[SyncStreamMessage[MsgType], StreamMessage[MsgType]],\n        **extra_ack_args: Any,\n    ):\n        \"\"\"Initialize a new instance of the class.\n\n        Args:\n            watcher: An instance of BaseWatcher.\n            message: An instance of SyncStreamMessage or StreamMessage.\n            **extra_ack_args: Additional arguments for acknowledgement.\n\n        Attributes:\n            watcher: An instance of BaseWatcher.\n            message: An instance of SyncStreamMessage or StreamMessage.\n            extra_ack_args: Additional arguments for acknowledgement.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        self.watcher = watcher\n        self.message = message\n        self.extra_ack_args = extra_ack_args or {}\n\n    async def __aenter__(self) -&gt; None:\n        self.watcher.add(self.message.message_id)\n\n    async def __aexit__(\n        self,\n        exc_type: Optional[Type[BaseException]],\n        exc_val: Optional[BaseException],\n        exc_tb: Optional[TracebackType],\n    ) -&gt; bool:\n        \"\"\"Exit the asynchronous context manager.\n\n        Args:\n            exc_type: The type of the exception raised, if any.\n            exc_val: The exception instance raised, if any.\n            exc_tb: The traceback for the exception raised, if any.\n\n        Returns:\n            A boolean indicating whether the exit was successful or not.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        if not exc_type:\n            await self.__ack()\n\n        elif isinstance(exc_val, SkipMessage):\n            self.watcher.remove(self.message.message_id)\n\n        elif isinstance(exc_val, HandlerException):\n            if isinstance(exc_val, AckMessage):\n                await self.__ack()\n            elif isinstance(exc_val, NackMessage):\n                await self.__nack()\n            elif isinstance(exc_val, RejectMessage):\n                await self.__reject()\n            return True\n\n        elif self.watcher.is_max(self.message.message_id):\n            await self.__reject()\n\n        else:\n            await self.__nack()\n\n        return False\n\n    async def __ack(self) -&gt; None:\n        await call_or_await(self.message.ack, **self.extra_ack_args)\n        self.watcher.remove(self.message.message_id)\n\n    async def __nack(self) -&gt; None:\n        await call_or_await(self.message.nack, **self.extra_ack_args)\n\n    async def __reject(self) -&gt; None:\n        await call_or_await(self.message.reject, **self.extra_ack_args)\n        self.watcher.remove(self.message.message_id)\n</code></pre>"},{"location":"api/faststream/broker/push_back_watcher/WatcherContext/#faststream.broker.push_back_watcher.WatcherContext.extra_ack_args","title":"extra_ack_args  <code>instance-attribute</code>","text":"<pre><code>extra_ack_args = extra_ack_args or {}\n</code></pre>"},{"location":"api/faststream/broker/push_back_watcher/WatcherContext/#faststream.broker.push_back_watcher.WatcherContext.message","title":"message  <code>instance-attribute</code>","text":"<pre><code>message = message\n</code></pre>"},{"location":"api/faststream/broker/push_back_watcher/WatcherContext/#faststream.broker.push_back_watcher.WatcherContext.watcher","title":"watcher  <code>instance-attribute</code>","text":"<pre><code>watcher = watcher\n</code></pre>"},{"location":"api/faststream/broker/router/BrokerRoute/","title":"BrokerRoute","text":""},{"location":"api/faststream/broker/router/BrokerRoute/#faststream.broker.router.BrokerRoute","title":"faststream.broker.router.BrokerRoute","text":"<p>             Bases: <code>Generic[MsgType, T_HandlerReturn]</code></p> <p>A generic class to represent a broker route.</p> PARAMETER  DESCRIPTION <code>call</code> <p>callable object representing the route</p> <p> </p> <code>*args</code> <p>variable length arguments for the route</p> <p> DEFAULT: <code>()</code> </p> <code>**kwargs</code> <p>variable length keyword arguments for the route</p> <p> DEFAULT: <code>{}</code> </p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/router.py</code> <pre><code>class BrokerRoute(Generic[MsgType, T_HandlerReturn]):\n    \"\"\"A generic class to represent a broker route.\n\n    Attributes:\n        call : callable object representing the route\n        args : tuple of arguments for the route\n        kwargs : dictionary of keyword arguments for the route\n\n    Args:\n        call : callable object representing the route\n        *args : variable length arguments for the route\n        **kwargs : variable length keyword arguments for the route\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    call: Callable[..., T_HandlerReturn]\n    args: Tuple[Any, ...]\n    kwargs: AnyDict\n\n    def __init__(\n        self,\n        call: Callable[..., T_HandlerReturn],\n        *args: Any,\n        **kwargs: Any,\n    ):\n        \"\"\"Initialize a callable object with arguments and keyword arguments.\n\n        Args:\n            call: A callable object.\n            *args: Positional arguments to be passed to the callable object.\n            **kwargs: Keyword arguments to be passed to the callable object.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        self.call = call\n        self.args = args\n        self.kwargs = kwargs\n</code></pre>"},{"location":"api/faststream/broker/router/BrokerRoute/#faststream.broker.router.BrokerRoute.args","title":"args  <code>instance-attribute</code>","text":"<pre><code>args: Tuple[Any, ...] = args\n</code></pre>"},{"location":"api/faststream/broker/router/BrokerRoute/#faststream.broker.router.BrokerRoute.call","title":"call  <code>instance-attribute</code>","text":"<pre><code>call: Callable[..., T_HandlerReturn] = call\n</code></pre>"},{"location":"api/faststream/broker/router/BrokerRoute/#faststream.broker.router.BrokerRoute.kwargs","title":"kwargs  <code>instance-attribute</code>","text":"<pre><code>kwargs: AnyDict = kwargs\n</code></pre>"},{"location":"api/faststream/broker/router/BrokerRouter/","title":"BrokerRouter","text":""},{"location":"api/faststream/broker/router/BrokerRouter/#faststream.broker.router.BrokerRouter","title":"faststream.broker.router.BrokerRouter","text":"<p>             Bases: <code>Generic[PublisherKeyType, MsgType]</code></p> <p>A generic class representing a broker router.</p> METHOD DESCRIPTION <code>_get_publisher_key </code> <p>abstract method to get the publisher key</p> <code>_update_publisher_prefix </code> <p>abstract method to update the publisher prefix</p> <code>__init__ </code> <p>constructor method</p> <code>subscriber </code> <p>abstract method to define a subscriber</p> <code>_wrap_subscriber </code> <p>method to wrap a subscriber function</p> <code>publisher </code> <p>abstract method to define a publisher</p> <code>include_router </code> <p>method to include a router</p> <code>include_routers </code> <p>method to include multiple routers</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/router.py</code> <pre><code>class BrokerRouter(Generic[PublisherKeyType, MsgType]):\n    \"\"\"A generic class representing a broker router.\n\n    Attributes:\n        prefix : prefix for the router\n        _handlers : list of broker routes\n        _publishers : dictionary of publishers\n\n    Methods:\n        _get_publisher_key : abstract method to get the publisher key\n        _update_publisher_prefix : abstract method to update the publisher prefix\n        __init__ : constructor method\n        subscriber : abstract method to define a subscriber\n        _wrap_subscriber : method to wrap a subscriber function\n        publisher : abstract method to define a publisher\n        include_router : method to include a router\n        include_routers : method to include multiple routers\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    prefix: str\n    _handlers: List[BrokerRoute[MsgType, Any]]\n    _publishers: Dict[PublisherKeyType, BasePublisher[MsgType]]\n\n    @staticmethod\n    @abstractmethod\n    def _get_publisher_key(publisher: BasePublisher[MsgType]) -&gt; PublisherKeyType:\n        \"\"\"This is a Python function.\n\n        _get_publisher_key function:\n\n        Args:\n            publisher: An instance of BasePublisher class.\n\n        Returns:\n            The publisher key.\n\n        Raises:\n            NotImplementedError: This function is not implemented.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        raise NotImplementedError()\n\n    @staticmethod\n    @abstractmethod\n    def _update_publisher_prefix(\n        prefix: str,\n        publisher: BasePublisher[MsgType],\n    ) -&gt; BasePublisher[MsgType]:\n        \"\"\"Updates the publisher prefix.\n\n        Args:\n            prefix: The new prefix to be set.\n            publisher: The publisher to update.\n\n        Returns:\n            The updated publisher.\n\n        Raises:\n            NotImplementedError: If the function is not implemented.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        raise NotImplementedError()\n\n    def __init__(\n        self,\n        prefix: str = \"\",\n        handlers: Sequence[BrokerRoute[MsgType, SendableMessage]] = (),\n        dependencies: Sequence[Depends] = (),\n        middlewares: Optional[\n            Sequence[\n                Callable[\n                    [StreamMessage[MsgType]],\n                    AsyncContextManager[None],\n                ]\n            ]\n        ] = None,\n        parser: Optional[CustomParser[MsgType, StreamMessage[MsgType]]] = None,\n        decoder: Optional[CustomDecoder[StreamMessage[MsgType]]] = None,\n    ):\n        \"\"\"Initialize a class object.\n\n        Args:\n            prefix (str): Prefix for the object.\n            handlers (Sequence[BrokerRoute[MsgType, SendableMessage]]): Handlers for the object.\n            dependencies (Sequence[Depends]): Dependencies for the object.\n            middlewares (Optional[Sequence[Callable[[StreamMessage[MsgType]], AsyncContextManager[None]]]]): Middlewares for the object.\n            parser (Optional[CustomParser[MsgType]]): Parser for the object.\n            decoder (Optional[CustomDecoder[StreamMessage[MsgType]]]): Decoder for the object.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        self.prefix = prefix\n        self._handlers = list(handlers)\n        self._publishers = {}\n        self._dependencies = dependencies\n        self._middlewares = middlewares\n        self._parser = parser\n        self._decoder = decoder\n\n    @abstractmethod\n    def subscriber(\n        self,\n        subj: str,\n        *args: Any,\n        dependencies: Sequence[Depends] = (),\n        middlewares: Optional[\n            Sequence[\n                Callable[\n                    [StreamMessage[MsgType]],\n                    AsyncContextManager[None],\n                ]\n            ]\n        ] = None,\n        parser: Optional[CustomParser[MsgType, StreamMessage[MsgType]]] = None,\n        decoder: Optional[CustomDecoder[StreamMessage[MsgType]]] = None,\n        **kwargs: Any,\n    ) -&gt; Callable[\n        [Callable[P_HandlerParams, T_HandlerReturn]],\n        HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn],\n    ]:\n        \"\"\"A function to subscribe to a subject.\n\n        Args:\n            subj : subject to subscribe to\n            *args : additional arguments\n            dependencies : sequence of dependencies\n            middlewares : optional sequence of middlewares\n            parser : optional custom parser\n            decoder : optional custom decoder\n            **kwargs : additional keyword arguments\n\n        Returns:\n            A callable handler function\n\n        Raises:\n            NotImplementedError: If the function is not implemented\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        raise NotImplementedError()\n\n    def _wrap_subscriber(\n        self,\n        *args: Any,\n        dependencies: Sequence[Depends] = (),\n        middlewares: Optional[\n            Sequence[\n                Callable[\n                    [StreamMessage[MsgType]],\n                    AsyncContextManager[None],\n                ]\n            ]\n        ] = None,\n        parser: Optional[CustomParser[MsgType, StreamMessage[MsgType]]] = None,\n        decoder: Optional[CustomDecoder[StreamMessage[MsgType]]] = None,\n        **kwargs: Any,\n    ) -&gt; Callable[\n        [Callable[P_HandlerParams, T_HandlerReturn]],\n        HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn],\n    ]:\n        \"\"\"This is a function named `_wrap_subscriber` that returns a callable object. It is used as a decorator for another function.\n\n        Args:\n            *args: Variable length arguments\n            dependencies: Sequence of dependencies\n            middlewares: Optional sequence of middlewares\n            parser: Optional custom parser\n            decoder: Optional custom decoder\n            **kwargs: Variable length keyword arguments\n\n        Returns:\n            A callable object that wraps the decorated function\n\n        This function is decorated with `@abstractmethod`, indicating that it is an abstract method and must be implemented by any subclass.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n\n        def router_subscriber_wrapper(\n            func: Callable[P_HandlerParams, T_HandlerReturn]\n        ) -&gt; HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn]:\n            \"\"\"Wraps a function with a router subscriber.\n\n            Args:\n                func: The function to be wrapped.\n\n            Returns:\n                The wrapped function.\n            !!! note\n\n                The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n            \"\"\"\n            wrapped_func: HandlerCallWrapper[\n                MsgType, P_HandlerParams, T_HandlerReturn\n            ] = HandlerCallWrapper(func)\n            route: BrokerRoute[MsgType, T_HandlerReturn] = BrokerRoute(\n                wrapped_func,\n                *args,\n                dependencies=(*self._dependencies, *dependencies),\n                middlewares=(*(self._middlewares or ()), *(middlewares or ())) or None,\n                parser=parser or self._parser,\n                decoder=decoder or self._decoder,\n                **kwargs,\n            )\n            self._handlers.append(route)\n            return wrapped_func\n\n        return router_subscriber_wrapper\n\n    @abstractmethod\n    def publisher(\n        self,\n        subj: str,\n        *args: Any,\n        **kwargs: Any,\n    ) -&gt; BasePublisher[MsgType]:\n        \"\"\"Publishes a message.\n\n        Args:\n            subj: Subject of the message\n            *args: Additional arguments\n            **kwargs: Additional keyword arguments\n\n        Returns:\n            The published message\n\n        Raises:\n            NotImplementedError: If the method is not implemented\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        raise NotImplementedError()\n\n    def include_router(self, router: \"BrokerRouter[PublisherKeyType, MsgType]\") -&gt; None:\n        \"\"\"Includes a router in the current object.\n\n        Args:\n            router: The router to be included.\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        for h in router._handlers:\n            self.subscriber(*h.args, **h.kwargs)(h.call)\n\n        for p in router._publishers.values():\n            p = self._update_publisher_prefix(self.prefix, p)\n            key = self._get_publisher_key(p)\n            self._publishers[key] = self._publishers.get(key, p)\n\n    def include_routers(\n        self, *routers: \"BrokerRouter[PublisherKeyType, MsgType]\"\n    ) -&gt; None:\n        \"\"\"Includes routers in the object.\n\n        Args:\n            *routers: Variable length argument list of routers to include.\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        for r in routers:\n            self.include_router(r)\n</code></pre>"},{"location":"api/faststream/broker/router/BrokerRouter/#faststream.broker.router.BrokerRouter.prefix","title":"prefix  <code>instance-attribute</code>","text":"<pre><code>prefix: str = prefix\n</code></pre>"},{"location":"api/faststream/broker/router/BrokerRouter/#faststream.broker.router.BrokerRouter.include_router","title":"include_router","text":"<pre><code>include_router(\n    router: BrokerRouter[PublisherKeyType, MsgType]\n) -&gt; None\n</code></pre> <p>Includes a router in the current object.</p> PARAMETER  DESCRIPTION <code>router</code> <p>The router to be included.</p> <p> TYPE: <code>BrokerRouter[PublisherKeyType, MsgType]</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/router.py</code> <pre><code>def include_router(self, router: \"BrokerRouter[PublisherKeyType, MsgType]\") -&gt; None:\n    \"\"\"Includes a router in the current object.\n\n    Args:\n        router: The router to be included.\n\n    Returns:\n        None\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    for h in router._handlers:\n        self.subscriber(*h.args, **h.kwargs)(h.call)\n\n    for p in router._publishers.values():\n        p = self._update_publisher_prefix(self.prefix, p)\n        key = self._get_publisher_key(p)\n        self._publishers[key] = self._publishers.get(key, p)\n</code></pre>"},{"location":"api/faststream/broker/router/BrokerRouter/#faststream.broker.router.BrokerRouter.include_routers","title":"include_routers","text":"<pre><code>include_routers(\n    *routers: BrokerRouter[PublisherKeyType, MsgType]\n) -&gt; None\n</code></pre> <p>Includes routers in the object.</p> PARAMETER  DESCRIPTION <code>*routers</code> <p>Variable length argument list of routers to include.</p> <p> TYPE: <code>BrokerRouter[PublisherKeyType, MsgType]</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/router.py</code> <pre><code>def include_routers(\n    self, *routers: \"BrokerRouter[PublisherKeyType, MsgType]\"\n) -&gt; None:\n    \"\"\"Includes routers in the object.\n\n    Args:\n        *routers: Variable length argument list of routers to include.\n\n    Returns:\n        None\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    for r in routers:\n        self.include_router(r)\n</code></pre>"},{"location":"api/faststream/broker/router/BrokerRouter/#faststream.broker.router.BrokerRouter.publisher","title":"publisher  <code>abstractmethod</code>","text":"<pre><code>publisher(\n    subj: str, *args: Any, **kwargs: Any\n) -&gt; BasePublisher[MsgType]\n</code></pre> <p>Publishes a message.</p> PARAMETER  DESCRIPTION <code>subj</code> <p>Subject of the message</p> <p> TYPE: <code>str</code> </p> <code>*args</code> <p>Additional arguments</p> <p> TYPE: <code>Any</code> DEFAULT: <code>()</code> </p> <code>**kwargs</code> <p>Additional keyword arguments</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>BasePublisher[MsgType]</code> <p>The published message</p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>If the method is not implemented</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/router.py</code> <pre><code>@abstractmethod\ndef publisher(\n    self,\n    subj: str,\n    *args: Any,\n    **kwargs: Any,\n) -&gt; BasePublisher[MsgType]:\n    \"\"\"Publishes a message.\n\n    Args:\n        subj: Subject of the message\n        *args: Additional arguments\n        **kwargs: Additional keyword arguments\n\n    Returns:\n        The published message\n\n    Raises:\n        NotImplementedError: If the method is not implemented\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/broker/router/BrokerRouter/#faststream.broker.router.BrokerRouter.subscriber","title":"subscriber  <code>abstractmethod</code>","text":"<pre><code>subscriber(\n    subj: str,\n    *args: Any,\n    dependencies: Sequence[Depends] = (),\n    middlewares: Optional[\n        Sequence[\n            Callable[\n                [StreamMessage[MsgType]],\n                AsyncContextManager[None],\n            ]\n        ]\n    ] = None,\n    parser: Optional[\n        CustomParser[MsgType, StreamMessage[MsgType]]\n    ] = None,\n    decoder: Optional[\n        CustomDecoder[StreamMessage[MsgType]]\n    ] = None,\n    **kwargs: Any\n) -&gt; Callable[\n    [Callable[P_HandlerParams, T_HandlerReturn]],\n    HandlerCallWrapper[\n        MsgType, P_HandlerParams, T_HandlerReturn\n    ],\n]\n</code></pre> <p>A function to subscribe to a subject.</p> PARAMETER  DESCRIPTION <code>subj</code> <p>subject to subscribe to</p> <p> </p> <code>*args</code> <p>additional arguments</p> <p> DEFAULT: <code>()</code> </p> <code>dependencies</code> <p>sequence of dependencies</p> <p> DEFAULT: <code>()</code> </p> <code>middlewares</code> <p>optional sequence of middlewares</p> <p> DEFAULT: <code>None</code> </p> <code>parser</code> <p>optional custom parser</p> <p> DEFAULT: <code>None</code> </p> <code>decoder</code> <p>optional custom decoder</p> <p> DEFAULT: <code>None</code> </p> <code>**kwargs</code> <p>additional keyword arguments</p> <p> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Callable[[Callable[P_HandlerParams, T_HandlerReturn]], HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn]]</code> <p>A callable handler function</p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>If the function is not implemented</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/router.py</code> <pre><code>@abstractmethod\ndef subscriber(\n    self,\n    subj: str,\n    *args: Any,\n    dependencies: Sequence[Depends] = (),\n    middlewares: Optional[\n        Sequence[\n            Callable[\n                [StreamMessage[MsgType]],\n                AsyncContextManager[None],\n            ]\n        ]\n    ] = None,\n    parser: Optional[CustomParser[MsgType, StreamMessage[MsgType]]] = None,\n    decoder: Optional[CustomDecoder[StreamMessage[MsgType]]] = None,\n    **kwargs: Any,\n) -&gt; Callable[\n    [Callable[P_HandlerParams, T_HandlerReturn]],\n    HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn],\n]:\n    \"\"\"A function to subscribe to a subject.\n\n    Args:\n        subj : subject to subscribe to\n        *args : additional arguments\n        dependencies : sequence of dependencies\n        middlewares : optional sequence of middlewares\n        parser : optional custom parser\n        decoder : optional custom decoder\n        **kwargs : additional keyword arguments\n\n    Returns:\n        A callable handler function\n\n    Raises:\n        NotImplementedError: If the function is not implemented\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/broker/schemas/NameRequired/","title":"NameRequired","text":""},{"location":"api/faststream/broker/schemas/NameRequired/#faststream.broker.schemas.NameRequired","title":"faststream.broker.schemas.NameRequired","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent a required name.</p> METHOD DESCRIPTION <code>__eq__</code> <p>object) -&gt; bool: Check if the given value is equal to the current instance.</p> <code>__init__</code> <p>str, **kwargs: Any): Initialize the NameRequired instance.</p> <code>validate</code> <p>Type[NameRequiredCls], value: Union[str, NameRequiredCls]) -&gt; NameRequiredCls: Validate the given value and return a NameRequiredCls instance.</p> <code>validate</code> <p>Type[NameRequiredCls], value: None) -&gt; None: Validate the given value and return None.</p> <code>validate</code> <p>Type[NameRequiredCls], value: Union[str, NameRequiredCls, None]) -&gt; Optional[NameRequiredCls]: Validate the given value and return an optional NameRequiredCls instance.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/schemas.py</code> <pre><code>class NameRequired(BaseModel):\n    \"\"\"A class to represent a required name.\n\n    Attributes:\n        name : optional name\n\n    Methods:\n        __eq__(self, __value: object) -&gt; bool: Check if the given value is equal to the current instance.\n        __init__(self, name: str, **kwargs: Any): Initialize the NameRequired instance.\n        validate(cls: Type[NameRequiredCls], value: Union[str, NameRequiredCls]) -&gt; NameRequiredCls: Validate the given value and return a NameRequiredCls instance.\n        validate(cls: Type[NameRequiredCls], value: None) -&gt; None: Validate the given value and return None.\n        validate(cls: Type[NameRequiredCls], value: Union[str, NameRequiredCls, None]) -&gt; Optional[NameRequiredCls]: Validate the given value and return an optional NameRequiredCls instance.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    name: str = Field(...)\n\n    def __eq__(self, __value: object) -&gt; bool:\n        \"\"\"Compares the current object with another object for equality.\n\n        Args:\n            __value: The object to compare with.\n\n        Returns:\n            True if the objects are equal, False otherwise.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        if __value is None:\n            return False\n\n        if not isinstance(__value, NameRequired):  # pragma: no cover\n            return NotImplemented\n\n        return self.name == __value.name\n\n    def __init__(self, name: str, **kwargs: Any) -&gt; None:\n        \"\"\"This is a Python function.\n\n        Args:\n            name (str): The name of the object.\n            **kwargs (Any): Additional keyword arguments.\n\n        Returns:\n            None.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        super().__init__(name=name, **kwargs)\n\n    @overload\n    @classmethod\n    def validate(\n        cls: Type[NameRequiredCls], value: Union[str, NameRequiredCls]\n    ) -&gt; NameRequiredCls:\n        \"\"\"Validates a value.\n\n        Args:\n            value: The value to validate.\n\n        Returns:\n            The validated value.\n\n        Raises:\n            TypeError: If the value is not of the expected type.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        ...\n\n    @overload\n    @classmethod\n    def validate(cls: Type[NameRequiredCls], value: None) -&gt; None:\n        \"\"\"Validate a value.\n\n        Args:\n            value: The value to be validated\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        ...\n\n    @classmethod\n    def validate(\n        cls: Type[NameRequiredCls], value: Union[str, NameRequiredCls, None]\n    ) -&gt; Optional[NameRequiredCls]:\n        \"\"\"Validates a value.\n\n        Args:\n            value: The value to be validated.\n\n        Returns:\n            The validated value.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        if value is not None:\n            if isinstance(value, str):\n                value = cls(value)\n        return value\n</code></pre>"},{"location":"api/faststream/broker/schemas/NameRequired/#faststream.broker.schemas.NameRequired.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str = Field(...)\n</code></pre>"},{"location":"api/faststream/broker/schemas/NameRequired/#faststream.broker.schemas.NameRequired.validate","title":"validate  <code>classmethod</code>","text":"<pre><code>validate(\n    value: Union[str, NameRequiredCls, None]\n) -&gt; Optional[NameRequiredCls]\n</code></pre> <p>Validates a value.</p> PARAMETER  DESCRIPTION <code>value</code> <p>The value to be validated.</p> <p> TYPE: <code>Union[str, NameRequiredCls, None]</code> </p> RETURNS DESCRIPTION <code>Optional[NameRequiredCls]</code> <p>The validated value.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/schemas.py</code> <pre><code>@classmethod\ndef validate(\n    cls: Type[NameRequiredCls], value: Union[str, NameRequiredCls, None]\n) -&gt; Optional[NameRequiredCls]:\n    \"\"\"Validates a value.\n\n    Args:\n        value: The value to be validated.\n\n    Returns:\n        The validated value.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    if value is not None:\n        if isinstance(value, str):\n            value = cls(value)\n    return value\n</code></pre>"},{"location":"api/faststream/broker/schemas/RawDecoced/","title":"RawDecoced","text":""},{"location":"api/faststream/broker/schemas/RawDecoced/#faststream.broker.schemas.RawDecoced","title":"faststream.broker.schemas.RawDecoced","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent a raw decoded message.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/schemas.py</code> <pre><code>class RawDecoced(BaseModel):\n    \"\"\"A class to represent a raw decoded message.\n\n    Attributes:\n        message : the decoded message, which can be either a JSON object or a string\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    message: Union[Json[Any], str]\n</code></pre>"},{"location":"api/faststream/broker/schemas/RawDecoced/#faststream.broker.schemas.RawDecoced.message","title":"message  <code>instance-attribute</code>","text":"<pre><code>message: Union[Json[Any], str]\n</code></pre>"},{"location":"api/faststream/broker/security/BaseSecurity/","title":"BaseSecurity","text":""},{"location":"api/faststream/broker/security/BaseSecurity/#faststream.broker.security.BaseSecurity","title":"faststream.broker.security.BaseSecurity","text":"<p>Base class for defining security configurations.</p> <p>This class provides a base for defining security configurations for communication with a broker. It allows setting SSL encryption and provides methods to retrieve security requirements and schemas.</p> PARAMETER  DESCRIPTION <code>ssl_context</code> <p>An SSLContext object for SSL encryption. If None, SSL encryption is disabled.</p> <p> TYPE: <code>Optional[SSLContext]</code> DEFAULT: <code>None</code> </p> <code>use_ssl</code> <p>A boolean indicating whether to use SSL encryption. Defaults to True.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> METHOD DESCRIPTION <code>get_requirement</code> <p>Get the security requirements in the form of a list of dictionaries.</p> <code>get_schema</code> <p>Get the security schema as a dictionary.</p> Source code in <code>faststream/broker/security.py</code> <pre><code>class BaseSecurity:\n    \"\"\"\n    Base class for defining security configurations.\n\n    This class provides a base for defining security configurations for communication with a broker. It allows setting\n    SSL encryption and provides methods to retrieve security requirements and schemas.\n\n    Args:\n        ssl_context (Optional[SSLContext]): An SSLContext object for SSL encryption. If None, SSL encryption is disabled.\n        use_ssl (Optional[bool]): A boolean indicating whether to use SSL encryption. Defaults to True.\n\n    Attributes:\n        use_ssl (bool): A boolean indicating whether SSL encryption is enabled.\n        ssl_context (Optional[SSLContext]): An SSLContext object for SSL encryption. None if SSL is not used.\n\n    Methods:\n        get_requirement(self) -&gt; List[Dict[str, Any]]:\n            Get the security requirements in the form of a list of dictionaries.\n\n        get_schema(self) -&gt; Dict[str, Dict[str, str]]:\n            Get the security schema as a dictionary.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        ssl_context: Optional[SSLContext] = None,\n        use_ssl: Optional[bool] = None,\n    ):\n        if use_ssl is None:\n            use_ssl = True\n\n        if use_ssl and ssl_context is None:\n            raise RuntimeError(ssl_not_set_error_msg)\n\n        self.use_ssl = use_ssl\n        self.ssl_context = ssl_context\n\n    def get_requirement(self) -&gt; List[Dict[str, Any]]:\n        \"\"\"\n        Get the security requirements.\n\n        Returns:\n            List[Dict[str, Any]]: A list of dictionaries representing security requirements.\n        \"\"\"\n        return []\n\n    def get_schema(self) -&gt; Dict[str, Dict[str, str]]:\n        \"\"\"\n        Get the security schema.\n\n        Returns:\n            Dict[str, Dict[str, str]]: A dictionary representing the security schema.\n        \"\"\"\n        return {}\n</code></pre>"},{"location":"api/faststream/broker/security/BaseSecurity/#faststream.broker.security.BaseSecurity.ssl_context","title":"ssl_context  <code>instance-attribute</code>","text":"<pre><code>ssl_context = ssl_context\n</code></pre>"},{"location":"api/faststream/broker/security/BaseSecurity/#faststream.broker.security.BaseSecurity.use_ssl","title":"use_ssl  <code>instance-attribute</code>","text":"<pre><code>use_ssl = use_ssl\n</code></pre>"},{"location":"api/faststream/broker/security/BaseSecurity/#faststream.broker.security.BaseSecurity.get_requirement","title":"get_requirement","text":"<pre><code>get_requirement() -&gt; List[Dict[str, Any]]\n</code></pre> <p>Get the security requirements.</p> RETURNS DESCRIPTION <code>List[Dict[str, Any]]</code> <p>List[Dict[str, Any]]: A list of dictionaries representing security requirements.</p> Source code in <code>faststream/broker/security.py</code> <pre><code>def get_requirement(self) -&gt; List[Dict[str, Any]]:\n    \"\"\"\n    Get the security requirements.\n\n    Returns:\n        List[Dict[str, Any]]: A list of dictionaries representing security requirements.\n    \"\"\"\n    return []\n</code></pre>"},{"location":"api/faststream/broker/security/BaseSecurity/#faststream.broker.security.BaseSecurity.get_schema","title":"get_schema","text":"<pre><code>get_schema() -&gt; Dict[str, Dict[str, str]]\n</code></pre> <p>Get the security schema.</p> RETURNS DESCRIPTION <code>Dict[str, Dict[str, str]]</code> <p>Dict[str, Dict[str, str]]: A dictionary representing the security schema.</p> Source code in <code>faststream/broker/security.py</code> <pre><code>def get_schema(self) -&gt; Dict[str, Dict[str, str]]:\n    \"\"\"\n    Get the security schema.\n\n    Returns:\n        Dict[str, Dict[str, str]]: A dictionary representing the security schema.\n    \"\"\"\n    return {}\n</code></pre>"},{"location":"api/faststream/broker/security/SASLPlaintext/","title":"SASLPlaintext","text":""},{"location":"api/faststream/broker/security/SASLPlaintext/#faststream.broker.security.SASLPlaintext","title":"faststream.broker.security.SASLPlaintext","text":"<p>             Bases: <code>BaseSecurity</code></p> <p>Security configuration for SASL/PLAINTEXT authentication.</p> <p>This class defines security configuration for SASL/PLAINTEXT authentication, which includes a username and password.</p> PARAMETER  DESCRIPTION <code>username</code> <p>The username for authentication.</p> <p> TYPE: <code>str</code> </p> <code>password</code> <p>The password for authentication.</p> <p> TYPE: <code>str</code> </p> <code>ssl_context</code> <p>An SSLContext object for SSL encryption. If None, SSL encryption is disabled.</p> <p> TYPE: <code>Optional[SSLContext]</code> DEFAULT: <code>None</code> </p> <code>use_ssl</code> <p>A boolean indicating whether to use SSL encryption. Defaults to True.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> METHOD DESCRIPTION <code>get_requirement</code> <p>Get the security requirements for SASL/PLAINTEXT authentication.</p> <code>get_schema</code> <p>Get the security schema for SASL/PLAINTEXT authentication.</p> Source code in <code>faststream/broker/security.py</code> <pre><code>class SASLPlaintext(BaseSecurity):\n    \"\"\"\n    Security configuration for SASL/PLAINTEXT authentication.\n\n    This class defines security configuration for SASL/PLAINTEXT authentication, which includes a username and password.\n\n    Args:\n        username (str): The username for authentication.\n        password (str): The password for authentication.\n        ssl_context (Optional[SSLContext]): An SSLContext object for SSL encryption. If None, SSL encryption is disabled.\n        use_ssl (Optional[bool]): A boolean indicating whether to use SSL encryption. Defaults to True.\n\n    Methods:\n        get_requirement(self) -&gt; List[Dict[str, Any]]:\n            Get the security requirements for SASL/PLAINTEXT authentication.\n\n        get_schema(self) -&gt; Dict[str, Dict[str, str]]:\n            Get the security schema for SASL/PLAINTEXT authentication.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        username: str,\n        password: str,\n        ssl_context: Optional[SSLContext] = None,\n        use_ssl: Optional[bool] = None,\n    ):\n        super().__init__(ssl_context, use_ssl)\n        self.username = username\n        self.password = password\n\n    def get_requirement(self) -&gt; List[Dict[str, Any]]:\n        \"\"\"\n        Get the security requirements for SASL/PLAINTEXT authentication.\n\n        Returns:\n            List[Dict[str, Any]]: A list of dictionaries representing security requirements.\n        \"\"\"\n        return [{\"user-password\": []}]\n\n    def get_schema(self) -&gt; Dict[str, Dict[str, str]]:\n        \"\"\"\n        Get the security schema for SASL/PLAINTEXT authentication.\n\n        Returns:\n            Dict[str, Dict[str, str]]: A dictionary representing the security schema.\n        \"\"\"\n        return {\"user-password\": {\"type\": \"userPassword\"}}\n</code></pre>"},{"location":"api/faststream/broker/security/SASLPlaintext/#faststream.broker.security.SASLPlaintext.password","title":"password  <code>instance-attribute</code>","text":"<pre><code>password = password\n</code></pre>"},{"location":"api/faststream/broker/security/SASLPlaintext/#faststream.broker.security.SASLPlaintext.username","title":"username  <code>instance-attribute</code>","text":"<pre><code>username = username\n</code></pre>"},{"location":"api/faststream/broker/security/SASLPlaintext/#faststream.broker.security.SASLPlaintext.get_requirement","title":"get_requirement","text":"<pre><code>get_requirement() -&gt; List[Dict[str, Any]]\n</code></pre> <p>Get the security requirements for SASL/PLAINTEXT authentication.</p> RETURNS DESCRIPTION <code>List[Dict[str, Any]]</code> <p>List[Dict[str, Any]]: A list of dictionaries representing security requirements.</p> Source code in <code>faststream/broker/security.py</code> <pre><code>def get_requirement(self) -&gt; List[Dict[str, Any]]:\n    \"\"\"\n    Get the security requirements for SASL/PLAINTEXT authentication.\n\n    Returns:\n        List[Dict[str, Any]]: A list of dictionaries representing security requirements.\n    \"\"\"\n    return [{\"user-password\": []}]\n</code></pre>"},{"location":"api/faststream/broker/security/SASLPlaintext/#faststream.broker.security.SASLPlaintext.get_schema","title":"get_schema","text":"<pre><code>get_schema() -&gt; Dict[str, Dict[str, str]]\n</code></pre> <p>Get the security schema for SASL/PLAINTEXT authentication.</p> RETURNS DESCRIPTION <code>Dict[str, Dict[str, str]]</code> <p>Dict[str, Dict[str, str]]: A dictionary representing the security schema.</p> Source code in <code>faststream/broker/security.py</code> <pre><code>def get_schema(self) -&gt; Dict[str, Dict[str, str]]:\n    \"\"\"\n    Get the security schema for SASL/PLAINTEXT authentication.\n\n    Returns:\n        Dict[str, Dict[str, str]]: A dictionary representing the security schema.\n    \"\"\"\n    return {\"user-password\": {\"type\": \"userPassword\"}}\n</code></pre>"},{"location":"api/faststream/broker/security/SASLScram256/","title":"SASLScram256","text":""},{"location":"api/faststream/broker/security/SASLScram256/#faststream.broker.security.SASLScram256","title":"faststream.broker.security.SASLScram256","text":"<p>             Bases: <code>BaseSecurity</code></p> <p>Security configuration for SASL/SCRAM-SHA-256 authentication.</p> <p>This class defines security configuration for SASL/SCRAM-SHA-256 authentication, which includes a username and password.</p> PARAMETER  DESCRIPTION <code>username</code> <p>The username for authentication.</p> <p> TYPE: <code>str</code> </p> <code>password</code> <p>The password for authentication.</p> <p> TYPE: <code>str</code> </p> <code>ssl_context</code> <p>An SSLContext object for SSL encryption. If None, SSL encryption is disabled.</p> <p> TYPE: <code>Optional[SSLContext]</code> DEFAULT: <code>None</code> </p> <code>use_ssl</code> <p>A boolean indicating whether to use SSL encryption. Defaults to True.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> METHOD DESCRIPTION <code>get_requirement</code> <p>Get the security requirements for SASL/SCRAM-SHA-256 authentication.</p> <code>get_schema</code> <p>Get the security schema for SASL/SCRAM-SHA-256 authentication.</p> Source code in <code>faststream/broker/security.py</code> <pre><code>class SASLScram256(BaseSecurity):\n    \"\"\"\n    Security configuration for SASL/SCRAM-SHA-256 authentication.\n\n    This class defines security configuration for SASL/SCRAM-SHA-256 authentication, which includes a username and password.\n\n    Args:\n        username (str): The username for authentication.\n        password (str): The password for authentication.\n        ssl_context (Optional[SSLContext]): An SSLContext object for SSL encryption. If None, SSL encryption is disabled.\n        use_ssl (Optional[bool]): A boolean indicating whether to use SSL encryption. Defaults to True.\n\n    Methods:\n        get_requirement(self) -&gt; List[Dict[str, Any]]:\n            Get the security requirements for SASL/SCRAM-SHA-256 authentication.\n\n        get_schema(self) -&gt; Dict[str, Dict[str, str]]:\n            Get the security schema for SASL/SCRAM-SHA-256 authentication.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        username: str,\n        password: str,\n        ssl_context: Optional[SSLContext] = None,\n        use_ssl: Optional[bool] = None,\n    ):\n        super().__init__(ssl_context, use_ssl)\n        self.username = username\n        self.password = password\n\n    def get_requirement(self) -&gt; List[Dict[str, Any]]:\n        \"\"\"\n        Get the security requirements for SASL/SCRAM-SHA-256 authentication.\n\n        Returns:\n            List[Dict[str, Any]]: A list of dictionaries representing security requirements.\n        \"\"\"\n        return [{\"scram256\": []}]\n\n    def get_schema(self) -&gt; Dict[str, Dict[str, str]]:\n        \"\"\"\n        Get the security schema for SASL/SCRAM-SHA-256 authentication.\n\n        Returns:\n            Dict[str, Dict[str, str]]: A dictionary representing the security schema.\n        \"\"\"\n        return {\"scram256\": {\"type\": \"scramSha256\"}}\n</code></pre>"},{"location":"api/faststream/broker/security/SASLScram256/#faststream.broker.security.SASLScram256.password","title":"password  <code>instance-attribute</code>","text":"<pre><code>password = password\n</code></pre>"},{"location":"api/faststream/broker/security/SASLScram256/#faststream.broker.security.SASLScram256.username","title":"username  <code>instance-attribute</code>","text":"<pre><code>username = username\n</code></pre>"},{"location":"api/faststream/broker/security/SASLScram256/#faststream.broker.security.SASLScram256.get_requirement","title":"get_requirement","text":"<pre><code>get_requirement() -&gt; List[Dict[str, Any]]\n</code></pre> <p>Get the security requirements for SASL/SCRAM-SHA-256 authentication.</p> RETURNS DESCRIPTION <code>List[Dict[str, Any]]</code> <p>List[Dict[str, Any]]: A list of dictionaries representing security requirements.</p> Source code in <code>faststream/broker/security.py</code> <pre><code>def get_requirement(self) -&gt; List[Dict[str, Any]]:\n    \"\"\"\n    Get the security requirements for SASL/SCRAM-SHA-256 authentication.\n\n    Returns:\n        List[Dict[str, Any]]: A list of dictionaries representing security requirements.\n    \"\"\"\n    return [{\"scram256\": []}]\n</code></pre>"},{"location":"api/faststream/broker/security/SASLScram256/#faststream.broker.security.SASLScram256.get_schema","title":"get_schema","text":"<pre><code>get_schema() -&gt; Dict[str, Dict[str, str]]\n</code></pre> <p>Get the security schema for SASL/SCRAM-SHA-256 authentication.</p> RETURNS DESCRIPTION <code>Dict[str, Dict[str, str]]</code> <p>Dict[str, Dict[str, str]]: A dictionary representing the security schema.</p> Source code in <code>faststream/broker/security.py</code> <pre><code>def get_schema(self) -&gt; Dict[str, Dict[str, str]]:\n    \"\"\"\n    Get the security schema for SASL/SCRAM-SHA-256 authentication.\n\n    Returns:\n        Dict[str, Dict[str, str]]: A dictionary representing the security schema.\n    \"\"\"\n    return {\"scram256\": {\"type\": \"scramSha256\"}}\n</code></pre>"},{"location":"api/faststream/broker/security/SASLScram512/","title":"SASLScram512","text":""},{"location":"api/faststream/broker/security/SASLScram512/#faststream.broker.security.SASLScram512","title":"faststream.broker.security.SASLScram512","text":"<p>             Bases: <code>BaseSecurity</code></p> <p>Security configuration for SASL/SCRAM-SHA-512 authentication.</p> <p>This class defines security configuration for SASL/SCRAM-SHA-512 authentication, which includes a username and password.</p> PARAMETER  DESCRIPTION <code>username</code> <p>The username for authentication.</p> <p> TYPE: <code>str</code> </p> <code>password</code> <p>The password for authentication.</p> <p> TYPE: <code>str</code> </p> <code>ssl_context</code> <p>An SSLContext object for SSL encryption. If None, SSL encryption is disabled.</p> <p> TYPE: <code>Optional[SSLContext]</code> DEFAULT: <code>None</code> </p> <code>use_ssl</code> <p>A boolean indicating whether to use SSL encryption. Defaults to True.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> METHOD DESCRIPTION <code>get_requirement</code> <p>Get the security requirements for SASL/SCRAM-SHA-512 authentication.</p> <code>get_schema</code> <p>Get the security schema for SASL/SCRAM-SHA-512 authentication.</p> Source code in <code>faststream/broker/security.py</code> <pre><code>class SASLScram512(BaseSecurity):\n    \"\"\"\n    Security configuration for SASL/SCRAM-SHA-512 authentication.\n\n    This class defines security configuration for SASL/SCRAM-SHA-512 authentication, which includes a username and password.\n\n    Args:\n        username (str): The username for authentication.\n        password (str): The password for authentication.\n        ssl_context (Optional[SSLContext]): An SSLContext object for SSL encryption. If None, SSL encryption is disabled.\n        use_ssl (Optional[bool]): A boolean indicating whether to use SSL encryption. Defaults to True.\n\n    Methods:\n        get_requirement(self) -&gt; List[Dict[str, Any]]:\n            Get the security requirements for SASL/SCRAM-SHA-512 authentication.\n\n        get_schema(self) -&gt; Dict[str, Dict[str, str]]:\n            Get the security schema for SASL/SCRAM-SHA-512 authentication.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        username: str,\n        password: str,\n        ssl_context: Optional[SSLContext] = None,\n        use_ssl: Optional[bool] = None,\n    ):\n        super().__init__(ssl_context, use_ssl)\n        self.username = username\n        self.password = password\n\n    def get_requirement(self) -&gt; List[Dict[str, Any]]:\n        \"\"\"\n        Get the security requirements for SASL/SCRAM-SHA-512 authentication.\n\n        Returns:\n            List[Dict[str, Any]]: A list of dictionaries representing security requirements.\n        \"\"\"\n        return [{\"scram512\": []}]\n\n    def get_schema(self) -&gt; Dict[str, Dict[str, str]]:\n        \"\"\"\n        Get the security schema for SASL/SCRAM-SHA-512 authentication.\n\n        Returns:\n            Dict[str, Dict[str, str]]: A dictionary representing the security schema.\n        \"\"\"\n        return {\"scram512\": {\"type\": \"scramSha512\"}}\n</code></pre>"},{"location":"api/faststream/broker/security/SASLScram512/#faststream.broker.security.SASLScram512.password","title":"password  <code>instance-attribute</code>","text":"<pre><code>password = password\n</code></pre>"},{"location":"api/faststream/broker/security/SASLScram512/#faststream.broker.security.SASLScram512.username","title":"username  <code>instance-attribute</code>","text":"<pre><code>username = username\n</code></pre>"},{"location":"api/faststream/broker/security/SASLScram512/#faststream.broker.security.SASLScram512.get_requirement","title":"get_requirement","text":"<pre><code>get_requirement() -&gt; List[Dict[str, Any]]\n</code></pre> <p>Get the security requirements for SASL/SCRAM-SHA-512 authentication.</p> RETURNS DESCRIPTION <code>List[Dict[str, Any]]</code> <p>List[Dict[str, Any]]: A list of dictionaries representing security requirements.</p> Source code in <code>faststream/broker/security.py</code> <pre><code>def get_requirement(self) -&gt; List[Dict[str, Any]]:\n    \"\"\"\n    Get the security requirements for SASL/SCRAM-SHA-512 authentication.\n\n    Returns:\n        List[Dict[str, Any]]: A list of dictionaries representing security requirements.\n    \"\"\"\n    return [{\"scram512\": []}]\n</code></pre>"},{"location":"api/faststream/broker/security/SASLScram512/#faststream.broker.security.SASLScram512.get_schema","title":"get_schema","text":"<pre><code>get_schema() -&gt; Dict[str, Dict[str, str]]\n</code></pre> <p>Get the security schema for SASL/SCRAM-SHA-512 authentication.</p> RETURNS DESCRIPTION <code>Dict[str, Dict[str, str]]</code> <p>Dict[str, Dict[str, str]]: A dictionary representing the security schema.</p> Source code in <code>faststream/broker/security.py</code> <pre><code>def get_schema(self) -&gt; Dict[str, Dict[str, str]]:\n    \"\"\"\n    Get the security schema for SASL/SCRAM-SHA-512 authentication.\n\n    Returns:\n        Dict[str, Dict[str, str]]: A dictionary representing the security schema.\n    \"\"\"\n    return {\"scram512\": {\"type\": \"scramSha512\"}}\n</code></pre>"},{"location":"api/faststream/broker/test/TestApp/","title":"TestApp","text":""},{"location":"api/faststream/broker/test/TestApp/#faststream.broker.test.TestApp","title":"faststream.broker.test.TestApp","text":"<p>A class to represent a test application.</p> METHOD DESCRIPTION <code>__init__ </code> <p>initializes the TestApp object</p> <code>__aenter__ </code> <p>enters the asynchronous context and starts the FastStream application</p> <code>__aexit__ </code> <p>exits the asynchronous context and stops the FastStream application</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/test.py</code> <pre><code>class TestApp:\n    # make sure pytest doesn't try to collect this class as a test class\n    \"\"\"A class to represent a test application.\n\n    Attributes:\n        app : an instance of FastStream\n        _extra_options : optional dictionary of additional options\n        _event : an instance of anyio.Event\n        _task : an instance of TaskGroup\n\n    Methods:\n        __init__ : initializes the TestApp object\n        __aenter__ : enters the asynchronous context and starts the FastStream application\n        __aexit__ : exits the asynchronous context and stops the FastStream application\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    __test__ = False\n    app: FastStream\n    _extra_options: Optional[Dict[str, SettingField]]\n    _event: anyio.Event\n    _task: TaskGroup\n\n    def __init__(\n        self,\n        app: FastStream,\n        run_extra_options: Optional[Dict[str, SettingField]] = None,\n    ) -&gt; None:\n        \"\"\"Initialize a class instance.\n\n        Args:\n            app: An instance of the FastStream class.\n            run_extra_options: Optional dictionary of extra options for running the application.\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        self.app = app\n        self._extra_options = run_extra_options\n\n    async def __aenter__(self) -&gt; FastStream:\n        self.app._stop_event = self._event = anyio.Event()\n        await self.app._start(run_extra_options=self._extra_options)\n        self._task = tg = anyio.create_task_group()\n        await tg.__aenter__()\n        tg.start_soon(self.app._stop)\n        return self.app\n\n    async def __aexit__(\n        self,\n        exc_type: Optional[Type[BaseException]] = None,\n        exc_val: Optional[BaseException] = None,\n        exec_tb: Optional[TracebackType] = None,\n    ) -&gt; None:\n        \"\"\"Exit the asynchronous context manager.\n\n        Args:\n            exc_type: The type of the exception raised, if any.\n            exc_val: The exception instance raised, if any.\n            exec_tb: The traceback for the exception raised, if any.\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        self._event.set()\n        await self._task.__aexit__(None, None, None)\n</code></pre>"},{"location":"api/faststream/broker/test/TestApp/#faststream.broker.test.TestApp.app","title":"app  <code>instance-attribute</code>","text":"<pre><code>app: FastStream = app\n</code></pre>"},{"location":"api/faststream/broker/test/call_handler/","title":"Call handler","text":""},{"location":"api/faststream/broker/test/call_handler/#faststream.broker.test.call_handler","title":"faststream.broker.test.call_handler  <code>async</code>","text":"<pre><code>call_handler(\n    handler: AsyncHandler[Any],\n    message: Any,\n    rpc: bool = False,\n    rpc_timeout: Optional[float] = 30.0,\n    raise_timeout: bool = False,\n) -&gt; Optional[SendableMessage]\n</code></pre> <p>Asynchronously call a handler function.</p> PARAMETER  DESCRIPTION <code>handler</code> <p>The handler function to be called.</p> <p> TYPE: <code>AsyncHandler[Any]</code> </p> <code>message</code> <p>The message to be passed to the handler function.</p> <p> TYPE: <code>Any</code> </p> <code>rpc</code> <p>Whether the call is a remote procedure call (RPC).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>rpc_timeout</code> <p>The timeout for the RPC, in seconds.</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>30.0</code> </p> <code>raise_timeout</code> <p>Whether to raise a timeout error if the RPC times out.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Optional[SendableMessage]</code> <p>The result of the handler function if <code>rpc</code> is True, otherwise None.</p> RAISES DESCRIPTION <code>TimeoutError</code> <p>If the RPC times out and <code>raise_timeout</code> is True.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/test.py</code> <pre><code>async def call_handler(\n    handler: AsyncHandler[Any],\n    message: Any,\n    rpc: bool = False,\n    rpc_timeout: Optional[float] = 30.0,\n    raise_timeout: bool = False,\n) -&gt; Optional[SendableMessage]:\n    \"\"\"Asynchronously call a handler function.\n\n    Args:\n        handler: The handler function to be called.\n        message: The message to be passed to the handler function.\n        rpc: Whether the call is a remote procedure call (RPC).\n        rpc_timeout: The timeout for the RPC, in seconds.\n        raise_timeout: Whether to raise a timeout error if the RPC times out.\n\n    Returns:\n        The result of the handler function if `rpc` is True, otherwise None.\n\n    Raises:\n        TimeoutError: If the RPC times out and `raise_timeout` is True.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    with timeout_scope(rpc_timeout, raise_timeout):\n        result = await handler.consume(message)\n\n        if rpc is True:\n            return result\n\n    return None\n</code></pre>"},{"location":"api/faststream/broker/test/patch_broker_calls/","title":"Patch broker calls","text":""},{"location":"api/faststream/broker/test/patch_broker_calls/#faststream.broker.test.patch_broker_calls","title":"faststream.broker.test.patch_broker_calls","text":"<pre><code>patch_broker_calls(broker: BrokerUsecase[Any, Any]) -&gt; None\n</code></pre> <p>Patch broker calls.</p> PARAMETER  DESCRIPTION <code>broker</code> <p>The broker to patch.</p> <p> TYPE: <code>BrokerUsecase[Any, Any]</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/test.py</code> <pre><code>def patch_broker_calls(broker: BrokerUsecase[Any, Any]) -&gt; None:\n    \"\"\"Patch broker calls.\n\n    Args:\n        broker: The broker to patch.\n\n    Returns:\n        None.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    broker.middlewares = filter(  # type: ignore[assignment]\n        lambda x: not isinstance(x, CriticalLogMiddleware), broker.middlewares\n    )\n\n    for handler in broker.handlers.values():\n        for f, _, _, _, _, _ in handler.calls:\n            f.refresh(with_mock=False)\n</code></pre>"},{"location":"api/faststream/broker/types/AsyncPublisherProtocol/","title":"AsyncPublisherProtocol","text":""},{"location":"api/faststream/broker/types/AsyncPublisherProtocol/#faststream.broker.types.AsyncPublisherProtocol","title":"faststream.broker.types.AsyncPublisherProtocol","text":"<p>             Bases: <code>Protocol</code></p> <p>A protocol for an asynchronous publisher.</p> METHOD DESCRIPTION <code>publish</code> <p>SendableMessage, correlation_id: Optional[str] = None, **kwargs: Any) -&gt; Optional[SendableMessage]: Publishes a message asynchronously.</p> <p>Args:     message: The message to be published.     correlation_id: The correlation ID for the message (optional).     **kwargs: Additional keyword arguments.</p> <p>Returns:     The published message (optional).</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/types.py</code> <pre><code>class AsyncPublisherProtocol(Protocol):\n    \"\"\"A protocol for an asynchronous publisher.\n\n    Methods:\n        publish(message: SendableMessage, correlation_id: Optional[str] = None, **kwargs: Any) -&gt; Optional[SendableMessage]:\n            Publishes a message asynchronously.\n\n            Args:\n                message: The message to be published.\n                correlation_id: The correlation ID for the message (optional).\n                **kwargs: Additional keyword arguments.\n\n            Returns:\n                The published message (optional).\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    async def publish(\n        self,\n        message: SendableMessage,\n        correlation_id: Optional[str] = None,\n        **kwargs: Any,\n    ) -&gt; Optional[SendableMessage]:\n        \"\"\"Publishes a message.\n\n        Args:\n            message: The message to be published.\n            correlation_id: Optional correlation ID for the message.\n            **kwargs: Additional keyword arguments.\n\n        Returns:\n            The published message, or None if the message was not published.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        ...\n</code></pre>"},{"location":"api/faststream/broker/types/AsyncPublisherProtocol/#faststream.broker.types.AsyncPublisherProtocol.publish","title":"publish  <code>async</code>","text":"<pre><code>publish(\n    message: SendableMessage,\n    correlation_id: Optional[str] = None,\n    **kwargs: Any\n) -&gt; Optional[SendableMessage]\n</code></pre> <p>Publishes a message.</p> PARAMETER  DESCRIPTION <code>message</code> <p>The message to be published.</p> <p> TYPE: <code>SendableMessage</code> </p> <code>correlation_id</code> <p>Optional correlation ID for the message.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>**kwargs</code> <p>Additional keyword arguments.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Optional[SendableMessage]</code> <p>The published message, or None if the message was not published.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/types.py</code> <pre><code>async def publish(\n    self,\n    message: SendableMessage,\n    correlation_id: Optional[str] = None,\n    **kwargs: Any,\n) -&gt; Optional[SendableMessage]:\n    \"\"\"Publishes a message.\n\n    Args:\n        message: The message to be published.\n        correlation_id: Optional correlation ID for the message.\n        **kwargs: Additional keyword arguments.\n\n    Returns:\n        The published message, or None if the message was not published.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/faststream/broker/utils/change_logger_handlers/","title":"Change logger handlers","text":""},{"location":"api/faststream/broker/utils/change_logger_handlers/#faststream.broker.utils.change_logger_handlers","title":"faststream.broker.utils.change_logger_handlers","text":"<pre><code>change_logger_handlers(\n    logger: logging.Logger, fmt: str\n) -&gt; None\n</code></pre> <p>Change the formatter of the logger handlers.</p> PARAMETER  DESCRIPTION <code>logger</code> <p>The logger object.</p> <p> TYPE: <code>Logger</code> </p> <code>fmt</code> <p>The format string for the formatter.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/utils.py</code> <pre><code>def change_logger_handlers(logger: logging.Logger, fmt: str) -&gt; None:\n    \"\"\"Change the formatter of the logger handlers.\n\n    Args:\n        logger (logging.Logger): The logger object.\n        fmt (str): The format string for the formatter.\n\n    Returns:\n        None\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    for handler in getattr(logger, \"handlers\", ()):\n        formatter = handler.formatter\n        if formatter is not None:\n            use_colors = getattr(formatter, \"use_colors\", None)\n            if use_colors is not None:\n                kwargs = {\"use_colors\": use_colors}\n            else:\n                kwargs = {}\n            handler.setFormatter(type(formatter)(fmt, **kwargs))\n</code></pre>"},{"location":"api/faststream/broker/utils/get_watcher/","title":"Get watcher","text":""},{"location":"api/faststream/broker/utils/get_watcher/#faststream.broker.utils.get_watcher","title":"faststream.broker.utils.get_watcher","text":"<pre><code>get_watcher(\n    logger: Optional[logging.Logger],\n    try_number: Union[bool, int] = True,\n) -&gt; BaseWatcher\n</code></pre> <p>Get a watcher object based on the provided parameters.</p> PARAMETER  DESCRIPTION <code>logger</code> <p>Optional logger object for logging messages.</p> <p> TYPE: <code>Optional[Logger]</code> </p> <code>try_number</code> <p>Optional parameter to specify the type of watcher. - If set to True, an EndlessWatcher object will be returned. - If set to False, a OneTryWatcher object will be returned. - If set to an integer, a CounterWatcher object with the specified maximum number of tries will be returned.</p> <p> TYPE: <code>Union[bool, int]</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>BaseWatcher</code> <p>A watcher object based on the provided parameters.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/utils.py</code> <pre><code>def get_watcher(\n    logger: Optional[logging.Logger],\n    try_number: Union[bool, int] = True,\n) -&gt; BaseWatcher:\n    \"\"\"Get a watcher object based on the provided parameters.\n\n    Args:\n        logger: Optional logger object for logging messages.\n        try_number: Optional parameter to specify the type of watcher.\n            - If set to True, an EndlessWatcher object will be returned.\n            - If set to False, a OneTryWatcher object will be returned.\n            - If set to an integer, a CounterWatcher object with the specified maximum number of tries will be returned.\n\n    Returns:\n        A watcher object based on the provided parameters.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    watcher: Optional[BaseWatcher]\n    if try_number is True:\n        watcher = EndlessWatcher()\n    elif try_number is False:\n        watcher = OneTryWatcher()\n    else:\n        watcher = CounterWatcher(logger=logger, max_tries=try_number)\n    return watcher\n</code></pre>"},{"location":"api/faststream/broker/utils/set_message_context/","title":"Set message context","text":""},{"location":"api/faststream/broker/utils/set_message_context/#faststream.broker.utils.set_message_context","title":"faststream.broker.utils.set_message_context","text":"<pre><code>set_message_context(\n    func: Callable[\n        [StreamMessage[MsgType]],\n        Awaitable[WrappedReturn[T_HandlerReturn]],\n    ]\n) -&gt; Callable[\n    [StreamMessage[MsgType]],\n    Awaitable[WrappedReturn[T_HandlerReturn]],\n]\n</code></pre> <p>Sets the message context for a function.</p> PARAMETER  DESCRIPTION <code>func</code> <p>The function to set the message context for.</p> <p> TYPE: <code>Callable[[StreamMessage[MsgType]], Awaitable[WrappedReturn[T_HandlerReturn]]]</code> </p> RETURNS DESCRIPTION <code>Callable[[StreamMessage[MsgType]], Awaitable[WrappedReturn[T_HandlerReturn]]]</code> <p>The function with the message context set.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/utils.py</code> <pre><code>def set_message_context(\n    func: Callable[\n        [StreamMessage[MsgType]],\n        Awaitable[WrappedReturn[T_HandlerReturn]],\n    ],\n) -&gt; Callable[[StreamMessage[MsgType]], Awaitable[WrappedReturn[T_HandlerReturn]]]:\n    \"\"\"Sets the message context for a function.\n\n    Args:\n        func: The function to set the message context for.\n\n    Returns:\n        The function with the message context set.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    @wraps(func)\n    async def set_message_wrapper(\n        message: StreamMessage[MsgType],\n    ) -&gt; WrappedReturn[T_HandlerReturn]:\n        \"\"\"Wraps a function that handles a stream message.\n\n        Args:\n            message: The stream message to be handled.\n\n        Returns:\n            The wrapped return value of the handler function.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        with context.scope(\"message\", message):\n            return await func(message)\n\n    return set_message_wrapper\n</code></pre>"},{"location":"api/faststream/broker/wrapper/FakePublisher/","title":"FakePublisher","text":""},{"location":"api/faststream/broker/wrapper/FakePublisher/#faststream.broker.wrapper.FakePublisher","title":"faststream.broker.wrapper.FakePublisher","text":"<p>A class to represent a fake publisher.</p> METHOD DESCRIPTION <code>publish </code> <p>asynchronously publishes a message with optional correlation ID and additional keyword arguments</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/wrapper.py</code> <pre><code>class FakePublisher:\n    \"\"\"A class to represent a fake publisher.\n\n    Attributes:\n        method : a callable method that takes arguments and returns an awaitable sendable message\n\n    Methods:\n        publish : asynchronously publishes a message with optional correlation ID and additional keyword arguments\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    def __init__(self, method: Callable[..., Awaitable[SendableMessage]]) -&gt; None:\n        \"\"\"Initialize an object.\n\n        Args:\n            method: A callable that takes any number of arguments and returns an awaitable sendable message.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        self.method = method\n\n    async def publish(\n        self,\n        message: SendableMessage,\n        correlation_id: Optional[str] = None,\n        **kwargs: Any,\n    ) -&gt; Optional[SendableMessage]:\n        \"\"\"Publish a message.\n\n        Args:\n            message: The message to be published.\n            correlation_id: Optional correlation ID for the message.\n            **kwargs: Additional keyword arguments.\n\n        Returns:\n            The published message.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        return await self.method(message, correlation_id=correlation_id, **kwargs)\n</code></pre>"},{"location":"api/faststream/broker/wrapper/FakePublisher/#faststream.broker.wrapper.FakePublisher.method","title":"method  <code>instance-attribute</code>","text":"<pre><code>method = method\n</code></pre>"},{"location":"api/faststream/broker/wrapper/FakePublisher/#faststream.broker.wrapper.FakePublisher.publish","title":"publish  <code>async</code>","text":"<pre><code>publish(\n    message: SendableMessage,\n    correlation_id: Optional[str] = None,\n    **kwargs: Any\n) -&gt; Optional[SendableMessage]\n</code></pre> <p>Publish a message.</p> PARAMETER  DESCRIPTION <code>message</code> <p>The message to be published.</p> <p> TYPE: <code>SendableMessage</code> </p> <code>correlation_id</code> <p>Optional correlation ID for the message.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>**kwargs</code> <p>Additional keyword arguments.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Optional[SendableMessage]</code> <p>The published message.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/wrapper.py</code> <pre><code>async def publish(\n    self,\n    message: SendableMessage,\n    correlation_id: Optional[str] = None,\n    **kwargs: Any,\n) -&gt; Optional[SendableMessage]:\n    \"\"\"Publish a message.\n\n    Args:\n        message: The message to be published.\n        correlation_id: Optional correlation ID for the message.\n        **kwargs: Additional keyword arguments.\n\n    Returns:\n        The published message.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    return await self.method(message, correlation_id=correlation_id, **kwargs)\n</code></pre>"},{"location":"api/faststream/broker/wrapper/HandlerCallWrapper/","title":"HandlerCallWrapper","text":""},{"location":"api/faststream/broker/wrapper/HandlerCallWrapper/#faststream.broker.wrapper.HandlerCallWrapper","title":"faststream.broker.wrapper.HandlerCallWrapper","text":"<p>             Bases: <code>Generic[MsgType, P_HandlerParams, T_HandlerReturn]</code></p> <p>A generic class to wrap handler calls.</p> METHOD DESCRIPTION <code>__new__ </code> <p>Create a new instance of the class</p> <code>__init__ </code> <p>Initialize the instance</p> <code>__call__ </code> <p>Call the wrapped handler</p> <code>set_wrapped </code> <p>Set the wrapped handler call</p> <code>call_wrapped </code> <p>Call the wrapped handler</p> <code>wait_call </code> <p>Wait for the handler call to complete</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/wrapper.py</code> <pre><code>class HandlerCallWrapper(Generic[MsgType, P_HandlerParams, T_HandlerReturn]):\n    \"\"\"A generic class to wrap handler calls.\n\n    Attributes:\n        mock : MagicMock object used for mocking\n        event : an anyio.Event object used for synchronization\n\n        _wrapped_call : WrappedHandlerCall object representing the wrapped handler call\n        _original_call : original handler call\n        _publishers : list of AsyncPublisherProtocol objects\n\n    Methods:\n        __new__ : Create a new instance of the class\n        __init__ : Initialize the instance\n        __call__ : Call the wrapped handler\n        set_wrapped : Set the wrapped handler call\n        call_wrapped : Call the wrapped handler\n        wait_call : Wait for the handler call to complete\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    mock: MagicMock\n    event: Optional[anyio.Event]\n    future: Optional[\"asyncio.Future[Any]\"]\n\n    _wrapped_call: Optional[WrappedHandlerCall[MsgType, T_HandlerReturn]]\n    _original_call: Callable[P_HandlerParams, T_HandlerReturn]\n    _publishers: List[AsyncPublisherProtocol]\n\n    def __new__(\n        cls,\n        call: Union[\n            \"HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn]\",\n            Callable[P_HandlerParams, T_HandlerReturn],\n        ],\n    ) -&gt; Self:\n        \"\"\"Create a new instance of the class.\n\n        Args:\n            call: An instance of \"HandlerCallWrapper\" or a callable object\n\n        Returns:\n            An instance of the class\n\n        Note:\n            If the \"call\" argument is already an instance of the class, it is returned as is. Otherwise, a new instance of the class is created using the superclass's __new__ method.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        if isinstance(call, cls):\n            return call\n        else:\n            return super().__new__(cls)\n\n    def __init__(\n        self,\n        call: Callable[P_HandlerParams, T_HandlerReturn],\n    ):\n        \"\"\"Initialize a handler.\n\n        Args:\n            call: A callable object that represents the handler function.\n\n        Attributes:\n            _original_call: The original handler function.\n            _wrapped_call: The wrapped handler function.\n            _publishers: A list of publishers.\n            mock: A MagicMock object.\n            event: The event associated with the handler.\n            __name__: The name of the handler function.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        if not isinstance(call, HandlerCallWrapper):\n            self._original_call = call\n            self._wrapped_call = None\n            self._publishers = []\n            self.mock = MagicMock()\n            self.event = None\n            self.__name__ = getattr(self._original_call, \"__name__\", \"undefined\")\n\n    def __call__(\n        self,\n        *args: P_HandlerParams.args,\n        **kwargs: P_HandlerParams.kwargs,\n    ) -&gt; T_HandlerReturn:\n        \"\"\"Calls the object as a function.\n\n        Args:\n            *args: Positional arguments to be passed to the function.\n            **kwargs: Keyword arguments to be passed to the function.\n\n        Returns:\n            The return value of the function.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        self.mock(*args, **kwargs)\n        return self._original_call(*args, **kwargs)\n\n    def set_wrapped(\n        self, wrapped: WrappedHandlerCall[MsgType, T_HandlerReturn]\n    ) -&gt; None:\n        \"\"\"Set the wrapped handler call.\n\n        Args:\n            wrapped: The wrapped handler call to set\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        self._wrapped_call = wrapped\n\n    def call_wrapped(\n        self,\n        message: StreamMessage[MsgType],\n    ) -&gt; Union[\n        Optional[WrappedReturn[T_HandlerReturn]],\n        Awaitable[Optional[WrappedReturn[T_HandlerReturn]]],\n    ]:\n        \"\"\"Calls the wrapped function with the given message.\n\n        Args:\n            message: The message to be passed to the wrapped function.\n\n        Returns:\n            The result of the wrapped function call.\n\n        Raises:\n            AssertionError: If `set_wrapped` has not been called before calling this function.\n            AssertionError: If the broker has not been started before calling this function.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        assert self._wrapped_call, \"You should use `set_wrapped` first\"  # nosec B101\n        self.mock(message.decoded_body)\n        return self._wrapped_call(message)\n\n    async def wait_call(self, timeout: Optional[float] = None) -&gt; None:\n        \"\"\"Waits for a call with an optional timeout.\n\n        Args:\n            timeout: Optional timeout in seconds\n\n        Raises:\n            AssertionError: If the broker is not started\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        assert (\n            self.event and self.future\n        ), \"You should start the broker first\"  # nosec B101\n        with anyio.fail_after(timeout):\n            await self.future\n\n    def trigger(\n        self,\n        result: Any = None,\n        error: Optional[BaseException] = None,\n    ) -&gt; None:\n        assert (\n            self.event and self.future\n        ), \"You should start the broker first\"  # nosec B101\n        self.event.set()\n\n        if self.future.done():\n            self.future = asyncio.Future()\n\n        if error:\n            self.future.set_exception(error)\n        else:\n            self.future.set_result(result)\n\n    def refresh(self, with_mock: bool = False) -&gt; None:\n        self.event = anyio.Event()\n        self.future = asyncio.Future()\n        if with_mock:\n            self.mock.reset_mock()\n</code></pre>"},{"location":"api/faststream/broker/wrapper/HandlerCallWrapper/#faststream.broker.wrapper.HandlerCallWrapper.event","title":"event  <code>instance-attribute</code>","text":"<pre><code>event: Optional[anyio.Event]\n</code></pre>"},{"location":"api/faststream/broker/wrapper/HandlerCallWrapper/#faststream.broker.wrapper.HandlerCallWrapper.future","title":"future  <code>instance-attribute</code>","text":"<pre><code>future: Optional[asyncio.Future[Any]]\n</code></pre>"},{"location":"api/faststream/broker/wrapper/HandlerCallWrapper/#faststream.broker.wrapper.HandlerCallWrapper.mock","title":"mock  <code>instance-attribute</code>","text":"<pre><code>mock: MagicMock\n</code></pre>"},{"location":"api/faststream/broker/wrapper/HandlerCallWrapper/#faststream.broker.wrapper.HandlerCallWrapper.call_wrapped","title":"call_wrapped","text":"<pre><code>call_wrapped(\n    message: StreamMessage[MsgType],\n) -&gt; Union[\n    Optional[WrappedReturn[T_HandlerReturn]],\n    Awaitable[Optional[WrappedReturn[T_HandlerReturn]]],\n]\n</code></pre> <p>Calls the wrapped function with the given message.</p> PARAMETER  DESCRIPTION <code>message</code> <p>The message to be passed to the wrapped function.</p> <p> TYPE: <code>StreamMessage[MsgType]</code> </p> RETURNS DESCRIPTION <code>Union[Optional[WrappedReturn[T_HandlerReturn]], Awaitable[Optional[WrappedReturn[T_HandlerReturn]]]]</code> <p>The result of the wrapped function call.</p> RAISES DESCRIPTION <code>AssertionError</code> <p>If <code>set_wrapped</code> has not been called before calling this function.</p> <code>AssertionError</code> <p>If the broker has not been started before calling this function.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/wrapper.py</code> <pre><code>def call_wrapped(\n    self,\n    message: StreamMessage[MsgType],\n) -&gt; Union[\n    Optional[WrappedReturn[T_HandlerReturn]],\n    Awaitable[Optional[WrappedReturn[T_HandlerReturn]]],\n]:\n    \"\"\"Calls the wrapped function with the given message.\n\n    Args:\n        message: The message to be passed to the wrapped function.\n\n    Returns:\n        The result of the wrapped function call.\n\n    Raises:\n        AssertionError: If `set_wrapped` has not been called before calling this function.\n        AssertionError: If the broker has not been started before calling this function.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    assert self._wrapped_call, \"You should use `set_wrapped` first\"  # nosec B101\n    self.mock(message.decoded_body)\n    return self._wrapped_call(message)\n</code></pre>"},{"location":"api/faststream/broker/wrapper/HandlerCallWrapper/#faststream.broker.wrapper.HandlerCallWrapper.refresh","title":"refresh","text":"<pre><code>refresh(with_mock: bool = False) -&gt; None\n</code></pre> Source code in <code>faststream/broker/wrapper.py</code> <pre><code>def refresh(self, with_mock: bool = False) -&gt; None:\n    self.event = anyio.Event()\n    self.future = asyncio.Future()\n    if with_mock:\n        self.mock.reset_mock()\n</code></pre>"},{"location":"api/faststream/broker/wrapper/HandlerCallWrapper/#faststream.broker.wrapper.HandlerCallWrapper.set_wrapped","title":"set_wrapped","text":"<pre><code>set_wrapped(\n    wrapped: WrappedHandlerCall[MsgType, T_HandlerReturn]\n) -&gt; None\n</code></pre> <p>Set the wrapped handler call.</p> PARAMETER  DESCRIPTION <code>wrapped</code> <p>The wrapped handler call to set</p> <p> TYPE: <code>WrappedHandlerCall[MsgType, T_HandlerReturn]</code> </p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/wrapper.py</code> <pre><code>def set_wrapped(\n    self, wrapped: WrappedHandlerCall[MsgType, T_HandlerReturn]\n) -&gt; None:\n    \"\"\"Set the wrapped handler call.\n\n    Args:\n        wrapped: The wrapped handler call to set\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    self._wrapped_call = wrapped\n</code></pre>"},{"location":"api/faststream/broker/wrapper/HandlerCallWrapper/#faststream.broker.wrapper.HandlerCallWrapper.trigger","title":"trigger","text":"<pre><code>trigger(\n    result: Any = None,\n    error: Optional[BaseException] = None,\n) -&gt; None\n</code></pre> Source code in <code>faststream/broker/wrapper.py</code> <pre><code>def trigger(\n    self,\n    result: Any = None,\n    error: Optional[BaseException] = None,\n) -&gt; None:\n    assert (\n        self.event and self.future\n    ), \"You should start the broker first\"  # nosec B101\n    self.event.set()\n\n    if self.future.done():\n        self.future = asyncio.Future()\n\n    if error:\n        self.future.set_exception(error)\n    else:\n        self.future.set_result(result)\n</code></pre>"},{"location":"api/faststream/broker/wrapper/HandlerCallWrapper/#faststream.broker.wrapper.HandlerCallWrapper.wait_call","title":"wait_call  <code>async</code>","text":"<pre><code>wait_call(timeout: Optional[float] = None) -&gt; None\n</code></pre> <p>Waits for a call with an optional timeout.</p> PARAMETER  DESCRIPTION <code>timeout</code> <p>Optional timeout in seconds</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>AssertionError</code> <p>If the broker is not started</p> RETURNS DESCRIPTION <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/broker/wrapper.py</code> <pre><code>async def wait_call(self, timeout: Optional[float] = None) -&gt; None:\n    \"\"\"Waits for a call with an optional timeout.\n\n    Args:\n        timeout: Optional timeout in seconds\n\n    Raises:\n        AssertionError: If the broker is not started\n\n    Returns:\n        None\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    assert (\n        self.event and self.future\n    ), \"You should start the broker first\"  # nosec B101\n    with anyio.fail_after(timeout):\n        await self.future\n</code></pre>"},{"location":"api/faststream/cli/docs/app/gen/","title":"Gen","text":""},{"location":"api/faststream/cli/docs/app/gen/#faststream.cli.docs.app.gen","title":"faststream.cli.docs.app.gen","text":"<pre><code>gen(\n    app: str = typer.Argument(\n        ...,\n        help=\"[python_module:FastStream] - path to your application\",\n    ),\n    yaml: bool = typer.Option(\n        False,\n        \"--yaml\",\n        is_flag=True,\n        help=\"generate `asyncapi.yaml` schema\",\n    ),\n    out: Optional[str] = typer.Option(\n        None, help=\"output filename\"\n    ),\n) -&gt; None\n</code></pre> <p>Generate project AsyncAPI schema</p> Source code in <code>faststream/cli/docs/app.py</code> <pre><code>@docs_app.command(name=\"gen\")\ndef gen(\n    app: str = typer.Argument(\n        ...,\n        help=\"[python_module:FastStream] - path to your application\",\n    ),\n    yaml: bool = typer.Option(\n        False,\n        \"--yaml\",\n        is_flag=True,\n        help=\"generate `asyncapi.yaml` schema\",\n    ),\n    out: Optional[str] = typer.Option(\n        None,\n        help=\"output filename\",\n    ),\n) -&gt; None:\n    \"\"\"Generate project AsyncAPI schema\"\"\"\n    if \":\" in app:\n        module, app = get_app_path(app)\n        sys.path.insert(0, str(module.parent))\n        app_obj = try_import_app(module, app)\n        raw_schema = get_app_schema(app_obj)\n\n    else:\n        schema_filepath = Path.cwd() / app\n        raw_schema = model_parse(Schema, schema_filepath.read_text())\n\n    if yaml:\n        try:\n            schema = raw_schema.to_yaml()\n        except ImportError as e:  # pragma: no cover\n            typer.echo(INSTALL_YAML, err=True)\n            raise typer.Exit(1) from e\n\n        name = out or \"asyncapi.yaml\"\n\n        with open(name, \"w\") as f:\n            f.write(schema)\n\n    else:\n        schema = raw_schema.to_jsonable()\n        name = out or \"asyncapi.json\"\n\n        with open(name, \"w\") as f:\n            json.dump(schema, f, indent=2)\n\n    typer.echo(f\"Your project AsyncAPI scheme was placed to `{name}`\")\n</code></pre>"},{"location":"api/faststream/cli/docs/app/serve/","title":"Serve","text":""},{"location":"api/faststream/cli/docs/app/serve/#faststream.cli.docs.app.serve","title":"faststream.cli.docs.app.serve","text":"<pre><code>serve(\n    app: str = typer.Argument(\n        ...,\n        help=\"[python_module:FastStream] or [asyncapi.yaml/.json] - path to your application or documentation\",\n    ),\n    host: str = typer.Option(\n        \"localhost\", help=\"documentation hosting address\"\n    ),\n    port: int = typer.Option(\n        8000, help=\"documentation hosting port\"\n    ),\n) -&gt; None\n</code></pre> <p>Serve project AsyncAPI schema</p> Source code in <code>faststream/cli/docs/app.py</code> <pre><code>@docs_app.command(name=\"serve\")\ndef serve(\n    app: str = typer.Argument(\n        ...,\n        help=\"[python_module:FastStream] or [asyncapi.yaml/.json] - path to your application or documentation\",\n    ),\n    host: str = typer.Option(\n        \"localhost\",\n        help=\"documentation hosting address\",\n    ),\n    port: int = typer.Option(\n        8000,\n        help=\"documentation hosting port\",\n    ),\n) -&gt; None:\n    \"\"\"Serve project AsyncAPI schema\"\"\"\n    if \":\" in app:\n        module, app = get_app_path(app)\n        sys.path.insert(0, str(module.parent))\n        app_obj = try_import_app(module, app)\n        raw_schema = get_app_schema(app_obj)\n\n    else:\n        schema_filepath = Path.cwd() / app\n        if schema_filepath.suffix == \".json\":\n            data = schema_filepath.read_text()\n\n        elif schema_filepath.suffix == \".yaml\" or schema_filepath.suffix == \".yml\":\n            try:\n                import yaml\n            except ImportError as e:  # pragma: no cover\n                typer.echo(INSTALL_YAML, err=True)\n                raise typer.Exit(1) from e\n\n            with schema_filepath.open(\"r\") as f:\n                schema = yaml.safe_load(f)\n\n            data = json.dumps(schema)\n        else:\n            raise ValueError(\n                f\"Unknown extension given - {app}; Please provide app in format [python_module:FastStream] or [asyncapi.yaml/.json] - path to your application or documentation\"\n            )\n\n        raw_schema = model_parse(Schema, data)\n\n    serve_app(\n        schema=raw_schema,\n        host=host,\n        port=port,\n    )\n</code></pre>"},{"location":"api/faststream/cli/main/main/","title":"Main","text":""},{"location":"api/faststream/cli/main/main/#faststream.cli.main.main","title":"faststream.cli.main.main","text":"<pre><code>main(\n    version: Optional[bool] = typer.Option(\n        False,\n        \"-v\",\n        \"--version\",\n        callback=version_callback,\n        is_eager=True,\n        help=\"Show current platform, python and FastStream version\",\n    )\n) -&gt; None\n</code></pre> <p>Generate, run and manage FastStream apps to greater development experience</p> Source code in <code>faststream/cli/main.py</code> <pre><code>@cli.callback()\ndef main(\n    version: Optional[bool] = typer.Option(\n        False,\n        \"-v\",\n        \"--version\",\n        callback=version_callback,\n        is_eager=True,\n        help=\"Show current platform, python and FastStream version\",\n    )\n) -&gt; None:\n    \"\"\"\n    Generate, run and manage FastStream apps to greater development experience\n    \"\"\"\n</code></pre>"},{"location":"api/faststream/cli/main/run/","title":"Run","text":""},{"location":"api/faststream/cli/main/run/#faststream.cli.main.run","title":"faststream.cli.main.run","text":"<pre><code>run(\n    ctx: typer.Context,\n    app: str = typer.Argument(\n        ...,\n        help=\"[python_module:FastStream] - path to your application\",\n    ),\n    workers: int = typer.Option(\n        1,\n        show_default=False,\n        help=\"Run [workers] applications with process spawning\",\n    ),\n    log_level: LogLevels = typer.Option(\n        LogLevels.info,\n        case_sensitive=False,\n        show_default=False,\n        help=\"[INFO] default\",\n    ),\n    reload: bool = typer.Option(\n        False,\n        \"--reload\",\n        is_flag=True,\n        help=\"Restart app at directory files changes\",\n    ),\n    app_dir: str = typer.Option(\n        \".\",\n        \"--app-dir\",\n        help=\"Look for APP in the specified directory, by adding this to the PYTHONPATH. Defaults to the current working directory.\",\n    ),\n) -&gt; None\n</code></pre> <p>Run [MODULE:APP] FastStream application</p> Source code in <code>faststream/cli/main.py</code> <pre><code>@cli.command(\n    context_settings={\"allow_extra_args\": True, \"ignore_unknown_options\": True}\n)\ndef run(\n    ctx: typer.Context,\n    app: str = typer.Argument(\n        ...,\n        help=\"[python_module:FastStream] - path to your application\",\n    ),\n    workers: int = typer.Option(\n        1,\n        show_default=False,\n        help=\"Run [workers] applications with process spawning\",\n    ),\n    log_level: LogLevels = typer.Option(\n        LogLevels.info,\n        case_sensitive=False,\n        show_default=False,\n        help=\"[INFO] default\",\n    ),\n    reload: bool = typer.Option(\n        False,\n        \"--reload\",\n        is_flag=True,\n        help=\"Restart app at directory files changes\",\n    ),\n    app_dir: str = typer.Option(\n        \".\",\n        \"--app-dir\",\n        help=(\n            \"Look for APP in the specified directory, by adding this to the PYTHONPATH.\"\n            \" Defaults to the current working directory.\"\n        ),\n    ),\n) -&gt; None:\n    \"\"\"Run [MODULE:APP] FastStream application\"\"\"\n    app, extra = parse_cli_args(app, *ctx.args)\n    casted_log_level = get_log_level(log_level)\n\n    module, app = get_app_path(app)\n\n    if app_dir:\n        sys.path.insert(0, app_dir)\n\n    args = (module, app, extra, casted_log_level)\n\n    if reload and workers &gt; 1:\n        raise ValueError(\"You can't use reload option with multiprocessing\")\n\n    if reload is True:\n        from faststream.cli.supervisors.watchfiles import WatchReloader\n\n        WatchReloader(target=_run, args=args, reload_dirs=(str(module.parent),)).run()\n\n    elif workers &gt; 1:\n        from faststream.cli.supervisors.multiprocess import Multiprocess\n\n        Multiprocess(target=_run, args=(*args, logging.DEBUG), workers=workers).run()\n\n    else:\n        _run(module=module, app=app, extra_options=extra, log_level=casted_log_level)\n</code></pre>"},{"location":"api/faststream/cli/main/version_callback/","title":"Version callback","text":""},{"location":"api/faststream/cli/main/version_callback/#faststream.cli.main.version_callback","title":"faststream.cli.main.version_callback","text":"<pre><code>version_callback(version: bool) -&gt; None\n</code></pre> <p>Callback function for displaying version information.</p> PARAMETER  DESCRIPTION <code>version</code> <p>If True, display version information</p> <p> TYPE: <code>bool</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/cli/main.py</code> <pre><code>def version_callback(version: bool) -&gt; None:\n    \"\"\"Callback function for displaying version information.\n\n    Args:\n        version: If True, display version information\n\n    Returns:\n        None\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    if version is True:\n        import platform\n\n        typer.echo(\n            \"Running FastStream %s with %s %s on %s\"\n            % (\n                __version__,\n                platform.python_implementation(),\n                platform.python_version(),\n                platform.system(),\n            )\n        )\n\n        raise typer.Exit()\n</code></pre>"},{"location":"api/faststream/cli/supervisors/basereload/BaseReload/","title":"BaseReload","text":""},{"location":"api/faststream/cli/supervisors/basereload/BaseReload/#faststream.cli.supervisors.basereload.BaseReload","title":"faststream.cli.supervisors.basereload.BaseReload","text":"<p>A base class for implementing a reloader process.</p> METHOD DESCRIPTION <code>__init__</code> <p>DecoratedCallable, args: Tuple[Any, ...], reload_delay: Optional[float] = 0.5) -&gt; None: Initializes the BaseReload object.</p> <code>run</code> <p>Runs the reloader process.</p> <code>startup</code> <p>Performs startup operations for the reloader process.</p> <code>restart</code> <p>Restarts the process.</p> <code>shutdown</code> <p>Shuts down the reloader process.</p> <code>_stop_process</code> <p>Stops the spawned process.</p> <code>_start_process</code> <p>Starts the spawned process.</p> <code>should_restart</code> <p>Determines whether the process should be restarted.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/cli/supervisors/basereload.py</code> <pre><code>class BaseReload:\n    \"\"\"A base class for implementing a reloader process.\n\n    Attributes:\n        _process : The spawned process\n        _target : The target callable function\n        _args : The arguments to be passed to the target function\n        reload_delay : The delay between reloads\n        should_exit : A threading event to signal the reloader to exit\n        pid : The process ID of the reloader\n        reloader_name : The name of the reloader\n\n    Methods:\n        __init__(self, target: DecoratedCallable, args: Tuple[Any, ...], reload_delay: Optional[float] = 0.5) -&gt; None:\n            Initializes the BaseReload object.\n\n        run(self) -&gt; None:\n            Runs the reloader process.\n\n        startup(self) -&gt; None:\n            Performs startup operations for the reloader process.\n\n        restart(self) -&gt; None:\n            Restarts the process.\n\n        shutdown(self) -&gt; None:\n            Shuts down the reloader process.\n\n        _stop_process(self) -&gt; None:\n            Stops the spawned process.\n\n        _start_process(self) -&gt; SpawnProcess:\n            Starts the spawned process.\n\n        should_restart(self) -&gt; bool:\n            Determines whether the process should be restarted.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    _process: SpawnProcess\n    _target: DecoratedCallable\n    _args: Tuple[Any, ...]\n\n    reload_delay: Optional[float]\n    should_exit: threading.Event\n    pid: int\n    reloader_name: str = \"\"\n\n    def __init__(\n        self,\n        target: DecoratedCallable,\n        args: Tuple[Any, ...],\n        reload_delay: Optional[float] = 0.5,\n    ) -&gt; None:\n        \"\"\"Initialize a class instance.\n\n        Args:\n            target: The target callable object\n            args: Tuple of arguments to be passed to the target callable\n            reload_delay: Optional delay in seconds before reloading the target callable (default is 0.5 seconds)\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        self._target = target\n        self._args = args\n\n        self.should_exit = threading.Event()\n        self.pid = os.getpid()\n        self.reload_delay = reload_delay\n\n        set_exit(lambda *_: self.should_exit.set())\n\n    def run(self) -&gt; None:\n        self.startup()\n        while not self.should_exit.wait(self.reload_delay):\n            if self.should_restart():  # pragma: no branch\n                self.restart()\n        self.shutdown()\n\n    def startup(self) -&gt; None:\n        logger.info(f\"Started reloader process [{self.pid}] using {self.reloader_name}\")\n        self._process = self._start_process()\n\n    def restart(self) -&gt; None:\n        self._stop_process()\n        logger.info(\"Process successfully reloaded\")\n        self._process = self._start_process()\n\n    def shutdown(self) -&gt; None:\n        self._stop_process()\n        logger.info(f\"Stopping reloader process [{self.pid}]\")\n\n    def _stop_process(self) -&gt; None:\n        self._process.terminate()\n        self._process.join()\n\n    def _start_process(self) -&gt; SpawnProcess:\n        process = get_subprocess(target=self._target, args=self._args)\n        process.start()\n        return process\n\n    def should_restart(self) -&gt; bool:\n        raise NotImplementedError(\"Reload strategies should override should_restart()\")\n</code></pre>"},{"location":"api/faststream/cli/supervisors/basereload/BaseReload/#faststream.cli.supervisors.basereload.BaseReload.pid","title":"pid  <code>instance-attribute</code>","text":"<pre><code>pid: int = os.getpid()\n</code></pre>"},{"location":"api/faststream/cli/supervisors/basereload/BaseReload/#faststream.cli.supervisors.basereload.BaseReload.reload_delay","title":"reload_delay  <code>instance-attribute</code>","text":"<pre><code>reload_delay: Optional[float] = reload_delay\n</code></pre>"},{"location":"api/faststream/cli/supervisors/basereload/BaseReload/#faststream.cli.supervisors.basereload.BaseReload.reloader_name","title":"reloader_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>reloader_name: str = ''\n</code></pre>"},{"location":"api/faststream/cli/supervisors/basereload/BaseReload/#faststream.cli.supervisors.basereload.BaseReload.should_exit","title":"should_exit  <code>instance-attribute</code>","text":"<pre><code>should_exit: threading.Event = threading.Event()\n</code></pre>"},{"location":"api/faststream/cli/supervisors/basereload/BaseReload/#faststream.cli.supervisors.basereload.BaseReload.restart","title":"restart","text":"<pre><code>restart() -&gt; None\n</code></pre> Source code in <code>faststream/cli/supervisors/basereload.py</code> <pre><code>def restart(self) -&gt; None:\n    self._stop_process()\n    logger.info(\"Process successfully reloaded\")\n    self._process = self._start_process()\n</code></pre>"},{"location":"api/faststream/cli/supervisors/basereload/BaseReload/#faststream.cli.supervisors.basereload.BaseReload.run","title":"run","text":"<pre><code>run() -&gt; None\n</code></pre> Source code in <code>faststream/cli/supervisors/basereload.py</code> <pre><code>def run(self) -&gt; None:\n    self.startup()\n    while not self.should_exit.wait(self.reload_delay):\n        if self.should_restart():  # pragma: no branch\n            self.restart()\n    self.shutdown()\n</code></pre>"},{"location":"api/faststream/cli/supervisors/basereload/BaseReload/#faststream.cli.supervisors.basereload.BaseReload.should_restart","title":"should_restart","text":"<pre><code>should_restart() -&gt; bool\n</code></pre> Source code in <code>faststream/cli/supervisors/basereload.py</code> <pre><code>def should_restart(self) -&gt; bool:\n    raise NotImplementedError(\"Reload strategies should override should_restart()\")\n</code></pre>"},{"location":"api/faststream/cli/supervisors/basereload/BaseReload/#faststream.cli.supervisors.basereload.BaseReload.shutdown","title":"shutdown","text":"<pre><code>shutdown() -&gt; None\n</code></pre> Source code in <code>faststream/cli/supervisors/basereload.py</code> <pre><code>def shutdown(self) -&gt; None:\n    self._stop_process()\n    logger.info(f\"Stopping reloader process [{self.pid}]\")\n</code></pre>"},{"location":"api/faststream/cli/supervisors/basereload/BaseReload/#faststream.cli.supervisors.basereload.BaseReload.startup","title":"startup","text":"<pre><code>startup() -&gt; None\n</code></pre> Source code in <code>faststream/cli/supervisors/basereload.py</code> <pre><code>def startup(self) -&gt; None:\n    logger.info(f\"Started reloader process [{self.pid}] using {self.reloader_name}\")\n    self._process = self._start_process()\n</code></pre>"},{"location":"api/faststream/cli/supervisors/multiprocess/Multiprocess/","title":"Multiprocess","text":""},{"location":"api/faststream/cli/supervisors/multiprocess/Multiprocess/#faststream.cli.supervisors.multiprocess.Multiprocess","title":"faststream.cli.supervisors.multiprocess.Multiprocess","text":"<p>             Bases: <code>BaseReload</code></p> <p>A class to represent a multiprocess.</p> METHOD DESCRIPTION <code>startup </code> <p>starts the parent process and creates worker processes</p> <code>shutdown </code> <p>terminates and joins all worker processes, and stops the parent process</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/cli/supervisors/multiprocess.py</code> <pre><code>class Multiprocess(BaseReload):\n    \"\"\"A class to represent a multiprocess.\n\n    Attributes:\n        target : the target function to be executed by each process\n        args : arguments to be passed to the target function\n        workers : number of worker processes\n\n    Methods:\n        startup : starts the parent process and creates worker processes\n        shutdown : terminates and joins all worker processes, and stops the parent process\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    def __init__(\n        self,\n        target: DecoratedCallable,\n        args: Tuple[Any, ...],\n        workers: int,\n    ) -&gt; None:\n        \"\"\"Initialize a new instance of the class.\n\n        Args:\n            target: The target callable object to be executed.\n            args: The arguments to be passed to the target callable.\n            workers: The number of workers to be used.\n\n        Returns:\n            None.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        super().__init__(target, args, None)\n\n        self.workers = workers\n        self.processes: List[SpawnProcess] = []\n\n    def startup(self) -&gt; None:\n        logger.info(f\"Started parent process [{self.pid}]\")\n\n        for _ in range(self.workers):\n            process = self._start_process()\n            logger.info(f\"Started child process [{process.pid}]\")\n            self.processes.append(process)\n\n    def shutdown(self) -&gt; None:\n        for process in self.processes:\n            process.terminate()\n            logger.info(f\"Stopping child process [{process.pid}]\")\n            process.join()\n\n        logger.info(f\"Stopping parent process [{self.pid}]\")\n</code></pre>"},{"location":"api/faststream/cli/supervisors/multiprocess/Multiprocess/#faststream.cli.supervisors.multiprocess.Multiprocess.processes","title":"processes  <code>instance-attribute</code>","text":"<pre><code>processes: List[SpawnProcess] = []\n</code></pre>"},{"location":"api/faststream/cli/supervisors/multiprocess/Multiprocess/#faststream.cli.supervisors.multiprocess.Multiprocess.workers","title":"workers  <code>instance-attribute</code>","text":"<pre><code>workers = workers\n</code></pre>"},{"location":"api/faststream/cli/supervisors/multiprocess/Multiprocess/#faststream.cli.supervisors.multiprocess.Multiprocess.shutdown","title":"shutdown","text":"<pre><code>shutdown() -&gt; None\n</code></pre> Source code in <code>faststream/cli/supervisors/multiprocess.py</code> <pre><code>def shutdown(self) -&gt; None:\n    for process in self.processes:\n        process.terminate()\n        logger.info(f\"Stopping child process [{process.pid}]\")\n        process.join()\n\n    logger.info(f\"Stopping parent process [{self.pid}]\")\n</code></pre>"},{"location":"api/faststream/cli/supervisors/multiprocess/Multiprocess/#faststream.cli.supervisors.multiprocess.Multiprocess.startup","title":"startup","text":"<pre><code>startup() -&gt; None\n</code></pre> Source code in <code>faststream/cli/supervisors/multiprocess.py</code> <pre><code>def startup(self) -&gt; None:\n    logger.info(f\"Started parent process [{self.pid}]\")\n\n    for _ in range(self.workers):\n        process = self._start_process()\n        logger.info(f\"Started child process [{process.pid}]\")\n        self.processes.append(process)\n</code></pre>"},{"location":"api/faststream/cli/supervisors/utils/get_subprocess/","title":"Get subprocess","text":""},{"location":"api/faststream/cli/supervisors/utils/get_subprocess/#faststream.cli.supervisors.utils.get_subprocess","title":"faststream.cli.supervisors.utils.get_subprocess","text":"<pre><code>get_subprocess(\n    target: DecoratedCallableNone, args: Any\n) -&gt; SpawnProcess\n</code></pre> <p>Spawn a subprocess.</p> PARAMETER  DESCRIPTION <code>target</code> <p>The target function to be executed in the subprocess.</p> <p> TYPE: <code>DecoratedCallableNone</code> </p> <code>args</code> <p>The arguments to be passed to the target function.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>SpawnProcess</code> <p>The spawned subprocess.</p> RAISES DESCRIPTION <code>OSError</code> <p>If there is an error getting the file descriptor of sys.stdin.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/cli/supervisors/utils.py</code> <pre><code>def get_subprocess(target: DecoratedCallableNone, args: Any) -&gt; SpawnProcess:\n    \"\"\"Spawn a subprocess.\n\n    Args:\n        target: The target function to be executed in the subprocess.\n        args: The arguments to be passed to the target function.\n\n    Returns:\n        The spawned subprocess.\n\n    Raises:\n        OSError: If there is an error getting the file descriptor of sys.stdin.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    stdin_fileno: Optional[int]\n    try:\n        stdin_fileno = sys.stdin.fileno()\n    except OSError:\n        stdin_fileno = None\n\n    return spawn.Process(\n        target=subprocess_started,\n        args=args,\n        kwargs={\"t\": target, \"stdin_fileno\": stdin_fileno},\n    )\n</code></pre>"},{"location":"api/faststream/cli/supervisors/utils/set_exit/","title":"Set exit","text":""},{"location":"api/faststream/cli/supervisors/utils/set_exit/#faststream.cli.supervisors.utils.set_exit","title":"faststream.cli.supervisors.utils.set_exit","text":"<pre><code>set_exit(\n    func: Callable[[int, Optional[FrameType]], Any]\n) -&gt; None\n</code></pre> <p>Set exit handler for signals.</p> PARAMETER  DESCRIPTION <code>func</code> <p>A callable object that takes an integer and an optional frame type as arguments and returns any value.</p> <p> TYPE: <code>Callable[[int, Optional[FrameType]], Any]</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/cli/supervisors/utils.py</code> <pre><code>def set_exit(func: Callable[[int, Optional[FrameType]], Any]) -&gt; None:\n    \"\"\"Set exit handler for signals.\n\n    Args:\n        func: A callable object that takes an integer and an optional frame type as arguments and returns any value.\n\n    Returns:\n        None\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    for sig in HANDLED_SIGNALS:\n        signal.signal(sig, func)\n</code></pre>"},{"location":"api/faststream/cli/supervisors/utils/subprocess_started/","title":"Subprocess started","text":""},{"location":"api/faststream/cli/supervisors/utils/subprocess_started/#faststream.cli.supervisors.utils.subprocess_started","title":"faststream.cli.supervisors.utils.subprocess_started","text":"<pre><code>subprocess_started(\n    *args: Any,\n    t: DecoratedCallableNone,\n    stdin_fileno: Optional[int]\n) -&gt; None\n</code></pre> <p>Start a subprocess.</p> PARAMETER  DESCRIPTION <code>*args</code> <p>Arguments to be passed to the subprocess.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>()</code> </p> <code>t</code> <p>The decorated callable function.</p> <p> TYPE: <code>DecoratedCallableNone</code> </p> <code>stdin_fileno</code> <p>File descriptor for the standard input of the subprocess.</p> <p> TYPE: <code>Optional[int]</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/cli/supervisors/utils.py</code> <pre><code>def subprocess_started(\n    *args: Any,\n    t: DecoratedCallableNone,\n    stdin_fileno: Optional[int],\n) -&gt; None:\n    \"\"\"Start a subprocess.\n\n    Args:\n        *args: Arguments to be passed to the subprocess.\n        t: The decorated callable function.\n        stdin_fileno: File descriptor for the standard input of the subprocess.\n\n    Returns:\n        None\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    if stdin_fileno is not None:  # pragma: no cover\n        sys.stdin = os.fdopen(stdin_fileno)\n    t(*args)\n</code></pre>"},{"location":"api/faststream/cli/supervisors/watchfiles/ExtendedFilter/","title":"ExtendedFilter","text":""},{"location":"api/faststream/cli/supervisors/watchfiles/ExtendedFilter/#faststream.cli.supervisors.watchfiles.ExtendedFilter","title":"faststream.cli.supervisors.watchfiles.ExtendedFilter","text":"<p>             Bases: <code>PythonFilter</code></p> <p>A class that extends the <code>watchfiles.PythonFilter</code> class.</p> METHOD DESCRIPTION <code>__init__ </code> <p>Initializes the <code>ExtendedFilter</code> object Args:     ignore_paths : Optional sequence of paths to ignore     extra_extensions : Sequence of extra extensions to include</p> <p>Returns:     None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/cli/supervisors/watchfiles.py</code> <pre><code>class ExtendedFilter(watchfiles.PythonFilter):\n    \"\"\"A class that extends the `watchfiles.PythonFilter` class.\n\n    Attributes:\n        ignore_dirs : Tuple of directories to ignore\n\n    Methods:\n        __init__ : Initializes the `ExtendedFilter` object\n            Args:\n                ignore_paths : Optional sequence of paths to ignore\n                extra_extensions : Sequence of extra extensions to include\n\n            Returns:\n                None\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    ignore_dirs: Tuple[str, ...]\n\n    def __init__(\n        self,\n        *,\n        ignore_paths: Optional[Sequence[Union[str, Path]]] = None,\n        extra_extensions: Sequence[str] = (),\n    ) -&gt; None:\n        \"\"\"Initialize the class.\n\n        Args:\n            ignore_paths: Optional sequence of paths to ignore.\n            extra_extensions: Sequence of extra extensions.\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        super().__init__(ignore_paths=ignore_paths, extra_extensions=extra_extensions)\n        self.extensions = self.extensions + (\".env\", \".yaml\")\n        self.ignore_dirs = self.ignore_dirs + (\n            \"venv\",\n            \"env\",\n            \".github\",\n            \".mypy_cache\",\n            \".pytest_cache\",\n            \".ruff_cache\",\n        )\n</code></pre>"},{"location":"api/faststream/cli/supervisors/watchfiles/ExtendedFilter/#faststream.cli.supervisors.watchfiles.ExtendedFilter.extensions","title":"extensions  <code>instance-attribute</code>","text":"<pre><code>extensions = self.extensions + ('.env', '.yaml')\n</code></pre>"},{"location":"api/faststream/cli/supervisors/watchfiles/ExtendedFilter/#faststream.cli.supervisors.watchfiles.ExtendedFilter.ignore_dirs","title":"ignore_dirs  <code>instance-attribute</code>","text":"<pre><code>ignore_dirs: Tuple[str, ...] = self.ignore_dirs + (\n    \"venv\",\n    \"env\",\n    \".github\",\n    \".mypy_cache\",\n    \".pytest_cache\",\n    \".ruff_cache\",\n)\n</code></pre>"},{"location":"api/faststream/cli/supervisors/watchfiles/WatchReloader/","title":"WatchReloader","text":""},{"location":"api/faststream/cli/supervisors/watchfiles/WatchReloader/#faststream.cli.supervisors.watchfiles.WatchReloader","title":"faststream.cli.supervisors.watchfiles.WatchReloader","text":"<p>             Bases: <code>BaseReload</code></p> <p>A class to reload a target function when files in specified directories change.</p> METHOD DESCRIPTION <code>should_restart</code> <p>Checks if any files in the watched directories have changed and returns True if a change is detected, False otherwise.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/cli/supervisors/watchfiles.py</code> <pre><code>class WatchReloader(BaseReload):\n    \"\"\"A class to reload a target function when files in specified directories change.\n\n    Attributes:\n        target : the function to be reloaded\n        args : arguments to be passed to the target function\n        reload_dirs : directories to watch for file changes\n        reload_delay : delay in seconds between each check for file changes\n\n    Methods:\n        should_restart() -&gt; bool: Checks if any files in the watched directories have changed and returns True if a change is detected, False otherwise.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    def __init__(\n        self,\n        target: DecoratedCallable,\n        args: Tuple[Any, ...],\n        reload_dirs: Sequence[Union[Path, str]],\n        reload_delay: float = 0.3,\n    ) -&gt; None:\n        \"\"\"Initialize a WatchFilesReloader object.\n\n        Args:\n            target: The target callable to be executed.\n            args: The arguments to be passed to the target callable.\n            reload_dirs: A sequence of directories to watch for changes.\n            reload_delay: The delay in seconds between checking for changes. Default is 0.3.\n\n        Returns:\n            None.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        super().__init__(target, args, reload_delay)\n        self.reloader_name = \"WatchFiles\"\n        self.watcher = watchfiles.watch(\n            *reload_dirs,\n            step=int(reload_delay * 1000),\n            watch_filter=ExtendedFilter(),\n            stop_event=self.should_exit,\n            yield_on_timeout=True,\n        )\n\n    def should_restart(self) -&gt; bool:\n        for changes in self.watcher:  # pragma: no branch\n            if changes:  # pragma: no branch\n                unique_paths = {Path(c[1]).name for c in changes}\n                message = \"WatchReloader detected file change in '%s'. Reloading...\"\n                logger.info(message % tuple(unique_paths))\n                return True\n        return False  # pragma: no cover\n</code></pre>"},{"location":"api/faststream/cli/supervisors/watchfiles/WatchReloader/#faststream.cli.supervisors.watchfiles.WatchReloader.reloader_name","title":"reloader_name  <code>instance-attribute</code>","text":"<pre><code>reloader_name = 'WatchFiles'\n</code></pre>"},{"location":"api/faststream/cli/supervisors/watchfiles/WatchReloader/#faststream.cli.supervisors.watchfiles.WatchReloader.watcher","title":"watcher  <code>instance-attribute</code>","text":"<pre><code>watcher = watchfiles.watch(\n    *reload_dirs,\n    step=int(reload_delay * 1000),\n    watch_filter=ExtendedFilter(),\n    stop_event=self.should_exit,\n    yield_on_timeout=True\n)\n</code></pre>"},{"location":"api/faststream/cli/supervisors/watchfiles/WatchReloader/#faststream.cli.supervisors.watchfiles.WatchReloader.should_restart","title":"should_restart","text":"<pre><code>should_restart() -&gt; bool\n</code></pre> Source code in <code>faststream/cli/supervisors/watchfiles.py</code> <pre><code>def should_restart(self) -&gt; bool:\n    for changes in self.watcher:  # pragma: no branch\n        if changes:  # pragma: no branch\n            unique_paths = {Path(c[1]).name for c in changes}\n            message = \"WatchReloader detected file change in '%s'. Reloading...\"\n            logger.info(message % tuple(unique_paths))\n            return True\n    return False  # pragma: no cover\n</code></pre>"},{"location":"api/faststream/cli/utils/imports/get_app_path/","title":"Get app path","text":""},{"location":"api/faststream/cli/utils/imports/get_app_path/#faststream.cli.utils.imports.get_app_path","title":"faststream.cli.utils.imports.get_app_path","text":"<pre><code>get_app_path(app: str) -&gt; Tuple[Path, str]\n</code></pre> <p>Get the application path.</p> PARAMETER  DESCRIPTION <code>app</code> <p>The name of the application in the format \"module:app_name\".</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Tuple[Path, str]</code> <p>Tuple[Path, str]: A tuple containing the path to the module and the name of the application.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the given app is not in the format \"module:app_name\".</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/cli/utils/imports.py</code> <pre><code>def get_app_path(app: str) -&gt; Tuple[Path, str]:\n    \"\"\"Get the application path.\n\n    Args:\n        app (str): The name of the application in the format \"module:app_name\".\n\n    Returns:\n        Tuple[Path, str]: A tuple containing the path to the module and the name of the application.\n\n    Raises:\n        ValueError: If the given app is not in the format \"module:app_name\".\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    if \":\" not in app:\n        raise ValueError(f\"{app} is not a FastStream\")\n\n    module, app_name = app.split(\":\", 2)\n\n    mod_path = Path.cwd()\n    for i in module.split(\".\"):\n        mod_path = mod_path / i\n\n    return mod_path, app_name\n</code></pre>"},{"location":"api/faststream/cli/utils/imports/import_object/","title":"Import object","text":""},{"location":"api/faststream/cli/utils/imports/import_object/#faststream.cli.utils.imports.import_object","title":"faststream.cli.utils.imports.import_object","text":"<pre><code>import_object(module: Path, app: str) -&gt; object\n</code></pre> <p>Import an object from a module.</p> PARAMETER  DESCRIPTION <code>module</code> <p>The path to the module file.</p> <p> TYPE: <code>Path</code> </p> <code>app</code> <p>The name of the object to import.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>object</code> <p>The imported object.</p> RAISES DESCRIPTION <code>FileNotFoundError</code> <p>If the module file is not found.</p> <code>ValueError</code> <p>If the module has no loader.</p> <code>AttributeError</code> <p>If the object is not found in the module.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/cli/utils/imports.py</code> <pre><code>def import_object(module: Path, app: str) -&gt; object:\n    \"\"\"Import an object from a module.\n\n    Args:\n        module: The path to the module file.\n        app: The name of the object to import.\n\n    Returns:\n        The imported object.\n\n    Raises:\n        FileNotFoundError: If the module file is not found.\n        ValueError: If the module has no loader.\n        AttributeError: If the object is not found in the module.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    spec = spec_from_file_location(\n        \"mode\",\n        f\"{module}.py\",\n        submodule_search_locations=[str(module.parent.absolute())],\n    )\n\n    if spec is None:  # pragma: no cover\n        raise FileNotFoundError(module)\n\n    mod = module_from_spec(spec)\n    loader = spec.loader\n\n    if loader is None:  # pragma: no cover\n        raise ValueError(f\"{spec} has no loader\")\n\n    loader.exec_module(mod)\n\n    try:\n        obj = getattr(mod, app)\n    except AttributeError as e:\n        raise FileNotFoundError(module) from e\n\n    return obj\n</code></pre>"},{"location":"api/faststream/cli/utils/imports/try_import_app/","title":"Try import app","text":""},{"location":"api/faststream/cli/utils/imports/try_import_app/#faststream.cli.utils.imports.try_import_app","title":"faststream.cli.utils.imports.try_import_app","text":"<pre><code>try_import_app(module: Path, app: str) -&gt; FastStream\n</code></pre> <p>Tries to import a FastStream app from a module.</p> PARAMETER  DESCRIPTION <code>module</code> <p>Path to the module containing the app.</p> <p> TYPE: <code>Path</code> </p> <code>app</code> <p>Name of the FastStream app.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>FastStream</code> <p>The imported FastStream app object.</p> RAISES DESCRIPTION <code>FileNotFoundError</code> <p>If the module file is not found.</p> <code>BadParameter</code> <p>If the module or app name is not provided correctly.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/cli/utils/imports.py</code> <pre><code>def try_import_app(module: Path, app: str) -&gt; FastStream:\n    \"\"\"Tries to import a FastStream app from a module.\n\n    Args:\n        module: Path to the module containing the app.\n        app: Name of the FastStream app.\n\n    Returns:\n        The imported FastStream app object.\n\n    Raises:\n        FileNotFoundError: If the module file is not found.\n        typer.BadParameter: If the module or app name is not provided correctly.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    try:\n        app_object = import_object(module, app)\n\n    except FileNotFoundError as e:\n        typer.echo(e, err=True)\n        raise typer.BadParameter(\n            \"Please, input module like [python_file:faststream_app_name]\"\n        ) from e\n\n    else:\n        return app_object  # type: ignore\n</code></pre>"},{"location":"api/faststream/cli/utils/logs/LogLevels/","title":"LogLevels","text":""},{"location":"api/faststream/cli/utils/logs/LogLevels/#faststream.cli.utils.logs.LogLevels","title":"faststream.cli.utils.logs.LogLevels","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p> <p>A class to represent log levels.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/cli/utils/logs.py</code> <pre><code>class LogLevels(str, Enum):\n    \"\"\"A class to represent log levels.\n\n    Attributes:\n        critical : critical log level\n        error : error log level\n        warning : warning log level\n        info : info log level\n        debug : debug log level\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    critical = \"critical\"\n    error = \"error\"\n    warning = \"warning\"\n    info = \"info\"\n    debug = \"debug\"\n</code></pre>"},{"location":"api/faststream/cli/utils/logs/LogLevels/#faststream.cli.utils.logs.LogLevels.critical","title":"critical  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>critical = 'critical'\n</code></pre>"},{"location":"api/faststream/cli/utils/logs/LogLevels/#faststream.cli.utils.logs.LogLevels.debug","title":"debug  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>debug = 'debug'\n</code></pre>"},{"location":"api/faststream/cli/utils/logs/LogLevels/#faststream.cli.utils.logs.LogLevels.error","title":"error  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>error = 'error'\n</code></pre>"},{"location":"api/faststream/cli/utils/logs/LogLevels/#faststream.cli.utils.logs.LogLevels.info","title":"info  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>info = 'info'\n</code></pre>"},{"location":"api/faststream/cli/utils/logs/LogLevels/#faststream.cli.utils.logs.LogLevels.warning","title":"warning  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>warning = 'warning'\n</code></pre>"},{"location":"api/faststream/cli/utils/logs/get_log_level/","title":"Get log level","text":""},{"location":"api/faststream/cli/utils/logs/get_log_level/#faststream.cli.utils.logs.get_log_level","title":"faststream.cli.utils.logs.get_log_level","text":"<pre><code>get_log_level(level: Union[LogLevels, str, int]) -&gt; int\n</code></pre> <p>Get the log level.</p> PARAMETER  DESCRIPTION <code>level</code> <p>The log level to get. Can be an integer, a LogLevels enum value, or a string.</p> <p> TYPE: <code>Union[LogLevels, str, int]</code> </p> RETURNS DESCRIPTION <code>int</code> <p>The log level as an integer.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/cli/utils/logs.py</code> <pre><code>def get_log_level(level: Union[LogLevels, str, int]) -&gt; int:\n    \"\"\"Get the log level.\n\n    Args:\n        level: The log level to get. Can be an integer, a LogLevels enum value, or a string.\n\n    Returns:\n        The log level as an integer.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    if isinstance(level, int):\n        return level\n\n    if isinstance(level, LogLevels):\n        return LOG_LEVELS[level.value]\n\n    if isinstance(level, str):  # pragma: no branch\n        return LOG_LEVELS[level.lower()]\n</code></pre>"},{"location":"api/faststream/cli/utils/logs/set_log_level/","title":"Set log level","text":""},{"location":"api/faststream/cli/utils/logs/set_log_level/#faststream.cli.utils.logs.set_log_level","title":"faststream.cli.utils.logs.set_log_level","text":"<pre><code>set_log_level(level: int, app: FastStream) -&gt; None\n</code></pre> <p>Sets the log level for an application.</p> PARAMETER  DESCRIPTION <code>level</code> <p>The log level to set.</p> <p> TYPE: <code>int</code> </p> <code>app</code> <p>The application object.</p> <p> TYPE: <code>FastStream</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/cli/utils/logs.py</code> <pre><code>def set_log_level(level: int, app: FastStream) -&gt; None:\n    \"\"\"Sets the log level for an application.\n\n    Args:\n        level (int): The log level to set.\n        app (FastStream): The application object.\n\n    Returns:\n        None\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    if app.logger and isinstance(app.logger, logging.Logger):\n        app.logger.setLevel(level)\n\n    broker_logger: Optional[logging.Logger] = getattr(app.broker, \"logger\", None)\n    if broker_logger is not None and isinstance(broker_logger, logging.Logger):\n        broker_logger.setLevel(level)\n</code></pre>"},{"location":"api/faststream/cli/utils/parser/parse_cli_args/","title":"Parse cli args","text":""},{"location":"api/faststream/cli/utils/parser/parse_cli_args/#faststream.cli.utils.parser.parse_cli_args","title":"faststream.cli.utils.parser.parse_cli_args","text":"<pre><code>parse_cli_args(\n    *args: str,\n) -&gt; Tuple[str, Dict[str, SettingField]]\n</code></pre> <p>Parses command line arguments.</p> PARAMETER  DESCRIPTION <code>*args</code> <p>Command line arguments as strings.</p> <p> TYPE: <code>str</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>Tuple[str, Dict[str, SettingField]]</code> <p>A tuple containing the application name and a dictionary of additional keyword arguments.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/cli/utils/parser.py</code> <pre><code>def parse_cli_args(*args: str) -&gt; Tuple[str, Dict[str, SettingField]]:\n    \"\"\"Parses command line arguments.\n\n    Args:\n        *args: Command line arguments as strings.\n\n    Returns:\n        A tuple containing the application name and a dictionary of additional keyword arguments.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    extra_kwargs: Dict[str, SettingField] = {}\n\n    k: str = \"\"\n    v: SettingField\n\n    field_args: List[str] = []\n    app = \"\"\n    for item in reduce(\n        lambda acc, x: acc + x.split(\"=\"),  # type: ignore\n        args,\n        [],\n    ) + [\"-\"]:\n        if \":\" in item:\n            app = item\n\n        else:\n            if \"-\" in item:\n                if k:\n                    k = k.strip().lstrip(\"-\").replace(\"-\", \"_\")\n\n                    if len(field_args) == 0:\n                        v = not k.startswith(\"no_\")\n                    elif len(field_args) == 1:\n                        v = field_args[0]\n                    else:\n                        v = field_args\n\n                    extra_kwargs[remove_prefix(k, \"no_\")] = v\n                    field_args = []\n\n                k = item\n\n            else:\n                field_args.append(item)\n\n    return app, extra_kwargs\n</code></pre>"},{"location":"api/faststream/cli/utils/parser/remove_prefix/","title":"Remove prefix","text":""},{"location":"api/faststream/cli/utils/parser/remove_prefix/#faststream.cli.utils.parser.remove_prefix","title":"faststream.cli.utils.parser.remove_prefix","text":"<pre><code>remove_prefix(text: str, prefix: str) -&gt; str\n</code></pre> <p>Removes a prefix from a given text.</p> PARAMETER  DESCRIPTION <code>text</code> <p>The text from which the prefix will be removed.</p> <p> TYPE: <code>str</code> </p> <code>prefix</code> <p>The prefix to be removed from the text.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The text with the prefix removed. If the text does not start with the prefix, the original text is returned.</p> <p> TYPE: <code>str</code> </p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/cli/utils/parser.py</code> <pre><code>def remove_prefix(text: str, prefix: str) -&gt; str:\n    \"\"\"Removes a prefix from a given text.\n\n    Args:\n        text (str): The text from which the prefix will be removed.\n        prefix (str): The prefix to be removed from the text.\n\n    Returns:\n        str: The text with the prefix removed. If the text does not start with the prefix, the original text is returned.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    if text.startswith(prefix):\n        return text[len(prefix) :]\n    return text\n</code></pre>"},{"location":"api/faststream/constants/ContentTypes/","title":"ContentTypes","text":""},{"location":"api/faststream/constants/ContentTypes/#faststream.constants.ContentTypes","title":"faststream.constants.ContentTypes","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p> <p>A class to represent content types.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/constants.py</code> <pre><code>class ContentTypes(str, Enum):\n    \"\"\"A class to represent content types.\n\n    Attributes:\n        text : content type for plain text\n        json : content type for JSON data\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    text = \"text/plain\"\n    json = \"application/json\"\n</code></pre>"},{"location":"api/faststream/constants/ContentTypes/#faststream.constants.ContentTypes.json","title":"json  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>json = 'application/json'\n</code></pre>"},{"location":"api/faststream/constants/ContentTypes/#faststream.constants.ContentTypes.text","title":"text  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>text = 'text/plain'\n</code></pre>"},{"location":"api/faststream/exceptions/AckMessage/","title":"AckMessage","text":""},{"location":"api/faststream/exceptions/AckMessage/#faststream.exceptions.AckMessage","title":"faststream.exceptions.AckMessage","text":"<p>             Bases: <code>HandlerException</code></p> <p>Raise it to <code>ack</code> a message immediately</p> Source code in <code>faststream/exceptions.py</code> <pre><code>class AckMessage(HandlerException):\n    \"\"\"Raise it to `ack` a message immediately\"\"\"\n</code></pre>"},{"location":"api/faststream/exceptions/HandlerException/","title":"HandlerException","text":""},{"location":"api/faststream/exceptions/HandlerException/#faststream.exceptions.HandlerException","title":"faststream.exceptions.HandlerException","text":"<p>             Bases: <code>Exception</code></p> <p>Base Handler Exception</p> Source code in <code>faststream/exceptions.py</code> <pre><code>class HandlerException(Exception):\n    \"\"\"Base Handler Exception\"\"\"\n</code></pre>"},{"location":"api/faststream/exceptions/NackMessage/","title":"NackMessage","text":""},{"location":"api/faststream/exceptions/NackMessage/#faststream.exceptions.NackMessage","title":"faststream.exceptions.NackMessage","text":"<p>             Bases: <code>HandlerException</code></p> <p>Raise it to <code>nack</code> a message immediately</p> Source code in <code>faststream/exceptions.py</code> <pre><code>class NackMessage(HandlerException):\n    \"\"\"Raise it to `nack` a message immediately\"\"\"\n</code></pre>"},{"location":"api/faststream/exceptions/RejectMessage/","title":"RejectMessage","text":""},{"location":"api/faststream/exceptions/RejectMessage/#faststream.exceptions.RejectMessage","title":"faststream.exceptions.RejectMessage","text":"<p>             Bases: <code>HandlerException</code></p> <p>Raise it to <code>reject</code> a message immediately</p> Source code in <code>faststream/exceptions.py</code> <pre><code>class RejectMessage(HandlerException):\n    \"\"\"Raise it to `reject` a message immediately\"\"\"\n</code></pre>"},{"location":"api/faststream/exceptions/SkipMessage/","title":"SkipMessage","text":""},{"location":"api/faststream/exceptions/SkipMessage/#faststream.exceptions.SkipMessage","title":"faststream.exceptions.SkipMessage","text":"<p>             Bases: <code>Exception</code></p> <p>Watcher Instruction to skip message</p> Source code in <code>faststream/exceptions.py</code> <pre><code>class SkipMessage(Exception):\n    \"\"\"Watcher Instruction to skip message\"\"\"\n</code></pre>"},{"location":"api/faststream/exceptions/StopConsume/","title":"StopConsume","text":""},{"location":"api/faststream/exceptions/StopConsume/#faststream.exceptions.StopConsume","title":"faststream.exceptions.StopConsume","text":"<p>             Bases: <code>Exception</code></p> <p>Raise it to stop Handler consuming</p> Source code in <code>faststream/exceptions.py</code> <pre><code>class StopConsume(Exception):\n    \"\"\"Raise it to stop Handler consuming\"\"\"\n</code></pre>"},{"location":"api/faststream/kafka/asyncapi/Handler/","title":"Handler","text":""},{"location":"api/faststream/kafka/asyncapi/Handler/#faststream.kafka.asyncapi.Handler","title":"faststream.kafka.asyncapi.Handler","text":"<p>             Bases: <code>LogicHandler</code>, <code>AsyncAPIOperation</code></p> <p>A class to handle logic and async API operations.</p> METHOD DESCRIPTION <code>schema</code> <p>Returns a dictionary of channels.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/kafka/asyncapi.py</code> <pre><code>class Handler(LogicHandler, AsyncAPIOperation):\n    \"\"\"A class to handle logic and async API operations.\n\n    Methods:\n        schema() -&gt; Dict[str, Channel]: Returns a dictionary of channels.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    def schema(self) -&gt; Dict[str, Channel]:\n        name: str\n        if self.name is True:\n            name, add_topic = self.call_name, True\n        elif self.name is False:  # pragma: no cover\n            name, add_topic = \"Handler\", True\n        else:\n            name, add_topic = self.name, False\n\n        channels = {}\n\n        for t in self.topics:\n            if add_topic:\n                t_ = to_camelcase(t)\n                if not name.lower().endswith(t_.lower()):\n                    name_ = f\"{name}{t_}\"\n                else:\n                    name_ = name\n            else:\n                name_ = name\n\n            payloads = []\n            for _, _, _, _, _, dep in self.calls:\n                body = parse_handler_params(dep, prefix=name_)\n                payloads.append(body)\n\n            channels[name_] = Channel(\n                description=self.description,\n                subscribe=Operation(\n                    message=Message(\n                        title=f\"{name_}Message\",\n                        payload=resolve_payloads(payloads),\n                        correlationId=CorrelationId(\n                            location=\"$message.header#/correlation_id\"\n                        ),\n                    ),\n                ),\n                bindings=ChannelBinding(kafka=kafka.ChannelBinding(topic=t)),\n            )\n\n        return channels\n</code></pre>"},{"location":"api/faststream/kafka/asyncapi/Handler/#faststream.kafka.asyncapi.Handler.schema","title":"schema","text":"<pre><code>schema() -&gt; Dict[str, Channel]\n</code></pre> Source code in <code>faststream/kafka/asyncapi.py</code> <pre><code>def schema(self) -&gt; Dict[str, Channel]:\n    name: str\n    if self.name is True:\n        name, add_topic = self.call_name, True\n    elif self.name is False:  # pragma: no cover\n        name, add_topic = \"Handler\", True\n    else:\n        name, add_topic = self.name, False\n\n    channels = {}\n\n    for t in self.topics:\n        if add_topic:\n            t_ = to_camelcase(t)\n            if not name.lower().endswith(t_.lower()):\n                name_ = f\"{name}{t_}\"\n            else:\n                name_ = name\n        else:\n            name_ = name\n\n        payloads = []\n        for _, _, _, _, _, dep in self.calls:\n            body = parse_handler_params(dep, prefix=name_)\n            payloads.append(body)\n\n        channels[name_] = Channel(\n            description=self.description,\n            subscribe=Operation(\n                message=Message(\n                    title=f\"{name_}Message\",\n                    payload=resolve_payloads(payloads),\n                    correlationId=CorrelationId(\n                        location=\"$message.header#/correlation_id\"\n                    ),\n                ),\n            ),\n            bindings=ChannelBinding(kafka=kafka.ChannelBinding(topic=t)),\n        )\n\n    return channels\n</code></pre>"},{"location":"api/faststream/kafka/asyncapi/Publisher/","title":"Publisher","text":""},{"location":"api/faststream/kafka/asyncapi/Publisher/#faststream.kafka.asyncapi.Publisher","title":"faststream.kafka.asyncapi.Publisher","text":"<p>             Bases: <code>LogicPublisher</code>, <code>AsyncAPIOperation</code></p> <p>A class representing a publisher.</p> METHOD DESCRIPTION <code>schema</code> <p>returns the schema for the publisher</p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>If silent animals are not supported</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/kafka/asyncapi.py</code> <pre><code>class Publisher(LogicPublisher, AsyncAPIOperation):\n    \"\"\"A class representing a publisher.\n\n    Attributes:\n        name : name of the publisher\n\n    Methods:\n        schema() : returns the schema for the publisher\n\n    Raises:\n        NotImplementedError: If silent animals are not supported\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    @property\n    def name(self) -&gt; str:\n        return self.title or f\"{self.topic.title()}Publisher\"\n\n    def schema(self) -&gt; Dict[str, Channel]:\n        payloads = []\n        for call in self.calls:\n            call_model = build_call_model(call)\n            body = get_response_schema(\n                call_model,\n                prefix=to_camelcase(call_model.call_name),\n            )\n            if body:\n                payloads.append(body)\n\n        return {\n            self.name: Channel(\n                description=self.description,\n                publish=Operation(\n                    message=Message(\n                        title=f\"{self.name}Message\",\n                        payload=resolve_payloads(payloads),\n                        correlationId=CorrelationId(\n                            location=\"$message.header#/correlation_id\"\n                        ),\n                    ),\n                ),\n                bindings=ChannelBinding(kafka=kafka.ChannelBinding(topic=self.topic)),\n            )\n        }\n</code></pre>"},{"location":"api/faststream/kafka/asyncapi/Publisher/#faststream.kafka.asyncapi.Publisher.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"api/faststream/kafka/asyncapi/Publisher/#faststream.kafka.asyncapi.Publisher.schema","title":"schema","text":"<pre><code>schema() -&gt; Dict[str, Channel]\n</code></pre> Source code in <code>faststream/kafka/asyncapi.py</code> <pre><code>def schema(self) -&gt; Dict[str, Channel]:\n    payloads = []\n    for call in self.calls:\n        call_model = build_call_model(call)\n        body = get_response_schema(\n            call_model,\n            prefix=to_camelcase(call_model.call_name),\n        )\n        if body:\n            payloads.append(body)\n\n    return {\n        self.name: Channel(\n            description=self.description,\n            publish=Operation(\n                message=Message(\n                    title=f\"{self.name}Message\",\n                    payload=resolve_payloads(payloads),\n                    correlationId=CorrelationId(\n                        location=\"$message.header#/correlation_id\"\n                    ),\n                ),\n            ),\n            bindings=ChannelBinding(kafka=kafka.ChannelBinding(topic=self.topic)),\n        )\n    }\n</code></pre>"},{"location":"api/faststream/kafka/broker/KafkaBroker/","title":"KafkaBroker","text":""},{"location":"api/faststream/kafka/broker/KafkaBroker/#faststream.kafka.broker.KafkaBroker","title":"faststream.kafka.broker.KafkaBroker","text":"<p>             Bases: <code>KafkaLoggingMixin</code>, <code>BrokerAsyncUsecase[ConsumerRecord, ConsumerConnectionParams]</code></p> <p>KafkaBroker is a class for managing Kafka message consumption and publishing. It extends BrokerAsyncUsecase to handle asynchronous operations.</p> PARAMETER  DESCRIPTION <code>bootstrap_servers</code> <p>Kafka bootstrap server(s).</p> <p> TYPE: <code>Union[str, Iterable[str]]</code> DEFAULT: <code>'localhost'</code> </p> <code>protocol</code> <p>The protocol used (default is \"kafka\").</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>protocol_version</code> <p>The Kafka protocol version (default is \"auto\").</p> <p> TYPE: <code>str</code> DEFAULT: <code>'auto'</code> </p> <code>client_id</code> <p>The client ID for the Kafka client.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'faststream-' + __version__</code> </p> <code>**kwargs</code> <p>Additional keyword arguments.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> METHOD DESCRIPTION <code>connect</code> <p>Establishes a connection to Kafka.</p> <code>start</code> <p>Starts the KafkaBroker and message handlers.</p> <code>publish</code> <p>Publishes a message to Kafka.</p> Source code in <code>faststream/kafka/broker.py</code> <pre><code>class KafkaBroker(\n    KafkaLoggingMixin,\n    BrokerAsyncUsecase[aiokafka.ConsumerRecord, ConsumerConnectionParams],\n):\n    \"\"\"\n    KafkaBroker is a class for managing Kafka message consumption and publishing.\n    It extends BrokerAsyncUsecase to handle asynchronous operations.\n\n    Args:\n        bootstrap_servers (Union[str, Iterable[str]]): Kafka bootstrap server(s).\n        protocol (str): The protocol used (default is \"kafka\").\n        protocol_version (str): The Kafka protocol version (default is \"auto\").\n        client_id (str): The client ID for the Kafka client.\n        **kwargs: Additional keyword arguments.\n\n    Attributes:\n        handlers (Dict[str, Handler]): A dictionary of message handlers.\n        _publishers (Dict[str, Publisher]): A dictionary of message publishers.\n        _producer (Optional[AioKafkaFastProducer]): An optional Kafka producer.\n\n    Methods:\n        connect(*args, **kwargs): Establishes a connection to Kafka.\n        start(): Starts the KafkaBroker and message handlers.\n        publish(*args, **kwargs): Publishes a message to Kafka.\n    \"\"\"\n\n    handlers: Dict[str, Handler]  # type: ignore[assignment]\n    _publishers: Dict[str, Publisher]  # type: ignore[assignment]\n    _producer: Optional[AioKafkaFastProducer]\n\n    def __init__(\n        self,\n        bootstrap_servers: Union[str, Iterable[str]] = \"localhost\",\n        *,\n        protocol: Optional[str] = None,\n        protocol_version: str = \"auto\",\n        client_id: str = \"faststream-\" + __version__,\n        security: Optional[BaseSecurity] = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"\n        Initialize a KafkaBroker instance.\n\n        Args:\n            bootstrap_servers (Union[str, Iterable[str]]): Kafka bootstrap server(s).\n            protocol (str): The protocol used (default is \"kafka\").\n            protocol_version (str): The Kafka protocol version (default is \"auto\").\n            client_id (str): The client ID for the Kafka client.\n            security (Optional[BaseSecurity]): Security protocol to use in communication with the broker (default is None).\n            **kwargs: Additional keyword arguments.\n        \"\"\"\n        if protocol is None:\n            if security is not None and security.use_ssl:\n                protocol = \"kafka-secure\"\n            else:\n                protocol = \"kafka\"\n\n        super().__init__(\n            url=bootstrap_servers,\n            protocol=protocol,\n            protocol_version=protocol_version,\n            security=security,\n            **kwargs,\n            client_id=client_id,\n            bootstrap_servers=bootstrap_servers,\n        )\n        self.client_id = client_id\n        self._producer = None\n\n    async def _close(\n        self,\n        exc_type: Optional[Type[BaseException]] = None,\n        exc_val: Optional[BaseException] = None,\n        exec_tb: Optional[TracebackType] = None,\n    ) -&gt; None:\n        \"\"\"\n        Close the KafkaBroker, stopping the producer and cleaning up resources.\n\n        Args:\n            exc_type (Optional[Type[BaseException]]): The exception type.\n            exc_val (Optional[BaseException]]): The exception value.\n            exec_tb (Optional[TracebackType]]): The traceback.\n        \"\"\"\n        if self._producer is not None:  # pragma: no branch\n            await self._producer.stop()\n            self._producer = None\n\n        await super()._close(exc_type, exc_val, exec_tb)\n\n    async def connect(\n        self,\n        *args: Any,\n        **kwargs: Any,\n    ) -&gt; ConsumerConnectionParams:\n        \"\"\"\n        Establishes a connection to Kafka and returns connection parameters.\n\n        Args:\n            *args: Additional arguments.\n            **kwargs: Additional keyword arguments.\n\n        Returns:\n            ConsumerConnectionParams: The connection parameters.\n        \"\"\"\n        connection = await super().connect(*args, **kwargs)\n        for p in self._publishers.values():\n            p._producer = self._producer\n        return connection\n\n    @override\n    async def _connect(  # type: ignore[override]\n        self,\n        *,\n        client_id: str,\n        **kwargs: Any,\n    ) -&gt; ConsumerConnectionParams:\n        \"\"\"\n        Connects to Kafka, initializes the producer, and returns connection parameters.\n\n        Args:\n            client_id (str): The client ID.\n            **kwargs: Additional keyword arguments.\n\n        Returns:\n            ConsumerConnectionParams: The connection parameters.\n        \"\"\"\n        security_params = parse_security(self.security)\n        producer = aiokafka.AIOKafkaProducer(\n            **kwargs, **security_params, client_id=client_id\n        )\n        await producer.start()\n        self._producer = AioKafkaFastProducer(\n            producer=producer,\n        )\n        return filter_by_dict(ConsumerConnectionParams, {**kwargs, **security_params})\n\n    async def start(self) -&gt; None:\n        \"\"\"\n        Start the KafkaBroker and message handlers.\n        \"\"\"\n        context.set_local(\n            \"log_context\",\n            self._get_log_context(None, \"\"),\n        )\n\n        await super().start()\n\n        for handler in self.handlers.values():\n            c = self._get_log_context(None, handler.topics, handler.group_id)\n\n            if (name := handler.name) is True:\n                name = handler.call_name\n\n            self._log(f\"`{name}` waiting for messages\", extra=c)\n            await handler.start(**(self._connection or {}))\n\n    def _process_message(\n        self,\n        func: Callable[[KafkaMessage], Awaitable[T_HandlerReturn]],\n        watcher: BaseWatcher,\n    ) -&gt; Callable[[KafkaMessage], Awaitable[WrappedReturn[T_HandlerReturn]],]:\n        \"\"\"\n        Wrap a message processing function with a watcher and publisher.\n\n        Args:\n            func (Callable[[KafkaMessage], Awaitable[T_HandlerReturn]]): The message processing function.\n            watcher (BaseWatcher): The message watcher.\n\n        Returns:\n            Callable[[KafkaMessage], Awaitable[WrappedReturn[T_HandlerReturn]]]: The wrapped message processing function.\n        \"\"\"\n\n        @wraps(func)\n        async def process_wrapper(\n            message: KafkaMessage,\n        ) -&gt; WrappedReturn[T_HandlerReturn]:\n            \"\"\"Asynchronously process a Kafka message and wrap the return value.\n\n            Args:\n                message (KafkaMessage): The Kafka message to process.\n\n            Returns:\n                WrappedReturn[T_HandlerReturn]: The wrapped return value.\n\n            Raises:\n                AssertionError: If the code reaches an unreachable point.\n            !!! note\n\n                The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n            \"\"\"\n            async with WatcherContext(watcher, message):\n                r = await self._execute_handler(func, message)\n\n                pub_response: Optional[AsyncPublisherProtocol]\n                if message.reply_to:\n                    pub_response = FakePublisher(\n                        partial(self.publish, topic=message.reply_to)\n                    )\n                else:\n                    pub_response = None\n\n                return r, pub_response\n\n        return process_wrapper\n\n    @override\n    def subscriber(  # type: ignore[override]\n        self,\n        *topics: str,\n        group_id: Optional[str] = None,\n        key_deserializer: Optional[Callable[[bytes], Any]] = None,\n        value_deserializer: Optional[Callable[[bytes], Any]] = None,\n        fetch_max_wait_ms: int = 500,\n        fetch_max_bytes: int = 52428800,\n        fetch_min_bytes: int = 1,\n        max_partition_fetch_bytes: int = 1 * 1024 * 1024,\n        auto_offset_reset: Literal[\n            \"latest\",\n            \"earliest\",\n            \"none\",\n        ] = \"latest\",\n        enable_auto_commit: bool = True,\n        auto_commit_interval_ms: int = 5000,\n        check_crcs: bool = True,\n        partition_assignment_strategy: Sequence[AbstractPartitionAssignor] = (\n            RoundRobinPartitionAssignor,\n        ),\n        max_poll_interval_ms: int = 300000,\n        rebalance_timeout_ms: Optional[int] = None,\n        session_timeout_ms: int = 10000,\n        heartbeat_interval_ms: int = 3000,\n        consumer_timeout_ms: int = 200,\n        max_poll_records: Optional[int] = None,\n        exclude_internal_topics: bool = True,\n        isolation_level: Literal[\n            \"read_uncommitted\",\n            \"read_committed\",\n        ] = \"read_uncommitted\",\n        # broker arguments\n        dependencies: Sequence[Depends] = (),\n        parser: Optional[\n            Union[\n                CustomParser[aiokafka.ConsumerRecord, KafkaMessage],\n                CustomParser[Tuple[aiokafka.ConsumerRecord, ...], KafkaMessage],\n            ]\n        ] = None,\n        decoder: Optional[CustomDecoder] = None,\n        middlewares: Optional[\n            Sequence[\n                Callable[\n                    [aiokafka.ConsumerRecord],\n                    BaseMiddleware,\n                ]\n            ]\n        ] = None,\n        filter: Union[\n            Filter[KafkaMessage],\n            Filter[StreamMessage[Tuple[aiokafka.ConsumerRecord, ...]]],\n        ] = default_filter,\n        batch: bool = False,\n        max_records: Optional[int] = None,\n        batch_timeout_ms: int = 200,\n        # AsyncAPI information\n        title: Optional[str] = None,\n        description: Optional[str] = None,\n        **original_kwargs: Any,\n    ) -&gt; Callable[\n        [Callable[P_HandlerParams, T_HandlerReturn]],\n        Union[\n            HandlerCallWrapper[\n                aiokafka.ConsumerRecord, P_HandlerParams, T_HandlerReturn\n            ],\n            HandlerCallWrapper[\n                Tuple[aiokafka.ConsumerRecord, ...], P_HandlerParams, T_HandlerReturn\n            ],\n        ],\n    ]:\n        \"\"\"\n        Create a message subscriber for the specified topics.\n\n        Args:\n            *topics (str): The topics to subscribe to.\n            group_id (Optional[str]): The Kafka consumer group ID.\n            key_deserializer (Optional[Callable[[bytes], Any]]): Key deserializer function.\n            value_deserializer (Optional[Callable[[bytes], Any]]): Value deserializer function.\n            fetch_max_wait_ms (int): The maximum time to wait for data.\n            fetch_max_bytes (int): The maximum number of bytes to fetch.\n            fetch_min_bytes (int): The minimum number of bytes to fetch.\n            max_partition_fetch_bytes (int): The maximum bytes to fetch for a partition.\n            auto_offset_reset (Literal[\"latest\", \"earliest\", \"none\"]): Auto offset reset policy.\n            enable_auto_commit (bool): Whether to enable auto-commit.\n            auto_commit_interval_ms (int): Auto-commit interval in milliseconds.\n            check_crcs (bool): Whether to check CRCs.\n            partition_assignment_strategy (Sequence[AbstractPartitionAssignor]): Partition assignment strategy.\n            max_poll_interval_ms (int): Maximum poll interval in milliseconds.\n            rebalance_timeout_ms (Optional[int]): Rebalance timeout in milliseconds.\n            session_timeout_ms (int): Session timeout in milliseconds.\n            heartbeat_interval_ms (int): Heartbeat interval in milliseconds.\n            consumer_timeout_ms (int): Consumer timeout in milliseconds.\n            max_poll_records (Optional[int]): Maximum number of records to poll.\n            exclude_internal_topics (bool): Whether to exclude internal topics.\n            isolation_level (Literal[\"read_uncommitted\", \"read_committed\"]): Isolation level.\n            dependencies (Sequence[Depends]): Additional dependencies for message handling.\n            parser (Optional[Union[CustomParser[aiokafka.ConsumerRecord], CustomParser[Tuple[aiokafka.ConsumerRecord, ...]]]]): Message parser.\n            decoder (Optional[CustomDecoder]): Message decoder.\n            middlewares (Optional[Sequence[Callable[[aiokafka.ConsumerRecord], BaseMiddleware]]]): Message middlewares.\n            filter (Union[Filter[KafkaMessage], Filter[StreamMessage[Tuple[aiokafka.ConsumerRecord, ...]]]]): Message filter.\n            batch (bool): Whether to process messages in batches.\n            max_records (Optional[int]): Maximum number of records to process in each batch.\n            batch_timeout_ms (int): Batch timeout in milliseconds.\n            title (Optional[str]): AsyncAPI title.\n            description (Optional[str]): AsyncAPI description.\n            **original_kwargs: Additional keyword arguments.\n\n        Returns:\n            Callable: A decorator that wraps a message handler function.\n        \"\"\"\n        super().subscriber()\n\n        self._setup_log_context(topics, group_id)\n\n        key = Handler.get_routing_hash(topics, group_id)\n        builder = partial(\n            aiokafka.AIOKafkaConsumer,\n            key_deserializer=key_deserializer,\n            value_deserializer=value_deserializer,\n            fetch_max_wait_ms=fetch_max_wait_ms,\n            fetch_max_bytes=fetch_max_bytes,\n            fetch_min_bytes=fetch_min_bytes,\n            max_partition_fetch_bytes=max_partition_fetch_bytes,\n            auto_offset_reset=auto_offset_reset,\n            enable_auto_commit=enable_auto_commit,\n            auto_commit_interval_ms=auto_commit_interval_ms,\n            check_crcs=check_crcs,\n            partition_assignment_strategy=partition_assignment_strategy,\n            max_poll_interval_ms=max_poll_interval_ms,\n            rebalance_timeout_ms=rebalance_timeout_ms,\n            session_timeout_ms=session_timeout_ms,\n            heartbeat_interval_ms=heartbeat_interval_ms,\n            consumer_timeout_ms=consumer_timeout_ms,\n            max_poll_records=max_poll_records,\n            exclude_internal_topics=exclude_internal_topics,\n            isolation_level=isolation_level,\n        )\n        handler = self.handlers.get(\n            key,\n            Handler(\n                *topics,\n                log_context_builder=partial(\n                    self._get_log_context,\n                    topics=topics,\n                    group_id=group_id,\n                ),\n                group_id=group_id,\n                client_id=self.client_id,\n                builder=builder,\n                description=description,\n                title=title,\n                batch=batch,\n                batch_timeout_ms=batch_timeout_ms,\n                max_records=max_records,\n            ),\n        )\n\n        self.handlers[key] = handler\n\n        def consumer_wrapper(\n            func: Callable[P_HandlerParams, T_HandlerReturn],\n        ) -&gt; HandlerCallWrapper[\n            aiokafka.ConsumerRecord, P_HandlerParams, T_HandlerReturn\n        ]:\n            \"\"\"A wrapper function for a consumer handler.\n\n            Args:\n                func : The consumer handler function to be wrapped.\n\n            Returns:\n                The wrapped handler call.\n\n            Raises:\n                NotImplementedError: If silent animals are not supported.\n            !!! note\n\n                The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n            \"\"\"\n            handler_call, dependant = self._wrap_handler(\n                func=func,\n                extra_dependencies=dependencies,\n                **original_kwargs,\n            )\n\n            handler.add_call(\n                handler=handler_call,\n                filter=filter,\n                middlewares=middlewares,\n                parser=parser or self._global_parser,\n                decoder=decoder or self._global_decoder,\n                dependant=dependant,\n            )\n\n            return handler_call\n\n        return consumer_wrapper\n\n    @override\n    def publisher(  # type: ignore[override]\n        self,\n        topic: str,\n        key: Optional[bytes] = None,\n        partition: Optional[int] = None,\n        timestamp_ms: Optional[int] = None,\n        headers: Optional[Dict[str, str]] = None,\n        reply_to: str = \"\",\n        batch: bool = False,\n        # AsyncAPI information\n        title: Optional[str] = None,\n        description: Optional[str] = None,\n    ) -&gt; Publisher:\n        \"\"\"\n        Create a message publisher for the specified topic.\n\n        Args:\n            topic (str): The topic to publish messages to.\n            key (Optional[bytes]): Message key.\n            partition (Optional[int]): Partition to send the message to.\n            timestamp_ms (Optional[int]): Message timestamp in milliseconds.\n            headers (Optional[Dict[str, str]]): Message headers.\n            reply_to (str): The topic to which responses should be sent.\n            batch (bool): Whether to publish messages in batches.\n            title (Optional[str]): AsyncAPI title.\n            description (Optional[str]): AsyncAPI description.\n\n        Returns:\n            Publisher: A message publisher.\n        \"\"\"\n        publisher = self._publishers.get(\n            topic,\n            Publisher(\n                topic=topic,\n                client_id=self.client_id,\n                key=key,\n                batch=batch,\n                partition=partition,\n                timestamp_ms=timestamp_ms,\n                headers=headers,\n                reply_to=reply_to,\n                title=title,\n                _description=description,\n            ),\n        )\n        super().publisher(topic, publisher)\n        return publisher\n\n    @override\n    async def publish(  # type: ignore[override]\n        self,\n        *args: Any,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"\n        Publish a message to Kafka.\n\n        Args:\n            *args: Positional arguments for message publishing.\n            **kwargs: Keyword arguments for message publishing.\n\n        Raises:\n            RuntimeError: If KafkaBroker is not started yet.\n        \"\"\"\n        assert self._producer, \"KafkaBroker is not started yet\"  # nosec B101\n        return await self._producer.publish(*args, **kwargs)\n\n    async def publish_batch(\n        self,\n        *args: Any,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"\n        Publish a batch of messages to Kafka.\n\n        Args:\n            *args: Positional arguments for message publishing.\n            **kwargs: Keyword arguments for message publishing.\n\n        Raises:\n            RuntimeError: If KafkaBroker is not started yet.\n        \"\"\"\n        assert self._producer, \"KafkaBroker is not started yet\"  # nosec B101\n        await self._producer.publish_batch(*args, **kwargs)\n</code></pre>"},{"location":"api/faststream/kafka/broker/KafkaBroker/#faststream.kafka.broker.KafkaBroker.client_id","title":"client_id  <code>instance-attribute</code>","text":"<pre><code>client_id = client_id\n</code></pre>"},{"location":"api/faststream/kafka/broker/KafkaBroker/#faststream.kafka.broker.KafkaBroker.handlers","title":"handlers  <code>instance-attribute</code>","text":"<pre><code>handlers: Dict[str, Handler]\n</code></pre>"},{"location":"api/faststream/kafka/broker/KafkaBroker/#faststream.kafka.broker.KafkaBroker.connect","title":"connect  <code>async</code>","text":"<pre><code>connect(\n    *args: Any, **kwargs: Any\n) -&gt; ConsumerConnectionParams\n</code></pre> <p>Establishes a connection to Kafka and returns connection parameters.</p> PARAMETER  DESCRIPTION <code>*args</code> <p>Additional arguments.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>()</code> </p> <code>**kwargs</code> <p>Additional keyword arguments.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>ConsumerConnectionParams</code> <p>The connection parameters.</p> <p> TYPE: <code>ConsumerConnectionParams</code> </p> Source code in <code>faststream/kafka/broker.py</code> <pre><code>async def connect(\n    self,\n    *args: Any,\n    **kwargs: Any,\n) -&gt; ConsumerConnectionParams:\n    \"\"\"\n    Establishes a connection to Kafka and returns connection parameters.\n\n    Args:\n        *args: Additional arguments.\n        **kwargs: Additional keyword arguments.\n\n    Returns:\n        ConsumerConnectionParams: The connection parameters.\n    \"\"\"\n    connection = await super().connect(*args, **kwargs)\n    for p in self._publishers.values():\n        p._producer = self._producer\n    return connection\n</code></pre>"},{"location":"api/faststream/kafka/broker/KafkaBroker/#faststream.kafka.broker.KafkaBroker.publish","title":"publish  <code>async</code>","text":"<pre><code>publish(*args: Any, **kwargs: Any) -&gt; None\n</code></pre> <p>Publish a message to Kafka.</p> PARAMETER  DESCRIPTION <code>*args</code> <p>Positional arguments for message publishing.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>()</code> </p> <code>**kwargs</code> <p>Keyword arguments for message publishing.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If KafkaBroker is not started yet.</p> Source code in <code>faststream/kafka/broker.py</code> <pre><code>@override\nasync def publish(  # type: ignore[override]\n    self,\n    *args: Any,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    Publish a message to Kafka.\n\n    Args:\n        *args: Positional arguments for message publishing.\n        **kwargs: Keyword arguments for message publishing.\n\n    Raises:\n        RuntimeError: If KafkaBroker is not started yet.\n    \"\"\"\n    assert self._producer, \"KafkaBroker is not started yet\"  # nosec B101\n    return await self._producer.publish(*args, **kwargs)\n</code></pre>"},{"location":"api/faststream/kafka/broker/KafkaBroker/#faststream.kafka.broker.KafkaBroker.publish_batch","title":"publish_batch  <code>async</code>","text":"<pre><code>publish_batch(*args: Any, **kwargs: Any) -&gt; None\n</code></pre> <p>Publish a batch of messages to Kafka.</p> PARAMETER  DESCRIPTION <code>*args</code> <p>Positional arguments for message publishing.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>()</code> </p> <code>**kwargs</code> <p>Keyword arguments for message publishing.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If KafkaBroker is not started yet.</p> Source code in <code>faststream/kafka/broker.py</code> <pre><code>async def publish_batch(\n    self,\n    *args: Any,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    Publish a batch of messages to Kafka.\n\n    Args:\n        *args: Positional arguments for message publishing.\n        **kwargs: Keyword arguments for message publishing.\n\n    Raises:\n        RuntimeError: If KafkaBroker is not started yet.\n    \"\"\"\n    assert self._producer, \"KafkaBroker is not started yet\"  # nosec B101\n    await self._producer.publish_batch(*args, **kwargs)\n</code></pre>"},{"location":"api/faststream/kafka/broker/KafkaBroker/#faststream.kafka.broker.KafkaBroker.publisher","title":"publisher","text":"<pre><code>publisher(\n    topic: str,\n    key: Optional[bytes] = None,\n    partition: Optional[int] = None,\n    timestamp_ms: Optional[int] = None,\n    headers: Optional[Dict[str, str]] = None,\n    reply_to: str = \"\",\n    batch: bool = False,\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n) -&gt; Publisher\n</code></pre> <p>Create a message publisher for the specified topic.</p> PARAMETER  DESCRIPTION <code>topic</code> <p>The topic to publish messages to.</p> <p> TYPE: <code>str</code> </p> <code>key</code> <p>Message key.</p> <p> TYPE: <code>Optional[bytes]</code> DEFAULT: <code>None</code> </p> <code>partition</code> <p>Partition to send the message to.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>timestamp_ms</code> <p>Message timestamp in milliseconds.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>headers</code> <p>Message headers.</p> <p> TYPE: <code>Optional[Dict[str, str]]</code> DEFAULT: <code>None</code> </p> <code>reply_to</code> <p>The topic to which responses should be sent.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>batch</code> <p>Whether to publish messages in batches.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>title</code> <p>AsyncAPI title.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>description</code> <p>AsyncAPI description.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Publisher</code> <p>A message publisher.</p> <p> TYPE: <code>Publisher</code> </p> Source code in <code>faststream/kafka/broker.py</code> <pre><code>@override\ndef publisher(  # type: ignore[override]\n    self,\n    topic: str,\n    key: Optional[bytes] = None,\n    partition: Optional[int] = None,\n    timestamp_ms: Optional[int] = None,\n    headers: Optional[Dict[str, str]] = None,\n    reply_to: str = \"\",\n    batch: bool = False,\n    # AsyncAPI information\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n) -&gt; Publisher:\n    \"\"\"\n    Create a message publisher for the specified topic.\n\n    Args:\n        topic (str): The topic to publish messages to.\n        key (Optional[bytes]): Message key.\n        partition (Optional[int]): Partition to send the message to.\n        timestamp_ms (Optional[int]): Message timestamp in milliseconds.\n        headers (Optional[Dict[str, str]]): Message headers.\n        reply_to (str): The topic to which responses should be sent.\n        batch (bool): Whether to publish messages in batches.\n        title (Optional[str]): AsyncAPI title.\n        description (Optional[str]): AsyncAPI description.\n\n    Returns:\n        Publisher: A message publisher.\n    \"\"\"\n    publisher = self._publishers.get(\n        topic,\n        Publisher(\n            topic=topic,\n            client_id=self.client_id,\n            key=key,\n            batch=batch,\n            partition=partition,\n            timestamp_ms=timestamp_ms,\n            headers=headers,\n            reply_to=reply_to,\n            title=title,\n            _description=description,\n        ),\n    )\n    super().publisher(topic, publisher)\n    return publisher\n</code></pre>"},{"location":"api/faststream/kafka/broker/KafkaBroker/#faststream.kafka.broker.KafkaBroker.start","title":"start  <code>async</code>","text":"<pre><code>start() -&gt; None\n</code></pre> <p>Start the KafkaBroker and message handlers.</p> Source code in <code>faststream/kafka/broker.py</code> <pre><code>async def start(self) -&gt; None:\n    \"\"\"\n    Start the KafkaBroker and message handlers.\n    \"\"\"\n    context.set_local(\n        \"log_context\",\n        self._get_log_context(None, \"\"),\n    )\n\n    await super().start()\n\n    for handler in self.handlers.values():\n        c = self._get_log_context(None, handler.topics, handler.group_id)\n\n        if (name := handler.name) is True:\n            name = handler.call_name\n\n        self._log(f\"`{name}` waiting for messages\", extra=c)\n        await handler.start(**(self._connection or {}))\n</code></pre>"},{"location":"api/faststream/kafka/broker/KafkaBroker/#faststream.kafka.broker.KafkaBroker.subscriber","title":"subscriber","text":"<pre><code>subscriber(\n    *topics: str,\n    group_id: Optional[str] = None,\n    key_deserializer: Optional[\n        Callable[[bytes], Any]\n    ] = None,\n    value_deserializer: Optional[\n        Callable[[bytes], Any]\n    ] = None,\n    fetch_max_wait_ms: int = 500,\n    fetch_max_bytes: int = 52428800,\n    fetch_min_bytes: int = 1,\n    max_partition_fetch_bytes: int = 1 * 1024 * 1024,\n    auto_offset_reset: Literal[\n        \"latest\", \"earliest\", \"none\"\n    ] = \"latest\",\n    enable_auto_commit: bool = True,\n    auto_commit_interval_ms: int = 5000,\n    check_crcs: bool = True,\n    partition_assignment_strategy: Sequence[\n        AbstractPartitionAssignor\n    ] = (RoundRobinPartitionAssignor),\n    max_poll_interval_ms: int = 300000,\n    rebalance_timeout_ms: Optional[int] = None,\n    session_timeout_ms: int = 10000,\n    heartbeat_interval_ms: int = 3000,\n    consumer_timeout_ms: int = 200,\n    max_poll_records: Optional[int] = None,\n    exclude_internal_topics: bool = True,\n    isolation_level: Literal[\n        \"read_uncommitted\", \"read_committed\"\n    ] = \"read_uncommitted\",\n    dependencies: Sequence[Depends] = (),\n    parser: Optional[\n        Union[\n            CustomParser[\n                aiokafka.ConsumerRecord, KafkaMessage\n            ],\n            CustomParser[\n                Tuple[aiokafka.ConsumerRecord, ...],\n                KafkaMessage,\n            ],\n        ]\n    ] = None,\n    decoder: Optional[CustomDecoder] = None,\n    middlewares: Optional[\n        Sequence[\n            Callable[\n                [aiokafka.ConsumerRecord], BaseMiddleware\n            ]\n        ]\n    ] = None,\n    filter: Union[\n        Filter[KafkaMessage],\n        Filter[\n            StreamMessage[\n                Tuple[aiokafka.ConsumerRecord, ...]\n            ]\n        ],\n    ] = default_filter,\n    batch: bool = False,\n    max_records: Optional[int] = None,\n    batch_timeout_ms: int = 200,\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n    **original_kwargs: Any\n) -&gt; Callable[\n    [Callable[P_HandlerParams, T_HandlerReturn]],\n    Union[\n        HandlerCallWrapper[\n            aiokafka.ConsumerRecord,\n            P_HandlerParams,\n            T_HandlerReturn,\n        ],\n        HandlerCallWrapper[\n            Tuple[aiokafka.ConsumerRecord, ...],\n            P_HandlerParams,\n            T_HandlerReturn,\n        ],\n    ],\n]\n</code></pre> <p>Create a message subscriber for the specified topics.</p> PARAMETER  DESCRIPTION <code>*topics</code> <p>The topics to subscribe to.</p> <p> TYPE: <code>str</code> DEFAULT: <code>()</code> </p> <code>group_id</code> <p>The Kafka consumer group ID.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>key_deserializer</code> <p>Key deserializer function.</p> <p> TYPE: <code>Optional[Callable[[bytes], Any]]</code> DEFAULT: <code>None</code> </p> <code>value_deserializer</code> <p>Value deserializer function.</p> <p> TYPE: <code>Optional[Callable[[bytes], Any]]</code> DEFAULT: <code>None</code> </p> <code>fetch_max_wait_ms</code> <p>The maximum time to wait for data.</p> <p> TYPE: <code>int</code> DEFAULT: <code>500</code> </p> <code>fetch_max_bytes</code> <p>The maximum number of bytes to fetch.</p> <p> TYPE: <code>int</code> DEFAULT: <code>52428800</code> </p> <code>fetch_min_bytes</code> <p>The minimum number of bytes to fetch.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>max_partition_fetch_bytes</code> <p>The maximum bytes to fetch for a partition.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1 * 1024 * 1024</code> </p> <code>auto_offset_reset</code> <p>Auto offset reset policy.</p> <p> TYPE: <code>Literal['latest', 'earliest', 'none']</code> DEFAULT: <code>'latest'</code> </p> <code>enable_auto_commit</code> <p>Whether to enable auto-commit.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>auto_commit_interval_ms</code> <p>Auto-commit interval in milliseconds.</p> <p> TYPE: <code>int</code> DEFAULT: <code>5000</code> </p> <code>check_crcs</code> <p>Whether to check CRCs.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>partition_assignment_strategy</code> <p>Partition assignment strategy.</p> <p> TYPE: <code>Sequence[AbstractPartitionAssignor]</code> DEFAULT: <code>(RoundRobinPartitionAssignor)</code> </p> <code>max_poll_interval_ms</code> <p>Maximum poll interval in milliseconds.</p> <p> TYPE: <code>int</code> DEFAULT: <code>300000</code> </p> <code>rebalance_timeout_ms</code> <p>Rebalance timeout in milliseconds.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>session_timeout_ms</code> <p>Session timeout in milliseconds.</p> <p> TYPE: <code>int</code> DEFAULT: <code>10000</code> </p> <code>heartbeat_interval_ms</code> <p>Heartbeat interval in milliseconds.</p> <p> TYPE: <code>int</code> DEFAULT: <code>3000</code> </p> <code>consumer_timeout_ms</code> <p>Consumer timeout in milliseconds.</p> <p> TYPE: <code>int</code> DEFAULT: <code>200</code> </p> <code>max_poll_records</code> <p>Maximum number of records to poll.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>exclude_internal_topics</code> <p>Whether to exclude internal topics.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>isolation_level</code> <p>Isolation level.</p> <p> TYPE: <code>Literal['read_uncommitted', 'read_committed']</code> DEFAULT: <code>'read_uncommitted'</code> </p> <code>dependencies</code> <p>Additional dependencies for message handling.</p> <p> TYPE: <code>Sequence[Depends]</code> DEFAULT: <code>()</code> </p> <code>parser</code> <p>Message parser.</p> <p> TYPE: <code>Optional[Union[CustomParser[ConsumerRecord], CustomParser[Tuple[ConsumerRecord, ...]]]]</code> DEFAULT: <code>None</code> </p> <code>decoder</code> <p>Message decoder.</p> <p> TYPE: <code>Optional[CustomDecoder]</code> DEFAULT: <code>None</code> </p> <code>middlewares</code> <p>Message middlewares.</p> <p> TYPE: <code>Optional[Sequence[Callable[[ConsumerRecord], BaseMiddleware]]]</code> DEFAULT: <code>None</code> </p> <code>filter</code> <p>Message filter.</p> <p> TYPE: <code>Union[Filter[KafkaMessage], Filter[StreamMessage[Tuple[ConsumerRecord, ...]]]]</code> DEFAULT: <code>default_filter</code> </p> <code>batch</code> <p>Whether to process messages in batches.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>max_records</code> <p>Maximum number of records to process in each batch.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>batch_timeout_ms</code> <p>Batch timeout in milliseconds.</p> <p> TYPE: <code>int</code> DEFAULT: <code>200</code> </p> <code>title</code> <p>AsyncAPI title.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>description</code> <p>AsyncAPI description.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>**original_kwargs</code> <p>Additional keyword arguments.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Callable</code> <p>A decorator that wraps a message handler function.</p> <p> TYPE: <code>Callable[[Callable[P_HandlerParams, T_HandlerReturn]], Union[HandlerCallWrapper[ConsumerRecord, P_HandlerParams, T_HandlerReturn], HandlerCallWrapper[Tuple[ConsumerRecord, ...], P_HandlerParams, T_HandlerReturn]]]</code> </p> Source code in <code>faststream/kafka/broker.py</code> <pre><code>@override\ndef subscriber(  # type: ignore[override]\n    self,\n    *topics: str,\n    group_id: Optional[str] = None,\n    key_deserializer: Optional[Callable[[bytes], Any]] = None,\n    value_deserializer: Optional[Callable[[bytes], Any]] = None,\n    fetch_max_wait_ms: int = 500,\n    fetch_max_bytes: int = 52428800,\n    fetch_min_bytes: int = 1,\n    max_partition_fetch_bytes: int = 1 * 1024 * 1024,\n    auto_offset_reset: Literal[\n        \"latest\",\n        \"earliest\",\n        \"none\",\n    ] = \"latest\",\n    enable_auto_commit: bool = True,\n    auto_commit_interval_ms: int = 5000,\n    check_crcs: bool = True,\n    partition_assignment_strategy: Sequence[AbstractPartitionAssignor] = (\n        RoundRobinPartitionAssignor,\n    ),\n    max_poll_interval_ms: int = 300000,\n    rebalance_timeout_ms: Optional[int] = None,\n    session_timeout_ms: int = 10000,\n    heartbeat_interval_ms: int = 3000,\n    consumer_timeout_ms: int = 200,\n    max_poll_records: Optional[int] = None,\n    exclude_internal_topics: bool = True,\n    isolation_level: Literal[\n        \"read_uncommitted\",\n        \"read_committed\",\n    ] = \"read_uncommitted\",\n    # broker arguments\n    dependencies: Sequence[Depends] = (),\n    parser: Optional[\n        Union[\n            CustomParser[aiokafka.ConsumerRecord, KafkaMessage],\n            CustomParser[Tuple[aiokafka.ConsumerRecord, ...], KafkaMessage],\n        ]\n    ] = None,\n    decoder: Optional[CustomDecoder] = None,\n    middlewares: Optional[\n        Sequence[\n            Callable[\n                [aiokafka.ConsumerRecord],\n                BaseMiddleware,\n            ]\n        ]\n    ] = None,\n    filter: Union[\n        Filter[KafkaMessage],\n        Filter[StreamMessage[Tuple[aiokafka.ConsumerRecord, ...]]],\n    ] = default_filter,\n    batch: bool = False,\n    max_records: Optional[int] = None,\n    batch_timeout_ms: int = 200,\n    # AsyncAPI information\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n    **original_kwargs: Any,\n) -&gt; Callable[\n    [Callable[P_HandlerParams, T_HandlerReturn]],\n    Union[\n        HandlerCallWrapper[\n            aiokafka.ConsumerRecord, P_HandlerParams, T_HandlerReturn\n        ],\n        HandlerCallWrapper[\n            Tuple[aiokafka.ConsumerRecord, ...], P_HandlerParams, T_HandlerReturn\n        ],\n    ],\n]:\n    \"\"\"\n    Create a message subscriber for the specified topics.\n\n    Args:\n        *topics (str): The topics to subscribe to.\n        group_id (Optional[str]): The Kafka consumer group ID.\n        key_deserializer (Optional[Callable[[bytes], Any]]): Key deserializer function.\n        value_deserializer (Optional[Callable[[bytes], Any]]): Value deserializer function.\n        fetch_max_wait_ms (int): The maximum time to wait for data.\n        fetch_max_bytes (int): The maximum number of bytes to fetch.\n        fetch_min_bytes (int): The minimum number of bytes to fetch.\n        max_partition_fetch_bytes (int): The maximum bytes to fetch for a partition.\n        auto_offset_reset (Literal[\"latest\", \"earliest\", \"none\"]): Auto offset reset policy.\n        enable_auto_commit (bool): Whether to enable auto-commit.\n        auto_commit_interval_ms (int): Auto-commit interval in milliseconds.\n        check_crcs (bool): Whether to check CRCs.\n        partition_assignment_strategy (Sequence[AbstractPartitionAssignor]): Partition assignment strategy.\n        max_poll_interval_ms (int): Maximum poll interval in milliseconds.\n        rebalance_timeout_ms (Optional[int]): Rebalance timeout in milliseconds.\n        session_timeout_ms (int): Session timeout in milliseconds.\n        heartbeat_interval_ms (int): Heartbeat interval in milliseconds.\n        consumer_timeout_ms (int): Consumer timeout in milliseconds.\n        max_poll_records (Optional[int]): Maximum number of records to poll.\n        exclude_internal_topics (bool): Whether to exclude internal topics.\n        isolation_level (Literal[\"read_uncommitted\", \"read_committed\"]): Isolation level.\n        dependencies (Sequence[Depends]): Additional dependencies for message handling.\n        parser (Optional[Union[CustomParser[aiokafka.ConsumerRecord], CustomParser[Tuple[aiokafka.ConsumerRecord, ...]]]]): Message parser.\n        decoder (Optional[CustomDecoder]): Message decoder.\n        middlewares (Optional[Sequence[Callable[[aiokafka.ConsumerRecord], BaseMiddleware]]]): Message middlewares.\n        filter (Union[Filter[KafkaMessage], Filter[StreamMessage[Tuple[aiokafka.ConsumerRecord, ...]]]]): Message filter.\n        batch (bool): Whether to process messages in batches.\n        max_records (Optional[int]): Maximum number of records to process in each batch.\n        batch_timeout_ms (int): Batch timeout in milliseconds.\n        title (Optional[str]): AsyncAPI title.\n        description (Optional[str]): AsyncAPI description.\n        **original_kwargs: Additional keyword arguments.\n\n    Returns:\n        Callable: A decorator that wraps a message handler function.\n    \"\"\"\n    super().subscriber()\n\n    self._setup_log_context(topics, group_id)\n\n    key = Handler.get_routing_hash(topics, group_id)\n    builder = partial(\n        aiokafka.AIOKafkaConsumer,\n        key_deserializer=key_deserializer,\n        value_deserializer=value_deserializer,\n        fetch_max_wait_ms=fetch_max_wait_ms,\n        fetch_max_bytes=fetch_max_bytes,\n        fetch_min_bytes=fetch_min_bytes,\n        max_partition_fetch_bytes=max_partition_fetch_bytes,\n        auto_offset_reset=auto_offset_reset,\n        enable_auto_commit=enable_auto_commit,\n        auto_commit_interval_ms=auto_commit_interval_ms,\n        check_crcs=check_crcs,\n        partition_assignment_strategy=partition_assignment_strategy,\n        max_poll_interval_ms=max_poll_interval_ms,\n        rebalance_timeout_ms=rebalance_timeout_ms,\n        session_timeout_ms=session_timeout_ms,\n        heartbeat_interval_ms=heartbeat_interval_ms,\n        consumer_timeout_ms=consumer_timeout_ms,\n        max_poll_records=max_poll_records,\n        exclude_internal_topics=exclude_internal_topics,\n        isolation_level=isolation_level,\n    )\n    handler = self.handlers.get(\n        key,\n        Handler(\n            *topics,\n            log_context_builder=partial(\n                self._get_log_context,\n                topics=topics,\n                group_id=group_id,\n            ),\n            group_id=group_id,\n            client_id=self.client_id,\n            builder=builder,\n            description=description,\n            title=title,\n            batch=batch,\n            batch_timeout_ms=batch_timeout_ms,\n            max_records=max_records,\n        ),\n    )\n\n    self.handlers[key] = handler\n\n    def consumer_wrapper(\n        func: Callable[P_HandlerParams, T_HandlerReturn],\n    ) -&gt; HandlerCallWrapper[\n        aiokafka.ConsumerRecord, P_HandlerParams, T_HandlerReturn\n    ]:\n        \"\"\"A wrapper function for a consumer handler.\n\n        Args:\n            func : The consumer handler function to be wrapped.\n\n        Returns:\n            The wrapped handler call.\n\n        Raises:\n            NotImplementedError: If silent animals are not supported.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        handler_call, dependant = self._wrap_handler(\n            func=func,\n            extra_dependencies=dependencies,\n            **original_kwargs,\n        )\n\n        handler.add_call(\n            handler=handler_call,\n            filter=filter,\n            middlewares=middlewares,\n            parser=parser or self._global_parser,\n            decoder=decoder or self._global_decoder,\n            dependant=dependant,\n        )\n\n        return handler_call\n\n    return consumer_wrapper\n</code></pre>"},{"location":"api/faststream/kafka/fastapi/KafkaRouter/","title":"KafkaRouter","text":""},{"location":"api/faststream/kafka/fastapi/KafkaRouter/#faststream.kafka.fastapi.KafkaRouter","title":"faststream.kafka.fastapi.KafkaRouter","text":"<p>             Bases: <code>StreamRouter[ConsumerRecord]</code></p> <p>A class to route Kafka streams.</p> METHOD DESCRIPTION <code>_setup_log_context </code> <p>sets up the log context for the main broker and including broker</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/kafka/fastapi.py</code> <pre><code>class KafkaRouter(StreamRouter[ConsumerRecord]):\n    \"\"\"A class to route Kafka streams.\n\n    Attributes:\n        broker_class : class representing the Kafka broker\n\n    Methods:\n        _setup_log_context : sets up the log context for the main broker and including broker\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    broker_class = KafkaBroker\n\n    @staticmethod\n    def _setup_log_context(\n        main_broker: KafkaBroker,\n        including_broker: KafkaBroker,\n    ) -&gt; None:\n        \"\"\"Set up log context for a Kafka broker.\n\n        Args:\n            main_broker: The main Kafka broker.\n            including_broker: The Kafka broker to include in the log context.\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        for h in including_broker.handlers.values():\n            main_broker._setup_log_context(h.topics)\n</code></pre>"},{"location":"api/faststream/kafka/fastapi/KafkaRouter/#faststream.kafka.fastapi.KafkaRouter.broker","title":"broker  <code>instance-attribute</code>","text":"<pre><code>broker: KafkaBroker\n</code></pre>"},{"location":"api/faststream/kafka/fastapi/KafkaRouter/#faststream.kafka.fastapi.KafkaRouter.broker_class","title":"broker_class  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>broker_class: Type[KafkaBroker] = KafkaBroker\n</code></pre>"},{"location":"api/faststream/kafka/fastapi/KafkaRouter/#faststream.kafka.fastapi.KafkaRouter.publisher","title":"publisher","text":"<pre><code>publisher(\n    topic: str,\n    key: Optional[bytes] = None,\n    partition: Optional[int] = None,\n    timestamp_ms: Optional[int] = None,\n    headers: Optional[Dict[str, str]] = None,\n    reply_to: str = \"\",\n    batch: bool = False,\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n) -&gt; Publisher\n</code></pre>"},{"location":"api/faststream/kafka/handler/LogicHandler/","title":"LogicHandler","text":""},{"location":"api/faststream/kafka/handler/LogicHandler/#faststream.kafka.handler.LogicHandler","title":"faststream.kafka.handler.LogicHandler","text":"<p>             Bases: <code>AsyncHandler[ConsumerRecord]</code></p> <p>A class to handle logic for consuming messages from Kafka.</p> METHOD DESCRIPTION <code>__init__ </code> <p>constructor method for the LogicHandler class</p> <code>start </code> <p>method to start consuming messages from Kafka</p> <code>close </code> <p>method to close the Kafka consumer and cancel the consuming task</p> <code>add_call </code> <p>method to add a handler call for processing consumed messages</p> <code>_consume </code> <p>method to consume messages from Kafka and call the appropriate handler</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/kafka/handler.py</code> <pre><code>class LogicHandler(AsyncHandler[ConsumerRecord]):\n    \"\"\"A class to handle logic for consuming messages from Kafka.\n\n    Attributes:\n        topics : sequence of strings representing the topics to consume from\n        group_id : optional string representing the consumer group ID\n        consumer : optional AIOKafkaConsumer object representing the Kafka consumer\n        task : optional asyncio.Task object representing the task for consuming messages\n        batch : boolean indicating whether to consume messages in batches\n\n    Methods:\n        __init__ : constructor method for the LogicHandler class\n        start : method to start consuming messages from Kafka\n        close : method to close the Kafka consumer and cancel the consuming task\n        add_call : method to add a handler call for processing consumed messages\n        _consume : method to consume messages from Kafka and call the appropriate handler\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    topics: Sequence[str]\n    group_id: Optional[str] = None\n\n    consumer: Optional[AIOKafkaConsumer] = None\n    task: Optional[\"asyncio.Task[Any]\"] = None\n    batch: bool = False\n\n    @override\n    def __init__(\n        self,\n        *topics: str,\n        log_context_builder: Callable[[StreamMessage[Any]], Dict[str, str]],\n        # Kafka information\n        group_id: Optional[str] = None,\n        client_id: str = \"faststream-\" + __version__,\n        builder: Callable[..., AIOKafkaConsumer],\n        batch: bool = False,\n        batch_timeout_ms: int = 200,\n        max_records: Optional[int] = None,\n        # AsyncAPI information\n        title: Optional[str] = None,\n        description: Optional[str] = None,\n    ):\n        \"\"\"Initialize a Kafka consumer for the specified topics.\n\n        Args:\n            *topics: Variable length argument list of topics to consume from.\n            group_id: Optional group ID for the consumer.\n            client_id: Client ID for the consumer.\n            builder: Callable that constructs an AIOKafkaConsumer instance.\n            batch: Flag indicating whether to consume messages in batches.\n            batch_timeout_ms: Timeout in milliseconds for batch consumption.\n            max_records: Maximum number of records to consume in a batch.\n            title: Optional title for the consumer.\n            description: Optional description for the consumer.\n\n        Raises:\n            NotImplementedError: If silent animals are not supported.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        super().__init__(\n            log_context_builder=log_context_builder,\n            description=description,\n            title=title,\n        )\n\n        self.group_id = group_id\n        self.client_id = client_id\n        self.topics = topics\n\n        self.batch = batch\n        self.batch_timeout_ms = batch_timeout_ms\n        self.max_records = max_records\n\n        self.builder = builder\n        self.task = None\n        self.consumer = None\n\n    # TODO: use **kwargs: Unpack[ConsumerConnectionParams] with py3.12 release 2023-10-02\n    async def start(self, **consumer_kwargs: Any) -&gt; None:\n        \"\"\"Start the consumer.\n\n        Args:\n            **consumer_kwargs: Additional keyword arguments to pass to the consumer.\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        self.consumer = consumer = self.builder(\n            *self.topics,\n            group_id=self.group_id,\n            client_id=self.client_id,\n            **consumer_kwargs,\n        )\n        await consumer.start()\n        self.task = asyncio.create_task(self._consume())\n\n    async def close(self) -&gt; None:\n        if self.consumer is not None:\n            await self.consumer.stop()\n            self.consumer = None\n\n        if self.task is not None:\n            self.task.cancel()\n            self.task = None\n\n    def add_call(\n        self,\n        *,\n        handler: HandlerCallWrapper[ConsumerRecord, P_HandlerParams, T_HandlerReturn],\n        dependant: CallModel[P_HandlerParams, T_HandlerReturn],\n        parser: CustomParser[\n            Union[ConsumerRecord, Tuple[ConsumerRecord, ...]], KafkaMessage\n        ],\n        decoder: Optional[CustomDecoder[KafkaMessage]],\n        filter: Union[\n            Filter[KafkaMessage],\n            Filter[StreamMessage[Tuple[ConsumerRecord, ...]]],\n        ],\n        middlewares: Optional[Sequence[Callable[[ConsumerRecord], BaseMiddleware]]],\n    ) -&gt; None:\n        \"\"\"Adds a call to the handler.\n\n        Args:\n            handler: The handler function to be called.\n            dependant: The dependant model.\n            parser: Optional custom parser for parsing the input.\n            decoder: Optional custom decoder for decoding the input.\n            filter: The filter for filtering the input.\n            middlewares: Optional sequence of middlewares to be applied.\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        parser_ = resolve_custom_func(  # type: ignore[type-var]\n            parser,  # type: ignore[arg-type]\n            (\n                AioKafkaParser.parse_message_batch  # type: ignore[arg-type]\n                if self.batch\n                else AioKafkaParser.parse_message\n            ),\n        )\n        decoder_ = resolve_custom_func(\n            decoder,  # type: ignore[arg-type]\n            (\n                AioKafkaParser.decode_message_batch  # type: ignore[arg-type]\n                if self.batch\n                else AioKafkaParser.decode_message\n            ),\n        )\n        super().add_call(\n            handler=handler,\n            parser=parser_,\n            decoder=decoder_,\n            filter=filter,  # type: ignore[arg-type]\n            dependant=dependant,\n            middlewares=middlewares,\n        )\n\n    async def _consume(self) -&gt; None:\n        assert self.consumer, \"You need to start handler first\"  # nosec B101\n\n        connected = True\n        while self.consumer:\n            try:\n                if self.batch:\n                    messages = await self.consumer.getmany(\n                        timeout_ms=self.batch_timeout_ms,\n                        max_records=self.max_records,\n                    )\n                    if not messages:\n                        await anyio.sleep(self.batch_timeout_ms / 1000)\n                        continue\n                    msg = tuple(chain(*messages.values()))\n                else:\n                    msg = await self.consumer.getone()\n\n            except KafkaError:\n                if connected is True:\n                    connected = False\n                await anyio.sleep(5)\n\n            else:\n                if connected is False:\n                    connected = True\n                await self.consume(msg)\n\n    @staticmethod\n    def get_routing_hash(topics: Sequence[str], group_id: Optional[str] = None) -&gt; str:\n        return \"\".join((*topics, group_id or \"\"))\n</code></pre>"},{"location":"api/faststream/kafka/handler/LogicHandler/#faststream.kafka.handler.LogicHandler.batch","title":"batch  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>batch: bool = batch\n</code></pre>"},{"location":"api/faststream/kafka/handler/LogicHandler/#faststream.kafka.handler.LogicHandler.batch_timeout_ms","title":"batch_timeout_ms  <code>instance-attribute</code>","text":"<pre><code>batch_timeout_ms = batch_timeout_ms\n</code></pre>"},{"location":"api/faststream/kafka/handler/LogicHandler/#faststream.kafka.handler.LogicHandler.builder","title":"builder  <code>instance-attribute</code>","text":"<pre><code>builder = builder\n</code></pre>"},{"location":"api/faststream/kafka/handler/LogicHandler/#faststream.kafka.handler.LogicHandler.client_id","title":"client_id  <code>instance-attribute</code>","text":"<pre><code>client_id = client_id\n</code></pre>"},{"location":"api/faststream/kafka/handler/LogicHandler/#faststream.kafka.handler.LogicHandler.consumer","title":"consumer  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>consumer: Optional[AIOKafkaConsumer] = None\n</code></pre>"},{"location":"api/faststream/kafka/handler/LogicHandler/#faststream.kafka.handler.LogicHandler.group_id","title":"group_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>group_id: Optional[str] = group_id\n</code></pre>"},{"location":"api/faststream/kafka/handler/LogicHandler/#faststream.kafka.handler.LogicHandler.max_records","title":"max_records  <code>instance-attribute</code>","text":"<pre><code>max_records = max_records\n</code></pre>"},{"location":"api/faststream/kafka/handler/LogicHandler/#faststream.kafka.handler.LogicHandler.task","title":"task  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>task: Optional[asyncio.Task[Any]] = None\n</code></pre>"},{"location":"api/faststream/kafka/handler/LogicHandler/#faststream.kafka.handler.LogicHandler.topics","title":"topics  <code>instance-attribute</code>","text":"<pre><code>topics: Sequence[str] = topics\n</code></pre>"},{"location":"api/faststream/kafka/handler/LogicHandler/#faststream.kafka.handler.LogicHandler.add_call","title":"add_call","text":"<pre><code>add_call(\n    *,\n    handler: HandlerCallWrapper[\n        ConsumerRecord, P_HandlerParams, T_HandlerReturn\n    ],\n    dependant: CallModel[P_HandlerParams, T_HandlerReturn],\n    parser: CustomParser[\n        Union[ConsumerRecord, Tuple[ConsumerRecord, ...]],\n        KafkaMessage,\n    ],\n    decoder: Optional[CustomDecoder[KafkaMessage]],\n    filter: Union[\n        Filter[KafkaMessage],\n        Filter[StreamMessage[Tuple[ConsumerRecord, ...]]],\n    ],\n    middlewares: Optional[\n        Sequence[Callable[[ConsumerRecord], BaseMiddleware]]\n    ]\n) -&gt; None\n</code></pre> <p>Adds a call to the handler.</p> PARAMETER  DESCRIPTION <code>handler</code> <p>The handler function to be called.</p> <p> TYPE: <code>HandlerCallWrapper[ConsumerRecord, P_HandlerParams, T_HandlerReturn]</code> </p> <code>dependant</code> <p>The dependant model.</p> <p> TYPE: <code>CallModel[P_HandlerParams, T_HandlerReturn]</code> </p> <code>parser</code> <p>Optional custom parser for parsing the input.</p> <p> TYPE: <code>CustomParser[Union[ConsumerRecord, Tuple[ConsumerRecord, ...]], KafkaMessage]</code> </p> <code>decoder</code> <p>Optional custom decoder for decoding the input.</p> <p> TYPE: <code>Optional[CustomDecoder[KafkaMessage]]</code> </p> <code>filter</code> <p>The filter for filtering the input.</p> <p> TYPE: <code>Union[Filter[KafkaMessage], Filter[StreamMessage[Tuple[ConsumerRecord, ...]]]]</code> </p> <code>middlewares</code> <p>Optional sequence of middlewares to be applied.</p> <p> TYPE: <code>Optional[Sequence[Callable[[ConsumerRecord], BaseMiddleware]]]</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/kafka/handler.py</code> <pre><code>def add_call(\n    self,\n    *,\n    handler: HandlerCallWrapper[ConsumerRecord, P_HandlerParams, T_HandlerReturn],\n    dependant: CallModel[P_HandlerParams, T_HandlerReturn],\n    parser: CustomParser[\n        Union[ConsumerRecord, Tuple[ConsumerRecord, ...]], KafkaMessage\n    ],\n    decoder: Optional[CustomDecoder[KafkaMessage]],\n    filter: Union[\n        Filter[KafkaMessage],\n        Filter[StreamMessage[Tuple[ConsumerRecord, ...]]],\n    ],\n    middlewares: Optional[Sequence[Callable[[ConsumerRecord], BaseMiddleware]]],\n) -&gt; None:\n    \"\"\"Adds a call to the handler.\n\n    Args:\n        handler: The handler function to be called.\n        dependant: The dependant model.\n        parser: Optional custom parser for parsing the input.\n        decoder: Optional custom decoder for decoding the input.\n        filter: The filter for filtering the input.\n        middlewares: Optional sequence of middlewares to be applied.\n\n    Returns:\n        None\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    parser_ = resolve_custom_func(  # type: ignore[type-var]\n        parser,  # type: ignore[arg-type]\n        (\n            AioKafkaParser.parse_message_batch  # type: ignore[arg-type]\n            if self.batch\n            else AioKafkaParser.parse_message\n        ),\n    )\n    decoder_ = resolve_custom_func(\n        decoder,  # type: ignore[arg-type]\n        (\n            AioKafkaParser.decode_message_batch  # type: ignore[arg-type]\n            if self.batch\n            else AioKafkaParser.decode_message\n        ),\n    )\n    super().add_call(\n        handler=handler,\n        parser=parser_,\n        decoder=decoder_,\n        filter=filter,  # type: ignore[arg-type]\n        dependant=dependant,\n        middlewares=middlewares,\n    )\n</code></pre>"},{"location":"api/faststream/kafka/handler/LogicHandler/#faststream.kafka.handler.LogicHandler.close","title":"close  <code>async</code>","text":"<pre><code>close() -&gt; None\n</code></pre> Source code in <code>faststream/kafka/handler.py</code> <pre><code>async def close(self) -&gt; None:\n    if self.consumer is not None:\n        await self.consumer.stop()\n        self.consumer = None\n\n    if self.task is not None:\n        self.task.cancel()\n        self.task = None\n</code></pre>"},{"location":"api/faststream/kafka/handler/LogicHandler/#faststream.kafka.handler.LogicHandler.get_routing_hash","title":"get_routing_hash  <code>staticmethod</code>","text":"<pre><code>get_routing_hash(\n    topics: Sequence[str], group_id: Optional[str] = None\n) -&gt; str\n</code></pre> Source code in <code>faststream/kafka/handler.py</code> <pre><code>@staticmethod\ndef get_routing_hash(topics: Sequence[str], group_id: Optional[str] = None) -&gt; str:\n    return \"\".join((*topics, group_id or \"\"))\n</code></pre>"},{"location":"api/faststream/kafka/handler/LogicHandler/#faststream.kafka.handler.LogicHandler.start","title":"start  <code>async</code>","text":"<pre><code>start(**consumer_kwargs: Any) -&gt; None\n</code></pre> <p>Start the consumer.</p> PARAMETER  DESCRIPTION <code>**consumer_kwargs</code> <p>Additional keyword arguments to pass to the consumer.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/kafka/handler.py</code> <pre><code>async def start(self, **consumer_kwargs: Any) -&gt; None:\n    \"\"\"Start the consumer.\n\n    Args:\n        **consumer_kwargs: Additional keyword arguments to pass to the consumer.\n\n    Returns:\n        None\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    self.consumer = consumer = self.builder(\n        *self.topics,\n        group_id=self.group_id,\n        client_id=self.client_id,\n        **consumer_kwargs,\n    )\n    await consumer.start()\n    self.task = asyncio.create_task(self._consume())\n</code></pre>"},{"location":"api/faststream/kafka/message/KafkaMessage/","title":"KafkaMessage","text":""},{"location":"api/faststream/kafka/message/KafkaMessage/#faststream.kafka.message.KafkaMessage","title":"faststream.kafka.message.KafkaMessage","text":"<p>             Bases: <code>StreamMessage[ConsumerRecord]</code></p> <p>Represents a Kafka message in the FastStream framework.</p> <p>This class extends <code>StreamMessage</code> and is specialized for handling Kafka ConsumerRecord objects.</p> METHOD DESCRIPTION <code>ack</code> <p>Acknowledge the Kafka message.</p> <code>nack</code> <p>Negative acknowledgment of the Kafka message.</p> <code>reject</code> <p>Reject the Kafka message.</p> Source code in <code>faststream/kafka/message.py</code> <pre><code>class KafkaMessage(StreamMessage[aiokafka.ConsumerRecord]):\n    \"\"\"\n    Represents a Kafka message in the FastStream framework.\n\n    This class extends `StreamMessage` and is specialized for handling Kafka ConsumerRecord objects.\n\n    Methods:\n        ack(**kwargs) -&gt; None:\n            Acknowledge the Kafka message.\n\n        nack(**kwargs) -&gt; None:\n            Negative acknowledgment of the Kafka message.\n\n        reject(**kwargs) -&gt; None:\n            Reject the Kafka message.\n    \"\"\"\n\n    async def ack(self, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Acknowledge the Kafka message.\n\n        Args:\n            **kwargs (Any): Additional keyword arguments.\n\n        Returns:\n            None: This method does not return a value.\n        \"\"\"\n        return None\n\n    async def nack(self, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Negative acknowledgment of the Kafka message.\n\n        Args:\n            **kwargs (Any): Additional keyword arguments.\n\n        Returns:\n            None: This method does not return a value.\n        \"\"\"\n        return None\n\n    async def reject(self, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Reject the Kafka message.\n\n        Args:\n            **kwargs (Any): Additional keyword arguments.\n\n        Returns:\n            None: This method does not return a value.\n        \"\"\"\n        return None\n</code></pre>"},{"location":"api/faststream/kafka/message/KafkaMessage/#faststream.kafka.message.KafkaMessage.ack","title":"ack  <code>async</code>","text":"<pre><code>ack(**kwargs: Any) -&gt; None\n</code></pre> <p>Acknowledge the Kafka message.</p> PARAMETER  DESCRIPTION <code>**kwargs</code> <p>Additional keyword arguments.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>None</code> <p>This method does not return a value.</p> <p> TYPE: <code>None</code> </p> Source code in <code>faststream/kafka/message.py</code> <pre><code>async def ack(self, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Acknowledge the Kafka message.\n\n    Args:\n        **kwargs (Any): Additional keyword arguments.\n\n    Returns:\n        None: This method does not return a value.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"api/faststream/kafka/message/KafkaMessage/#faststream.kafka.message.KafkaMessage.nack","title":"nack  <code>async</code>","text":"<pre><code>nack(**kwargs: Any) -&gt; None\n</code></pre> <p>Negative acknowledgment of the Kafka message.</p> PARAMETER  DESCRIPTION <code>**kwargs</code> <p>Additional keyword arguments.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>None</code> <p>This method does not return a value.</p> <p> TYPE: <code>None</code> </p> Source code in <code>faststream/kafka/message.py</code> <pre><code>async def nack(self, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Negative acknowledgment of the Kafka message.\n\n    Args:\n        **kwargs (Any): Additional keyword arguments.\n\n    Returns:\n        None: This method does not return a value.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"api/faststream/kafka/message/KafkaMessage/#faststream.kafka.message.KafkaMessage.reject","title":"reject  <code>async</code>","text":"<pre><code>reject(**kwargs: Any) -&gt; None\n</code></pre> <p>Reject the Kafka message.</p> PARAMETER  DESCRIPTION <code>**kwargs</code> <p>Additional keyword arguments.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>None</code> <p>This method does not return a value.</p> <p> TYPE: <code>None</code> </p> Source code in <code>faststream/kafka/message.py</code> <pre><code>async def reject(self, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Reject the Kafka message.\n\n    Args:\n        **kwargs (Any): Additional keyword arguments.\n\n    Returns:\n        None: This method does not return a value.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"api/faststream/kafka/parser/AioKafkaParser/","title":"AioKafkaParser","text":""},{"location":"api/faststream/kafka/parser/AioKafkaParser/#faststream.kafka.parser.AioKafkaParser","title":"faststream.kafka.parser.AioKafkaParser","text":"Source code in <code>faststream/kafka/parser.py</code> <pre><code>class AioKafkaParser:\n    @staticmethod\n    async def parse_message(\n        message: ConsumerRecord,\n    ) -&gt; StreamMessage[ConsumerRecord]:\n        \"\"\"Parses a Kafka message.\n\n        Args:\n            message: The Kafka message to parse.\n\n        Returns:\n            A StreamMessage object representing the parsed message.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        headers = {i: j.decode() for i, j in message.headers}\n        return KafkaMessage(\n            body=message.value,\n            headers=headers,\n            reply_to=headers.get(\"reply_to\", \"\"),\n            content_type=headers.get(\"content-type\"),\n            message_id=f\"{message.offset}-{message.timestamp}\",\n            correlation_id=headers.get(\"correlation_id\", str(uuid4())),\n            raw_message=message,\n        )\n\n    @staticmethod\n    async def parse_message_batch(\n        message: Tuple[ConsumerRecord, ...],\n    ) -&gt; KafkaMessage:\n        \"\"\"Parses a batch of messages from a Kafka consumer.\n\n        Args:\n            message : A tuple of ConsumerRecord objects representing the messages to parse.\n\n        Returns:\n            A StreamMessage object containing the parsed messages.\n\n        Raises:\n            NotImplementedError: If any of the messages are silent (i.e., have no sound).\n\n        Static Method:\n            This method is a static method. It does not require an instance of the class to be called.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        first = message[0]\n        last = message[-1]\n        headers = {i: j.decode() for i, j in first.headers}\n        return KafkaMessage(\n            body=[m.value for m in message],\n            headers=headers,\n            reply_to=headers.get(\"reply_to\", \"\"),\n            content_type=headers.get(\"content-type\"),\n            message_id=f\"{first.offset}-{last.offset}-{first.timestamp}\",\n            correlation_id=headers.get(\"correlation_id\", str(uuid4())),\n            raw_message=message,\n        )\n\n    @staticmethod\n    async def decode_message(msg: StreamMessage[ConsumerRecord]) -&gt; DecodedMessage:\n        \"\"\"Decodes a message.\n\n        Args:\n            msg: The message to be decoded.\n\n        Returns:\n            The decoded message.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        return decode_message(msg)\n\n    @classmethod\n    async def decode_message_batch(\n        cls, msg: StreamMessage[Tuple[ConsumerRecord, ...]]\n    ) -&gt; List[DecodedMessage]:\n        \"\"\"Decode a batch of messages.\n\n        Args:\n            msg: A stream message containing a tuple of consumer records.\n\n        Returns:\n            A list of decoded messages.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        return [decode_message(await cls.parse_message(m)) for m in msg.raw_message]\n</code></pre>"},{"location":"api/faststream/kafka/parser/AioKafkaParser/#faststream.kafka.parser.AioKafkaParser.decode_message","title":"decode_message  <code>async</code> <code>staticmethod</code>","text":"<pre><code>decode_message(\n    msg: StreamMessage[ConsumerRecord],\n) -&gt; DecodedMessage\n</code></pre> <p>Decodes a message.</p> PARAMETER  DESCRIPTION <code>msg</code> <p>The message to be decoded.</p> <p> TYPE: <code>StreamMessage[ConsumerRecord]</code> </p> RETURNS DESCRIPTION <code>DecodedMessage</code> <p>The decoded message.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/kafka/parser.py</code> <pre><code>@staticmethod\nasync def decode_message(msg: StreamMessage[ConsumerRecord]) -&gt; DecodedMessage:\n    \"\"\"Decodes a message.\n\n    Args:\n        msg: The message to be decoded.\n\n    Returns:\n        The decoded message.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    return decode_message(msg)\n</code></pre>"},{"location":"api/faststream/kafka/parser/AioKafkaParser/#faststream.kafka.parser.AioKafkaParser.decode_message_batch","title":"decode_message_batch  <code>async</code> <code>classmethod</code>","text":"<pre><code>decode_message_batch(\n    msg: StreamMessage[Tuple[ConsumerRecord, ...]]\n) -&gt; List[DecodedMessage]\n</code></pre> <p>Decode a batch of messages.</p> PARAMETER  DESCRIPTION <code>msg</code> <p>A stream message containing a tuple of consumer records.</p> <p> TYPE: <code>StreamMessage[Tuple[ConsumerRecord, ...]]</code> </p> RETURNS DESCRIPTION <code>List[DecodedMessage]</code> <p>A list of decoded messages.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/kafka/parser.py</code> <pre><code>@classmethod\nasync def decode_message_batch(\n    cls, msg: StreamMessage[Tuple[ConsumerRecord, ...]]\n) -&gt; List[DecodedMessage]:\n    \"\"\"Decode a batch of messages.\n\n    Args:\n        msg: A stream message containing a tuple of consumer records.\n\n    Returns:\n        A list of decoded messages.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    return [decode_message(await cls.parse_message(m)) for m in msg.raw_message]\n</code></pre>"},{"location":"api/faststream/kafka/parser/AioKafkaParser/#faststream.kafka.parser.AioKafkaParser.parse_message","title":"parse_message  <code>async</code> <code>staticmethod</code>","text":"<pre><code>parse_message(\n    message: ConsumerRecord,\n) -&gt; StreamMessage[ConsumerRecord]\n</code></pre> <p>Parses a Kafka message.</p> PARAMETER  DESCRIPTION <code>message</code> <p>The Kafka message to parse.</p> <p> TYPE: <code>ConsumerRecord</code> </p> RETURNS DESCRIPTION <code>StreamMessage[ConsumerRecord]</code> <p>A StreamMessage object representing the parsed message.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/kafka/parser.py</code> <pre><code>@staticmethod\nasync def parse_message(\n    message: ConsumerRecord,\n) -&gt; StreamMessage[ConsumerRecord]:\n    \"\"\"Parses a Kafka message.\n\n    Args:\n        message: The Kafka message to parse.\n\n    Returns:\n        A StreamMessage object representing the parsed message.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    headers = {i: j.decode() for i, j in message.headers}\n    return KafkaMessage(\n        body=message.value,\n        headers=headers,\n        reply_to=headers.get(\"reply_to\", \"\"),\n        content_type=headers.get(\"content-type\"),\n        message_id=f\"{message.offset}-{message.timestamp}\",\n        correlation_id=headers.get(\"correlation_id\", str(uuid4())),\n        raw_message=message,\n    )\n</code></pre>"},{"location":"api/faststream/kafka/parser/AioKafkaParser/#faststream.kafka.parser.AioKafkaParser.parse_message_batch","title":"parse_message_batch  <code>async</code> <code>staticmethod</code>","text":"<pre><code>parse_message_batch(\n    message: Tuple[ConsumerRecord, ...]\n) -&gt; KafkaMessage\n</code></pre> <p>Parses a batch of messages from a Kafka consumer.</p> PARAMETER  DESCRIPTION <code>message</code> <p>A tuple of ConsumerRecord objects representing the messages to parse.</p> <p> </p> RETURNS DESCRIPTION <code>KafkaMessage</code> <p>A StreamMessage object containing the parsed messages.</p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>If any of the messages are silent (i.e., have no sound).</p> Static Method <p>This method is a static method. It does not require an instance of the class to be called.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/kafka/parser.py</code> <pre><code>@staticmethod\nasync def parse_message_batch(\n    message: Tuple[ConsumerRecord, ...],\n) -&gt; KafkaMessage:\n    \"\"\"Parses a batch of messages from a Kafka consumer.\n\n    Args:\n        message : A tuple of ConsumerRecord objects representing the messages to parse.\n\n    Returns:\n        A StreamMessage object containing the parsed messages.\n\n    Raises:\n        NotImplementedError: If any of the messages are silent (i.e., have no sound).\n\n    Static Method:\n        This method is a static method. It does not require an instance of the class to be called.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    first = message[0]\n    last = message[-1]\n    headers = {i: j.decode() for i, j in first.headers}\n    return KafkaMessage(\n        body=[m.value for m in message],\n        headers=headers,\n        reply_to=headers.get(\"reply_to\", \"\"),\n        content_type=headers.get(\"content-type\"),\n        message_id=f\"{first.offset}-{last.offset}-{first.timestamp}\",\n        correlation_id=headers.get(\"correlation_id\", str(uuid4())),\n        raw_message=message,\n    )\n</code></pre>"},{"location":"api/faststream/kafka/producer/AioKafkaFastProducer/","title":"AioKafkaFastProducer","text":""},{"location":"api/faststream/kafka/producer/AioKafkaFastProducer/#faststream.kafka.producer.AioKafkaFastProducer","title":"faststream.kafka.producer.AioKafkaFastProducer","text":"<p>A class to represent a fast Kafka producer.</p> METHOD DESCRIPTION <code>publish </code> <p>Publishes a message to a Kafka topic.</p> <code>stop </code> <p>Stops the Kafka producer.</p> <code>publish_batch </code> <p>Publishes a batch of messages to a Kafka topic.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/kafka/producer.py</code> <pre><code>class AioKafkaFastProducer:\n    \"\"\"A class to represent a fast Kafka producer.\n\n    Attributes:\n        _producer : AIOKafkaProducer object representing the Kafka producer\n\n    Methods:\n        publish : Publishes a message to a Kafka topic.\n        stop : Stops the Kafka producer.\n        publish_batch : Publishes a batch of messages to a Kafka topic.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    _producer: Optional[AIOKafkaProducer]\n\n    def __init__(\n        self,\n        producer: AIOKafkaProducer,\n    ):\n        \"\"\"Initialize the class.\n\n        Args:\n            producer: An instance of AIOKafkaProducer.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        self._producer = producer\n\n    async def publish(\n        self,\n        message: SendableMessage,\n        topic: str,\n        key: Optional[bytes] = None,\n        partition: Optional[int] = None,\n        timestamp_ms: Optional[int] = None,\n        headers: Optional[Dict[str, str]] = None,\n        correlation_id: Optional[str] = None,\n        *,\n        reply_to: str = \"\",\n    ) -&gt; None:\n        \"\"\"Publish a message to a topic.\n\n        Args:\n            message: The message to be published.\n            topic: The topic to publish the message to.\n            key: The key associated with the message.\n            partition: The partition to which the message should be sent.\n            timestamp_ms: The timestamp of the message in milliseconds.\n            headers: Additional headers to be included with the message.\n            correlation_id: The correlation ID of the message.\n            reply_to: The topic to which the reply should be sent.\n\n        Returns:\n            None\n\n        Raises:\n            AssertionError: If the broker is not connected.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        assert self._producer, \"You need to connect broker at first\"  # nosec B101\n\n        message, content_type = encode_message(message)\n\n        headers_to_send = {\n            \"content-type\": content_type or \"\",\n            \"correlation_id\": correlation_id or str(uuid4()),\n            **(headers or {}),\n        }\n\n        if reply_to:\n            headers_to_send.update({\"reply_to\": reply_to})\n\n        await self._producer.send(\n            topic=topic,\n            value=message,\n            key=key,\n            partition=partition,\n            timestamp_ms=timestamp_ms,\n            headers=[(i, (j or \"\").encode()) for i, j in headers_to_send.items()],\n        )\n\n        return None\n\n    async def stop(self) -&gt; None:\n        if self._producer is not None:  # pragma: no branch\n            await self._producer.stop()\n\n    async def publish_batch(\n        self,\n        *msgs: SendableMessage,\n        topic: str,\n        partition: Optional[int] = None,\n        timestamp_ms: Optional[int] = None,\n        headers: Optional[Dict[str, str]] = None,\n    ) -&gt; None:\n        \"\"\"Publish a batch of messages to a topic.\n\n        Args:\n            *msgs: Variable length argument list of messages to be sent.\n            topic: The topic to which the messages should be published.\n            partition: The partition to which the messages should be sent. Defaults to None.\n            timestamp_ms: The timestamp to be associated with the messages. Defaults to None.\n            headers: Additional headers to be included with the messages. Defaults to None.\n\n        Returns:\n            None\n\n        Raises:\n            AssertionError: If the broker is not connected.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        assert self._producer, \"You need to connect broker at first\"  # nosec B101\n\n        batch = self._producer.create_batch()\n\n        for msg in msgs:\n            message, content_type = encode_message(msg)\n\n            headers_to_send = {\n                \"content-type\": content_type or \"\",\n                **(headers or {}),\n            }\n\n            batch.append(\n                key=None,\n                value=message,\n                timestamp=timestamp_ms,\n                headers=[(i, j.encode()) for i, j in headers_to_send.items()],\n            )\n\n        await self._producer.send_batch(batch, topic, partition=partition)\n</code></pre>"},{"location":"api/faststream/kafka/producer/AioKafkaFastProducer/#faststream.kafka.producer.AioKafkaFastProducer.publish","title":"publish  <code>async</code>","text":"<pre><code>publish(\n    message: SendableMessage,\n    topic: str,\n    key: Optional[bytes] = None,\n    partition: Optional[int] = None,\n    timestamp_ms: Optional[int] = None,\n    headers: Optional[Dict[str, str]] = None,\n    correlation_id: Optional[str] = None,\n    *,\n    reply_to: str = \"\"\n) -&gt; None\n</code></pre> <p>Publish a message to a topic.</p> PARAMETER  DESCRIPTION <code>message</code> <p>The message to be published.</p> <p> TYPE: <code>SendableMessage</code> </p> <code>topic</code> <p>The topic to publish the message to.</p> <p> TYPE: <code>str</code> </p> <code>key</code> <p>The key associated with the message.</p> <p> TYPE: <code>Optional[bytes]</code> DEFAULT: <code>None</code> </p> <code>partition</code> <p>The partition to which the message should be sent.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>timestamp_ms</code> <p>The timestamp of the message in milliseconds.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>headers</code> <p>Additional headers to be included with the message.</p> <p> TYPE: <code>Optional[Dict[str, str]]</code> DEFAULT: <code>None</code> </p> <code>correlation_id</code> <p>The correlation ID of the message.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>reply_to</code> <p>The topic to which the reply should be sent.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> RAISES DESCRIPTION <code>AssertionError</code> <p>If the broker is not connected.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/kafka/producer.py</code> <pre><code>async def publish(\n    self,\n    message: SendableMessage,\n    topic: str,\n    key: Optional[bytes] = None,\n    partition: Optional[int] = None,\n    timestamp_ms: Optional[int] = None,\n    headers: Optional[Dict[str, str]] = None,\n    correlation_id: Optional[str] = None,\n    *,\n    reply_to: str = \"\",\n) -&gt; None:\n    \"\"\"Publish a message to a topic.\n\n    Args:\n        message: The message to be published.\n        topic: The topic to publish the message to.\n        key: The key associated with the message.\n        partition: The partition to which the message should be sent.\n        timestamp_ms: The timestamp of the message in milliseconds.\n        headers: Additional headers to be included with the message.\n        correlation_id: The correlation ID of the message.\n        reply_to: The topic to which the reply should be sent.\n\n    Returns:\n        None\n\n    Raises:\n        AssertionError: If the broker is not connected.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    assert self._producer, \"You need to connect broker at first\"  # nosec B101\n\n    message, content_type = encode_message(message)\n\n    headers_to_send = {\n        \"content-type\": content_type or \"\",\n        \"correlation_id\": correlation_id or str(uuid4()),\n        **(headers or {}),\n    }\n\n    if reply_to:\n        headers_to_send.update({\"reply_to\": reply_to})\n\n    await self._producer.send(\n        topic=topic,\n        value=message,\n        key=key,\n        partition=partition,\n        timestamp_ms=timestamp_ms,\n        headers=[(i, (j or \"\").encode()) for i, j in headers_to_send.items()],\n    )\n\n    return None\n</code></pre>"},{"location":"api/faststream/kafka/producer/AioKafkaFastProducer/#faststream.kafka.producer.AioKafkaFastProducer.publish_batch","title":"publish_batch  <code>async</code>","text":"<pre><code>publish_batch(\n    *msgs: SendableMessage,\n    topic: str,\n    partition: Optional[int] = None,\n    timestamp_ms: Optional[int] = None,\n    headers: Optional[Dict[str, str]] = None\n) -&gt; None\n</code></pre> <p>Publish a batch of messages to a topic.</p> PARAMETER  DESCRIPTION <code>*msgs</code> <p>Variable length argument list of messages to be sent.</p> <p> TYPE: <code>SendableMessage</code> DEFAULT: <code>()</code> </p> <code>topic</code> <p>The topic to which the messages should be published.</p> <p> TYPE: <code>str</code> </p> <code>partition</code> <p>The partition to which the messages should be sent. Defaults to None.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>timestamp_ms</code> <p>The timestamp to be associated with the messages. Defaults to None.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>headers</code> <p>Additional headers to be included with the messages. Defaults to None.</p> <p> TYPE: <code>Optional[Dict[str, str]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> RAISES DESCRIPTION <code>AssertionError</code> <p>If the broker is not connected.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/kafka/producer.py</code> <pre><code>async def publish_batch(\n    self,\n    *msgs: SendableMessage,\n    topic: str,\n    partition: Optional[int] = None,\n    timestamp_ms: Optional[int] = None,\n    headers: Optional[Dict[str, str]] = None,\n) -&gt; None:\n    \"\"\"Publish a batch of messages to a topic.\n\n    Args:\n        *msgs: Variable length argument list of messages to be sent.\n        topic: The topic to which the messages should be published.\n        partition: The partition to which the messages should be sent. Defaults to None.\n        timestamp_ms: The timestamp to be associated with the messages. Defaults to None.\n        headers: Additional headers to be included with the messages. Defaults to None.\n\n    Returns:\n        None\n\n    Raises:\n        AssertionError: If the broker is not connected.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    assert self._producer, \"You need to connect broker at first\"  # nosec B101\n\n    batch = self._producer.create_batch()\n\n    for msg in msgs:\n        message, content_type = encode_message(msg)\n\n        headers_to_send = {\n            \"content-type\": content_type or \"\",\n            **(headers or {}),\n        }\n\n        batch.append(\n            key=None,\n            value=message,\n            timestamp=timestamp_ms,\n            headers=[(i, j.encode()) for i, j in headers_to_send.items()],\n        )\n\n    await self._producer.send_batch(batch, topic, partition=partition)\n</code></pre>"},{"location":"api/faststream/kafka/producer/AioKafkaFastProducer/#faststream.kafka.producer.AioKafkaFastProducer.stop","title":"stop  <code>async</code>","text":"<pre><code>stop() -&gt; None\n</code></pre> Source code in <code>faststream/kafka/producer.py</code> <pre><code>async def stop(self) -&gt; None:\n    if self._producer is not None:  # pragma: no branch\n        await self._producer.stop()\n</code></pre>"},{"location":"api/faststream/kafka/publisher/LogicPublisher/","title":"LogicPublisher","text":""},{"location":"api/faststream/kafka/publisher/LogicPublisher/#faststream.kafka.publisher.LogicPublisher","title":"faststream.kafka.publisher.LogicPublisher  <code>dataclass</code>","text":"<p>             Bases: <code>ABCPublisher[ConsumerRecord]</code></p> <p>A class to publish messages to a Kafka topic.</p> METHOD DESCRIPTION <code>publish </code> <p>Publishes messages to the Kafka topic</p> RAISES DESCRIPTION <code>AssertionError</code> <p>If <code>_producer</code> is not set up or if multiple messages are sent without the <code>batch</code> flag</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/kafka/publisher.py</code> <pre><code>@dataclass\nclass LogicPublisher(ABCPublisher[ConsumerRecord]):\n    \"\"\"A class to publish messages to a Kafka topic.\n\n    Attributes:\n        _producer : An optional instance of AioKafkaFastProducer\n        batch : A boolean indicating whether to send messages in batch\n        client_id : A string representing the client ID\n\n    Methods:\n        publish : Publishes messages to the Kafka topic\n\n    Raises:\n        AssertionError: If `_producer` is not set up or if multiple messages are sent without the `batch` flag\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    _producer: Optional[AioKafkaFastProducer] = field(default=None, init=False)\n    batch: bool = field(default=False)\n    client_id: str = field(default=\"faststream-\" + __version__)\n\n    @override\n    async def publish(  # type: ignore[override]\n        self,\n        *messages: SendableMessage,\n        message: SendableMessage = \"\",\n        key: Optional[bytes] = None,\n        partition: Optional[int] = None,\n        timestamp_ms: Optional[int] = None,\n        headers: Optional[Dict[str, str]] = None,\n        correlation_id: Optional[str] = None,\n    ) -&gt; None:\n        \"\"\"Publish messages to a topic.\n\n        Args:\n            *messages: Variable length argument list of SendableMessage objects.\n            message: A SendableMessage object. Default is an empty string.\n            key: Optional bytes object representing the message key.\n            partition: Optional integer representing the partition to publish the message to.\n            timestamp_ms: Optional integer representing the timestamp of the message in milliseconds.\n            headers: Optional dictionary of header key-value pairs.\n            correlation_id: Optional string representing the correlation ID of the message.\n\n        Returns:\n            None\n\n        Raises:\n            AssertionError: If `_producer` is not set up.\n            AssertionError: If `batch` flag is not set and there are multiple messages.\n            ValueError: If `message` is not a sequence when `messages` is empty.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        assert self._producer, \"Please, setup `_producer` first\"  # nosec B101\n        assert (  # nosec B101\n            self.batch or len(messages) &lt; 2\n        ), \"You can't send multiple messages without `batch` flag\"\n\n        if not self.batch:\n            return await self._producer.publish(\n                message=next(iter(messages), message),\n                topic=self.topic,\n                key=key or self.key,\n                partition=partition or self.partition,\n                timestamp_ms=timestamp_ms or self.timestamp_ms,\n                correlation_id=correlation_id,\n                headers=headers or self.headers,\n                reply_to=self.reply_to or \"\",\n            )\n        else:\n            to_send: Sequence[SendableMessage]\n            if not messages:\n                if not isinstance(message, Sequence):\n                    raise ValueError(\n                        f\"Message: {messages} should be Sequence type to send in batch\"\n                    )\n                else:\n                    to_send = message\n            else:\n                to_send = messages\n\n            await self._producer.publish_batch(\n                *to_send,\n                topic=self.topic,\n                partition=partition or self.partition,\n                timestamp_ms=timestamp_ms or self.timestamp_ms,\n                headers=headers or self.headers,\n            )\n            return None\n</code></pre>"},{"location":"api/faststream/kafka/publisher/LogicPublisher/#faststream.kafka.publisher.LogicPublisher.batch","title":"batch  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>batch: bool = field(default=False)\n</code></pre>"},{"location":"api/faststream/kafka/publisher/LogicPublisher/#faststream.kafka.publisher.LogicPublisher.client_id","title":"client_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>client_id: str = field(default='faststream-' + __version__)\n</code></pre>"},{"location":"api/faststream/kafka/publisher/LogicPublisher/#faststream.kafka.publisher.LogicPublisher.publish","title":"publish  <code>async</code>","text":"<pre><code>publish(\n    *messages: SendableMessage,\n    message: SendableMessage = \"\",\n    key: Optional[bytes] = None,\n    partition: Optional[int] = None,\n    timestamp_ms: Optional[int] = None,\n    headers: Optional[Dict[str, str]] = None,\n    correlation_id: Optional[str] = None\n) -&gt; None\n</code></pre> <p>Publish messages to a topic.</p> PARAMETER  DESCRIPTION <code>*messages</code> <p>Variable length argument list of SendableMessage objects.</p> <p> TYPE: <code>SendableMessage</code> DEFAULT: <code>()</code> </p> <code>message</code> <p>A SendableMessage object. Default is an empty string.</p> <p> TYPE: <code>SendableMessage</code> DEFAULT: <code>''</code> </p> <code>key</code> <p>Optional bytes object representing the message key.</p> <p> TYPE: <code>Optional[bytes]</code> DEFAULT: <code>None</code> </p> <code>partition</code> <p>Optional integer representing the partition to publish the message to.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>timestamp_ms</code> <p>Optional integer representing the timestamp of the message in milliseconds.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>headers</code> <p>Optional dictionary of header key-value pairs.</p> <p> TYPE: <code>Optional[Dict[str, str]]</code> DEFAULT: <code>None</code> </p> <code>correlation_id</code> <p>Optional string representing the correlation ID of the message.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> RAISES DESCRIPTION <code>AssertionError</code> <p>If <code>_producer</code> is not set up.</p> <code>AssertionError</code> <p>If <code>batch</code> flag is not set and there are multiple messages.</p> <code>ValueError</code> <p>If <code>message</code> is not a sequence when <code>messages</code> is empty.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/kafka/publisher.py</code> <pre><code>@override\nasync def publish(  # type: ignore[override]\n    self,\n    *messages: SendableMessage,\n    message: SendableMessage = \"\",\n    key: Optional[bytes] = None,\n    partition: Optional[int] = None,\n    timestamp_ms: Optional[int] = None,\n    headers: Optional[Dict[str, str]] = None,\n    correlation_id: Optional[str] = None,\n) -&gt; None:\n    \"\"\"Publish messages to a topic.\n\n    Args:\n        *messages: Variable length argument list of SendableMessage objects.\n        message: A SendableMessage object. Default is an empty string.\n        key: Optional bytes object representing the message key.\n        partition: Optional integer representing the partition to publish the message to.\n        timestamp_ms: Optional integer representing the timestamp of the message in milliseconds.\n        headers: Optional dictionary of header key-value pairs.\n        correlation_id: Optional string representing the correlation ID of the message.\n\n    Returns:\n        None\n\n    Raises:\n        AssertionError: If `_producer` is not set up.\n        AssertionError: If `batch` flag is not set and there are multiple messages.\n        ValueError: If `message` is not a sequence when `messages` is empty.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    assert self._producer, \"Please, setup `_producer` first\"  # nosec B101\n    assert (  # nosec B101\n        self.batch or len(messages) &lt; 2\n    ), \"You can't send multiple messages without `batch` flag\"\n\n    if not self.batch:\n        return await self._producer.publish(\n            message=next(iter(messages), message),\n            topic=self.topic,\n            key=key or self.key,\n            partition=partition or self.partition,\n            timestamp_ms=timestamp_ms or self.timestamp_ms,\n            correlation_id=correlation_id,\n            headers=headers or self.headers,\n            reply_to=self.reply_to or \"\",\n        )\n    else:\n        to_send: Sequence[SendableMessage]\n        if not messages:\n            if not isinstance(message, Sequence):\n                raise ValueError(\n                    f\"Message: {messages} should be Sequence type to send in batch\"\n                )\n            else:\n                to_send = message\n        else:\n            to_send = messages\n\n        await self._producer.publish_batch(\n            *to_send,\n            topic=self.topic,\n            partition=partition or self.partition,\n            timestamp_ms=timestamp_ms or self.timestamp_ms,\n            headers=headers or self.headers,\n        )\n        return None\n</code></pre>"},{"location":"api/faststream/kafka/router/KafkaRouter/","title":"KafkaRouter","text":""},{"location":"api/faststream/kafka/router/KafkaRouter/#faststream.kafka.router.KafkaRouter","title":"faststream.kafka.router.KafkaRouter","text":"<p>             Bases: <code>KafkaRouter</code></p> <p>A class to represent a Kafka router.</p> METHOD DESCRIPTION <code>_get_publisher_key </code> <p>Get the key for a publisher</p> <code>_update_publisher_prefix </code> <p>Update the prefix of a publisher</p> <code>publisher </code> <p>Create a new publisher</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/kafka/router.py</code> <pre><code>class KafkaRouter(BaseRouter):\n    \"\"\"A class to represent a Kafka router.\n\n    Attributes:\n        _publishers : Dictionary of publishers\n\n    Methods:\n        _get_publisher_key : Get the key for a publisher\n        _update_publisher_prefix : Update the prefix of a publisher\n        publisher : Create a new publisher\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    _publishers: Dict[str, Publisher]  # type: ignore[assignment]\n\n    @override\n    @staticmethod\n    def _get_publisher_key(publisher: Publisher) -&gt; str:  # type: ignore[override]\n        \"\"\"Get the publisher key.\n\n        Args:\n            publisher: The publisher object.\n\n        Returns:\n            The publisher key.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        return publisher.topic\n\n    @override\n    @staticmethod\n    def _update_publisher_prefix(  # type: ignore[override]\n        prefix: str,\n        publisher: Publisher,\n    ) -&gt; Publisher:\n        \"\"\"Updates the prefix of a publisher.\n\n        Args:\n            prefix: The prefix to be added to the publisher's topic.\n            publisher: The publisher object to be updated.\n\n        Returns:\n            The updated publisher object.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        publisher.topic = prefix + publisher.topic\n        return publisher\n\n    @override\n    def publisher(  # type: ignore[override]\n        self,\n        topic: str,\n        key: Optional[bytes] = None,\n        partition: Optional[int] = None,\n        timestamp_ms: Optional[int] = None,\n        headers: Optional[Dict[str, str]] = None,\n        reply_to: str = \"\",\n        batch: bool = False,\n        # AsyncAPI information\n        title: Optional[str] = None,\n        description: Optional[str] = None,\n    ) -&gt; Publisher:\n        \"\"\"Publishes a message to a topic.\n\n        Args:\n            topic (str): The topic to publish the message to.\n            key (bytes, optional): The key associated with the message.\n            partition (int, optional): The partition to publish the message to.\n            timestamp_ms (int, optional): The timestamp of the message in milliseconds.\n            headers (Dict[str, str], optional): Additional headers for the message.\n            reply_to (str, optional): The topic to reply to.\n            batch (bool, optional): Whether to publish the message as part of a batch.\n            title (str, optional): The title of the message.\n            description (str, optional): The description of the message.\n\n        Returns:\n            Publisher: The publisher object used to publish the message.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        new_publisher = self._update_publisher_prefix(\n            self.prefix,\n            Publisher(\n                topic=topic,\n                key=key,\n                partition=partition,\n                timestamp_ms=timestamp_ms,\n                headers=headers,\n                reply_to=reply_to,\n                title=title,\n                batch=batch,\n                _description=description,\n            ),\n        )\n        publisher_key = self._get_publisher_key(new_publisher)\n        publisher = self._publishers[publisher_key] = self._publishers.get(\n            publisher_key, new_publisher\n        )\n        return publisher\n</code></pre>"},{"location":"api/faststream/kafka/router/KafkaRouter/#faststream.kafka.router.KafkaRouter.publisher","title":"publisher","text":"<pre><code>publisher(\n    topic: str,\n    key: Optional[bytes] = None,\n    partition: Optional[int] = None,\n    timestamp_ms: Optional[int] = None,\n    headers: Optional[Dict[str, str]] = None,\n    reply_to: str = \"\",\n    batch: bool = False,\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n) -&gt; Publisher\n</code></pre> <p>Publishes a message to a topic.</p> PARAMETER  DESCRIPTION <code>topic</code> <p>The topic to publish the message to.</p> <p> TYPE: <code>str</code> </p> <code>key</code> <p>The key associated with the message.</p> <p> TYPE: <code>bytes</code> DEFAULT: <code>None</code> </p> <code>partition</code> <p>The partition to publish the message to.</p> <p> TYPE: <code>int</code> DEFAULT: <code>None</code> </p> <code>timestamp_ms</code> <p>The timestamp of the message in milliseconds.</p> <p> TYPE: <code>int</code> DEFAULT: <code>None</code> </p> <code>headers</code> <p>Additional headers for the message.</p> <p> TYPE: <code>Dict[str, str]</code> DEFAULT: <code>None</code> </p> <code>reply_to</code> <p>The topic to reply to.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>batch</code> <p>Whether to publish the message as part of a batch.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>title</code> <p>The title of the message.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>description</code> <p>The description of the message.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Publisher</code> <p>The publisher object used to publish the message.</p> <p> TYPE: <code>Publisher</code> </p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/kafka/router.py</code> <pre><code>@override\ndef publisher(  # type: ignore[override]\n    self,\n    topic: str,\n    key: Optional[bytes] = None,\n    partition: Optional[int] = None,\n    timestamp_ms: Optional[int] = None,\n    headers: Optional[Dict[str, str]] = None,\n    reply_to: str = \"\",\n    batch: bool = False,\n    # AsyncAPI information\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n) -&gt; Publisher:\n    \"\"\"Publishes a message to a topic.\n\n    Args:\n        topic (str): The topic to publish the message to.\n        key (bytes, optional): The key associated with the message.\n        partition (int, optional): The partition to publish the message to.\n        timestamp_ms (int, optional): The timestamp of the message in milliseconds.\n        headers (Dict[str, str], optional): Additional headers for the message.\n        reply_to (str, optional): The topic to reply to.\n        batch (bool, optional): Whether to publish the message as part of a batch.\n        title (str, optional): The title of the message.\n        description (str, optional): The description of the message.\n\n    Returns:\n        Publisher: The publisher object used to publish the message.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    new_publisher = self._update_publisher_prefix(\n        self.prefix,\n        Publisher(\n            topic=topic,\n            key=key,\n            partition=partition,\n            timestamp_ms=timestamp_ms,\n            headers=headers,\n            reply_to=reply_to,\n            title=title,\n            batch=batch,\n            _description=description,\n        ),\n    )\n    publisher_key = self._get_publisher_key(new_publisher)\n    publisher = self._publishers[publisher_key] = self._publishers.get(\n        publisher_key, new_publisher\n    )\n    return publisher\n</code></pre>"},{"location":"api/faststream/kafka/router/KafkaRouter/#faststream.kafka.router.KafkaRouter.subscriber","title":"subscriber","text":"<pre><code>subscriber(\n    *topics: str,\n    group_id: Optional[str] = None,\n    key_deserializer: Optional[\n        Callable[[bytes], Any]\n    ] = None,\n    value_deserializer: Optional[\n        Callable[[bytes], Any]\n    ] = None,\n    fetch_max_wait_ms: int = 500,\n    fetch_max_bytes: int = 52428800,\n    fetch_min_bytes: int = 1,\n    max_partition_fetch_bytes: int = 1 * 1024 * 1024,\n    auto_offset_reset: Literal[\n        \"latest\", \"earliest\", \"none\"\n    ] = \"latest\",\n    enable_auto_commit: bool = True,\n    auto_commit_interval_ms: int = 5000,\n    check_crcs: bool = True,\n    partition_assignment_strategy: Sequence[\n        AbstractPartitionAssignor\n    ] = (RoundRobinPartitionAssignor),\n    max_poll_interval_ms: int = 300000,\n    rebalance_timeout_ms: Optional[int] = None,\n    session_timeout_ms: int = 10000,\n    heartbeat_interval_ms: int = 3000,\n    consumer_timeout_ms: int = 200,\n    max_poll_records: Optional[int] = None,\n    exclude_internal_topics: bool = True,\n    isolation_level: Literal[\n        \"read_uncommitted\", \"read_committed\"\n    ] = \"read_uncommitted\",\n    dependencies: Sequence[Depends] = (),\n    parser: Optional[\n        CustomParser[aiokafka.ConsumerRecord, KafkaMessage]\n    ] = None,\n    decoder: Optional[CustomDecoder[KafkaMessage]] = None,\n    middlewares: Optional[\n        Sequence[\n            Callable[\n                [aiokafka.ConsumerRecord], BaseMiddleware\n            ]\n        ]\n    ] = None,\n    filter: Filter[KafkaMessage] = default_filter,\n    batch: bool = False,\n    max_records: Optional[int] = None,\n    batch_timeout_ms: int = 200,\n    retry: Union[bool, int] = False,\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n    **__service_kwargs: Any\n) -&gt; Callable[\n    [Callable[P_HandlerParams, T_HandlerReturn]],\n    HandlerCallWrapper[\n        aiokafka.ConsumerRecord,\n        P_HandlerParams,\n        T_HandlerReturn,\n    ],\n]\n</code></pre> Source code in <code>faststream/kafka/router.py</code> <pre><code>    self,\n    topic: str,\n    key: Optional[bytes] = None,\n    partition: Optional[int] = None,\n    timestamp_ms: Optional[int] = None,\n    headers: Optional[Dict[str, str]] = None,\n    reply_to: str = \"\",\n    batch: bool = False,\n    # AsyncAPI information\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n) -&gt; Publisher:\n    \"\"\"Publishes a message to a topic.\n\n    Args:\n        topic (str): The topic to publish the message to.\n        key (bytes, optional): The key associated with the message.\n        partition (int, optional): The partition to publish the message to.\n        timestamp_ms (int, optional): The timestamp of the message in milliseconds.\n        headers (Dict[str, str], optional): Additional headers for the message.\n        reply_to (str, optional): The topic to reply to.\n        batch (bool, optional): Whether to publish the message as part of a batch.\n        title (str, optional): The title of the message.\n        description (str, optional): The description of the message.\n\n    Returns:\n        Publisher: The publisher object used to publish the message.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    new_publisher = self._update_publisher_prefix(\n        self.prefix,\n        Publisher(\n            topic=topic,\n            key=key,\n            partition=partition,\n            timestamp_ms=timestamp_ms,\n            headers=headers,\n            reply_to=reply_to,\n            title=title,\n            batch=batch,\n            _description=description,\n        ),\n    )\n    publisher_key = self._get_publisher_key(new_publisher)\n    publisher = self._publishers[publisher_key] = self._publishers.get(\n        publisher_key, new_publisher\n    )\n    return publisher\n</code></pre>"},{"location":"api/faststream/kafka/security/parse_security/","title":"Parse security","text":""},{"location":"api/faststream/kafka/security/parse_security/#faststream.kafka.security.parse_security","title":"faststream.kafka.security.parse_security","text":"<pre><code>parse_security(\n    security: Optional[BaseSecurity],\n) -&gt; Dict[str, Any]\n</code></pre> Source code in <code>faststream/kafka/security.py</code> <pre><code>def parse_security(security: Optional[BaseSecurity]) -&gt; Dict[str, Any]:\n    if security is None:\n        return {}\n    elif type(security) == BaseSecurity:\n        return _parse_base_security(security)\n    elif type(security) == SASLPlaintext:\n        return _parse_sasl_plaintext(security)\n    elif type(security) == SASLScram256:\n        return _parse_sasl_scram256(security)\n    elif type(security) == SASLScram512:\n        return _parse_sasl_scram512(security)\n    else:\n        raise NotImplementedError(f\"KafkaBroker does not support {type(security)}\")\n</code></pre>"},{"location":"api/faststream/kafka/shared/logging/KafkaLoggingMixin/","title":"KafkaLoggingMixin","text":""},{"location":"api/faststream/kafka/shared/logging/KafkaLoggingMixin/#faststream.kafka.shared.logging.KafkaLoggingMixin","title":"faststream.kafka.shared.logging.KafkaLoggingMixin","text":"<p>             Bases: <code>LoggingMixin</code></p> <p>A class that provides logging functionality for Kafka.</p> METHOD DESCRIPTION <code>__init__ </code> <p>initializes the KafkaLoggingMixin object</p> <code>_get_log_context </code> <p>returns the log context for a given message and topics</p> <code>fmt </code> <p>returns the log format string</p> <code>_setup_log_context </code> <p>sets up the log context for a given list of topics</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/kafka/shared/logging.py</code> <pre><code>class KafkaLoggingMixin(LoggingMixin):\n    \"\"\"A class that provides logging functionality for Kafka.\n\n    Attributes:\n        _max_topic_len : maximum length of the topic name\n\n    Methods:\n        __init__ : initializes the KafkaLoggingMixin object\n        _get_log_context : returns the log context for a given message and topics\n        fmt : returns the log format string\n        _setup_log_context : sets up the log context for a given list of topics\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    _max_topic_len: int\n\n    def __init__(\n        self,\n        *args: Any,\n        logger: Optional[logging.Logger] = access_logger,\n        log_level: int = logging.INFO,\n        log_fmt: Optional[str] = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"Initialize the class.\n\n        Args:\n            *args: Variable length argument list\n            logger: Optional logger object\n            log_level: Log level (default: logging.INFO)\n            log_fmt: Optional log format string\n            **kwargs: Arbitrary keyword arguments\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        super().__init__(\n            *args,\n            logger=logger,\n            log_level=log_level,\n            log_fmt=log_fmt,\n            **kwargs,\n        )\n        self._max_topic_len = 4\n        self._max_group_len = 0\n\n    @override\n    def _get_log_context(  # type: ignore[override]\n        self,\n        message: Optional[StreamMessage[ConsumerRecord]],\n        topics: Sequence[str] = (),\n        group_id: Optional[str] = None,\n    ) -&gt; AnyDict:\n        \"\"\"Get the log context.\n\n        Args:\n            message: Optional stream message of type ConsumerRecord\n            topics: Sequence of topics\n\n        Returns:\n            A dictionary containing the log context\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        if topics:\n            topic = \", \".join(topics)\n        elif message is not None:\n            topic = message.raw_message.topic\n        else:\n            topic = \"\"\n\n        context = {\n            \"topic\": topic,\n            \"group_id\": group_id or \"\",\n            **super()._get_log_context(message),\n        }\n        return context\n\n    @property\n    def fmt(self) -&gt; str:\n        return super().fmt or (\n            \"%(asctime)s %(levelname)s - \"\n            + f\"%(topic)-{self._max_topic_len}s | \"\n            + (f\"%(group_id)-{self._max_group_len}s | \" if self._max_group_len else \"\")\n            + \"%(message_id)-10s \"\n            + \"- %(message)s\"\n        )\n\n    def _setup_log_context(\n        self, topics: Iterable[str], group_id: Optional[str] = None\n    ) -&gt; None:\n        \"\"\"Set up log context.\n\n        Args:\n            topics: An iterable of topics.\n\n        Returns:\n            None.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        for t in topics:\n            self._max_topic_len = max((self._max_topic_len, len(t)))\n\n        if group_id:\n            self._max_group_len = max((self._max_group_len, len(group_id)))\n</code></pre>"},{"location":"api/faststream/kafka/shared/logging/KafkaLoggingMixin/#faststream.kafka.shared.logging.KafkaLoggingMixin.fmt","title":"fmt  <code>property</code>","text":"<pre><code>fmt: str\n</code></pre>"},{"location":"api/faststream/kafka/shared/publisher/ABCPublisher/","title":"ABCPublisher","text":""},{"location":"api/faststream/kafka/shared/publisher/ABCPublisher/#faststream.kafka.shared.publisher.ABCPublisher","title":"faststream.kafka.shared.publisher.ABCPublisher  <code>dataclass</code>","text":"<p>             Bases: <code>ABC</code>, <code>BasePublisher[MsgType]</code></p> <p>A class representing an ABCPublisher.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/kafka/shared/publisher.py</code> <pre><code>@dataclass\nclass ABCPublisher(ABC, BasePublisher[MsgType]):\n    \"\"\"A class representing an ABCPublisher.\n\n    Attributes:\n        topic : str\n            The topic of the publisher.\n        key : Optional[bytes]\n            The key of the publisher.\n        partition : Optional[int]\n            The partition of the publisher.\n        timestamp_ms : Optional[int]\n            The timestamp in milliseconds of the publisher.\n        headers : Optional[Dict[str, str]]\n            The headers of the publisher.\n        reply_to : Optional[str]\n            The reply-to address of the publisher.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    topic: str = \"\"\n    key: Optional[bytes] = None\n    partition: Optional[int] = None\n    timestamp_ms: Optional[int] = None\n    headers: Optional[Dict[str, str]] = None\n    reply_to: Optional[str] = \"\"\n</code></pre>"},{"location":"api/faststream/kafka/shared/publisher/ABCPublisher/#faststream.kafka.shared.publisher.ABCPublisher.headers","title":"headers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>headers: Optional[Dict[str, str]] = None\n</code></pre>"},{"location":"api/faststream/kafka/shared/publisher/ABCPublisher/#faststream.kafka.shared.publisher.ABCPublisher.key","title":"key  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>key: Optional[bytes] = None\n</code></pre>"},{"location":"api/faststream/kafka/shared/publisher/ABCPublisher/#faststream.kafka.shared.publisher.ABCPublisher.partition","title":"partition  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>partition: Optional[int] = None\n</code></pre>"},{"location":"api/faststream/kafka/shared/publisher/ABCPublisher/#faststream.kafka.shared.publisher.ABCPublisher.reply_to","title":"reply_to  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>reply_to: Optional[str] = ''\n</code></pre>"},{"location":"api/faststream/kafka/shared/publisher/ABCPublisher/#faststream.kafka.shared.publisher.ABCPublisher.timestamp_ms","title":"timestamp_ms  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>timestamp_ms: Optional[int] = None\n</code></pre>"},{"location":"api/faststream/kafka/shared/publisher/ABCPublisher/#faststream.kafka.shared.publisher.ABCPublisher.topic","title":"topic  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>topic: str = ''\n</code></pre>"},{"location":"api/faststream/kafka/shared/router/KafkaRouter/","title":"KafkaRouter","text":""},{"location":"api/faststream/kafka/shared/router/KafkaRouter/#faststream.kafka.shared.router.KafkaRouter","title":"faststream.kafka.shared.router.KafkaRouter","text":"<p>             Bases: <code>BrokerRouter[str, ConsumerRecord]</code></p> <p>A class to represent a Kafka router.</p> METHOD DESCRIPTION <code>subscriber </code> <p>decorator for subscribing to topics and handling messages</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/kafka/shared/router.py</code> <pre><code>class KafkaRouter(BrokerRouter[str, ConsumerRecord]):\n    \"\"\"A class to represent a Kafka router.\n\n    Attributes:\n        prefix : prefix for the topics\n        handlers : sequence of Kafka routes\n        kwargs : additional keyword arguments\n\n    Methods:\n        subscriber : decorator for subscribing to topics and handling messages\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    def __init__(\n        self,\n        prefix: str = \"\",\n        handlers: Sequence[KafkaRoute[ConsumerRecord, SendableMessage]] = (),\n        **kwargs: Any,\n    ):\n        \"\"\"Initialize the class.\n\n        Args:\n            prefix (str): Prefix string.\n            handlers (Sequence[KafkaRoute[ConsumerRecord, SendableMessage]]): Sequence of KafkaRoute objects.\n            **kwargs (Any): Additional keyword arguments.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        for h in handlers:\n            h.args = tuple(prefix + x for x in h.args)\n        super().__init__(prefix, handlers, **kwargs)\n\n    def subscriber(\n        self,\n        *topics: str,\n        **broker_kwargs: Any,\n    ) -&gt; Callable[\n        [Callable[P_HandlerParams, T_HandlerReturn]],\n        HandlerCallWrapper[ConsumerRecord, P_HandlerParams, T_HandlerReturn],\n    ]:\n        \"\"\"A function to subscribe to topics.\n\n        Args:\n            *topics : variable number of topic names\n            **broker_kwargs : keyword arguments for the broker\n\n        Returns:\n            A callable function that wraps the handler function\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        return self._wrap_subscriber(\n            *(self.prefix + x for x in topics),\n            **broker_kwargs,\n        )\n</code></pre>"},{"location":"api/faststream/kafka/shared/router/KafkaRouter/#faststream.kafka.shared.router.KafkaRouter.subscriber","title":"subscriber","text":"<pre><code>subscriber(\n    *topics: str, **broker_kwargs: Any\n) -&gt; Callable[\n    [Callable[P_HandlerParams, T_HandlerReturn]],\n    HandlerCallWrapper[\n        ConsumerRecord, P_HandlerParams, T_HandlerReturn\n    ],\n]\n</code></pre> <p>A function to subscribe to topics.</p> PARAMETER  DESCRIPTION <code>*topics</code> <p>variable number of topic names</p> <p> DEFAULT: <code>()</code> </p> <code>**broker_kwargs</code> <p>keyword arguments for the broker</p> <p> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Callable[[Callable[P_HandlerParams, T_HandlerReturn]], HandlerCallWrapper[ConsumerRecord, P_HandlerParams, T_HandlerReturn]]</code> <p>A callable function that wraps the handler function</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/kafka/shared/router.py</code> <pre><code>def subscriber(\n    self,\n    *topics: str,\n    **broker_kwargs: Any,\n) -&gt; Callable[\n    [Callable[P_HandlerParams, T_HandlerReturn]],\n    HandlerCallWrapper[ConsumerRecord, P_HandlerParams, T_HandlerReturn],\n]:\n    \"\"\"A function to subscribe to topics.\n\n    Args:\n        *topics : variable number of topic names\n        **broker_kwargs : keyword arguments for the broker\n\n    Returns:\n        A callable function that wraps the handler function\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    return self._wrap_subscriber(\n        *(self.prefix + x for x in topics),\n        **broker_kwargs,\n    )\n</code></pre>"},{"location":"api/faststream/kafka/shared/schemas/ConsumerConnectionParams/","title":"ConsumerConnectionParams","text":""},{"location":"api/faststream/kafka/shared/schemas/ConsumerConnectionParams/#faststream.kafka.shared.schemas.ConsumerConnectionParams","title":"faststream.kafka.shared.schemas.ConsumerConnectionParams","text":"<p>             Bases: <code>TypedDict</code></p> <p>A class to represent the connection parameters for a consumer.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/kafka/shared/schemas.py</code> <pre><code>class ConsumerConnectionParams(TypedDict, total=False):\n    \"\"\"A class to represent the connection parameters for a consumer.\n\n    Attributes:\n        bootstrap_servers : Required. The bootstrap servers to connect to.\n        loop : Optional. The event loop to use for asynchronous operations.\n        client_id : The client ID to use for the connection.\n        request_timeout_ms : The timeout for network requests in milliseconds.\n        retry_backoff_ms : The backoff time in milliseconds for retrying failed requests.\n        metadata_max_age_ms : The maximum age of metadata in milliseconds.\n        security_protocol : The security protocol to use for the connection. Must be one of \"SSL\" or \"PLAINTEXT\".\n        api_version : The API version to use for the connection.\n        connections_max_idle_ms : The maximum idle time in milliseconds before closing a connection.\n        sasl_mechanism : The SASL mechanism to use for authentication. Must be one of \"PLAIN\", \"GSSAPI\", \"SCRAM-SHA-256\", \"SCRAM-SHA-512\", or \"OAUTHBEARER\".\n        sasl_plain_password : The password to use for PLAIN SASL mechanism.\n        sasl_plain_username : The username to use for PLAIN SASL mechanism.\n        sasl_kerberos_service_name : The service\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    bootstrap_servers: Required[Union[str, List[str]]]\n    loop: Optional[AbstractEventLoop]\n    client_id: str\n    request_timeout_ms: int\n    retry_backoff_ms: int\n    metadata_max_age_ms: int\n    security_protocol: Literal[\n        \"SSL\",\n        \"PLAINTEXT\",\n    ]\n    api_version: str\n    connections_max_idle_ms: int\n    sasl_mechanism: Literal[\n        \"PLAIN\",\n        \"GSSAPI\",\n        \"SCRAM-SHA-256\",\n        \"SCRAM-SHA-512\",\n        \"OAUTHBEARER\",\n    ]\n    sasl_plain_password: str\n    sasl_plain_username: str\n    sasl_kerberos_service_name: str\n    sasl_kerberos_domain_name: str\n    ssl_context: ssl.SSLContext\n    sasl_oauth_token_provider: AbstractTokenProvider\n</code></pre>"},{"location":"api/faststream/kafka/shared/schemas/ConsumerConnectionParams/#faststream.kafka.shared.schemas.ConsumerConnectionParams.api_version","title":"api_version  <code>instance-attribute</code>","text":"<pre><code>api_version: str\n</code></pre>"},{"location":"api/faststream/kafka/shared/schemas/ConsumerConnectionParams/#faststream.kafka.shared.schemas.ConsumerConnectionParams.bootstrap_servers","title":"bootstrap_servers  <code>instance-attribute</code>","text":"<pre><code>bootstrap_servers: Required[Union[str, List[str]]]\n</code></pre>"},{"location":"api/faststream/kafka/shared/schemas/ConsumerConnectionParams/#faststream.kafka.shared.schemas.ConsumerConnectionParams.client_id","title":"client_id  <code>instance-attribute</code>","text":"<pre><code>client_id: str\n</code></pre>"},{"location":"api/faststream/kafka/shared/schemas/ConsumerConnectionParams/#faststream.kafka.shared.schemas.ConsumerConnectionParams.connections_max_idle_ms","title":"connections_max_idle_ms  <code>instance-attribute</code>","text":"<pre><code>connections_max_idle_ms: int\n</code></pre>"},{"location":"api/faststream/kafka/shared/schemas/ConsumerConnectionParams/#faststream.kafka.shared.schemas.ConsumerConnectionParams.loop","title":"loop  <code>instance-attribute</code>","text":"<pre><code>loop: Optional[AbstractEventLoop]\n</code></pre>"},{"location":"api/faststream/kafka/shared/schemas/ConsumerConnectionParams/#faststream.kafka.shared.schemas.ConsumerConnectionParams.metadata_max_age_ms","title":"metadata_max_age_ms  <code>instance-attribute</code>","text":"<pre><code>metadata_max_age_ms: int\n</code></pre>"},{"location":"api/faststream/kafka/shared/schemas/ConsumerConnectionParams/#faststream.kafka.shared.schemas.ConsumerConnectionParams.request_timeout_ms","title":"request_timeout_ms  <code>instance-attribute</code>","text":"<pre><code>request_timeout_ms: int\n</code></pre>"},{"location":"api/faststream/kafka/shared/schemas/ConsumerConnectionParams/#faststream.kafka.shared.schemas.ConsumerConnectionParams.retry_backoff_ms","title":"retry_backoff_ms  <code>instance-attribute</code>","text":"<pre><code>retry_backoff_ms: int\n</code></pre>"},{"location":"api/faststream/kafka/shared/schemas/ConsumerConnectionParams/#faststream.kafka.shared.schemas.ConsumerConnectionParams.sasl_kerberos_domain_name","title":"sasl_kerberos_domain_name  <code>instance-attribute</code>","text":"<pre><code>sasl_kerberos_domain_name: str\n</code></pre>"},{"location":"api/faststream/kafka/shared/schemas/ConsumerConnectionParams/#faststream.kafka.shared.schemas.ConsumerConnectionParams.sasl_kerberos_service_name","title":"sasl_kerberos_service_name  <code>instance-attribute</code>","text":"<pre><code>sasl_kerberos_service_name: str\n</code></pre>"},{"location":"api/faststream/kafka/shared/schemas/ConsumerConnectionParams/#faststream.kafka.shared.schemas.ConsumerConnectionParams.sasl_mechanism","title":"sasl_mechanism  <code>instance-attribute</code>","text":"<pre><code>sasl_mechanism: Literal[\n    \"PLAIN\",\n    \"GSSAPI\",\n    \"SCRAM-SHA-256\",\n    \"SCRAM-SHA-512\",\n    \"OAUTHBEARER\",\n]\n</code></pre>"},{"location":"api/faststream/kafka/shared/schemas/ConsumerConnectionParams/#faststream.kafka.shared.schemas.ConsumerConnectionParams.sasl_oauth_token_provider","title":"sasl_oauth_token_provider  <code>instance-attribute</code>","text":"<pre><code>sasl_oauth_token_provider: AbstractTokenProvider\n</code></pre>"},{"location":"api/faststream/kafka/shared/schemas/ConsumerConnectionParams/#faststream.kafka.shared.schemas.ConsumerConnectionParams.sasl_plain_password","title":"sasl_plain_password  <code>instance-attribute</code>","text":"<pre><code>sasl_plain_password: str\n</code></pre>"},{"location":"api/faststream/kafka/shared/schemas/ConsumerConnectionParams/#faststream.kafka.shared.schemas.ConsumerConnectionParams.sasl_plain_username","title":"sasl_plain_username  <code>instance-attribute</code>","text":"<pre><code>sasl_plain_username: str\n</code></pre>"},{"location":"api/faststream/kafka/shared/schemas/ConsumerConnectionParams/#faststream.kafka.shared.schemas.ConsumerConnectionParams.security_protocol","title":"security_protocol  <code>instance-attribute</code>","text":"<pre><code>security_protocol: Literal['SSL', 'PLAINTEXT']\n</code></pre>"},{"location":"api/faststream/kafka/shared/schemas/ConsumerConnectionParams/#faststream.kafka.shared.schemas.ConsumerConnectionParams.ssl_context","title":"ssl_context  <code>instance-attribute</code>","text":"<pre><code>ssl_context: ssl.SSLContext\n</code></pre>"},{"location":"api/faststream/kafka/test/FakeProducer/","title":"FakeProducer","text":""},{"location":"api/faststream/kafka/test/FakeProducer/#faststream.kafka.test.FakeProducer","title":"faststream.kafka.test.FakeProducer","text":"<p>             Bases: <code>AioKafkaFastProducer</code></p> <p>A fake Kafka producer for testing purposes.</p> <p>This class extends AioKafkaFastProducer and is used to simulate Kafka message publishing during tests.</p> Source code in <code>faststream/kafka/test.py</code> <pre><code>class FakeProducer(AioKafkaFastProducer):\n    \"\"\"\n    A fake Kafka producer for testing purposes.\n\n    This class extends AioKafkaFastProducer and is used to simulate Kafka message publishing during tests.\n    \"\"\"\n\n    def __init__(self, broker: KafkaBroker):\n        \"\"\"\n        Initialize the FakeProducer.\n\n        Args:\n            broker (KafkaBroker): The KafkaBroker instance to associate with this FakeProducer.\n        \"\"\"\n        self.broker = broker\n\n    @override\n    async def publish(  # type: ignore[override]\n        self,\n        message: SendableMessage,\n        topic: str,\n        key: Optional[bytes] = None,\n        partition: Optional[int] = None,\n        timestamp_ms: Optional[int] = None,\n        headers: Optional[Dict[str, str]] = None,\n        correlation_id: Optional[str] = None,\n        *,\n        reply_to: str = \"\",\n        rpc: bool = False,\n        rpc_timeout: Optional[float] = None,\n        raise_timeout: bool = False,\n    ) -&gt; Optional[SendableMessage]:\n        \"\"\"\n        Publish a message to the Kafka broker.\n\n        Args:\n            message (SendableMessage): The message to be published.\n            topic (str): The Kafka topic to publish the message to.\n            key (Optional[bytes], optional): The message key. Defaults to None.\n            partition (Optional[int], optional): The Kafka partition to use. Defaults to None.\n            timestamp_ms (Optional[int], optional): The message timestamp in milliseconds. Defaults to None.\n            headers (Optional[Dict[str, str]], optional): Additional headers for the message. Defaults to None.\n            correlation_id (Optional[str], optional): The correlation ID for the message. Defaults to None.\n            reply_to (str, optional): The topic to which responses should be sent. Defaults to \"\".\n            rpc (bool, optional): If True, treat the message as an RPC request. Defaults to False.\n            rpc_timeout (Optional[float], optional): Timeout for RPC requests. Defaults to None.\n            raise_timeout (bool, optional): If True, raise an exception on timeout. Defaults to False.\n\n        Returns:\n            Optional[SendableMessage]: The response message, if this was an RPC request, otherwise None.\n        \"\"\"\n        incoming = build_message(\n            message=message,\n            topic=topic,\n            key=key,\n            partition=partition,\n            timestamp_ms=timestamp_ms,\n            headers=headers,\n            correlation_id=correlation_id,\n            reply_to=reply_to,\n        )\n\n        for handler in self.broker.handlers.values():  # pragma: no branch\n            if topic in handler.topics:\n                r = await call_handler(\n                    handler=handler,\n                    message=[incoming] if handler.batch else incoming,\n                    rpc=rpc,\n                    rpc_timeout=rpc_timeout,\n                    raise_timeout=raise_timeout,\n                )\n\n                if rpc:  # pragma: no branch\n                    return r\n\n        return None\n\n    async def publish_batch(\n        self,\n        *msgs: SendableMessage,\n        topic: str,\n        partition: Optional[int] = None,\n        timestamp_ms: Optional[int] = None,\n        headers: Optional[Dict[str, str]] = None,\n    ) -&gt; None:\n        \"\"\"\n        Publish a batch of messages to the Kafka broker.\n\n        Args:\n            *msgs (SendableMessage): Variable number of messages to be published.\n            topic (str): The Kafka topic to publish the messages to.\n            partition (Optional[int], optional): The Kafka partition to use. Defaults to None.\n            timestamp_ms (Optional[int], optional): The message timestamp in milliseconds. Defaults to None.\n            headers (Optional[Dict[str, str]], optional): Additional headers for the messages. Defaults to None.\n\n        Returns:\n            None: This method does not return a value.\n        \"\"\"\n        for handler in self.broker.handlers.values():  # pragma: no branch\n            if topic in handler.topics:\n                await call_handler(\n                    handler=handler,\n                    message=[\n                        build_message(\n                            message=message,\n                            topic=topic,\n                            partition=partition,\n                            timestamp_ms=timestamp_ms,\n                            headers=headers,\n                        )\n                        for message in msgs\n                    ],\n                )\n\n        return None\n</code></pre>"},{"location":"api/faststream/kafka/test/FakeProducer/#faststream.kafka.test.FakeProducer.broker","title":"broker  <code>instance-attribute</code>","text":"<pre><code>broker = broker\n</code></pre>"},{"location":"api/faststream/kafka/test/FakeProducer/#faststream.kafka.test.FakeProducer.publish","title":"publish  <code>async</code>","text":"<pre><code>publish(\n    message: SendableMessage,\n    topic: str,\n    key: Optional[bytes] = None,\n    partition: Optional[int] = None,\n    timestamp_ms: Optional[int] = None,\n    headers: Optional[Dict[str, str]] = None,\n    correlation_id: Optional[str] = None,\n    *,\n    reply_to: str = \"\",\n    rpc: bool = False,\n    rpc_timeout: Optional[float] = None,\n    raise_timeout: bool = False\n) -&gt; Optional[SendableMessage]\n</code></pre> <p>Publish a message to the Kafka broker.</p> PARAMETER  DESCRIPTION <code>message</code> <p>The message to be published.</p> <p> TYPE: <code>SendableMessage</code> </p> <code>topic</code> <p>The Kafka topic to publish the message to.</p> <p> TYPE: <code>str</code> </p> <code>key</code> <p>The message key. Defaults to None.</p> <p> TYPE: <code>Optional[bytes]</code> DEFAULT: <code>None</code> </p> <code>partition</code> <p>The Kafka partition to use. Defaults to None.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>timestamp_ms</code> <p>The message timestamp in milliseconds. Defaults to None.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>headers</code> <p>Additional headers for the message. Defaults to None.</p> <p> TYPE: <code>Optional[Dict[str, str]]</code> DEFAULT: <code>None</code> </p> <code>correlation_id</code> <p>The correlation ID for the message. Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>reply_to</code> <p>The topic to which responses should be sent. Defaults to \"\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>rpc</code> <p>If True, treat the message as an RPC request. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>rpc_timeout</code> <p>Timeout for RPC requests. Defaults to None.</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>raise_timeout</code> <p>If True, raise an exception on timeout. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Optional[SendableMessage]</code> <p>Optional[SendableMessage]: The response message, if this was an RPC request, otherwise None.</p> Source code in <code>faststream/kafka/test.py</code> <pre><code>@override\nasync def publish(  # type: ignore[override]\n    self,\n    message: SendableMessage,\n    topic: str,\n    key: Optional[bytes] = None,\n    partition: Optional[int] = None,\n    timestamp_ms: Optional[int] = None,\n    headers: Optional[Dict[str, str]] = None,\n    correlation_id: Optional[str] = None,\n    *,\n    reply_to: str = \"\",\n    rpc: bool = False,\n    rpc_timeout: Optional[float] = None,\n    raise_timeout: bool = False,\n) -&gt; Optional[SendableMessage]:\n    \"\"\"\n    Publish a message to the Kafka broker.\n\n    Args:\n        message (SendableMessage): The message to be published.\n        topic (str): The Kafka topic to publish the message to.\n        key (Optional[bytes], optional): The message key. Defaults to None.\n        partition (Optional[int], optional): The Kafka partition to use. Defaults to None.\n        timestamp_ms (Optional[int], optional): The message timestamp in milliseconds. Defaults to None.\n        headers (Optional[Dict[str, str]], optional): Additional headers for the message. Defaults to None.\n        correlation_id (Optional[str], optional): The correlation ID for the message. Defaults to None.\n        reply_to (str, optional): The topic to which responses should be sent. Defaults to \"\".\n        rpc (bool, optional): If True, treat the message as an RPC request. Defaults to False.\n        rpc_timeout (Optional[float], optional): Timeout for RPC requests. Defaults to None.\n        raise_timeout (bool, optional): If True, raise an exception on timeout. Defaults to False.\n\n    Returns:\n        Optional[SendableMessage]: The response message, if this was an RPC request, otherwise None.\n    \"\"\"\n    incoming = build_message(\n        message=message,\n        topic=topic,\n        key=key,\n        partition=partition,\n        timestamp_ms=timestamp_ms,\n        headers=headers,\n        correlation_id=correlation_id,\n        reply_to=reply_to,\n    )\n\n    for handler in self.broker.handlers.values():  # pragma: no branch\n        if topic in handler.topics:\n            r = await call_handler(\n                handler=handler,\n                message=[incoming] if handler.batch else incoming,\n                rpc=rpc,\n                rpc_timeout=rpc_timeout,\n                raise_timeout=raise_timeout,\n            )\n\n            if rpc:  # pragma: no branch\n                return r\n\n    return None\n</code></pre>"},{"location":"api/faststream/kafka/test/FakeProducer/#faststream.kafka.test.FakeProducer.publish_batch","title":"publish_batch  <code>async</code>","text":"<pre><code>publish_batch(\n    *msgs: SendableMessage,\n    topic: str,\n    partition: Optional[int] = None,\n    timestamp_ms: Optional[int] = None,\n    headers: Optional[Dict[str, str]] = None\n) -&gt; None\n</code></pre> <p>Publish a batch of messages to the Kafka broker.</p> PARAMETER  DESCRIPTION <code>*msgs</code> <p>Variable number of messages to be published.</p> <p> TYPE: <code>SendableMessage</code> DEFAULT: <code>()</code> </p> <code>topic</code> <p>The Kafka topic to publish the messages to.</p> <p> TYPE: <code>str</code> </p> <code>partition</code> <p>The Kafka partition to use. Defaults to None.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>timestamp_ms</code> <p>The message timestamp in milliseconds. Defaults to None.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>headers</code> <p>Additional headers for the messages. Defaults to None.</p> <p> TYPE: <code>Optional[Dict[str, str]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>None</code> <p>This method does not return a value.</p> <p> TYPE: <code>None</code> </p> Source code in <code>faststream/kafka/test.py</code> <pre><code>async def publish_batch(\n    self,\n    *msgs: SendableMessage,\n    topic: str,\n    partition: Optional[int] = None,\n    timestamp_ms: Optional[int] = None,\n    headers: Optional[Dict[str, str]] = None,\n) -&gt; None:\n    \"\"\"\n    Publish a batch of messages to the Kafka broker.\n\n    Args:\n        *msgs (SendableMessage): Variable number of messages to be published.\n        topic (str): The Kafka topic to publish the messages to.\n        partition (Optional[int], optional): The Kafka partition to use. Defaults to None.\n        timestamp_ms (Optional[int], optional): The message timestamp in milliseconds. Defaults to None.\n        headers (Optional[Dict[str, str]], optional): Additional headers for the messages. Defaults to None.\n\n    Returns:\n        None: This method does not return a value.\n    \"\"\"\n    for handler in self.broker.handlers.values():  # pragma: no branch\n        if topic in handler.topics:\n            await call_handler(\n                handler=handler,\n                message=[\n                    build_message(\n                        message=message,\n                        topic=topic,\n                        partition=partition,\n                        timestamp_ms=timestamp_ms,\n                        headers=headers,\n                    )\n                    for message in msgs\n                ],\n            )\n\n    return None\n</code></pre>"},{"location":"api/faststream/kafka/test/TestKafkaBroker/","title":"TestKafkaBroker","text":""},{"location":"api/faststream/kafka/test/TestKafkaBroker/#faststream.kafka.test.TestKafkaBroker","title":"faststream.kafka.test.TestKafkaBroker","text":"<p>A context manager for creating a test KafkaBroker instance with optional mocking.</p> <p>This class serves as a context manager for creating a KafkaBroker instance for testing purposes. It can either use the original KafkaBroker instance (if <code>with_real</code> is True) or replace certain components with mocks (if <code>with_real</code> is False) to isolate the broker during testing.</p> PARAMETER  DESCRIPTION <code>broker</code> <p>The KafkaBroker instance to be used in testing.</p> <p> TYPE: <code>KafkaBroker</code> </p> <code>with_real</code> <p>If True, the original broker is returned; if False, components are replaced with mock objects. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> METHOD DESCRIPTION <code>__aenter__</code> <p>Enter the context and return the KafkaBroker instance.</p> <code>__aexit__</code> <p>Any) -&gt; None: Exit the context.</p> <p>Example usage:</p> <p>```python real_broker = KafkaBroker() with TestKafkaBroker(real_broker, with_real=True) as broker:     # Use the real KafkaBroker instance for testing.</p> <p>with TestKafkaBroker(real_broker, with_real=False) as broker:     # Use a mocked KafkaBroker instance for testing.</p> Source code in <code>faststream/kafka/test.py</code> <pre><code>class TestKafkaBroker:\n    \"\"\"\n    A context manager for creating a test KafkaBroker instance with optional mocking.\n\n    This class serves as a context manager for creating a KafkaBroker instance for testing purposes. It can either use the\n    original KafkaBroker instance (if `with_real` is True) or replace certain components with mocks (if `with_real` is\n    False) to isolate the broker during testing.\n\n    Args:\n        broker (KafkaBroker): The KafkaBroker instance to be used in testing.\n        with_real (bool, optional): If True, the original broker is returned; if False, components are replaced with\n            mock objects. Defaults to False.\n\n    Attributes:\n        broker (KafkaBroker): The KafkaBroker instance provided for testing.\n        with_real (bool): A boolean flag indicating whether to use the original broker (True) or replace components with\n            mocks (False).\n\n    Methods:\n        __aenter__(self) -&gt; KafkaBroker:\n            Enter the context and return the KafkaBroker instance.\n\n        __aexit__(self, *args: Any) -&gt; None:\n            Exit the context.\n\n    Example usage:\n\n    ```python\n    real_broker = KafkaBroker()\n    with TestKafkaBroker(real_broker, with_real=True) as broker:\n        # Use the real KafkaBroker instance for testing.\n\n    with TestKafkaBroker(real_broker, with_real=False) as broker:\n        # Use a mocked KafkaBroker instance for testing.\n    \"\"\"\n\n    # This is set so pytest ignores this class\n    __test__ = False\n\n    def __init__(\n        self,\n        broker: KafkaBroker,\n        with_real: bool = False,\n        connect_only: bool = False,\n    ):\n        \"\"\"\n        Initialize a TestKafkaBroker instance.\n\n        Args:\n            broker (KafkaBroker): The KafkaBroker instance to be used in testing.\n            with_real (bool, optional): If True, the original broker is returned; if False, components are replaced with\n                mock objects. Defaults to False.\n        \"\"\"\n        self.with_real = with_real\n        self.broker = broker\n        self.connect_only = connect_only\n\n    @asynccontextmanager\n    async def _create_ctx(self) -&gt; AsyncGenerator[KafkaBroker, None]:\n        \"\"\"\n        Create the context for the context manager.\n\n        Yields:\n            KafkaBroker: The KafkaBroker instance for testing, either with or without mocks.\n        \"\"\"\n        if not self.with_real:\n            self.broker.start = AsyncMock(wraps=partial(_fake_start, self.broker))  # type: ignore[method-assign]\n            self.broker._connect = MethodType(_fake_connect, self.broker)  # type: ignore[method-assign]\n            self.broker.close = AsyncMock()  # type: ignore[method-assign]\n        else:\n            _fake_start(self.broker)\n\n        async with self.broker:\n            try:\n                if not self.connect_only:\n                    await self.broker.start()\n                yield self.broker\n            finally:\n                _fake_close(self.broker)\n\n    async def __aenter__(self) -&gt; KafkaBroker:\n        \"\"\"\n        Enter the context and return the KafkaBroker instance.\n\n        Returns:\n            KafkaBroker: The KafkaBroker instance for testing, either with or without mocks.\n        \"\"\"\n        self._ctx = self._create_ctx()\n        return await self._ctx.__aenter__()\n\n    async def __aexit__(self, *args: Any) -&gt; None:\n        \"\"\"\n        Exit the context.\n\n        Args:\n            *args: Variable-length argument list.\n        \"\"\"\n        await self._ctx.__aexit__(*args)\n</code></pre>"},{"location":"api/faststream/kafka/test/TestKafkaBroker/#faststream.kafka.test.TestKafkaBroker.broker","title":"broker  <code>instance-attribute</code>","text":"<pre><code>broker = broker\n</code></pre>"},{"location":"api/faststream/kafka/test/TestKafkaBroker/#faststream.kafka.test.TestKafkaBroker.connect_only","title":"connect_only  <code>instance-attribute</code>","text":"<pre><code>connect_only = connect_only\n</code></pre>"},{"location":"api/faststream/kafka/test/TestKafkaBroker/#faststream.kafka.test.TestKafkaBroker.with_real","title":"with_real  <code>instance-attribute</code>","text":"<pre><code>with_real = with_real\n</code></pre>"},{"location":"api/faststream/kafka/test/build_message/","title":"Build message","text":""},{"location":"api/faststream/kafka/test/build_message/#faststream.kafka.test.build_message","title":"faststream.kafka.test.build_message","text":"<pre><code>build_message(\n    message: SendableMessage,\n    topic: str,\n    partition: Optional[int] = None,\n    timestamp_ms: Optional[int] = None,\n    key: Optional[bytes] = None,\n    headers: Optional[Dict[str, str]] = None,\n    correlation_id: Optional[str] = None,\n    *,\n    reply_to: str = \"\"\n) -&gt; ConsumerRecord\n</code></pre> <p>Build a Kafka ConsumerRecord for a sendable message.</p> PARAMETER  DESCRIPTION <code>message</code> <p>The sendable message to be encoded.</p> <p> TYPE: <code>SendableMessage</code> </p> <code>topic</code> <p>The Kafka topic for the message.</p> <p> TYPE: <code>str</code> </p> <code>partition</code> <p>The Kafka partition for the message. Defaults to None.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>timestamp_ms</code> <p>The message timestamp in milliseconds. Defaults to None.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>key</code> <p>The message key. Defaults to None.</p> <p> TYPE: <code>Optional[bytes]</code> DEFAULT: <code>None</code> </p> <code>headers</code> <p>Additional headers for the message. Defaults to None.</p> <p> TYPE: <code>Optional[Dict[str, str]]</code> DEFAULT: <code>None</code> </p> <code>correlation_id</code> <p>The correlation ID for the message. Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>reply_to</code> <p>The topic to which responses should be sent. Defaults to \"\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> RETURNS DESCRIPTION <code>ConsumerRecord</code> <p>A Kafka ConsumerRecord object.</p> <p> TYPE: <code>ConsumerRecord</code> </p> Source code in <code>faststream/kafka/test.py</code> <pre><code>def build_message(\n    message: SendableMessage,\n    topic: str,\n    partition: Optional[int] = None,\n    timestamp_ms: Optional[int] = None,\n    key: Optional[bytes] = None,\n    headers: Optional[Dict[str, str]] = None,\n    correlation_id: Optional[str] = None,\n    *,\n    reply_to: str = \"\",\n) -&gt; ConsumerRecord:\n    \"\"\"\n    Build a Kafka ConsumerRecord for a sendable message.\n\n    Args:\n        message (SendableMessage): The sendable message to be encoded.\n        topic (str): The Kafka topic for the message.\n        partition (Optional[int], optional): The Kafka partition for the message. Defaults to None.\n        timestamp_ms (Optional[int], optional): The message timestamp in milliseconds. Defaults to None.\n        key (Optional[bytes], optional): The message key. Defaults to None.\n        headers (Optional[Dict[str, str]], optional): Additional headers for the message. Defaults to None.\n        correlation_id (Optional[str], optional): The correlation ID for the message. Defaults to None.\n        reply_to (str, optional): The topic to which responses should be sent. Defaults to \"\".\n\n    Returns:\n        ConsumerRecord: A Kafka ConsumerRecord object.\n    \"\"\"\n    msg, content_type = encode_message(message)\n    k = key or b\"\"\n    headers = {\n        \"content-type\": content_type or \"\",\n        \"correlation_id\": correlation_id or str(uuid4()),\n        \"reply_to\": reply_to,\n        **(headers or {}),\n    }\n\n    return ConsumerRecord(\n        value=msg,\n        topic=topic,\n        partition=partition or 0,\n        timestamp=timestamp_ms or int(datetime.now().timestamp()),\n        timestamp_type=0,\n        key=k,\n        serialized_key_size=len(k),\n        serialized_value_size=len(msg),\n        checksum=sum(msg),\n        offset=0,\n        headers=[(i, j.encode()) for i, j in headers.items()],\n    )\n</code></pre>"},{"location":"api/faststream/log/formatter/ColourizedFormatter/","title":"ColourizedFormatter","text":""},{"location":"api/faststream/log/formatter/ColourizedFormatter/#faststream.log.formatter.ColourizedFormatter","title":"faststream.log.formatter.ColourizedFormatter","text":"<p>             Bases: <code>Formatter</code></p> <p>A class to format log messages with colorized level names.</p> METHOD DESCRIPTION <code>__init__ </code> <p>Initialize the formatter with specified format strings.</p> <code>color_level_name </code> <p>Colorize the level name based on the log level.</p> <code>formatMessage </code> <p>Format the log record message with colorized level name.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/log/formatter.py</code> <pre><code>class ColourizedFormatter(logging.Formatter):\n    \"\"\"A class to format log messages with colorized level names.\n\n    Attributes:\n        level_name_colors : A dictionary mapping log level names to functions that colorize the level names.\n\n    Methods:\n        __init__ : Initialize the formatter with specified format strings.\n        color_level_name : Colorize the level name based on the log level.\n        formatMessage : Format the log record message with colorized level name.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    level_name_colors: DefaultDict[str, Callable[[str], str]] = defaultdict(\n        lambda: str,\n        **{\n            str(logging.DEBUG): lambda level_name: click.style(\n                str(level_name), fg=\"cyan\"\n            ),\n            str(logging.INFO): lambda level_name: click.style(\n                str(level_name), fg=\"green\"\n            ),\n            str(logging.WARNING): lambda level_name: click.style(\n                str(level_name), fg=\"yellow\"\n            ),\n            str(logging.ERROR): lambda level_name: click.style(\n                str(level_name), fg=\"red\"\n            ),\n            str(logging.CRITICAL): lambda level_name: click.style(\n                str(level_name), fg=\"bright_red\"\n            ),\n        },\n    )\n\n    def __init__(\n        self,\n        fmt: Optional[str] = None,\n        datefmt: Optional[str] = None,\n        style: Literal[\"%\", \"{\", \"$\"] = \"%\",\n        use_colors: Optional[bool] = None,\n    ):\n        \"\"\"\n        Initialize the formatter with specified format strings.\n\n        Initialize the formatter either with the specified format string, or a\n        default as described above. Allow for specialized date formatting with\n        the optional datefmt argument. If datefmt is omitted, you get an\n        ISO8601-like (or RFC 3339-like) format.\n\n        Use a style parameter of '%', '{' or '$' to specify that you want to\n        use one of %-formatting, :meth:`str.format` (``{}``) formatting or\n        :class:`string.Template` formatting in your format string.\n        \"\"\"\n        if use_colors in (True, False):\n            self.use_colors = use_colors\n        else:\n            self.use_colors = sys.stdout.isatty()\n        super().__init__(fmt=fmt, datefmt=datefmt, style=style)\n\n    def color_level_name(self, level_name: str, level_no: int) -&gt; str:\n        \"\"\"Returns the colored level name.\n\n        Args:\n            level_name: The name of the level.\n            level_no: The number of the level.\n\n        Returns:\n            The colored level name.\n\n        Raises:\n            KeyError: If the level number is not found in the level name colors dictionary.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        return self.level_name_colors[str(level_no)](level_name)\n\n    def formatMessage(self, record: logging.LogRecord) -&gt; str:\n        \"\"\"Formats the log message.\n\n        Args:\n            record (logging.LogRecord): The log record to format.\n\n        Returns:\n            str: The formatted log message.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        levelname = expand_log_field(record.levelname, 8)\n        if self.use_colors is True:  # pragma: no cover\n            levelname = self.color_level_name(levelname, record.levelno)\n        record.__dict__[\"levelname\"] = levelname\n        return super().formatMessage(record)\n</code></pre>"},{"location":"api/faststream/log/formatter/ColourizedFormatter/#faststream.log.formatter.ColourizedFormatter.level_name_colors","title":"level_name_colors  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>level_name_colors: DefaultDict[\n    str, Callable[[str], str]\n] = defaultdict(\n    lambda: str,\n    **{\n        str(logging.DEBUG): lambda: click.style(\n            str(level_name), fg=\"cyan\"\n        ),\n        str(logging.INFO): lambda: click.style(\n            str(level_name), fg=\"green\"\n        ),\n        str(logging.WARNING): lambda: click.style(\n            str(level_name), fg=\"yellow\"\n        ),\n        str(logging.ERROR): lambda: click.style(\n            str(level_name), fg=\"red\"\n        ),\n        str(logging.CRITICAL): lambda: click.style(\n            str(level_name), fg=\"bright_red\"\n        ),\n    }\n)\n</code></pre>"},{"location":"api/faststream/log/formatter/ColourizedFormatter/#faststream.log.formatter.ColourizedFormatter.use_colors","title":"use_colors  <code>instance-attribute</code>","text":"<pre><code>use_colors = use_colors\n</code></pre>"},{"location":"api/faststream/log/formatter/ColourizedFormatter/#faststream.log.formatter.ColourizedFormatter.color_level_name","title":"color_level_name","text":"<pre><code>color_level_name(level_name: str, level_no: int) -&gt; str\n</code></pre> <p>Returns the colored level name.</p> PARAMETER  DESCRIPTION <code>level_name</code> <p>The name of the level.</p> <p> TYPE: <code>str</code> </p> <code>level_no</code> <p>The number of the level.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The colored level name.</p> RAISES DESCRIPTION <code>KeyError</code> <p>If the level number is not found in the level name colors dictionary.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/log/formatter.py</code> <pre><code>def color_level_name(self, level_name: str, level_no: int) -&gt; str:\n    \"\"\"Returns the colored level name.\n\n    Args:\n        level_name: The name of the level.\n        level_no: The number of the level.\n\n    Returns:\n        The colored level name.\n\n    Raises:\n        KeyError: If the level number is not found in the level name colors dictionary.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    return self.level_name_colors[str(level_no)](level_name)\n</code></pre>"},{"location":"api/faststream/log/formatter/ColourizedFormatter/#faststream.log.formatter.ColourizedFormatter.formatMessage","title":"formatMessage","text":"<pre><code>formatMessage(record: logging.LogRecord) -&gt; str\n</code></pre> <p>Formats the log message.</p> PARAMETER  DESCRIPTION <code>record</code> <p>The log record to format.</p> <p> TYPE: <code>LogRecord</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The formatted log message.</p> <p> TYPE: <code>str</code> </p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/log/formatter.py</code> <pre><code>def formatMessage(self, record: logging.LogRecord) -&gt; str:\n    \"\"\"Formats the log message.\n\n    Args:\n        record (logging.LogRecord): The log record to format.\n\n    Returns:\n        str: The formatted log message.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    levelname = expand_log_field(record.levelname, 8)\n    if self.use_colors is True:  # pragma: no cover\n        levelname = self.color_level_name(levelname, record.levelno)\n    record.__dict__[\"levelname\"] = levelname\n    return super().formatMessage(record)\n</code></pre>"},{"location":"api/faststream/log/formatter/expand_log_field/","title":"Expand log field","text":""},{"location":"api/faststream/log/formatter/expand_log_field/#faststream.log.formatter.expand_log_field","title":"faststream.log.formatter.expand_log_field","text":"<pre><code>expand_log_field(field: str, symbols: int) -&gt; str\n</code></pre> <p>Expands a log field by adding spaces.</p> PARAMETER  DESCRIPTION <code>field</code> <p>The log field to expand.</p> <p> TYPE: <code>str</code> </p> <code>symbols</code> <p>The desired length of the expanded field.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The expanded log field.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/log/formatter.py</code> <pre><code>def expand_log_field(field: str, symbols: int) -&gt; str:\n    \"\"\"Expands a log field by adding spaces.\n\n    Args:\n        field: The log field to expand.\n        symbols: The desired length of the expanded field.\n\n    Returns:\n        The expanded log field.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    return field + (\" \" * (symbols - len(field)))\n</code></pre>"},{"location":"api/faststream/log/formatter/make_record_with_extra/","title":"Make record with extra","text":""},{"location":"api/faststream/log/formatter/make_record_with_extra/#faststream.log.formatter.make_record_with_extra","title":"faststream.log.formatter.make_record_with_extra","text":"<pre><code>make_record_with_extra(\n    self: logging.Logger,\n    name: str,\n    level: int,\n    fn: str,\n    lno: int,\n    msg: str,\n    args: Tuple[str],\n    exc_info: Optional[\n        Union[\n            Tuple[\n                Type[BaseException],\n                BaseException,\n                Optional[TracebackType],\n            ],\n            Tuple[None, None, None],\n        ]\n    ],\n    func: Optional[str] = None,\n    extra: Optional[Mapping[str, object]] = None,\n    sinfo: Optional[str] = None,\n) -&gt; logging.LogRecord\n</code></pre> <p>Creates a log record with additional information.</p> PARAMETER  DESCRIPTION <code>self</code> <p>The logger object.</p> <p> TYPE: <code>Logger</code> </p> <code>name</code> <p>The name of the logger.</p> <p> TYPE: <code>str</code> </p> <code>level</code> <p>The logging level.</p> <p> TYPE: <code>int</code> </p> <code>fn</code> <p>The filename where the log message originated.</p> <p> TYPE: <code>str</code> </p> <code>lno</code> <p>The line number where the log message originated.</p> <p> TYPE: <code>int</code> </p> <code>msg</code> <p>The log message.</p> <p> TYPE: <code>str</code> </p> <code>args</code> <p>The arguments for the log message.</p> <p> TYPE: <code>Tuple[str]</code> </p> <code>exc_info</code> <p>Information about an exception.</p> <p> TYPE: <code>Optional[Union[Tuple[Type[BaseException], BaseException, Optional[TracebackType]], Tuple[None, None, None]]]</code> </p> <code>func</code> <p>The name of the function where the log message originated.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>extra</code> <p>Additional information to include in the log record.</p> <p> TYPE: <code>Optional[Mapping[str, object]]</code> DEFAULT: <code>None</code> </p> <code>sinfo</code> <p>Stack information.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>LogRecord</code> <p>The log record.</p> Note <p>If <code>extra</code> is <code>None</code>, it will be set to the value of <code>context.get_local(\"log_context\")</code>.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/log/formatter.py</code> <pre><code>def make_record_with_extra(\n    self: logging.Logger,\n    name: str,\n    level: int,\n    fn: str,\n    lno: int,\n    msg: str,\n    args: Tuple[str],\n    exc_info: Optional[\n        Union[\n            Tuple[Type[BaseException], BaseException, Optional[TracebackType]],\n            Tuple[None, None, None],\n        ]\n    ],\n    func: Optional[str] = None,\n    extra: Optional[Mapping[str, object]] = None,\n    sinfo: Optional[str] = None,\n) -&gt; logging.LogRecord:\n    \"\"\"Creates a log record with additional information.\n\n    Args:\n        self: The logger object.\n        name: The name of the logger.\n        level: The logging level.\n        fn: The filename where the log message originated.\n        lno: The line number where the log message originated.\n        msg: The log message.\n        args: The arguments for the log message.\n        exc_info: Information about an exception.\n        func: The name of the function where the log message originated.\n        extra: Additional information to include in the log record.\n        sinfo: Stack information.\n\n    Returns:\n        The log record.\n\n    Note:\n        If `extra` is `None`, it will be set to the value of `context.get_local(\"log_context\")`.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    if extra is None:\n        extra = context.get_local(\"log_context\")\n\n    record = original_makeRecord(\n        self,\n        name,\n        level,\n        fn,\n        lno,\n        msg,\n        args,\n        exc_info,\n        func,\n        extra,\n        sinfo,\n    )\n\n    return record\n</code></pre>"},{"location":"api/faststream/log/logging/configure_formatter/","title":"Configure formatter","text":""},{"location":"api/faststream/log/logging/configure_formatter/#faststream.log.logging.configure_formatter","title":"faststream.log.logging.configure_formatter","text":"<pre><code>configure_formatter(\n    formatter: Type[logging.Formatter],\n    *args: Any,\n    **kwargs: Any\n) -&gt; logging.Formatter\n</code></pre> <p>Configures a logging formatter.</p> PARAMETER  DESCRIPTION <code>formatter</code> <p>The type of logging formatter to configure.</p> <p> TYPE: <code>Type[Formatter]</code> </p> <code>*args</code> <p>Additional positional arguments to pass to the formatter constructor.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>()</code> </p> <code>**kwargs</code> <p>Additional keyword arguments to pass to the formatter constructor.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Formatter</code> <p>An instance of the configured logging formatter.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/log/logging.py</code> <pre><code>def configure_formatter(\n    formatter: Type[logging.Formatter], *args: Any, **kwargs: Any\n) -&gt; logging.Formatter:\n    \"\"\"Configures a logging formatter.\n\n    Args:\n        formatter: The type of logging formatter to configure.\n        *args: Additional positional arguments to pass to the formatter constructor.\n        **kwargs: Additional keyword arguments to pass to the formatter constructor.\n\n    Returns:\n        An instance of the configured logging formatter.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    return formatter(*args, **kwargs)\n</code></pre>"},{"location":"api/faststream/nats/asyncapi/Handler/","title":"Handler","text":""},{"location":"api/faststream/nats/asyncapi/Handler/#faststream.nats.asyncapi.Handler","title":"faststream.nats.asyncapi.Handler","text":"<p>             Bases: <code>LogicNatsHandler</code>, <code>AsyncAPIOperation</code></p> Source code in <code>faststream/nats/asyncapi.py</code> <pre><code>class Handler(LogicNatsHandler, AsyncAPIOperation):\n    def schema(self) -&gt; Dict[str, Channel]:\n        name = f\"{self.subject}/{self.call_name}\"\n\n        payloads = []\n        for _, _, _, _, _, dep in self.calls:\n            body = parse_handler_params(dep, prefix=name)\n            payloads.append(body)\n\n        return {\n            name: Channel(\n                description=self.description,\n                subscribe=Operation(\n                    message=Message(\n                        title=f\"{name}/Message\",\n                        payload=resolve_payloads(payloads),\n                        correlationId=CorrelationId(\n                            location=\"$message.header#/correlation_id\"\n                        ),\n                    ),\n                ),\n                bindings=ChannelBinding(\n                    nats=nats.ChannelBinding(\n                        subject=self.subject,\n                        queue=self.queue or None,\n                    )\n                ),\n            )\n        }\n\n    @property\n    def name(self) -&gt; str:\n        return self.call_name\n</code></pre>"},{"location":"api/faststream/nats/asyncapi/Handler/#faststream.nats.asyncapi.Handler.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"api/faststream/nats/asyncapi/Handler/#faststream.nats.asyncapi.Handler.schema","title":"schema","text":"<pre><code>schema() -&gt; Dict[str, Channel]\n</code></pre> Source code in <code>faststream/nats/asyncapi.py</code> <pre><code>def schema(self) -&gt; Dict[str, Channel]:\n    name = f\"{self.subject}/{self.call_name}\"\n\n    payloads = []\n    for _, _, _, _, _, dep in self.calls:\n        body = parse_handler_params(dep, prefix=name)\n        payloads.append(body)\n\n    return {\n        name: Channel(\n            description=self.description,\n            subscribe=Operation(\n                message=Message(\n                    title=f\"{name}/Message\",\n                    payload=resolve_payloads(payloads),\n                    correlationId=CorrelationId(\n                        location=\"$message.header#/correlation_id\"\n                    ),\n                ),\n            ),\n            bindings=ChannelBinding(\n                nats=nats.ChannelBinding(\n                    subject=self.subject,\n                    queue=self.queue or None,\n                )\n            ),\n        )\n    }\n</code></pre>"},{"location":"api/faststream/nats/asyncapi/Publisher/","title":"Publisher","text":""},{"location":"api/faststream/nats/asyncapi/Publisher/#faststream.nats.asyncapi.Publisher","title":"faststream.nats.asyncapi.Publisher","text":"<p>             Bases: <code>LogicPublisher</code>, <code>AsyncAPIOperation</code></p> Source code in <code>faststream/nats/asyncapi.py</code> <pre><code>class Publisher(LogicPublisher, AsyncAPIOperation):\n    def schema(self) -&gt; Dict[str, Channel]:\n        payloads = []\n        for call in self.calls:\n            call_model = build_call_model(call)\n            body = get_response_schema(\n                call_model,\n                prefix=to_camelcase(call_model.call_name),\n            )\n            if body:\n                payloads.append(body)\n\n        return {\n            self.name: Channel(\n                description=self.description,\n                publish=Operation(\n                    message=Message(\n                        title=f\"{self.name}/Message\",\n                        payload=resolve_payloads(payloads),\n                        correlationId=CorrelationId(\n                            location=\"$message.header#/correlation_id\"\n                        ),\n                    ),\n                ),\n                bindings=ChannelBinding(\n                    nats=nats.ChannelBinding(\n                        subject=self.subject,\n                    )\n                ),\n            )\n        }\n\n    @property\n    def name(self) -&gt; str:\n        return self.title or f\"{self.subject}/Publisher\"\n</code></pre>"},{"location":"api/faststream/nats/asyncapi/Publisher/#faststream.nats.asyncapi.Publisher.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"api/faststream/nats/asyncapi/Publisher/#faststream.nats.asyncapi.Publisher.schema","title":"schema","text":"<pre><code>schema() -&gt; Dict[str, Channel]\n</code></pre> Source code in <code>faststream/nats/asyncapi.py</code> <pre><code>def schema(self) -&gt; Dict[str, Channel]:\n    payloads = []\n    for call in self.calls:\n        call_model = build_call_model(call)\n        body = get_response_schema(\n            call_model,\n            prefix=to_camelcase(call_model.call_name),\n        )\n        if body:\n            payloads.append(body)\n\n    return {\n        self.name: Channel(\n            description=self.description,\n            publish=Operation(\n                message=Message(\n                    title=f\"{self.name}/Message\",\n                    payload=resolve_payloads(payloads),\n                    correlationId=CorrelationId(\n                        location=\"$message.header#/correlation_id\"\n                    ),\n                ),\n            ),\n            bindings=ChannelBinding(\n                nats=nats.ChannelBinding(\n                    subject=self.subject,\n                )\n            ),\n        )\n    }\n</code></pre>"},{"location":"api/faststream/nats/broker/NatsBroker/","title":"NatsBroker","text":""},{"location":"api/faststream/nats/broker/NatsBroker/#faststream.nats.broker.NatsBroker","title":"faststream.nats.broker.NatsBroker","text":"<p>             Bases: <code>NatsLoggingMixin</code>, <code>BrokerAsyncUsecase[Msg, Client]</code></p> Source code in <code>faststream/nats/broker.py</code> <pre><code>class NatsBroker(\n    NatsLoggingMixin,\n    BrokerAsyncUsecase[Msg, Client],\n):\n    stream: Optional[JetStreamContext]\n\n    handlers: Dict[Subject, Handler]  # type: ignore[assignment]\n    _publishers: Dict[Subject, Publisher]  # type: ignore[assignment]\n    _producer: Optional[NatsFastProducer]\n    _js_producer: Optional[NatsJSFastProducer]\n\n    def __init__(\n        self,\n        servers: Union[str, Sequence[str]] = (\"nats://localhost:4222\",),  # noqa: B006\n        *,\n        protocol: str = \"nats\",\n        protocol_version: Optional[str] = \"custom\",\n        **kwargs: Any,\n    ) -&gt; None:\n        super().__init__(\n            url=[servers]\n            if isinstance(servers, str)\n            else list(servers),  # AsyncAPI information\n            protocol=protocol,\n            protocol_version=protocol_version,\n            **kwargs,\n        )\n\n        self.__is_connected = False\n        self._producer = None\n\n        # JS options\n        self.stream = None\n        self._js_producer = None\n\n    async def connect(\n        self,\n        *args: Any,\n        **kwargs: Any,\n    ) -&gt; Client:\n        connection = await super().connect(*args, **kwargs)\n        for p in self._publishers.values():\n            if p.stream is not None:\n                p._producer = self._js_producer\n            else:\n                p._producer = self._producer\n        return connection\n\n    async def _connect(\n        self,\n        error_cb: Optional[ErrorCallback] = None,\n        reconnected_cb: Optional[Callback] = None,\n        **kwargs: Any,\n    ) -&gt; Client:\n        self.__is_connected = True\n\n        connect = await nats.connect(\n            error_cb=self._log_connection_broken(error_cb),\n            reconnected_cb=self._log_reconnected(reconnected_cb),\n            **kwargs,\n        )\n\n        self._producer = NatsFastProducer(\n            connect,\n            decoder=self._global_decoder,\n            parser=self._global_parser,\n        )\n\n        stream = self.stream = connect.jetstream()\n\n        self._js_producer = NatsJSFastProducer(\n            stream,\n            decoder=self._global_decoder,\n            parser=self._global_parser,\n        )\n\n        return connect\n\n    async def _close(\n        self,\n        exc_type: Optional[Type[BaseException]] = None,\n        exc_val: Optional[BaseException] = None,\n        exec_tb: Optional[TracebackType] = None,\n    ) -&gt; None:\n        self._producer = None\n        self._js_producer = None\n        self.stream = None\n\n        if self._connection is not None:\n            await self._connection.drain()\n\n        await super()._close(exc_type, exc_val, exec_tb)\n        self.__is_connected = False\n\n    async def start(self) -&gt; None:\n        context.set_local(\n            \"log_context\",\n            self._get_log_context(None, \"\"),\n        )\n\n        await super().start()\n        assert (\n            self._connection and self.stream\n        ), \"Broker should be started already\"  # nosec B101\n\n        for handler in self.handlers.values():\n            stream = handler.stream\n\n            if (is_js := stream is not None) and stream.declare:\n                try:  # pragma: no branch\n                    await self.stream.add_stream(\n                        config=stream.config,\n                        subjects=stream.subjects,\n                    )\n\n                except nats.js.errors.BadRequestError as e:\n                    old_config = (await self.stream.stream_info(stream.name)).config\n\n                    c = self._get_log_context(None, \"\")\n                    if (\n                        e.description\n                        == \"stream name already in use with a different configuration\"\n                    ):\n                        self._log(str(e), logging.WARNING, c)\n                        await self.stream.update_stream(\n                            config=stream.config,\n                            subjects=tuple(\n                                set(old_config.subjects or ()).union(stream.subjects)\n                            ),\n                        )\n\n                    else:  # pragma: no cover\n                        self._log(str(e), logging.ERROR, c, exc_info=e)\n\n                finally:\n                    # prevent from double declaration\n                    stream.declare = False\n\n            c = self._get_log_context(\n                None,\n                subject=handler.subject,\n                queue=handler.queue,\n                stream=stream.name if stream else \"\",\n            )\n            self._log(f\"`{handler.name}` waiting for messages\", extra=c)\n            await handler.start(self.stream if is_js else self._connection)\n\n    def _process_message(\n        self,\n        func: Callable[\n            [StreamMessage[Msg]],\n            Awaitable[T_HandlerReturn],\n        ],\n        watcher: BaseWatcher,\n    ) -&gt; Callable[[StreamMessage[Msg]], Awaitable[WrappedReturn[T_HandlerReturn]],]:\n        @wraps(func)\n        async def process_wrapper(\n            message: StreamMessage[Msg],\n        ) -&gt; WrappedReturn[T_HandlerReturn]:\n            async with WatcherContext(watcher, message):\n                r = await self._execute_handler(func, message)\n\n                pub_response: Optional[AsyncPublisherProtocol]\n                if message.reply_to:\n                    pub_response = FakePublisher(\n                        partial(self.publish, subject=message.reply_to)\n                    )\n                else:\n                    pub_response = None\n\n            return r, pub_response\n\n        return process_wrapper\n\n    def _log_connection_broken(\n        self,\n        error_cb: Optional[ErrorCallback] = None,\n    ) -&gt; ErrorCallback:\n        c = self._get_log_context(None, \"\")\n\n        async def wrapper(err: Exception) -&gt; None:\n            if error_cb is not None:\n                await error_cb(err)\n\n            if self.__is_connected is True:\n                self._log(str(err), logging.WARNING, c, exc_info=err)\n                self.__is_connected = False\n\n        return wrapper\n\n    def _log_reconnected(\n        self,\n        cb: Optional[Callback] = None,\n    ) -&gt; Callback:\n        c = self._get_log_context(None, \"\")\n\n        async def wrapper() -&gt; None:\n            if cb is not None:\n                await cb()\n\n            if self.__is_connected is False:\n                self._log(\"Connection established\", logging.INFO, c)\n                self.__is_connected = True\n\n        return wrapper\n\n    @override\n    def subscriber(  # type: ignore[override]\n        self,\n        subject: str,\n        queue: str = \"\",\n        pending_msgs_limit: Optional[int] = None,\n        pending_bytes_limit: Optional[int] = None,\n        # Core arguments\n        max_msgs: int = 0,\n        # JS arguments\n        durable: Optional[str] = None,\n        config: Optional[api.ConsumerConfig] = None,\n        ordered_consumer: bool = False,\n        idle_heartbeat: Optional[float] = None,\n        flow_control: bool = False,\n        deliver_policy: Optional[api.DeliverPolicy] = None,\n        headers_only: Optional[bool] = None,\n        # custom\n        ack_first: bool = False,\n        stream: Union[str, JStream, None] = None,\n        # broker arguments\n        dependencies: Sequence[Depends] = (),\n        parser: Optional[CustomParser[Msg, NatsMessage]] = None,\n        decoder: Optional[CustomDecoder[NatsMessage]] = None,\n        middlewares: Optional[Sequence[Callable[[Msg], BaseMiddleware]]] = None,\n        filter: Filter[NatsMessage] = default_filter,\n        # AsyncAPI information\n        title: Optional[str] = None,\n        description: Optional[str] = None,\n        **original_kwargs: Any,\n    ) -&gt; Callable[\n        [Callable[P_HandlerParams, T_HandlerReturn]],\n        HandlerCallWrapper[Msg, P_HandlerParams, T_HandlerReturn],\n    ]:\n        stream = stream_builder.stream(stream)\n\n        self._setup_log_context(\n            queue=queue,\n            subject=subject,\n            stream=stream.name if stream else None,\n        )\n        super().subscriber()\n\n        extra_options: Dict[str, Any] = {\n            \"pending_msgs_limit\": pending_msgs_limit\n            or (\n                DEFAULT_JS_SUB_PENDING_MSGS_LIMIT\n                if stream\n                else DEFAULT_SUB_PENDING_MSGS_LIMIT\n            ),\n            \"pending_bytes_limit\": pending_bytes_limit\n            or (\n                DEFAULT_JS_SUB_PENDING_BYTES_LIMIT\n                if stream\n                else DEFAULT_SUB_PENDING_BYTES_LIMIT\n            ),\n        }\n\n        if stream:\n            stream.subjects.append(subject)\n            extra_options.update(\n                {\n                    \"durable\": durable,\n                    \"stream\": stream.name,\n                    \"config\": config,\n                    \"ordered_consumer\": ordered_consumer,\n                    \"idle_heartbeat\": idle_heartbeat,\n                    \"flow_control\": flow_control,\n                    \"deliver_policy\": deliver_policy,\n                    \"headers_only\": headers_only,\n                    \"manual_ack\": not ack_first,\n                }\n            )\n        else:\n            extra_options.update(\n                {\n                    \"max_msgs\": max_msgs,\n                }\n            )\n\n        key = Handler.get_routing_hash(subject)\n        handler = self.handlers[key] = self.handlers.get(\n            key,\n            Handler(\n                subject=subject,\n                queue=queue,\n                stream=stream,\n                extra_options=extra_options,\n                title=title,\n                description=description,\n                log_context_builder=partial(\n                    self._get_log_context,\n                    stream=stream.name if stream else \"\",\n                    subject=subject,\n                    queue=queue,\n                ),\n            ),\n        )\n\n        def consumer_wrapper(\n            func: Callable[P_HandlerParams, T_HandlerReturn],\n        ) -&gt; HandlerCallWrapper[Msg, P_HandlerParams, T_HandlerReturn,]:\n            handler_call, dependant = self._wrap_handler(\n                func,\n                extra_dependencies=dependencies,\n                **original_kwargs,\n            )\n\n            handler.add_call(\n                handler=handler_call,\n                filter=filter,\n                middlewares=middlewares,\n                parser=parser or self._global_parser,\n                decoder=decoder or self._global_decoder,\n                dependant=dependant,\n            )\n\n            return handler_call\n\n        return consumer_wrapper\n\n    @override\n    def publisher(  # type: ignore[override]\n        self,\n        subject: str,\n        headers: Optional[Dict[str, str]] = None,\n        # Core\n        reply_to: str = \"\",\n        # JS\n        stream: Union[str, JStream, None] = None,\n        timeout: Optional[float] = None,\n        # AsyncAPI information\n        title: Optional[str] = None,\n        description: Optional[str] = None,\n    ) -&gt; Publisher:\n        if (stream := stream_builder.stream(stream)) is not None:\n            stream.subjects.append(subject)\n\n        publisher = self._publishers.get(\n            subject,\n            Publisher(\n                subject=subject,\n                headers=headers,\n                # Core\n                reply_to=reply_to,\n                # JS\n                timeout=timeout,\n                stream=stream,\n                # AsyncAPI\n                title=title,\n                _description=description,\n            ),\n        )\n        super().publisher(subject, publisher)\n        return publisher\n\n    @override\n    async def publish(  # type: ignore[override]\n        self,\n        *args: Any,\n        stream: Optional[str] = None,\n        **kwargs: Any,\n    ) -&gt; Optional[DecodedMessage]:\n        if stream is None:\n            assert self._producer, \"NatsBroker is not started yet\"  # nosec B101\n            return await self._producer.publish(*args, **kwargs)\n        else:\n            assert self._js_producer, \"NatsBroker is not started yet\"  # nosec B101\n            return await self._js_producer.publish(\n                *args,\n                stream=stream,\n                **kwargs,  # type: ignore[misc]\n            )\n</code></pre>"},{"location":"api/faststream/nats/broker/NatsBroker/#faststream.nats.broker.NatsBroker.handlers","title":"handlers  <code>instance-attribute</code>","text":"<pre><code>handlers: Dict[Subject, Handler]\n</code></pre>"},{"location":"api/faststream/nats/broker/NatsBroker/#faststream.nats.broker.NatsBroker.stream","title":"stream  <code>instance-attribute</code>","text":"<pre><code>stream: Optional[JetStreamContext] = None\n</code></pre>"},{"location":"api/faststream/nats/broker/NatsBroker/#faststream.nats.broker.NatsBroker.connect","title":"connect  <code>async</code>","text":"<pre><code>connect(*args: Any, **kwargs: Any) -&gt; Client\n</code></pre> Source code in <code>faststream/nats/broker.py</code> <pre><code>async def connect(\n    self,\n    *args: Any,\n    **kwargs: Any,\n) -&gt; Client:\n    connection = await super().connect(*args, **kwargs)\n    for p in self._publishers.values():\n        if p.stream is not None:\n            p._producer = self._js_producer\n        else:\n            p._producer = self._producer\n    return connection\n</code></pre>"},{"location":"api/faststream/nats/broker/NatsBroker/#faststream.nats.broker.NatsBroker.publish","title":"publish  <code>async</code>","text":"<pre><code>publish(\n    *args: Any, stream: Optional[str] = None, **kwargs: Any\n) -&gt; Optional[DecodedMessage]\n</code></pre> Source code in <code>faststream/nats/broker.py</code> <pre><code>@override\nasync def publish(  # type: ignore[override]\n    self,\n    *args: Any,\n    stream: Optional[str] = None,\n    **kwargs: Any,\n) -&gt; Optional[DecodedMessage]:\n    if stream is None:\n        assert self._producer, \"NatsBroker is not started yet\"  # nosec B101\n        return await self._producer.publish(*args, **kwargs)\n    else:\n        assert self._js_producer, \"NatsBroker is not started yet\"  # nosec B101\n        return await self._js_producer.publish(\n            *args,\n            stream=stream,\n            **kwargs,  # type: ignore[misc]\n        )\n</code></pre>"},{"location":"api/faststream/nats/broker/NatsBroker/#faststream.nats.broker.NatsBroker.publisher","title":"publisher","text":"<pre><code>publisher(\n    subject: str,\n    headers: Optional[Dict[str, str]] = None,\n    reply_to: str = \"\",\n    stream: Union[str, JStream, None] = None,\n    timeout: Optional[float] = None,\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n) -&gt; Publisher\n</code></pre> Source code in <code>faststream/nats/broker.py</code> <pre><code>@override\ndef publisher(  # type: ignore[override]\n    self,\n    subject: str,\n    headers: Optional[Dict[str, str]] = None,\n    # Core\n    reply_to: str = \"\",\n    # JS\n    stream: Union[str, JStream, None] = None,\n    timeout: Optional[float] = None,\n    # AsyncAPI information\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n) -&gt; Publisher:\n    if (stream := stream_builder.stream(stream)) is not None:\n        stream.subjects.append(subject)\n\n    publisher = self._publishers.get(\n        subject,\n        Publisher(\n            subject=subject,\n            headers=headers,\n            # Core\n            reply_to=reply_to,\n            # JS\n            timeout=timeout,\n            stream=stream,\n            # AsyncAPI\n            title=title,\n            _description=description,\n        ),\n    )\n    super().publisher(subject, publisher)\n    return publisher\n</code></pre>"},{"location":"api/faststream/nats/broker/NatsBroker/#faststream.nats.broker.NatsBroker.start","title":"start  <code>async</code>","text":"<pre><code>start() -&gt; None\n</code></pre> Source code in <code>faststream/nats/broker.py</code> <pre><code>async def start(self) -&gt; None:\n    context.set_local(\n        \"log_context\",\n        self._get_log_context(None, \"\"),\n    )\n\n    await super().start()\n    assert (\n        self._connection and self.stream\n    ), \"Broker should be started already\"  # nosec B101\n\n    for handler in self.handlers.values():\n        stream = handler.stream\n\n        if (is_js := stream is not None) and stream.declare:\n            try:  # pragma: no branch\n                await self.stream.add_stream(\n                    config=stream.config,\n                    subjects=stream.subjects,\n                )\n\n            except nats.js.errors.BadRequestError as e:\n                old_config = (await self.stream.stream_info(stream.name)).config\n\n                c = self._get_log_context(None, \"\")\n                if (\n                    e.description\n                    == \"stream name already in use with a different configuration\"\n                ):\n                    self._log(str(e), logging.WARNING, c)\n                    await self.stream.update_stream(\n                        config=stream.config,\n                        subjects=tuple(\n                            set(old_config.subjects or ()).union(stream.subjects)\n                        ),\n                    )\n\n                else:  # pragma: no cover\n                    self._log(str(e), logging.ERROR, c, exc_info=e)\n\n            finally:\n                # prevent from double declaration\n                stream.declare = False\n\n        c = self._get_log_context(\n            None,\n            subject=handler.subject,\n            queue=handler.queue,\n            stream=stream.name if stream else \"\",\n        )\n        self._log(f\"`{handler.name}` waiting for messages\", extra=c)\n        await handler.start(self.stream if is_js else self._connection)\n</code></pre>"},{"location":"api/faststream/nats/broker/NatsBroker/#faststream.nats.broker.NatsBroker.subscriber","title":"subscriber","text":"<pre><code>subscriber(\n    subject: str,\n    queue: str = \"\",\n    pending_msgs_limit: Optional[int] = None,\n    pending_bytes_limit: Optional[int] = None,\n    max_msgs: int = 0,\n    durable: Optional[str] = None,\n    config: Optional[api.ConsumerConfig] = None,\n    ordered_consumer: bool = False,\n    idle_heartbeat: Optional[float] = None,\n    flow_control: bool = False,\n    deliver_policy: Optional[api.DeliverPolicy] = None,\n    headers_only: Optional[bool] = None,\n    ack_first: bool = False,\n    stream: Union[str, JStream, None] = None,\n    dependencies: Sequence[Depends] = (),\n    parser: Optional[CustomParser[Msg, NatsMessage]] = None,\n    decoder: Optional[CustomDecoder[NatsMessage]] = None,\n    middlewares: Optional[\n        Sequence[Callable[[Msg], BaseMiddleware]]\n    ] = None,\n    filter: Filter[NatsMessage] = default_filter,\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n    **original_kwargs: Any\n) -&gt; Callable[\n    [Callable[P_HandlerParams, T_HandlerReturn]],\n    HandlerCallWrapper[\n        Msg, P_HandlerParams, T_HandlerReturn\n    ],\n]\n</code></pre> Source code in <code>faststream/nats/broker.py</code> <pre><code>@override\ndef subscriber(  # type: ignore[override]\n    self,\n    subject: str,\n    queue: str = \"\",\n    pending_msgs_limit: Optional[int] = None,\n    pending_bytes_limit: Optional[int] = None,\n    # Core arguments\n    max_msgs: int = 0,\n    # JS arguments\n    durable: Optional[str] = None,\n    config: Optional[api.ConsumerConfig] = None,\n    ordered_consumer: bool = False,\n    idle_heartbeat: Optional[float] = None,\n    flow_control: bool = False,\n    deliver_policy: Optional[api.DeliverPolicy] = None,\n    headers_only: Optional[bool] = None,\n    # custom\n    ack_first: bool = False,\n    stream: Union[str, JStream, None] = None,\n    # broker arguments\n    dependencies: Sequence[Depends] = (),\n    parser: Optional[CustomParser[Msg, NatsMessage]] = None,\n    decoder: Optional[CustomDecoder[NatsMessage]] = None,\n    middlewares: Optional[Sequence[Callable[[Msg], BaseMiddleware]]] = None,\n    filter: Filter[NatsMessage] = default_filter,\n    # AsyncAPI information\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n    **original_kwargs: Any,\n) -&gt; Callable[\n    [Callable[P_HandlerParams, T_HandlerReturn]],\n    HandlerCallWrapper[Msg, P_HandlerParams, T_HandlerReturn],\n]:\n    stream = stream_builder.stream(stream)\n\n    self._setup_log_context(\n        queue=queue,\n        subject=subject,\n        stream=stream.name if stream else None,\n    )\n    super().subscriber()\n\n    extra_options: Dict[str, Any] = {\n        \"pending_msgs_limit\": pending_msgs_limit\n        or (\n            DEFAULT_JS_SUB_PENDING_MSGS_LIMIT\n            if stream\n            else DEFAULT_SUB_PENDING_MSGS_LIMIT\n        ),\n        \"pending_bytes_limit\": pending_bytes_limit\n        or (\n            DEFAULT_JS_SUB_PENDING_BYTES_LIMIT\n            if stream\n            else DEFAULT_SUB_PENDING_BYTES_LIMIT\n        ),\n    }\n\n    if stream:\n        stream.subjects.append(subject)\n        extra_options.update(\n            {\n                \"durable\": durable,\n                \"stream\": stream.name,\n                \"config\": config,\n                \"ordered_consumer\": ordered_consumer,\n                \"idle_heartbeat\": idle_heartbeat,\n                \"flow_control\": flow_control,\n                \"deliver_policy\": deliver_policy,\n                \"headers_only\": headers_only,\n                \"manual_ack\": not ack_first,\n            }\n        )\n    else:\n        extra_options.update(\n            {\n                \"max_msgs\": max_msgs,\n            }\n        )\n\n    key = Handler.get_routing_hash(subject)\n    handler = self.handlers[key] = self.handlers.get(\n        key,\n        Handler(\n            subject=subject,\n            queue=queue,\n            stream=stream,\n            extra_options=extra_options,\n            title=title,\n            description=description,\n            log_context_builder=partial(\n                self._get_log_context,\n                stream=stream.name if stream else \"\",\n                subject=subject,\n                queue=queue,\n            ),\n        ),\n    )\n\n    def consumer_wrapper(\n        func: Callable[P_HandlerParams, T_HandlerReturn],\n    ) -&gt; HandlerCallWrapper[Msg, P_HandlerParams, T_HandlerReturn,]:\n        handler_call, dependant = self._wrap_handler(\n            func,\n            extra_dependencies=dependencies,\n            **original_kwargs,\n        )\n\n        handler.add_call(\n            handler=handler_call,\n            filter=filter,\n            middlewares=middlewares,\n            parser=parser or self._global_parser,\n            decoder=decoder or self._global_decoder,\n            dependant=dependant,\n        )\n\n        return handler_call\n\n    return consumer_wrapper\n</code></pre>"},{"location":"api/faststream/nats/fastapi/NatsRouter/","title":"NatsRouter","text":""},{"location":"api/faststream/nats/fastapi/NatsRouter/#faststream.nats.fastapi.NatsRouter","title":"faststream.nats.fastapi.NatsRouter","text":"<p>             Bases: <code>StreamRouter[Msg]</code></p> Source code in <code>faststream/nats/fastapi.py</code> <pre><code>class NatsRouter(StreamRouter[Msg]):\n    broker_class = NatsBroker\n\n    @override\n    @staticmethod\n    def _setup_log_context(  # type: ignore[override]\n        main_broker: NatsBroker,\n        including_broker: NatsBroker,\n    ) -&gt; None:\n        for h in including_broker.handlers.values():\n            main_broker._setup_log_context(\n                queue=h.queue,\n                subject=h.subject,\n                stream=h.stream.name if h.stream else None,\n            )\n</code></pre>"},{"location":"api/faststream/nats/fastapi/NatsRouter/#faststream.nats.fastapi.NatsRouter.broker","title":"broker  <code>instance-attribute</code>","text":"<pre><code>broker: NatsBroker\n</code></pre>"},{"location":"api/faststream/nats/fastapi/NatsRouter/#faststream.nats.fastapi.NatsRouter.broker_class","title":"broker_class  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>broker_class = NatsBroker\n</code></pre>"},{"location":"api/faststream/nats/fastapi/NatsRouter/#faststream.nats.fastapi.NatsRouter.add_api_mq_route","title":"add_api_mq_route","text":"<pre><code>add_api_mq_route(\n    subject: str,\n    *,\n    endpoint: Callable[..., T_HandlerReturn],\n    queue: str = \"\",\n    pending_msgs_limit: Optional[int] = None,\n    pending_bytes_limit: Optional[int] = None,\n    max_msgs: int = 0,\n    ack_first: bool = False,\n    stream: Union[str, JStream, None] = None,\n    durable: Optional[str] = None,\n    config: Optional[api.ConsumerConfig] = None,\n    ordered_consumer: bool = False,\n    idle_heartbeat: Optional[float] = None,\n    flow_control: bool = False,\n    deliver_policy: Optional[api.DeliverPolicy] = None,\n    headers_only: Optional[bool] = None,\n    dependencies: Sequence[Depends] = (),\n    parser: Optional[CustomParser[Msg, NatsMessage]] = None,\n    decoder: Optional[CustomDecoder[NatsMessage]] = None,\n    middlewares: Optional[\n        Sequence[Callable[[Msg], BaseMiddleware]]\n    ] = None,\n    filter: Filter[NatsMessage] = default_filter,\n    retry: bool = False,\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n    **__service_kwargs: Any\n) -&gt; Callable[[Msg, bool], Awaitable[T_HandlerReturn]]\n</code></pre>"},{"location":"api/faststream/nats/fastapi/NatsRouter/#faststream.nats.fastapi.NatsRouter.publisher","title":"publisher","text":"<pre><code>publisher(\n    subject: str,\n    headers: Optional[Dict[str, str]] = None,\n    reply_to: str = \"\",\n    stream: Union[str, JStream, None] = None,\n    timeout: Optional[float] = None,\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n) -&gt; Publisher\n</code></pre>"},{"location":"api/faststream/nats/fastapi/NatsRouter/#faststream.nats.fastapi.NatsRouter.subscriber","title":"subscriber","text":"<pre><code>subscriber(\n    subject: str,\n    queue: str = \"\",\n    pending_msgs_limit: Optional[int] = None,\n    pending_bytes_limit: Optional[int] = None,\n    max_msgs: int = 0,\n    ack_first: bool = False,\n    stream: Union[str, JStream, None] = None,\n    durable: Optional[str] = None,\n    config: Optional[api.ConsumerConfig] = None,\n    ordered_consumer: bool = False,\n    idle_heartbeat: Optional[float] = None,\n    flow_control: bool = False,\n    deliver_policy: Optional[api.DeliverPolicy] = None,\n    headers_only: Optional[bool] = None,\n    dependencies: Sequence[Depends] = (),\n    parser: Optional[CustomParser[Msg, NatsMessage]] = None,\n    decoder: Optional[CustomDecoder[NatsMessage]] = None,\n    middlewares: Optional[\n        Sequence[Callable[[Msg], BaseMiddleware]]\n    ] = None,\n    filter: Filter[NatsMessage] = default_filter,\n    retry: bool = False,\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n    **__service_kwargs: Any\n) -&gt; Callable[\n    [Callable[P_HandlerParams, T_HandlerReturn]],\n    HandlerCallWrapper[\n        Msg, P_HandlerParams, T_HandlerReturn\n    ],\n]\n</code></pre>"},{"location":"api/faststream/nats/handler/LogicNatsHandler/","title":"LogicNatsHandler","text":""},{"location":"api/faststream/nats/handler/LogicNatsHandler/#faststream.nats.handler.LogicNatsHandler","title":"faststream.nats.handler.LogicNatsHandler","text":"<p>             Bases: <code>AsyncHandler[Msg]</code></p> Source code in <code>faststream/nats/handler.py</code> <pre><code>class LogicNatsHandler(AsyncHandler[Msg]):\n    subscription: Optional[Union[Subscription, JetStreamContext.PushSubscription]]\n\n    def __init__(\n        self,\n        subject: str,\n        log_context_builder: Callable[[StreamMessage[Any]], Dict[str, str]],\n        queue: str = \"\",\n        stream: Optional[JStream] = None,\n        extra_options: Optional[Dict[str, Any]] = None,\n        # AsyncAPI information\n        description: Optional[str] = None,\n        title: Optional[str] = None,\n    ):\n        self.subject = subject\n        self.queue = queue\n\n        self.stream = stream\n        self.extra_options = extra_options or {}\n\n        super().__init__(\n            log_context_builder=log_context_builder,\n            description=description,\n            title=title,\n        )\n\n        self.subscription = None\n\n    def add_call(\n        self,\n        *,\n        handler: HandlerCallWrapper[Msg, P_HandlerParams, T_HandlerReturn],\n        dependant: CallModel[P_HandlerParams, T_HandlerReturn],\n        parser: Optional[CustomParser[Msg, NatsMessage]],\n        decoder: Optional[CustomDecoder[NatsMessage]],\n        filter: Filter[NatsMessage],\n        middlewares: Optional[Sequence[Callable[[Msg], BaseMiddleware]]],\n    ) -&gt; None:\n        parser_ = Parser if self.stream is None else JsParser\n        super().add_call(\n            handler=handler,\n            parser=resolve_custom_func(parser, parser_.parse_message),\n            decoder=resolve_custom_func(decoder, parser_.decode_message),\n            filter=filter,  # type: ignore[arg-type]\n            dependant=dependant,\n            middlewares=middlewares,\n        )\n\n    @override\n    async def start(self, connection: Union[Client, JetStreamContext]) -&gt; None:  # type: ignore[override]\n        self.subscription = await connection.subscribe(\n            subject=self.subject,\n            queue=self.queue,\n            cb=self.consume,  # type: ignore[arg-type]\n            **self.extra_options,\n        )\n\n    async def close(self) -&gt; None:\n        if self.subscription is not None:\n            await self.subscription.unsubscribe()\n            self.subscription = None\n\n    @staticmethod\n    def get_routing_hash(subject: str) -&gt; str:\n        return subject\n</code></pre>"},{"location":"api/faststream/nats/handler/LogicNatsHandler/#faststream.nats.handler.LogicNatsHandler.extra_options","title":"extra_options  <code>instance-attribute</code>","text":"<pre><code>extra_options = extra_options or {}\n</code></pre>"},{"location":"api/faststream/nats/handler/LogicNatsHandler/#faststream.nats.handler.LogicNatsHandler.queue","title":"queue  <code>instance-attribute</code>","text":"<pre><code>queue = queue\n</code></pre>"},{"location":"api/faststream/nats/handler/LogicNatsHandler/#faststream.nats.handler.LogicNatsHandler.stream","title":"stream  <code>instance-attribute</code>","text":"<pre><code>stream = stream\n</code></pre>"},{"location":"api/faststream/nats/handler/LogicNatsHandler/#faststream.nats.handler.LogicNatsHandler.subject","title":"subject  <code>instance-attribute</code>","text":"<pre><code>subject = subject\n</code></pre>"},{"location":"api/faststream/nats/handler/LogicNatsHandler/#faststream.nats.handler.LogicNatsHandler.subscription","title":"subscription  <code>instance-attribute</code>","text":"<pre><code>subscription: Optional[\n    Union[Subscription, JetStreamContext.PushSubscription]\n] = None\n</code></pre>"},{"location":"api/faststream/nats/handler/LogicNatsHandler/#faststream.nats.handler.LogicNatsHandler.add_call","title":"add_call","text":"<pre><code>add_call(\n    *,\n    handler: HandlerCallWrapper[\n        Msg, P_HandlerParams, T_HandlerReturn\n    ],\n    dependant: CallModel[P_HandlerParams, T_HandlerReturn],\n    parser: Optional[CustomParser[Msg, NatsMessage]],\n    decoder: Optional[CustomDecoder[NatsMessage]],\n    filter: Filter[NatsMessage],\n    middlewares: Optional[\n        Sequence[Callable[[Msg], BaseMiddleware]]\n    ]\n) -&gt; None\n</code></pre> Source code in <code>faststream/nats/handler.py</code> <pre><code>def add_call(\n    self,\n    *,\n    handler: HandlerCallWrapper[Msg, P_HandlerParams, T_HandlerReturn],\n    dependant: CallModel[P_HandlerParams, T_HandlerReturn],\n    parser: Optional[CustomParser[Msg, NatsMessage]],\n    decoder: Optional[CustomDecoder[NatsMessage]],\n    filter: Filter[NatsMessage],\n    middlewares: Optional[Sequence[Callable[[Msg], BaseMiddleware]]],\n) -&gt; None:\n    parser_ = Parser if self.stream is None else JsParser\n    super().add_call(\n        handler=handler,\n        parser=resolve_custom_func(parser, parser_.parse_message),\n        decoder=resolve_custom_func(decoder, parser_.decode_message),\n        filter=filter,  # type: ignore[arg-type]\n        dependant=dependant,\n        middlewares=middlewares,\n    )\n</code></pre>"},{"location":"api/faststream/nats/handler/LogicNatsHandler/#faststream.nats.handler.LogicNatsHandler.close","title":"close  <code>async</code>","text":"<pre><code>close() -&gt; None\n</code></pre> Source code in <code>faststream/nats/handler.py</code> <pre><code>async def close(self) -&gt; None:\n    if self.subscription is not None:\n        await self.subscription.unsubscribe()\n        self.subscription = None\n</code></pre>"},{"location":"api/faststream/nats/handler/LogicNatsHandler/#faststream.nats.handler.LogicNatsHandler.get_routing_hash","title":"get_routing_hash  <code>staticmethod</code>","text":"<pre><code>get_routing_hash(subject: str) -&gt; str\n</code></pre> Source code in <code>faststream/nats/handler.py</code> <pre><code>@staticmethod\ndef get_routing_hash(subject: str) -&gt; str:\n    return subject\n</code></pre>"},{"location":"api/faststream/nats/handler/LogicNatsHandler/#faststream.nats.handler.LogicNatsHandler.start","title":"start  <code>async</code>","text":"<pre><code>start(connection: Union[Client, JetStreamContext]) -&gt; None\n</code></pre> Source code in <code>faststream/nats/handler.py</code> <pre><code>@override\nasync def start(self, connection: Union[Client, JetStreamContext]) -&gt; None:  # type: ignore[override]\n    self.subscription = await connection.subscribe(\n        subject=self.subject,\n        queue=self.queue,\n        cb=self.consume,  # type: ignore[arg-type]\n        **self.extra_options,\n    )\n</code></pre>"},{"location":"api/faststream/nats/helpers/StreamBuilder/","title":"StreamBuilder","text":""},{"location":"api/faststream/nats/helpers/StreamBuilder/#faststream.nats.helpers.StreamBuilder","title":"faststream.nats.helpers.StreamBuilder","text":"Source code in <code>faststream/nats/helpers.py</code> <pre><code>class StreamBuilder:\n    streams: Dict[str, JStream]\n\n    def __init__(self) -&gt; None:\n        self.streams = {}\n\n    def stream(\n        self,\n        name: Union[str, JStream, None],\n        *args: Any,\n        declare: bool = True,\n        **kwargs: Any,\n    ) -&gt; Optional[JStream]:\n        stream = JStream.validate(name)\n\n        if stream is not None:\n            stream = self.streams[stream.name] = self.streams.get(stream.name, stream)\n\n        return stream\n</code></pre>"},{"location":"api/faststream/nats/helpers/StreamBuilder/#faststream.nats.helpers.StreamBuilder.streams","title":"streams  <code>instance-attribute</code>","text":"<pre><code>streams: Dict[str, JStream] = {}\n</code></pre>"},{"location":"api/faststream/nats/helpers/StreamBuilder/#faststream.nats.helpers.StreamBuilder.stream","title":"stream","text":"<pre><code>stream(\n    name: Union[str, JStream, None],\n    *args: Any,\n    declare: bool = True,\n    **kwargs: Any\n) -&gt; Optional[JStream]\n</code></pre> Source code in <code>faststream/nats/helpers.py</code> <pre><code>def stream(\n    self,\n    name: Union[str, JStream, None],\n    *args: Any,\n    declare: bool = True,\n    **kwargs: Any,\n) -&gt; Optional[JStream]:\n    stream = JStream.validate(name)\n\n    if stream is not None:\n        stream = self.streams[stream.name] = self.streams.get(stream.name, stream)\n\n    return stream\n</code></pre>"},{"location":"api/faststream/nats/js_stream/JStream/","title":"JStream","text":""},{"location":"api/faststream/nats/js_stream/JStream/#faststream.nats.js_stream.JStream","title":"faststream.nats.js_stream.JStream","text":"<p>             Bases: <code>NameRequired</code></p> Source code in <code>faststream/nats/js_stream.py</code> <pre><code>class JStream(NameRequired):\n    config: StreamConfig\n\n    subjects: List[str] = Field(default_factory=list)\n    declare: bool = Field(default=True)\n\n    def __init__(\n        self,\n        name: str,\n        *args: Any,\n        declare: bool = True,\n        **kwargs: Any,\n    ) -&gt; None:\n        super().__init__(\n            name=name,\n            declare=declare,\n            subjects=[],\n            config=StreamConfig(\n                *args,\n                name=name,\n                **kwargs,  # type: ignore[misc]\n            ),\n        )\n</code></pre>"},{"location":"api/faststream/nats/js_stream/JStream/#faststream.nats.js_stream.JStream.config","title":"config  <code>instance-attribute</code>","text":"<pre><code>config: StreamConfig\n</code></pre>"},{"location":"api/faststream/nats/js_stream/JStream/#faststream.nats.js_stream.JStream.declare","title":"declare  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>declare: bool = Field(default=True)\n</code></pre>"},{"location":"api/faststream/nats/js_stream/JStream/#faststream.nats.js_stream.JStream.subjects","title":"subjects  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>subjects: List[str] = Field(default_factory=list)\n</code></pre>"},{"location":"api/faststream/nats/message/NatsMessage/","title":"NatsMessage","text":""},{"location":"api/faststream/nats/message/NatsMessage/#faststream.nats.message.NatsMessage","title":"faststream.nats.message.NatsMessage  <code>dataclass</code>","text":"<p>             Bases: <code>StreamMessage[Msg]</code></p> Source code in <code>faststream/nats/message.py</code> <pre><code>@dataclass\nclass NatsMessage(StreamMessage[Msg]):\n    is_js: bool = True\n\n    async def ack(self, **kwargs: Any) -&gt; None:\n        if self.is_js and not self.raw_message._ackd:\n            await self.raw_message.ack()\n\n    async def nack(self, **kwargs: Any) -&gt; None:\n        if self.is_js and not self.raw_message._ackd:\n            await self.raw_message.nak()\n\n    async def reject(self, **kwargs: Any) -&gt; None:\n        if self.is_js and not self.raw_message._ackd:\n            await self.raw_message.term()\n</code></pre>"},{"location":"api/faststream/nats/message/NatsMessage/#faststream.nats.message.NatsMessage.is_js","title":"is_js  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>is_js: bool = True\n</code></pre>"},{"location":"api/faststream/nats/message/NatsMessage/#faststream.nats.message.NatsMessage.ack","title":"ack  <code>async</code>","text":"<pre><code>ack(**kwargs: Any) -&gt; None\n</code></pre> Source code in <code>faststream/nats/message.py</code> <pre><code>async def ack(self, **kwargs: Any) -&gt; None:\n    if self.is_js and not self.raw_message._ackd:\n        await self.raw_message.ack()\n</code></pre>"},{"location":"api/faststream/nats/message/NatsMessage/#faststream.nats.message.NatsMessage.nack","title":"nack  <code>async</code>","text":"<pre><code>nack(**kwargs: Any) -&gt; None\n</code></pre> Source code in <code>faststream/nats/message.py</code> <pre><code>async def nack(self, **kwargs: Any) -&gt; None:\n    if self.is_js and not self.raw_message._ackd:\n        await self.raw_message.nak()\n</code></pre>"},{"location":"api/faststream/nats/message/NatsMessage/#faststream.nats.message.NatsMessage.reject","title":"reject  <code>async</code>","text":"<pre><code>reject(**kwargs: Any) -&gt; None\n</code></pre> Source code in <code>faststream/nats/message.py</code> <pre><code>async def reject(self, **kwargs: Any) -&gt; None:\n    if self.is_js and not self.raw_message._ackd:\n        await self.raw_message.term()\n</code></pre>"},{"location":"api/faststream/nats/parser/NatsParser/","title":"NatsParser","text":""},{"location":"api/faststream/nats/parser/NatsParser/#faststream.nats.parser.NatsParser","title":"faststream.nats.parser.NatsParser","text":"Source code in <code>faststream/nats/parser.py</code> <pre><code>class NatsParser:\n    def __init__(self, is_js: bool):\n        self.is_js = is_js\n\n    async def parse_message(\n        self,\n        message: Msg,\n    ) -&gt; StreamMessage[Msg]:\n        headers = message.header or {}\n        return NatsMessage(\n            is_js=self.is_js,\n            raw_message=message,\n            body=message.data,\n            reply_to=headers.get(\"reply_to\", \"\") if self.is_js else message.reply,\n            headers=headers,\n            content_type=headers.get(\"content-type\", \"\"),\n            message_id=headers.get(\"message_id\", str(uuid4())),\n            correlation_id=headers.get(\"correlation_id\", str(uuid4())),\n        )\n\n    @staticmethod\n    async def decode_message(\n        msg: StreamMessage[Msg],\n    ) -&gt; DecodedMessage:\n        return decode_message(msg)\n</code></pre>"},{"location":"api/faststream/nats/parser/NatsParser/#faststream.nats.parser.NatsParser.is_js","title":"is_js  <code>instance-attribute</code>","text":"<pre><code>is_js = is_js\n</code></pre>"},{"location":"api/faststream/nats/parser/NatsParser/#faststream.nats.parser.NatsParser.decode_message","title":"decode_message  <code>async</code> <code>staticmethod</code>","text":"<pre><code>decode_message(msg: StreamMessage[Msg]) -&gt; DecodedMessage\n</code></pre> Source code in <code>faststream/nats/parser.py</code> <pre><code>@staticmethod\nasync def decode_message(\n    msg: StreamMessage[Msg],\n) -&gt; DecodedMessage:\n    return decode_message(msg)\n</code></pre>"},{"location":"api/faststream/nats/parser/NatsParser/#faststream.nats.parser.NatsParser.parse_message","title":"parse_message  <code>async</code>","text":"<pre><code>parse_message(message: Msg) -&gt; StreamMessage[Msg]\n</code></pre> Source code in <code>faststream/nats/parser.py</code> <pre><code>async def parse_message(\n    self,\n    message: Msg,\n) -&gt; StreamMessage[Msg]:\n    headers = message.header or {}\n    return NatsMessage(\n        is_js=self.is_js,\n        raw_message=message,\n        body=message.data,\n        reply_to=headers.get(\"reply_to\", \"\") if self.is_js else message.reply,\n        headers=headers,\n        content_type=headers.get(\"content-type\", \"\"),\n        message_id=headers.get(\"message_id\", str(uuid4())),\n        correlation_id=headers.get(\"correlation_id\", str(uuid4())),\n    )\n</code></pre>"},{"location":"api/faststream/nats/producer/NatsFastProducer/","title":"NatsFastProducer","text":""},{"location":"api/faststream/nats/producer/NatsFastProducer/#faststream.nats.producer.NatsFastProducer","title":"faststream.nats.producer.NatsFastProducer","text":"Source code in <code>faststream/nats/producer.py</code> <pre><code>class NatsFastProducer:\n    _connection: Client\n    _decoder: AsyncDecoder[Any]\n    _parser: AsyncParser[Msg, Any]\n\n    def __init__(\n        self,\n        connection: Client,\n        parser: Optional[AsyncCustomParser[Msg, NatsMessage]],\n        decoder: Optional[AsyncCustomDecoder[NatsMessage]],\n    ):\n        self._connection = connection\n        self._parser = resolve_custom_func(parser, Parser.parse_message)\n        self._decoder = resolve_custom_func(decoder, Parser.decode_message)\n\n    async def publish(\n        self,\n        message: SendableMessage,\n        subject: str,\n        reply_to: str = \"\",\n        headers: Optional[Dict[str, str]] = None,\n        correlation_id: Optional[str] = None,\n        *,\n        rpc: bool = False,\n        rpc_timeout: Optional[float] = 30.0,\n        raise_timeout: bool = False,\n    ) -&gt; Optional[DecodedMessage]:\n        payload, content_type = encode_message(message)\n\n        headers_to_send = {\n            \"content-type\": content_type or \"\",\n            \"correlation_id\": correlation_id or str(uuid4()),\n            **(headers or {}),\n        }\n\n        client = self._connection\n\n        if rpc:\n            if reply_to:\n                raise WRONG_PUBLISH_ARGS\n\n            token = client._nuid.next()\n            token.extend(token_hex(2).encode())\n            reply_to = token.decode()\n\n            future: asyncio.Future[Msg] = asyncio.Future()\n            sub = await client.subscribe(reply_to, future=future, max_msgs=1)\n            await sub.unsubscribe(limit=1)\n\n        await client.publish(\n            subject=subject,\n            payload=payload,\n            reply=reply_to,\n            headers=headers_to_send,\n        )\n\n        if rpc:\n            msg: Any = None\n            with timeout_scope(rpc_timeout, raise_timeout):\n                msg = await future\n\n            if msg:\n                if msg.headers:  # pragma: no branch\n                    if (\n                        msg.headers.get(nats.js.api.Header.STATUS)\n                        == nats.aio.client.NO_RESPONDERS_STATUS\n                    ):\n                        raise nats.errors.NoRespondersError\n                return await self._decoder(await self._parser(msg))\n\n        return None\n</code></pre>"},{"location":"api/faststream/nats/producer/NatsFastProducer/#faststream.nats.producer.NatsFastProducer.publish","title":"publish  <code>async</code>","text":"<pre><code>publish(\n    message: SendableMessage,\n    subject: str,\n    reply_to: str = \"\",\n    headers: Optional[Dict[str, str]] = None,\n    correlation_id: Optional[str] = None,\n    *,\n    rpc: bool = False,\n    rpc_timeout: Optional[float] = 30.0,\n    raise_timeout: bool = False\n) -&gt; Optional[DecodedMessage]\n</code></pre> Source code in <code>faststream/nats/producer.py</code> <pre><code>async def publish(\n    self,\n    message: SendableMessage,\n    subject: str,\n    reply_to: str = \"\",\n    headers: Optional[Dict[str, str]] = None,\n    correlation_id: Optional[str] = None,\n    *,\n    rpc: bool = False,\n    rpc_timeout: Optional[float] = 30.0,\n    raise_timeout: bool = False,\n) -&gt; Optional[DecodedMessage]:\n    payload, content_type = encode_message(message)\n\n    headers_to_send = {\n        \"content-type\": content_type or \"\",\n        \"correlation_id\": correlation_id or str(uuid4()),\n        **(headers or {}),\n    }\n\n    client = self._connection\n\n    if rpc:\n        if reply_to:\n            raise WRONG_PUBLISH_ARGS\n\n        token = client._nuid.next()\n        token.extend(token_hex(2).encode())\n        reply_to = token.decode()\n\n        future: asyncio.Future[Msg] = asyncio.Future()\n        sub = await client.subscribe(reply_to, future=future, max_msgs=1)\n        await sub.unsubscribe(limit=1)\n\n    await client.publish(\n        subject=subject,\n        payload=payload,\n        reply=reply_to,\n        headers=headers_to_send,\n    )\n\n    if rpc:\n        msg: Any = None\n        with timeout_scope(rpc_timeout, raise_timeout):\n            msg = await future\n\n        if msg:\n            if msg.headers:  # pragma: no branch\n                if (\n                    msg.headers.get(nats.js.api.Header.STATUS)\n                    == nats.aio.client.NO_RESPONDERS_STATUS\n                ):\n                    raise nats.errors.NoRespondersError\n            return await self._decoder(await self._parser(msg))\n\n    return None\n</code></pre>"},{"location":"api/faststream/nats/producer/NatsJSFastProducer/","title":"NatsJSFastProducer","text":""},{"location":"api/faststream/nats/producer/NatsJSFastProducer/#faststream.nats.producer.NatsJSFastProducer","title":"faststream.nats.producer.NatsJSFastProducer","text":"Source code in <code>faststream/nats/producer.py</code> <pre><code>class NatsJSFastProducer:\n    _connection: JetStreamContext\n    _decoder: AsyncDecoder[Any]\n    _parser: AsyncParser[Msg, Any]\n\n    def __init__(\n        self,\n        connection: JetStreamContext,\n        parser: Optional[AsyncCustomParser[Msg, NatsMessage]],\n        decoder: Optional[AsyncCustomDecoder[NatsMessage]],\n    ):\n        self._connection = connection\n        self._parser = resolve_custom_func(parser, Parser.parse_message)\n        self._decoder = resolve_custom_func(decoder, Parser.decode_message)\n\n    async def publish(\n        self,\n        message: SendableMessage,\n        subject: str,\n        headers: Optional[Dict[str, str]] = None,\n        reply_to: str = \"\",\n        correlation_id: Optional[str] = None,\n        stream: Optional[str] = None,\n        timeout: Optional[float] = None,\n        *,\n        rpc: bool = False,\n        rpc_timeout: Optional[float] = 30.0,\n        raise_timeout: bool = False,\n    ) -&gt; Optional[DecodedMessage]:\n        payload, content_type = encode_message(message)\n\n        headers_to_send = {\n            \"content-type\": content_type or \"\",\n            \"correlation_id\": correlation_id or str(uuid4()),\n            **(headers or {}),\n        }\n\n        if rpc:\n            if reply_to:\n                raise WRONG_PUBLISH_ARGS\n\n            reply_to = str(uuid4())\n            future: asyncio.Future[Msg] = asyncio.Future()\n            sub = await self._connection._nc.subscribe(\n                reply_to, future=future, max_msgs=1\n            )\n            await sub.unsubscribe(limit=1)\n\n        if reply_to:\n            headers_to_send.update({\"reply_to\": reply_to})\n\n        await self._connection.publish(\n            subject=subject,\n            payload=payload,\n            headers=headers_to_send,\n            stream=stream,\n            timeout=timeout,\n        )\n\n        if rpc:\n            msg: Any = None\n            with timeout_scope(rpc_timeout, raise_timeout):\n                msg = await future\n\n            if msg:\n                if msg.headers:  # pragma: no branch\n                    if (\n                        msg.headers.get(nats.js.api.Header.STATUS)\n                        == nats.aio.client.NO_RESPONDERS_STATUS\n                    ):\n                        raise nats.errors.NoRespondersError\n                return await self._decoder(await self._parser(msg))\n\n        return None\n</code></pre>"},{"location":"api/faststream/nats/producer/NatsJSFastProducer/#faststream.nats.producer.NatsJSFastProducer.publish","title":"publish  <code>async</code>","text":"<pre><code>publish(\n    message: SendableMessage,\n    subject: str,\n    headers: Optional[Dict[str, str]] = None,\n    reply_to: str = \"\",\n    correlation_id: Optional[str] = None,\n    stream: Optional[str] = None,\n    timeout: Optional[float] = None,\n    *,\n    rpc: bool = False,\n    rpc_timeout: Optional[float] = 30.0,\n    raise_timeout: bool = False\n) -&gt; Optional[DecodedMessage]\n</code></pre> Source code in <code>faststream/nats/producer.py</code> <pre><code>async def publish(\n    self,\n    message: SendableMessage,\n    subject: str,\n    headers: Optional[Dict[str, str]] = None,\n    reply_to: str = \"\",\n    correlation_id: Optional[str] = None,\n    stream: Optional[str] = None,\n    timeout: Optional[float] = None,\n    *,\n    rpc: bool = False,\n    rpc_timeout: Optional[float] = 30.0,\n    raise_timeout: bool = False,\n) -&gt; Optional[DecodedMessage]:\n    payload, content_type = encode_message(message)\n\n    headers_to_send = {\n        \"content-type\": content_type or \"\",\n        \"correlation_id\": correlation_id or str(uuid4()),\n        **(headers or {}),\n    }\n\n    if rpc:\n        if reply_to:\n            raise WRONG_PUBLISH_ARGS\n\n        reply_to = str(uuid4())\n        future: asyncio.Future[Msg] = asyncio.Future()\n        sub = await self._connection._nc.subscribe(\n            reply_to, future=future, max_msgs=1\n        )\n        await sub.unsubscribe(limit=1)\n\n    if reply_to:\n        headers_to_send.update({\"reply_to\": reply_to})\n\n    await self._connection.publish(\n        subject=subject,\n        payload=payload,\n        headers=headers_to_send,\n        stream=stream,\n        timeout=timeout,\n    )\n\n    if rpc:\n        msg: Any = None\n        with timeout_scope(rpc_timeout, raise_timeout):\n            msg = await future\n\n        if msg:\n            if msg.headers:  # pragma: no branch\n                if (\n                    msg.headers.get(nats.js.api.Header.STATUS)\n                    == nats.aio.client.NO_RESPONDERS_STATUS\n                ):\n                    raise nats.errors.NoRespondersError\n            return await self._decoder(await self._parser(msg))\n\n    return None\n</code></pre>"},{"location":"api/faststream/nats/publisher/LogicPublisher/","title":"LogicPublisher","text":""},{"location":"api/faststream/nats/publisher/LogicPublisher/#faststream.nats.publisher.LogicPublisher","title":"faststream.nats.publisher.LogicPublisher  <code>dataclass</code>","text":"<p>             Bases: <code>BasePublisher[Msg]</code></p> Source code in <code>faststream/nats/publisher.py</code> <pre><code>@dataclass\nclass LogicPublisher(BasePublisher[Msg]):\n    subject: str = field(default=\"\")\n    reply_to: str = field(default=\"\")\n    headers: Optional[Dict[str, str]] = field(default=None)\n    stream: Optional[JStream] = field(default=None)\n    timeout: Optional[float] = field(default=None)\n\n    _producer: Union[NatsFastProducer, NatsJSFastProducer, None] = field(\n        default=None, init=False\n    )\n\n    @override\n    async def publish(  # type: ignore[override]\n        self,\n        message: SendableMessage = \"\",\n        reply_to: str = \"\",\n        correlation_id: Optional[str] = None,\n        headers: Optional[Dict[str, str]] = None,\n        **producer_kwargs: Any,\n    ) -&gt; Optional[DecodedMessage]:\n        assert self._producer, \"Please, setup `_producer` first\"  # nosec B101\n        assert self.subject, \"You have to specify outcome subject\"  # nosec B101\n\n        extra: Dict[str, Any] = {\n            \"reply_to\": reply_to or self.reply_to,\n        }\n        if self.stream is not None:\n            extra.update(\n                {\n                    \"stream\": self.stream.name,\n                    \"timeout\": self.timeout,\n                }\n            )\n\n        return await self._producer.publish(\n            message=message,\n            subject=self.subject,\n            headers=headers or self.headers,\n            correlation_id=correlation_id,\n            **extra,\n            **producer_kwargs,\n        )\n</code></pre>"},{"location":"api/faststream/nats/publisher/LogicPublisher/#faststream.nats.publisher.LogicPublisher.headers","title":"headers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>headers: Optional[Dict[str, str]] = field(default=None)\n</code></pre>"},{"location":"api/faststream/nats/publisher/LogicPublisher/#faststream.nats.publisher.LogicPublisher.reply_to","title":"reply_to  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>reply_to: str = field(default='')\n</code></pre>"},{"location":"api/faststream/nats/publisher/LogicPublisher/#faststream.nats.publisher.LogicPublisher.stream","title":"stream  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stream: Optional[JStream] = field(default=None)\n</code></pre>"},{"location":"api/faststream/nats/publisher/LogicPublisher/#faststream.nats.publisher.LogicPublisher.subject","title":"subject  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>subject: str = field(default='')\n</code></pre>"},{"location":"api/faststream/nats/publisher/LogicPublisher/#faststream.nats.publisher.LogicPublisher.timeout","title":"timeout  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>timeout: Optional[float] = field(default=None)\n</code></pre>"},{"location":"api/faststream/nats/publisher/LogicPublisher/#faststream.nats.publisher.LogicPublisher.publish","title":"publish  <code>async</code>","text":"<pre><code>publish(\n    message: SendableMessage = \"\",\n    reply_to: str = \"\",\n    correlation_id: Optional[str] = None,\n    headers: Optional[Dict[str, str]] = None,\n    **producer_kwargs: Any\n) -&gt; Optional[DecodedMessage]\n</code></pre> Source code in <code>faststream/nats/publisher.py</code> <pre><code>@override\nasync def publish(  # type: ignore[override]\n    self,\n    message: SendableMessage = \"\",\n    reply_to: str = \"\",\n    correlation_id: Optional[str] = None,\n    headers: Optional[Dict[str, str]] = None,\n    **producer_kwargs: Any,\n) -&gt; Optional[DecodedMessage]:\n    assert self._producer, \"Please, setup `_producer` first\"  # nosec B101\n    assert self.subject, \"You have to specify outcome subject\"  # nosec B101\n\n    extra: Dict[str, Any] = {\n        \"reply_to\": reply_to or self.reply_to,\n    }\n    if self.stream is not None:\n        extra.update(\n            {\n                \"stream\": self.stream.name,\n                \"timeout\": self.timeout,\n            }\n        )\n\n    return await self._producer.publish(\n        message=message,\n        subject=self.subject,\n        headers=headers or self.headers,\n        correlation_id=correlation_id,\n        **extra,\n        **producer_kwargs,\n    )\n</code></pre>"},{"location":"api/faststream/nats/router/NatsRouter/","title":"NatsRouter","text":""},{"location":"api/faststream/nats/router/NatsRouter/#faststream.nats.router.NatsRouter","title":"faststream.nats.router.NatsRouter","text":"<p>             Bases: <code>NatsRouter</code></p> Source code in <code>faststream/nats/router.py</code> <pre><code>class NatsRouter(BaseRouter):\n    _publishers: Dict[str, Publisher]  # type: ignore[assignment]\n\n    @override\n    @staticmethod\n    def _get_publisher_key(publisher: Publisher) -&gt; str:  # type: ignore[override]\n        return publisher.subject\n\n    @override\n    @staticmethod\n    def _update_publisher_prefix(  # type: ignore[override]\n        prefix: str,\n        publisher: Publisher,\n    ) -&gt; Publisher:\n        publisher.subject = prefix + publisher.subject\n        return publisher\n\n    @override\n    def publisher(  # type: ignore[override]\n        self,\n        subject: str,\n        headers: Optional[Dict[str, str]] = None,\n        reply_to: str = \"\",\n        # AsyncAPI information\n        title: Optional[str] = None,\n        description: Optional[str] = None,\n    ) -&gt; Publisher:\n        new_publisher = self._update_publisher_prefix(\n            self.prefix,\n            Publisher(\n                subject=subject,\n                reply_to=reply_to,\n                headers=headers,\n                title=title,\n                _description=description,\n            ),\n        )\n        publisher_key = self._get_publisher_key(new_publisher)\n        publisher = self._publishers[publisher_key] = self._publishers.get(\n            publisher_key, new_publisher\n        )\n        return publisher\n</code></pre>"},{"location":"api/faststream/nats/router/NatsRouter/#faststream.nats.router.NatsRouter.publisher","title":"publisher","text":"<pre><code>publisher(\n    subject: str,\n    headers: Optional[Dict[str, str]] = None,\n    reply_to: str = \"\",\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n) -&gt; Publisher\n</code></pre> Source code in <code>faststream/nats/router.py</code> <pre><code>@override\ndef publisher(  # type: ignore[override]\n    self,\n    subject: str,\n    headers: Optional[Dict[str, str]] = None,\n    reply_to: str = \"\",\n    # AsyncAPI information\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n) -&gt; Publisher:\n    new_publisher = self._update_publisher_prefix(\n        self.prefix,\n        Publisher(\n            subject=subject,\n            reply_to=reply_to,\n            headers=headers,\n            title=title,\n            _description=description,\n        ),\n    )\n    publisher_key = self._get_publisher_key(new_publisher)\n    publisher = self._publishers[publisher_key] = self._publishers.get(\n        publisher_key, new_publisher\n    )\n    return publisher\n</code></pre>"},{"location":"api/faststream/nats/router/NatsRouter/#faststream.nats.router.NatsRouter.subscriber","title":"subscriber","text":"<pre><code>subscriber(\n    subject: str,\n    queue: str = \"\",\n    pending_msgs_limit: Optional[int] = None,\n    pending_bytes_limit: Optional[int] = None,\n    max_msgs: int = 0,\n    ack_first: bool = False,\n    stream: Union[str, JStream, None] = None,\n    durable: Optional[str] = None,\n    config: Optional[api.ConsumerConfig] = None,\n    ordered_consumer: bool = False,\n    idle_heartbeat: Optional[float] = None,\n    flow_control: bool = False,\n    deliver_policy: Optional[api.DeliverPolicy] = None,\n    headers_only: Optional[bool] = None,\n    dependencies: Sequence[Depends] = (),\n    parser: Optional[CustomParser[Msg, NatsMessage]] = None,\n    decoder: Optional[CustomDecoder[NatsMessage]] = None,\n    middlewares: Optional[\n        Sequence[Callable[[Msg], BaseMiddleware]]\n    ] = None,\n    filter: Filter[NatsMessage] = default_filter,\n    retry: bool = False,\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n    **__service_kwargs: Any\n) -&gt; Callable[\n    [Callable[P_HandlerParams, T_HandlerReturn]],\n    HandlerCallWrapper[\n        Msg, P_HandlerParams, T_HandlerReturn\n    ],\n]\n</code></pre>"},{"location":"api/faststream/nats/shared/logging/NatsLoggingMixin/","title":"NatsLoggingMixin","text":""},{"location":"api/faststream/nats/shared/logging/NatsLoggingMixin/#faststream.nats.shared.logging.NatsLoggingMixin","title":"faststream.nats.shared.logging.NatsLoggingMixin","text":"<p>             Bases: <code>LoggingMixin</code></p> Source code in <code>faststream/nats/shared/logging.py</code> <pre><code>class NatsLoggingMixin(LoggingMixin):\n    _max_queue_len: int\n    _max_subject_len: int\n\n    def __init__(\n        self,\n        *args: Any,\n        logger: Optional[logging.Logger] = access_logger,\n        log_level: int = logging.INFO,\n        log_fmt: Optional[str] = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        super().__init__(\n            *args,\n            logger=logger,\n            log_level=log_level,\n            log_fmt=log_fmt,\n            **kwargs,\n        )\n        self._max_queue_len = 0\n        self._max_stream_len = 0\n        self._max_subject_len = 4\n\n    @override\n    def _get_log_context(  # type: ignore[override]\n        self,\n        message: Optional[StreamMessage[Any]],\n        subject: str,\n        queue: str = \"\",\n        stream: str = \"\",\n    ) -&gt; AnyDict:\n        return {\n            \"subject\": subject,\n            \"queue\": queue,\n            \"stream\": stream,\n            **super()._get_log_context(message),\n        }\n\n    @property\n    def fmt(self) -&gt; str:\n        return self._fmt or (\n            \"%(asctime)s %(levelname)s - \"\n            + (f\"%(stream)-{self._max_stream_len}s | \" if self._max_stream_len else \"\")\n            + (f\"%(queue)-{self._max_queue_len}s | \" if self._max_queue_len else \"\")\n            + f\"%(subject)-{self._max_subject_len}s | \"\n            + \"%(message_id)-10s \"\n            \"- %(message)s\"\n        )\n\n    def _setup_log_context(\n        self,\n        queue: Optional[str] = None,\n        subject: Optional[str] = None,\n        stream: Optional[str] = None,\n    ) -&gt; None:\n        if subject is not None:\n            self._max_subject_len = max((self._max_subject_len, len(subject)))\n\n        if queue is not None:\n            self._max_queue_len = max((self._max_queue_len, len(queue)))\n\n        if stream is not None:\n            self._max_stream_len = max((self._max_stream_len, len(stream)))\n</code></pre>"},{"location":"api/faststream/nats/shared/logging/NatsLoggingMixin/#faststream.nats.shared.logging.NatsLoggingMixin.fmt","title":"fmt  <code>property</code>","text":"<pre><code>fmt: str\n</code></pre>"},{"location":"api/faststream/nats/shared/router/NatsRouter/","title":"NatsRouter","text":""},{"location":"api/faststream/nats/shared/router/NatsRouter/#faststream.nats.shared.router.NatsRouter","title":"faststream.nats.shared.router.NatsRouter","text":"<p>             Bases: <code>BrokerRouter[str, Msg]</code></p> Source code in <code>faststream/nats/shared/router.py</code> <pre><code>class NatsRouter(BrokerRouter[str, Msg]):\n    def __init__(\n        self,\n        prefix: str = \"\",\n        handlers: Sequence[NatsRoute[Msg, SendableMessage]] = (),\n        **kwargs: Any,\n    ):\n        for h in handlers:\n            if not (subj := h.kwargs.pop(\"subject\", None)):\n                subj, h.args = h.args[0], h.args[1:]\n            h.args = (prefix + subj, *h.args)\n        super().__init__(prefix, handlers, **kwargs)\n\n    @override\n    def subscriber(  # type: ignore[override]\n        self,\n        subject: str,\n        **broker_kwargs: Any,\n    ) -&gt; Callable[\n        [Callable[P_HandlerParams, T_HandlerReturn]],\n        HandlerCallWrapper[Msg, P_HandlerParams, T_HandlerReturn],\n    ]:\n        return self._wrap_subscriber(\n            self.prefix + subject,\n            **broker_kwargs,\n        )\n</code></pre>"},{"location":"api/faststream/nats/shared/router/NatsRouter/#faststream.nats.shared.router.NatsRouter.subscriber","title":"subscriber","text":"<pre><code>subscriber(\n    subject: str, **broker_kwargs: Any\n) -&gt; Callable[\n    [Callable[P_HandlerParams, T_HandlerReturn]],\n    HandlerCallWrapper[\n        Msg, P_HandlerParams, T_HandlerReturn\n    ],\n]\n</code></pre> Source code in <code>faststream/nats/shared/router.py</code> <pre><code>@override\ndef subscriber(  # type: ignore[override]\n    self,\n    subject: str,\n    **broker_kwargs: Any,\n) -&gt; Callable[\n    [Callable[P_HandlerParams, T_HandlerReturn]],\n    HandlerCallWrapper[Msg, P_HandlerParams, T_HandlerReturn],\n]:\n    return self._wrap_subscriber(\n        self.prefix + subject,\n        **broker_kwargs,\n    )\n</code></pre>"},{"location":"api/faststream/nats/test/FakeProducer/","title":"FakeProducer","text":""},{"location":"api/faststream/nats/test/FakeProducer/#faststream.nats.test.FakeProducer","title":"faststream.nats.test.FakeProducer","text":"<p>             Bases: <code>NatsFastProducer</code></p> Source code in <code>faststream/nats/test.py</code> <pre><code>class FakeProducer(NatsFastProducer):\n    def __init__(self, broker: NatsBroker):\n        self.broker = broker\n\n    @override\n    async def publish(  # type: ignore[override]\n        self,\n        message: SendableMessage,\n        subject: str,\n        reply_to: str = \"\",\n        headers: Optional[Dict[str, str]] = None,\n        stream: Optional[str] = None,\n        correlation_id: Optional[str] = None,\n        *,\n        rpc: bool = False,\n        rpc_timeout: Optional[float] = None,\n        raise_timeout: bool = False,\n    ) -&gt; Optional[SendableMessage]:\n        incoming = build_message(\n            message=message,\n            subject=subject,\n            headers=headers,\n            correlation_id=correlation_id,\n            reply_to=reply_to,\n        )\n\n        for handler in self.broker.handlers.values():  # pragma: no branch\n            call = False\n\n            if subject == handler.subject:\n                call = True\n\n            else:\n                call = True\n\n                for current, base in zip_longest(\n                    subject.split(\".\"),\n                    handler.subject.split(\".\"),\n                    fillvalue=None,\n                ):\n                    if base == \"&gt;\":\n                        break\n\n                    if base != \"*\" and current != base:\n                        call = False\n                        break\n\n            if call:\n                r = await call_handler(\n                    handler=handler,\n                    message=incoming,\n                    rpc=rpc,\n                    rpc_timeout=rpc_timeout,\n                    raise_timeout=raise_timeout,\n                )\n\n                if rpc:  # pragma: no branch\n                    return r\n\n        return None\n</code></pre>"},{"location":"api/faststream/nats/test/FakeProducer/#faststream.nats.test.FakeProducer.broker","title":"broker  <code>instance-attribute</code>","text":"<pre><code>broker = broker\n</code></pre>"},{"location":"api/faststream/nats/test/FakeProducer/#faststream.nats.test.FakeProducer.publish","title":"publish  <code>async</code>","text":"<pre><code>publish(\n    message: SendableMessage,\n    subject: str,\n    reply_to: str = \"\",\n    headers: Optional[Dict[str, str]] = None,\n    stream: Optional[str] = None,\n    correlation_id: Optional[str] = None,\n    *,\n    rpc: bool = False,\n    rpc_timeout: Optional[float] = None,\n    raise_timeout: bool = False\n) -&gt; Optional[SendableMessage]\n</code></pre> Source code in <code>faststream/nats/test.py</code> <pre><code>@override\nasync def publish(  # type: ignore[override]\n    self,\n    message: SendableMessage,\n    subject: str,\n    reply_to: str = \"\",\n    headers: Optional[Dict[str, str]] = None,\n    stream: Optional[str] = None,\n    correlation_id: Optional[str] = None,\n    *,\n    rpc: bool = False,\n    rpc_timeout: Optional[float] = None,\n    raise_timeout: bool = False,\n) -&gt; Optional[SendableMessage]:\n    incoming = build_message(\n        message=message,\n        subject=subject,\n        headers=headers,\n        correlation_id=correlation_id,\n        reply_to=reply_to,\n    )\n\n    for handler in self.broker.handlers.values():  # pragma: no branch\n        call = False\n\n        if subject == handler.subject:\n            call = True\n\n        else:\n            call = True\n\n            for current, base in zip_longest(\n                subject.split(\".\"),\n                handler.subject.split(\".\"),\n                fillvalue=None,\n            ):\n                if base == \"&gt;\":\n                    break\n\n                if base != \"*\" and current != base:\n                    call = False\n                    break\n\n        if call:\n            r = await call_handler(\n                handler=handler,\n                message=incoming,\n                rpc=rpc,\n                rpc_timeout=rpc_timeout,\n                raise_timeout=raise_timeout,\n            )\n\n            if rpc:  # pragma: no branch\n                return r\n\n    return None\n</code></pre>"},{"location":"api/faststream/nats/test/PatchedMessage/","title":"PatchedMessage","text":""},{"location":"api/faststream/nats/test/PatchedMessage/#faststream.nats.test.PatchedMessage","title":"faststream.nats.test.PatchedMessage","text":"<p>             Bases: <code>Msg</code></p> Source code in <code>faststream/nats/test.py</code> <pre><code>class PatchedMessage(Msg):\n    async def ack(self) -&gt; None:\n        pass\n\n    async def ack_sync(self, timeout: float = 1) -&gt; \"PatchedMessage\":\n        return self\n\n    async def nak(self, delay: Union[int, float, None] = None) -&gt; None:\n        pass\n\n    async def term(self) -&gt; None:\n        pass\n\n    async def in_progress(self) -&gt; None:\n        pass\n</code></pre>"},{"location":"api/faststream/nats/test/PatchedMessage/#faststream.nats.test.PatchedMessage.ack","title":"ack  <code>async</code>","text":"<pre><code>ack() -&gt; None\n</code></pre> Source code in <code>faststream/nats/test.py</code> <pre><code>async def ack(self) -&gt; None:\n    pass\n</code></pre>"},{"location":"api/faststream/nats/test/PatchedMessage/#faststream.nats.test.PatchedMessage.ack_sync","title":"ack_sync  <code>async</code>","text":"<pre><code>ack_sync(timeout: float = 1) -&gt; PatchedMessage\n</code></pre> Source code in <code>faststream/nats/test.py</code> <pre><code>async def ack_sync(self, timeout: float = 1) -&gt; \"PatchedMessage\":\n    return self\n</code></pre>"},{"location":"api/faststream/nats/test/PatchedMessage/#faststream.nats.test.PatchedMessage.in_progress","title":"in_progress  <code>async</code>","text":"<pre><code>in_progress() -&gt; None\n</code></pre> Source code in <code>faststream/nats/test.py</code> <pre><code>async def in_progress(self) -&gt; None:\n    pass\n</code></pre>"},{"location":"api/faststream/nats/test/PatchedMessage/#faststream.nats.test.PatchedMessage.nak","title":"nak  <code>async</code>","text":"<pre><code>nak(delay: Union[int, float, None] = None) -&gt; None\n</code></pre> Source code in <code>faststream/nats/test.py</code> <pre><code>async def nak(self, delay: Union[int, float, None] = None) -&gt; None:\n    pass\n</code></pre>"},{"location":"api/faststream/nats/test/PatchedMessage/#faststream.nats.test.PatchedMessage.term","title":"term  <code>async</code>","text":"<pre><code>term() -&gt; None\n</code></pre> Source code in <code>faststream/nats/test.py</code> <pre><code>async def term(self) -&gt; None:\n    pass\n</code></pre>"},{"location":"api/faststream/nats/test/TestNatsBroker/","title":"TestNatsBroker","text":""},{"location":"api/faststream/nats/test/TestNatsBroker/#faststream.nats.test.TestNatsBroker","title":"faststream.nats.test.TestNatsBroker","text":"Source code in <code>faststream/nats/test.py</code> <pre><code>class TestNatsBroker:\n    # This is set so pytest ignores this class\n    __test__ = False\n\n    def __init__(\n        self,\n        broker: NatsBroker,\n        with_real: bool = False,\n        connect_only: bool = False,\n    ):\n        self.with_real = with_real\n        self.broker = broker\n        self.connect_only = connect_only\n\n    @asynccontextmanager\n    async def _create_ctx(self) -&gt; AsyncGenerator[NatsBroker, None]:\n        if not self.with_real:\n            self.broker.start = AsyncMock(wraps=partial(_fake_start, self.broker))  # type: ignore[method-assign]\n            self.broker._connect = MethodType(_fake_connect, self.broker)  # type: ignore[method-assign]\n            self.broker.close = AsyncMock()  # type: ignore[method-assign]\n        else:\n            _fake_start(self.broker)\n\n        async with self.broker:\n            try:\n                if not self.connect_only:\n                    await self.broker.start()\n                yield self.broker\n            finally:\n                _fake_close(self.broker)\n\n    async def __aenter__(self) -&gt; NatsBroker:\n        self._ctx = self._create_ctx()\n        return await self._ctx.__aenter__()\n\n    async def __aexit__(self, *args: Any) -&gt; None:\n        await self._ctx.__aexit__(*args)\n</code></pre>"},{"location":"api/faststream/nats/test/TestNatsBroker/#faststream.nats.test.TestNatsBroker.broker","title":"broker  <code>instance-attribute</code>","text":"<pre><code>broker = broker\n</code></pre>"},{"location":"api/faststream/nats/test/TestNatsBroker/#faststream.nats.test.TestNatsBroker.connect_only","title":"connect_only  <code>instance-attribute</code>","text":"<pre><code>connect_only = connect_only\n</code></pre>"},{"location":"api/faststream/nats/test/TestNatsBroker/#faststream.nats.test.TestNatsBroker.with_real","title":"with_real  <code>instance-attribute</code>","text":"<pre><code>with_real = with_real\n</code></pre>"},{"location":"api/faststream/nats/test/build_message/","title":"Build message","text":""},{"location":"api/faststream/nats/test/build_message/#faststream.nats.test.build_message","title":"faststream.nats.test.build_message","text":"<pre><code>build_message(\n    message: SendableMessage,\n    subject: str,\n    *,\n    reply_to: str = \"\",\n    correlation_id: Optional[str] = None,\n    headers: Optional[Dict[str, Any]] = None\n) -&gt; PatchedMessage\n</code></pre> Source code in <code>faststream/nats/test.py</code> <pre><code>def build_message(\n    message: SendableMessage,\n    subject: str,\n    *,\n    reply_to: str = \"\",\n    correlation_id: Optional[str] = None,\n    headers: Optional[Dict[str, Any]] = None,\n) -&gt; PatchedMessage:\n    msg, content_type = encode_message(message)\n    return PatchedMessage(\n        _client=None,  # type: ignore[arg-type]\n        subject=subject,\n        reply=reply_to,\n        data=msg,\n        headers={\n            \"content-type\": content_type or \"\",\n            \"correlation_id\": correlation_id or str(uuid4()),\n            **(headers or {}),\n        },\n    )\n</code></pre>"},{"location":"api/faststream/rabbit/asyncapi/Handler/","title":"Handler","text":""},{"location":"api/faststream/rabbit/asyncapi/Handler/#faststream.rabbit.asyncapi.Handler","title":"faststream.rabbit.asyncapi.Handler","text":"<p>             Bases: <code>RMQAsyncAPIChannel</code>, <code>LogicHandler</code></p> <p>A class that serves as a handler for RMQAsyncAPIChannel and LogicHandler.</p> METHOD DESCRIPTION <code>- name</code> <p>Returns the name of the handler.</p> <code>- get_payloads</code> <p>Returns a list of payloads.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/rabbit/asyncapi.py</code> <pre><code>class Handler(RMQAsyncAPIChannel, LogicHandler):\n    \"\"\"A class that serves as a handler for RMQAsyncAPIChannel and LogicHandler.\n\n    Methods:\n        - name(): Returns the name of the handler.\n        - get_payloads(): Returns a list of payloads.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    @property\n    def name(self) -&gt; str:\n        original = super().name\n\n        name: str\n        queue_ = to_camelcase(self.queue.name)\n        if original is True:\n            if not self.call_name.lower().endswith(queue_.lower()):\n                name = f\"{self.call_name}{queue_}\"\n            else:\n                name = self.call_name\n        elif original is False:  # pragma: no cover\n            name = f\"Handler{queue_}\"\n        else:\n            name = original\n\n        return name\n\n    def get_payloads(self) -&gt; List[AnyDict]:\n        payloads = []\n        for _, _, _, _, _, dep in self.calls:\n            body = parse_handler_params(dep, prefix=self.name)\n            payloads.append(body)\n\n        return payloads\n</code></pre>"},{"location":"api/faststream/rabbit/asyncapi/Handler/#faststream.rabbit.asyncapi.Handler.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"api/faststream/rabbit/asyncapi/Handler/#faststream.rabbit.asyncapi.Handler.get_payloads","title":"get_payloads","text":"<pre><code>get_payloads() -&gt; List[AnyDict]\n</code></pre> Source code in <code>faststream/rabbit/asyncapi.py</code> <pre><code>def get_payloads(self) -&gt; List[AnyDict]:\n    payloads = []\n    for _, _, _, _, _, dep in self.calls:\n        body = parse_handler_params(dep, prefix=self.name)\n        payloads.append(body)\n\n    return payloads\n</code></pre>"},{"location":"api/faststream/rabbit/asyncapi/Publisher/","title":"Publisher","text":""},{"location":"api/faststream/rabbit/asyncapi/Publisher/#faststream.rabbit.asyncapi.Publisher","title":"faststream.rabbit.asyncapi.Publisher","text":"<p>             Bases: <code>RMQAsyncAPIChannel</code>, <code>LogicPublisher</code></p> <p>A class representing a publisher.</p> METHOD DESCRIPTION <code>get_payloads </code> <p>Get the payloads for the publisher</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/rabbit/asyncapi.py</code> <pre><code>class Publisher(RMQAsyncAPIChannel, LogicPublisher):\n    \"\"\"A class representing a publisher.\n\n    Attributes:\n        name : name of the publisher\n\n    Methods:\n        get_payloads : Get the payloads for the publisher\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    @property\n    def name(self) -&gt; str:\n        return self.title or f\"{self.queue.name.title()}Publisher\"\n\n    def get_payloads(self) -&gt; List[AnyDict]:\n        payloads = []\n        for call in self.calls:\n            call_model = build_call_model(call)\n            body = get_response_schema(\n                call_model,\n                prefix=to_camelcase(call_model.call_name),\n            )\n            if body:\n                payloads.append(body)\n\n        return payloads\n</code></pre>"},{"location":"api/faststream/rabbit/asyncapi/Publisher/#faststream.rabbit.asyncapi.Publisher.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"api/faststream/rabbit/asyncapi/Publisher/#faststream.rabbit.asyncapi.Publisher.get_payloads","title":"get_payloads","text":"<pre><code>get_payloads() -&gt; List[AnyDict]\n</code></pre> Source code in <code>faststream/rabbit/asyncapi.py</code> <pre><code>def get_payloads(self) -&gt; List[AnyDict]:\n    payloads = []\n    for call in self.calls:\n        call_model = build_call_model(call)\n        body = get_response_schema(\n            call_model,\n            prefix=to_camelcase(call_model.call_name),\n        )\n        if body:\n            payloads.append(body)\n\n    return payloads\n</code></pre>"},{"location":"api/faststream/rabbit/asyncapi/RMQAsyncAPIChannel/","title":"RMQAsyncAPIChannel","text":""},{"location":"api/faststream/rabbit/asyncapi/RMQAsyncAPIChannel/#faststream.rabbit.asyncapi.RMQAsyncAPIChannel","title":"faststream.rabbit.asyncapi.RMQAsyncAPIChannel","text":"<p>             Bases: <code>AsyncAPIOperation</code>, <code>BaseRMQInformation</code></p> <p>A class representing an RMQAsyncAPIChannel.</p> METHOD DESCRIPTION <code>get_payloads</code> <p>Abstract method that returns a list of dictionaries representing the payloads.</p> <code>schema</code> <p>Returns a dictionary representing the schema of the channel.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/rabbit/asyncapi.py</code> <pre><code>class RMQAsyncAPIChannel(AsyncAPIOperation, BaseRMQInformation):\n    \"\"\"A class representing an RMQAsyncAPIChannel.\n\n    Methods:\n        get_payloads: Abstract method that returns a list of dictionaries representing the payloads.\n        schema: Returns a dictionary representing the schema of the channel.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    @abstractmethod\n    def get_payloads(self) -&gt; List[AnyDict]:\n        raise NotImplementedError()\n\n    def schema(self) -&gt; Dict[str, Channel]:\n        payloads = self.get_payloads()\n\n        return {\n            self.name: Channel(\n                description=self.description,  # type: ignore[attr-defined]\n                subscribe=Operation(\n                    bindings=OperationBinding(\n                        amqp=amqp.OperationBinding(\n                            cc=self.queue.name,\n                        ),\n                    )\n                    if _is_exchange(self.exchange)\n                    else None,\n                    message=Message(\n                        title=f\"{self.name}Message\",\n                        payload=resolve_payloads(payloads),\n                        correlationId=CorrelationId(\n                            location=\"$message.header#/correlation_id\"\n                        ),\n                    ),\n                ),\n                bindings=ChannelBinding(\n                    amqp=amqp.ChannelBinding(\n                        **{\n                            \"is\": \"routingKey\",  # type: ignore\n                            \"queue\": amqp.Queue(\n                                name=self.queue.name,\n                                durable=self.queue.durable,\n                                exclusive=self.queue.exclusive,\n                                autoDelete=self.queue.auto_delete,\n                            )\n                            if _is_exchange(self.exchange)\n                            else None,\n                            \"exchange\": (\n                                amqp.Exchange(type=\"default\")\n                                if self.exchange is None\n                                else amqp.Exchange(\n                                    type=self.exchange.type,  # type: ignore\n                                    name=self.exchange.name,\n                                    durable=self.exchange.durable,\n                                    autoDelete=self.exchange.auto_delete,\n                                )\n                            ),\n                        }\n                    )\n                ),\n            )\n        }\n</code></pre>"},{"location":"api/faststream/rabbit/asyncapi/RMQAsyncAPIChannel/#faststream.rabbit.asyncapi.RMQAsyncAPIChannel.get_payloads","title":"get_payloads  <code>abstractmethod</code>","text":"<pre><code>get_payloads() -&gt; List[AnyDict]\n</code></pre> Source code in <code>faststream/rabbit/asyncapi.py</code> <pre><code>@abstractmethod\ndef get_payloads(self) -&gt; List[AnyDict]:\n    raise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/rabbit/asyncapi/RMQAsyncAPIChannel/#faststream.rabbit.asyncapi.RMQAsyncAPIChannel.schema","title":"schema","text":"<pre><code>schema() -&gt; Dict[str, Channel]\n</code></pre> Source code in <code>faststream/rabbit/asyncapi.py</code> <pre><code>def schema(self) -&gt; Dict[str, Channel]:\n    payloads = self.get_payloads()\n\n    return {\n        self.name: Channel(\n            description=self.description,  # type: ignore[attr-defined]\n            subscribe=Operation(\n                bindings=OperationBinding(\n                    amqp=amqp.OperationBinding(\n                        cc=self.queue.name,\n                    ),\n                )\n                if _is_exchange(self.exchange)\n                else None,\n                message=Message(\n                    title=f\"{self.name}Message\",\n                    payload=resolve_payloads(payloads),\n                    correlationId=CorrelationId(\n                        location=\"$message.header#/correlation_id\"\n                    ),\n                ),\n            ),\n            bindings=ChannelBinding(\n                amqp=amqp.ChannelBinding(\n                    **{\n                        \"is\": \"routingKey\",  # type: ignore\n                        \"queue\": amqp.Queue(\n                            name=self.queue.name,\n                            durable=self.queue.durable,\n                            exclusive=self.queue.exclusive,\n                            autoDelete=self.queue.auto_delete,\n                        )\n                        if _is_exchange(self.exchange)\n                        else None,\n                        \"exchange\": (\n                            amqp.Exchange(type=\"default\")\n                            if self.exchange is None\n                            else amqp.Exchange(\n                                type=self.exchange.type,  # type: ignore\n                                name=self.exchange.name,\n                                durable=self.exchange.durable,\n                                autoDelete=self.exchange.auto_delete,\n                            )\n                        ),\n                    }\n                )\n            ),\n        )\n    }\n</code></pre>"},{"location":"api/faststream/rabbit/broker/RabbitBroker/","title":"RabbitBroker","text":""},{"location":"api/faststream/rabbit/broker/RabbitBroker/#faststream.rabbit.broker.RabbitBroker","title":"faststream.rabbit.broker.RabbitBroker","text":"<p>             Bases: <code>RabbitLoggingMixin</code>, <code>BrokerAsyncUsecase[IncomingMessage, RobustConnection]</code></p> <p>A RabbitMQ broker for FastAPI applications.</p> <p>This class extends the base <code>BrokerAsyncUsecase</code> and provides asynchronous support for RabbitMQ as a message broker.</p> PARAMETER  DESCRIPTION <code>url</code> <p>The RabbitMQ connection URL. Defaults to \"amqp://guest:guest@localhost:5672/\".</p> <p> TYPE: <code>Union[str, URL, None]</code> DEFAULT: <code>'amqp://guest:guest@localhost:5672/'</code> </p> <code>max_consumers</code> <p>Maximum number of consumers to limit message consumption. Defaults to None.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>protocol</code> <p>The protocol to use (e.g., \"amqp\"). Defaults to \"amqp\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'amqp'</code> </p> <code>protocol_version</code> <p>The protocol version to use (e.g., \"0.9.1\"). Defaults to \"0.9.1\".</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'0.9.1'</code> </p> <code>**kwargs</code> <p>Additional keyword arguments.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>faststream/rabbit/broker.py</code> <pre><code>class RabbitBroker(\n    RabbitLoggingMixin,\n    BrokerAsyncUsecase[aio_pika.IncomingMessage, aio_pika.RobustConnection],\n):\n    \"\"\"\n    A RabbitMQ broker for FastAPI applications.\n\n    This class extends the base `BrokerAsyncUsecase` and provides asynchronous support for RabbitMQ as a message broker.\n\n    Args:\n        url (Union[str, URL, None], optional): The RabbitMQ connection URL. Defaults to \"amqp://guest:guest@localhost:5672/\".\n        max_consumers (Optional[int], optional): Maximum number of consumers to limit message consumption. Defaults to None.\n        protocol (str, optional): The protocol to use (e.g., \"amqp\"). Defaults to \"amqp\".\n        protocol_version (Optional[str], optional): The protocol version to use (e.g., \"0.9.1\"). Defaults to \"0.9.1\".\n        **kwargs: Additional keyword arguments.\n\n    Attributes:\n        handlers (Dict[int, Handler]): A dictionary of message handlers.\n        _publishers (Dict[int, Publisher]): A dictionary of message publishers.\n        declarer (Optional[RabbitDeclarer]): The RabbitMQ declarer instance.\n        _producer (Optional[AioPikaFastProducer]): The RabbitMQ producer instance.\n        _connection (Optional[aio_pika.RobustConnection]): The RabbitMQ connection instance.\n        _channel (Optional[aio_pika.RobustChannel]): The RabbitMQ channel instance.\n    \"\"\"\n\n    handlers: Dict[int, Handler]  # type: ignore[assignment]\n    _publishers: Dict[int, Publisher]  # type: ignore[assignment]\n\n    declarer: Optional[RabbitDeclarer]\n    _producer: Optional[AioPikaFastProducer]\n    _connection: Optional[aio_pika.RobustConnection]\n    _channel: Optional[aio_pika.RobustChannel]\n\n    def __init__(\n        self,\n        url: Union[str, URL, None] = \"amqp://guest:guest@localhost:5672/\",\n        *,\n        max_consumers: Optional[int] = None,\n        protocol: str = \"amqp\",\n        protocol_version: Optional[str] = \"0.9.1\",\n        security: Optional[BaseSecurity] = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"\n        Initialize the RabbitBroker.\n\n        Args:\n            url (Union[str, URL, None], optional): The RabbitMQ connection URL. Defaults to \"amqp://guest:guest@localhost:5672/\".\n            max_consumers (Optional[int], optional): Maximum number of consumers to limit message consumption. Defaults to None.\n            protocol (str, optional): The protocol to use (e.g., \"amqp\"). Defaults to \"amqp\".\n            protocol_version (Optional[str], optional): The protocol version to use (e.g., \"0.9.1\"). Defaults to \"0.9.1\".\n            **kwargs: Additional keyword arguments.\n        \"\"\"\n        super().__init__(\n            url=url,\n            protocol=protocol,\n            protocol_version=protocol_version,\n            security=security,\n            **kwargs,\n        )\n\n        self._max_consumers = max_consumers\n\n        self._channel = None\n        self.declarer = None\n        self._producer = None\n\n    async def _close(\n        self,\n        exc_type: Optional[Type[BaseException]] = None,\n        exc_val: Optional[BaseException] = None,\n        exec_tb: Optional[TracebackType] = None,\n    ) -&gt; None:\n        \"\"\"\n        Close the RabbitMQ broker.\n\n        Args:\n            exc_type (Optional[Type[BaseException]], optional): The type of exception. Defaults to None.\n            exc_val (Optional[BaseException], optional): The exception instance. Defaults to None.\n            exec_tb (Optional[TracebackType], optional): The traceback. Defaults to None.\n        \"\"\"\n        if self._channel is not None:\n            await self._channel.close()\n            self._channel = None\n\n        if self.declarer is not None:\n            self.declarer = None\n\n        if self._producer is not None:\n            self._producer = None\n\n        if self._connection is not None:  # pragma: no branch\n            await self._connection.close()\n\n        await super()._close(exc_type, exc_val, exec_tb)\n\n    async def connect(self, *args: Any, **kwargs: Any) -&gt; aio_pika.RobustConnection:\n        \"\"\"\n        Connect to the RabbitMQ server.\n\n        Args:\n            *args: Additional positional arguments.\n            **kwargs: Additional keyword arguments.\n\n        Returns:\n            aio_pika.RobustConnection: The RabbitMQ connection instance.\n        \"\"\"\n        connection = await super().connect(*args, **kwargs)\n        for p in self._publishers.values():\n            p._producer = self._producer\n        return connection\n\n    async def _connect(\n        self,\n        **kwargs: Any,\n    ) -&gt; aio_pika.RobustConnection:\n        \"\"\"\n        Connect to the RabbitMQ server.\n\n        Args:\n            **kwargs: Additional keyword arguments.\n\n        Returns:\n            aio_pika.RobustConnection: The RabbitMQ connection instance.\n        \"\"\"\n        connection = cast(\n            aio_pika.RobustConnection,\n            await aio_pika.connect_robust(**kwargs, **parse_security(self.security)),\n        )\n\n        if self._channel is None:  # pragma: no branch\n            max_consumers = self._max_consumers\n            channel = self._channel = cast(\n                aio_pika.RobustChannel,\n                await connection.channel(),\n            )\n\n            declarer = self.declarer = RabbitDeclarer(channel)\n            self.declarer.queues[RABBIT_REPLY] = cast(\n                aio_pika.RobustQueue,\n                await channel.get_queue(RABBIT_REPLY, ensure=False),\n            )\n\n            self._producer = AioPikaFastProducer(\n                channel,\n                declarer,\n                decoder=self._global_decoder,\n                parser=self._global_parser,\n            )\n\n            if max_consumers:\n                c = self._get_log_context(None, RabbitQueue(\"\"), RabbitExchange(\"\"))\n                self._log(f\"Set max consumers to {max_consumers}\", extra=c)\n                await channel.set_qos(prefetch_count=int(max_consumers))\n\n        return connection\n\n    async def start(self) -&gt; None:\n        \"\"\"\n        Start the RabbitMQ broker.\n\n        Raises:\n            RuntimeError: If the declarer is not initialized in the `connect` method.\n        \"\"\"\n        context.set_local(\n            \"log_context\",\n            self._get_log_context(None, RabbitQueue(\"\"), RabbitExchange(\"\")),\n        )\n\n        await super().start()\n        assert (  # nosec B101\n            self.declarer\n        ), \"Declarer should be initialized in `connect` method\"\n\n        for handler in self.handlers.values():\n            c = self._get_log_context(None, handler.queue, handler.exchange)\n            self._log(f\"`{handler.name}` waiting for messages\", extra=c)\n            await handler.start(self.declarer)\n\n    @override\n    def subscriber(  # type: ignore[override]\n        self,\n        queue: Union[str, RabbitQueue],\n        exchange: Union[str, RabbitExchange, None] = None,\n        *,\n        consume_args: Optional[AnyDict] = None,\n        # broker arguments\n        dependencies: Sequence[Depends] = (),\n        parser: Optional[CustomParser[aio_pika.IncomingMessage, RabbitMessage]] = None,\n        decoder: Optional[CustomDecoder[RabbitMessage]] = None,\n        middlewares: Optional[\n            Sequence[Callable[[aio_pika.IncomingMessage], BaseMiddleware]]\n        ] = None,\n        filter: Filter[RabbitMessage] = default_filter,\n        # AsyncAPI information\n        title: Optional[str] = None,\n        description: Optional[str] = None,\n        **original_kwargs: Any,\n    ) -&gt; Callable[\n        [Callable[P_HandlerParams, T_HandlerReturn]],\n        HandlerCallWrapper[aio_pika.IncomingMessage, P_HandlerParams, T_HandlerReturn],\n    ]:\n        \"\"\"\n        Decorator to define a message subscriber.\n\n        Args:\n            queue (Union[str, RabbitQueue]): The name of the RabbitMQ queue.\n            exchange (Union[str, RabbitExchange, None], optional): The name of the RabbitMQ exchange. Defaults to None.\n            consume_args (Optional[AnyDict], optional): Additional arguments for message consumption.\n            title (Optional[str]): Title for AsyncAPI docs.\n            description (Optional[str]): Description for AsyncAPI docs.\n\n        Returns:\n            Callable: A decorator function for defining message subscribers.\n        \"\"\"\n        super().subscriber()\n\n        r_queue = RabbitQueue.validate(queue)\n        r_exchange = RabbitExchange.validate(exchange)\n\n        self._setup_log_context(r_queue, r_exchange)\n\n        key = get_routing_hash(r_queue, r_exchange)\n        handler = self.handlers.get(\n            key,\n            Handler(\n                log_context_builder=partial(\n                    self._get_log_context, queue=r_queue, exchange=r_exchange\n                ),\n                queue=r_queue,\n                exchange=r_exchange,\n                consume_args=consume_args,\n                description=description,\n                title=title,\n            ),\n        )\n\n        self.handlers[key] = handler\n\n        def consumer_wrapper(\n            func: Callable[P_HandlerParams, T_HandlerReturn],\n        ) -&gt; HandlerCallWrapper[\n            aio_pika.IncomingMessage, P_HandlerParams, T_HandlerReturn\n        ]:\n            \"\"\"Wraps a consumer function with additional functionality.\n\n            Args:\n                func: The consumer function to be wrapped.\n\n            Returns:\n                The wrapped consumer function.\n\n            Raises:\n                NotImplementedError: If silent animals are not supported.\n            !!! note\n\n                The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n            \"\"\"\n            handler_call, dependant = self._wrap_handler(\n                func,\n                extra_dependencies=dependencies,\n                **original_kwargs,\n            )\n\n            handler.add_call(\n                handler=handler_call,\n                filter=filter,\n                middlewares=middlewares,\n                parser=parser or self._global_parser,\n                decoder=decoder or self._global_decoder,\n                dependant=dependant,\n            )\n\n            return handler_call\n\n        return consumer_wrapper\n\n    @override\n    def publisher(  # type: ignore[override]\n        self,\n        queue: Union[RabbitQueue, str] = \"\",\n        exchange: Union[RabbitExchange, str, None] = None,\n        *,\n        routing_key: str = \"\",\n        mandatory: bool = True,\n        immediate: bool = False,\n        timeout: TimeoutType = None,\n        persist: bool = False,\n        reply_to: Optional[str] = None,\n        # AsyncAPI information\n        title: Optional[str] = None,\n        description: Optional[str] = None,\n        **message_kwargs: Any,\n    ) -&gt; Publisher:\n        \"\"\"\n        Define a message publisher.\n\n        Args:\n            queue (Union[RabbitQueue, str], optional): The name of the RabbitMQ queue. Defaults to \"\".\n            exchange (Union[RabbitExchange, str, None], optional): The name of the RabbitMQ exchange. Defaults to None.\n            routing_key (str, optional): The routing key for messages. Defaults to \"\".\n            mandatory (bool, optional): Whether the message is mandatory. Defaults to True.\n            immediate (bool, optional): Whether the message should be sent immediately. Defaults to False.\n            timeout (TimeoutType, optional): Timeout for message publishing. Defaults to None.\n            persist (bool, optional): Whether to persist messages. Defaults to False.\n            reply_to (Optional[str], optional): The reply-to queue name. Defaults to None.\n            title (Optional[str]): Title for AsyncAPI docs.\n            description (Optional[str]): Description for AsyncAPI docs.\n            **message_kwargs (Any): Additional message properties and content.\n\n        Returns:\n            Publisher: A message publisher instance.\n        \"\"\"\n        q, ex = RabbitQueue.validate(queue), RabbitExchange.validate(exchange)\n        key = get_routing_hash(q, ex)\n        publisher = self._publishers.get(\n            key,\n            Publisher(\n                title=title,\n                queue=q,\n                exchange=ex,\n                routing_key=routing_key,\n                mandatory=mandatory,\n                immediate=immediate,\n                timeout=timeout,\n                persist=persist,\n                reply_to=reply_to,\n                message_kwargs=message_kwargs,\n                _description=description,\n            ),\n        )\n        super().publisher(key, publisher)\n        return publisher\n\n    @override\n    async def publish(  # type: ignore[override]\n        self,\n        *args: Any,\n        **kwargs: Any,\n    ) -&gt; Union[aiormq.abc.ConfirmationFrameType, SendableMessage]:\n        \"\"\"\n        Publish a message to the RabbitMQ broker.\n\n        Args:\n            *args: Additional positional arguments.\n            **kwargs: Additional keyword arguments.\n\n        Returns:\n            Union[aiormq.abc.ConfirmationFrameType, SendableMessage]: The confirmation frame or the response message.\n        \"\"\"\n\n        assert self._producer, \"RabbitBroker channel is not started yet\"  # nosec B101\n        return await self._producer.publish(*args, **kwargs)\n\n    def _process_message(\n        self,\n        func: Callable[\n            [StreamMessage[aio_pika.IncomingMessage]], Awaitable[T_HandlerReturn]\n        ],\n        watcher: BaseWatcher,\n    ) -&gt; Callable[\n        [StreamMessage[aio_pika.IncomingMessage]],\n        Awaitable[WrappedReturn[T_HandlerReturn]],\n    ]:\n        \"\"\"\n        Process a message using the provided handler function.\n\n        Args:\n            func (Callable): The handler function for processing the message.\n            watcher (BaseWatcher): The message watcher for tracking message processing.\n\n        Returns:\n            Callable: A wrapper function for processing messages.\n        \"\"\"\n\n        @wraps(func)\n        async def process_wrapper(\n            message: RabbitMessage,\n        ) -&gt; WrappedReturn[T_HandlerReturn]:\n            \"\"\"Asynchronously process a message and wrap the return value.\n\n            Args:\n                message: The RabbitMessage to process.\n\n            Returns:\n                A tuple containing the return value of the handler function and an optional AsyncPublisherProtocol.\n\n            Raises:\n                AssertionError: If the code reaches an unreachable point.\n            !!! note\n\n                The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n            \"\"\"\n            async with WatcherContext(watcher, message):\n                r = await self._execute_handler(func, message)\n\n                pub_response: Optional[AsyncPublisherProtocol]\n                if message.reply_to:\n                    pub_response = FakePublisher(\n                        partial(self.publish, routing_key=message.reply_to)\n                    )\n                else:\n                    pub_response = None\n\n                return r, pub_response\n\n        return process_wrapper\n\n    async def declare_queue(\n        self,\n        queue: RabbitQueue,\n    ) -&gt; aio_pika.RobustQueue:\n        \"\"\"\n        Declare a RabbitMQ queue.\n\n        Args:\n            queue (RabbitQueue): The RabbitMQ queue to declare.\n\n        Returns:\n            aio_pika.RobustQueue: The declared RabbitMQ queue.\n\n        Raises:\n            RuntimeError: If the declarer is not initialized in the `connect` method.\n        \"\"\"\n        assert (  # nosec B101\n            self.declarer\n        ), \"Declarer should be initialized in `connect` method\"\n        return await self.declarer.declare_queue(queue)\n\n    async def declare_exchange(\n        self,\n        exchange: RabbitExchange,\n    ) -&gt; aio_pika.RobustExchange:\n        \"\"\"\n        Declare a RabbitMQ exchange.\n\n        Args:\n            exchange (RabbitExchange): The RabbitMQ exchange to declare.\n\n        Returns:\n            aio_pika.RobustExchange: The declared RabbitMQ exchange.\n\n        Raises:\n            RuntimeError: If the declarer is not initialized in the `connect` method.\n        \"\"\"\n        assert (  # nosec B101\n            self.declarer\n        ), \"Declarer should be initialized in `connect` method\"\n        return await self.declarer.declare_exchange(exchange)\n</code></pre>"},{"location":"api/faststream/rabbit/broker/RabbitBroker/#faststream.rabbit.broker.RabbitBroker.declarer","title":"declarer  <code>instance-attribute</code>","text":"<pre><code>declarer: Optional[RabbitDeclarer] = None\n</code></pre>"},{"location":"api/faststream/rabbit/broker/RabbitBroker/#faststream.rabbit.broker.RabbitBroker.handlers","title":"handlers  <code>instance-attribute</code>","text":"<pre><code>handlers: Dict[int, Handler]\n</code></pre>"},{"location":"api/faststream/rabbit/broker/RabbitBroker/#faststream.rabbit.broker.RabbitBroker.connect","title":"connect  <code>async</code>","text":"<pre><code>connect(\n    *args: Any, **kwargs: Any\n) -&gt; aio_pika.RobustConnection\n</code></pre> <p>Connect to the RabbitMQ server.</p> PARAMETER  DESCRIPTION <code>*args</code> <p>Additional positional arguments.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>()</code> </p> <code>**kwargs</code> <p>Additional keyword arguments.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>RobustConnection</code> <p>aio_pika.RobustConnection: The RabbitMQ connection instance.</p> Source code in <code>faststream/rabbit/broker.py</code> <pre><code>async def connect(self, *args: Any, **kwargs: Any) -&gt; aio_pika.RobustConnection:\n    \"\"\"\n    Connect to the RabbitMQ server.\n\n    Args:\n        *args: Additional positional arguments.\n        **kwargs: Additional keyword arguments.\n\n    Returns:\n        aio_pika.RobustConnection: The RabbitMQ connection instance.\n    \"\"\"\n    connection = await super().connect(*args, **kwargs)\n    for p in self._publishers.values():\n        p._producer = self._producer\n    return connection\n</code></pre>"},{"location":"api/faststream/rabbit/broker/RabbitBroker/#faststream.rabbit.broker.RabbitBroker.declare_exchange","title":"declare_exchange  <code>async</code>","text":"<pre><code>declare_exchange(\n    exchange: RabbitExchange,\n) -&gt; aio_pika.RobustExchange\n</code></pre> <p>Declare a RabbitMQ exchange.</p> PARAMETER  DESCRIPTION <code>exchange</code> <p>The RabbitMQ exchange to declare.</p> <p> TYPE: <code>RabbitExchange</code> </p> RETURNS DESCRIPTION <code>RobustExchange</code> <p>aio_pika.RobustExchange: The declared RabbitMQ exchange.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If the declarer is not initialized in the <code>connect</code> method.</p> Source code in <code>faststream/rabbit/broker.py</code> <pre><code>async def declare_exchange(\n    self,\n    exchange: RabbitExchange,\n) -&gt; aio_pika.RobustExchange:\n    \"\"\"\n    Declare a RabbitMQ exchange.\n\n    Args:\n        exchange (RabbitExchange): The RabbitMQ exchange to declare.\n\n    Returns:\n        aio_pika.RobustExchange: The declared RabbitMQ exchange.\n\n    Raises:\n        RuntimeError: If the declarer is not initialized in the `connect` method.\n    \"\"\"\n    assert (  # nosec B101\n        self.declarer\n    ), \"Declarer should be initialized in `connect` method\"\n    return await self.declarer.declare_exchange(exchange)\n</code></pre>"},{"location":"api/faststream/rabbit/broker/RabbitBroker/#faststream.rabbit.broker.RabbitBroker.declare_queue","title":"declare_queue  <code>async</code>","text":"<pre><code>declare_queue(queue: RabbitQueue) -&gt; aio_pika.RobustQueue\n</code></pre> <p>Declare a RabbitMQ queue.</p> PARAMETER  DESCRIPTION <code>queue</code> <p>The RabbitMQ queue to declare.</p> <p> TYPE: <code>RabbitQueue</code> </p> RETURNS DESCRIPTION <code>RobustQueue</code> <p>aio_pika.RobustQueue: The declared RabbitMQ queue.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If the declarer is not initialized in the <code>connect</code> method.</p> Source code in <code>faststream/rabbit/broker.py</code> <pre><code>async def declare_queue(\n    self,\n    queue: RabbitQueue,\n) -&gt; aio_pika.RobustQueue:\n    \"\"\"\n    Declare a RabbitMQ queue.\n\n    Args:\n        queue (RabbitQueue): The RabbitMQ queue to declare.\n\n    Returns:\n        aio_pika.RobustQueue: The declared RabbitMQ queue.\n\n    Raises:\n        RuntimeError: If the declarer is not initialized in the `connect` method.\n    \"\"\"\n    assert (  # nosec B101\n        self.declarer\n    ), \"Declarer should be initialized in `connect` method\"\n    return await self.declarer.declare_queue(queue)\n</code></pre>"},{"location":"api/faststream/rabbit/broker/RabbitBroker/#faststream.rabbit.broker.RabbitBroker.publish","title":"publish  <code>async</code>","text":"<pre><code>publish(\n    *args: Any, **kwargs: Any\n) -&gt; Union[\n    aiormq.abc.ConfirmationFrameType, SendableMessage\n]\n</code></pre> <p>Publish a message to the RabbitMQ broker.</p> PARAMETER  DESCRIPTION <code>*args</code> <p>Additional positional arguments.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>()</code> </p> <code>**kwargs</code> <p>Additional keyword arguments.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Union[ConfirmationFrameType, SendableMessage]</code> <p>Union[aiormq.abc.ConfirmationFrameType, SendableMessage]: The confirmation frame or the response message.</p> Source code in <code>faststream/rabbit/broker.py</code> <pre><code>@override\nasync def publish(  # type: ignore[override]\n    self,\n    *args: Any,\n    **kwargs: Any,\n) -&gt; Union[aiormq.abc.ConfirmationFrameType, SendableMessage]:\n    \"\"\"\n    Publish a message to the RabbitMQ broker.\n\n    Args:\n        *args: Additional positional arguments.\n        **kwargs: Additional keyword arguments.\n\n    Returns:\n        Union[aiormq.abc.ConfirmationFrameType, SendableMessage]: The confirmation frame or the response message.\n    \"\"\"\n\n    assert self._producer, \"RabbitBroker channel is not started yet\"  # nosec B101\n    return await self._producer.publish(*args, **kwargs)\n</code></pre>"},{"location":"api/faststream/rabbit/broker/RabbitBroker/#faststream.rabbit.broker.RabbitBroker.publisher","title":"publisher","text":"<pre><code>publisher(\n    queue: Union[RabbitQueue, str] = \"\",\n    exchange: Union[RabbitExchange, str, None] = None,\n    *,\n    routing_key: str = \"\",\n    mandatory: bool = True,\n    immediate: bool = False,\n    timeout: TimeoutType = None,\n    persist: bool = False,\n    reply_to: Optional[str] = None,\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n    **message_kwargs: Any\n) -&gt; Publisher\n</code></pre> <p>Define a message publisher.</p> PARAMETER  DESCRIPTION <code>queue</code> <p>The name of the RabbitMQ queue. Defaults to \"\".</p> <p> TYPE: <code>Union[RabbitQueue, str]</code> DEFAULT: <code>''</code> </p> <code>exchange</code> <p>The name of the RabbitMQ exchange. Defaults to None.</p> <p> TYPE: <code>Union[RabbitExchange, str, None]</code> DEFAULT: <code>None</code> </p> <code>routing_key</code> <p>The routing key for messages. Defaults to \"\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>mandatory</code> <p>Whether the message is mandatory. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>immediate</code> <p>Whether the message should be sent immediately. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>timeout</code> <p>Timeout for message publishing. Defaults to None.</p> <p> TYPE: <code>TimeoutType</code> DEFAULT: <code>None</code> </p> <code>persist</code> <p>Whether to persist messages. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>reply_to</code> <p>The reply-to queue name. Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>title</code> <p>Title for AsyncAPI docs.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>description</code> <p>Description for AsyncAPI docs.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>**message_kwargs</code> <p>Additional message properties and content.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Publisher</code> <p>A message publisher instance.</p> <p> TYPE: <code>Publisher</code> </p> Source code in <code>faststream/rabbit/broker.py</code> <pre><code>@override\ndef publisher(  # type: ignore[override]\n    self,\n    queue: Union[RabbitQueue, str] = \"\",\n    exchange: Union[RabbitExchange, str, None] = None,\n    *,\n    routing_key: str = \"\",\n    mandatory: bool = True,\n    immediate: bool = False,\n    timeout: TimeoutType = None,\n    persist: bool = False,\n    reply_to: Optional[str] = None,\n    # AsyncAPI information\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n    **message_kwargs: Any,\n) -&gt; Publisher:\n    \"\"\"\n    Define a message publisher.\n\n    Args:\n        queue (Union[RabbitQueue, str], optional): The name of the RabbitMQ queue. Defaults to \"\".\n        exchange (Union[RabbitExchange, str, None], optional): The name of the RabbitMQ exchange. Defaults to None.\n        routing_key (str, optional): The routing key for messages. Defaults to \"\".\n        mandatory (bool, optional): Whether the message is mandatory. Defaults to True.\n        immediate (bool, optional): Whether the message should be sent immediately. Defaults to False.\n        timeout (TimeoutType, optional): Timeout for message publishing. Defaults to None.\n        persist (bool, optional): Whether to persist messages. Defaults to False.\n        reply_to (Optional[str], optional): The reply-to queue name. Defaults to None.\n        title (Optional[str]): Title for AsyncAPI docs.\n        description (Optional[str]): Description for AsyncAPI docs.\n        **message_kwargs (Any): Additional message properties and content.\n\n    Returns:\n        Publisher: A message publisher instance.\n    \"\"\"\n    q, ex = RabbitQueue.validate(queue), RabbitExchange.validate(exchange)\n    key = get_routing_hash(q, ex)\n    publisher = self._publishers.get(\n        key,\n        Publisher(\n            title=title,\n            queue=q,\n            exchange=ex,\n            routing_key=routing_key,\n            mandatory=mandatory,\n            immediate=immediate,\n            timeout=timeout,\n            persist=persist,\n            reply_to=reply_to,\n            message_kwargs=message_kwargs,\n            _description=description,\n        ),\n    )\n    super().publisher(key, publisher)\n    return publisher\n</code></pre>"},{"location":"api/faststream/rabbit/broker/RabbitBroker/#faststream.rabbit.broker.RabbitBroker.start","title":"start  <code>async</code>","text":"<pre><code>start() -&gt; None\n</code></pre> <p>Start the RabbitMQ broker.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If the declarer is not initialized in the <code>connect</code> method.</p> Source code in <code>faststream/rabbit/broker.py</code> <pre><code>async def start(self) -&gt; None:\n    \"\"\"\n    Start the RabbitMQ broker.\n\n    Raises:\n        RuntimeError: If the declarer is not initialized in the `connect` method.\n    \"\"\"\n    context.set_local(\n        \"log_context\",\n        self._get_log_context(None, RabbitQueue(\"\"), RabbitExchange(\"\")),\n    )\n\n    await super().start()\n    assert (  # nosec B101\n        self.declarer\n    ), \"Declarer should be initialized in `connect` method\"\n\n    for handler in self.handlers.values():\n        c = self._get_log_context(None, handler.queue, handler.exchange)\n        self._log(f\"`{handler.name}` waiting for messages\", extra=c)\n        await handler.start(self.declarer)\n</code></pre>"},{"location":"api/faststream/rabbit/broker/RabbitBroker/#faststream.rabbit.broker.RabbitBroker.subscriber","title":"subscriber","text":"<pre><code>subscriber(\n    queue: Union[str, RabbitQueue],\n    exchange: Union[str, RabbitExchange, None] = None,\n    *,\n    consume_args: Optional[AnyDict] = None,\n    dependencies: Sequence[Depends] = (),\n    parser: Optional[\n        CustomParser[\n            aio_pika.IncomingMessage, RabbitMessage\n        ]\n    ] = None,\n    decoder: Optional[CustomDecoder[RabbitMessage]] = None,\n    middlewares: Optional[\n        Sequence[\n            Callable[\n                [aio_pika.IncomingMessage], BaseMiddleware\n            ]\n        ]\n    ] = None,\n    filter: Filter[RabbitMessage] = default_filter,\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n    **original_kwargs: Any\n) -&gt; Callable[\n    [Callable[P_HandlerParams, T_HandlerReturn]],\n    HandlerCallWrapper[\n        aio_pika.IncomingMessage,\n        P_HandlerParams,\n        T_HandlerReturn,\n    ],\n]\n</code></pre> <p>Decorator to define a message subscriber.</p> PARAMETER  DESCRIPTION <code>queue</code> <p>The name of the RabbitMQ queue.</p> <p> TYPE: <code>Union[str, RabbitQueue]</code> </p> <code>exchange</code> <p>The name of the RabbitMQ exchange. Defaults to None.</p> <p> TYPE: <code>Union[str, RabbitExchange, None]</code> DEFAULT: <code>None</code> </p> <code>consume_args</code> <p>Additional arguments for message consumption.</p> <p> TYPE: <code>Optional[AnyDict]</code> DEFAULT: <code>None</code> </p> <code>title</code> <p>Title for AsyncAPI docs.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>description</code> <p>Description for AsyncAPI docs.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Callable</code> <p>A decorator function for defining message subscribers.</p> <p> TYPE: <code>Callable[[Callable[P_HandlerParams, T_HandlerReturn]], HandlerCallWrapper[IncomingMessage, P_HandlerParams, T_HandlerReturn]]</code> </p> Source code in <code>faststream/rabbit/broker.py</code> <pre><code>@override\ndef subscriber(  # type: ignore[override]\n    self,\n    queue: Union[str, RabbitQueue],\n    exchange: Union[str, RabbitExchange, None] = None,\n    *,\n    consume_args: Optional[AnyDict] = None,\n    # broker arguments\n    dependencies: Sequence[Depends] = (),\n    parser: Optional[CustomParser[aio_pika.IncomingMessage, RabbitMessage]] = None,\n    decoder: Optional[CustomDecoder[RabbitMessage]] = None,\n    middlewares: Optional[\n        Sequence[Callable[[aio_pika.IncomingMessage], BaseMiddleware]]\n    ] = None,\n    filter: Filter[RabbitMessage] = default_filter,\n    # AsyncAPI information\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n    **original_kwargs: Any,\n) -&gt; Callable[\n    [Callable[P_HandlerParams, T_HandlerReturn]],\n    HandlerCallWrapper[aio_pika.IncomingMessage, P_HandlerParams, T_HandlerReturn],\n]:\n    \"\"\"\n    Decorator to define a message subscriber.\n\n    Args:\n        queue (Union[str, RabbitQueue]): The name of the RabbitMQ queue.\n        exchange (Union[str, RabbitExchange, None], optional): The name of the RabbitMQ exchange. Defaults to None.\n        consume_args (Optional[AnyDict], optional): Additional arguments for message consumption.\n        title (Optional[str]): Title for AsyncAPI docs.\n        description (Optional[str]): Description for AsyncAPI docs.\n\n    Returns:\n        Callable: A decorator function for defining message subscribers.\n    \"\"\"\n    super().subscriber()\n\n    r_queue = RabbitQueue.validate(queue)\n    r_exchange = RabbitExchange.validate(exchange)\n\n    self._setup_log_context(r_queue, r_exchange)\n\n    key = get_routing_hash(r_queue, r_exchange)\n    handler = self.handlers.get(\n        key,\n        Handler(\n            log_context_builder=partial(\n                self._get_log_context, queue=r_queue, exchange=r_exchange\n            ),\n            queue=r_queue,\n            exchange=r_exchange,\n            consume_args=consume_args,\n            description=description,\n            title=title,\n        ),\n    )\n\n    self.handlers[key] = handler\n\n    def consumer_wrapper(\n        func: Callable[P_HandlerParams, T_HandlerReturn],\n    ) -&gt; HandlerCallWrapper[\n        aio_pika.IncomingMessage, P_HandlerParams, T_HandlerReturn\n    ]:\n        \"\"\"Wraps a consumer function with additional functionality.\n\n        Args:\n            func: The consumer function to be wrapped.\n\n        Returns:\n            The wrapped consumer function.\n\n        Raises:\n            NotImplementedError: If silent animals are not supported.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        handler_call, dependant = self._wrap_handler(\n            func,\n            extra_dependencies=dependencies,\n            **original_kwargs,\n        )\n\n        handler.add_call(\n            handler=handler_call,\n            filter=filter,\n            middlewares=middlewares,\n            parser=parser or self._global_parser,\n            decoder=decoder or self._global_decoder,\n            dependant=dependant,\n        )\n\n        return handler_call\n\n    return consumer_wrapper\n</code></pre>"},{"location":"api/faststream/rabbit/fastapi/RabbitRouter/","title":"RabbitRouter","text":""},{"location":"api/faststream/rabbit/fastapi/RabbitRouter/#faststream.rabbit.fastapi.RabbitRouter","title":"faststream.rabbit.fastapi.RabbitRouter","text":"<p>             Bases: <code>StreamRouter[IncomingMessage]</code></p> <p>A class to represent a RabbitMQ router for incoming messages.</p> METHOD DESCRIPTION <code>_setup_log_context </code> <p>sets up the log context for the main broker and the including broker</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/rabbit/fastapi.py</code> <pre><code>class RabbitRouter(StreamRouter[IncomingMessage]):\n    \"\"\"A class to represent a RabbitMQ router for incoming messages.\n\n    Attributes:\n        broker_class : the class representing the RabbitMQ broker\n\n    Methods:\n        _setup_log_context : sets up the log context for the main broker and the including broker\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    broker_class = RabbitBroker\n\n    @staticmethod\n    def _setup_log_context(\n        main_broker: RabbitBroker,\n        including_broker: RabbitBroker,\n    ) -&gt; None:\n        \"\"\"Sets up the log context for a main broker and an including broker.\n\n        Args:\n            main_broker: The main broker object.\n            including_broker: The including broker object.\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        for h in including_broker.handlers.values():\n            main_broker._setup_log_context(h.queue, h.exchange)\n</code></pre>"},{"location":"api/faststream/rabbit/fastapi/RabbitRouter/#faststream.rabbit.fastapi.RabbitRouter.broker","title":"broker  <code>instance-attribute</code>","text":"<pre><code>broker: RabbitBroker\n</code></pre>"},{"location":"api/faststream/rabbit/fastapi/RabbitRouter/#faststream.rabbit.fastapi.RabbitRouter.broker_class","title":"broker_class  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>broker_class: Type[RabbitBroker] = RabbitBroker\n</code></pre>"},{"location":"api/faststream/rabbit/fastapi/RabbitRouter/#faststream.rabbit.fastapi.RabbitRouter.add_api_mq_route","title":"add_api_mq_route","text":"<pre><code>add_api_mq_route(\n    queue: Union[str, RabbitQueue],\n    *,\n    endpoint: Callable[..., T_HandlerReturn],\n    exchange: Union[str, RabbitExchange, None] = None,\n    consume_args: Optional[AnyDict] = None,\n    dependencies: Sequence[params.Depends] = (),\n    filter: Filter[RabbitMessage] = default_filter,\n    parser: Optional[\n        CustomParser[\n            aio_pika.IncomingMessage, RabbitMessage\n        ]\n    ] = None,\n    decoder: Optional[CustomDecoder[RabbitMessage]] = None,\n    middlewares: Optional[\n        Sequence[\n            Callable[\n                [aio_pika.IncomingMessage], BaseMiddleware\n            ]\n        ]\n    ] = None,\n    retry: Union[bool, int] = False,\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n    **__service_kwargs: Any\n) -&gt; Callable[\n    [IncomingMessage, bool], Awaitable[T_HandlerReturn]\n]\n</code></pre>"},{"location":"api/faststream/rabbit/fastapi/RabbitRouter/#faststream.rabbit.fastapi.RabbitRouter.publisher","title":"publisher","text":"<pre><code>publisher(\n    queue: Union[RabbitQueue, str] = \"\",\n    exchange: Union[RabbitExchange, str, None] = None,\n    *,\n    routing_key: str = \"\",\n    mandatory: bool = True,\n    immediate: bool = False,\n    timeout: TimeoutType = None,\n    persist: bool = False,\n    reply_to: Optional[str] = None,\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n    headers: Optional[aio_pika.abc.HeadersType] = None,\n    content_type: Optional[str] = None,\n    content_encoding: Optional[str] = None,\n    priority: Optional[int] = None,\n    correlation_id: Optional[str] = None,\n    expiration: Optional[aio_pika.abc.DateType] = None,\n    message_id: Optional[str] = None,\n    timestamp: Optional[aio_pika.abc.DateType] = None,\n    type: Optional[str] = None,\n    user_id: Optional[str] = None,\n    app_id: Optional[str] = None\n) -&gt; Publisher\n</code></pre>"},{"location":"api/faststream/rabbit/fastapi/RabbitRouter/#faststream.rabbit.fastapi.RabbitRouter.subscriber","title":"subscriber","text":"<pre><code>subscriber(\n    queue: Union[str, RabbitQueue],\n    exchange: Union[str, RabbitExchange, None] = None,\n    *,\n    consume_args: Optional[AnyDict] = None,\n    dependencies: Sequence[params.Depends] = (),\n    filter: Filter[RabbitMessage] = default_filter,\n    parser: Optional[\n        CustomParser[\n            aio_pika.IncomingMessage, RabbitMessage\n        ]\n    ] = None,\n    decoder: Optional[CustomDecoder[RabbitMessage]] = None,\n    middlewares: Optional[\n        Sequence[\n            Callable[\n                [aio_pika.IncomingMessage], BaseMiddleware\n            ]\n        ]\n    ] = None,\n    retry: Union[bool, int] = False,\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n    **__service_kwargs: Any\n) -&gt; Callable[\n    [Callable[P_HandlerParams, T_HandlerReturn]],\n    HandlerCallWrapper[\n        aio_pika.IncomingMessage,\n        P_HandlerParams,\n        T_HandlerReturn,\n    ],\n]\n</code></pre>"},{"location":"api/faststream/rabbit/handler/LogicHandler/","title":"LogicHandler","text":""},{"location":"api/faststream/rabbit/handler/LogicHandler/#faststream.rabbit.handler.LogicHandler","title":"faststream.rabbit.handler.LogicHandler","text":"<p>             Bases: <code>AsyncHandler[IncomingMessage]</code>, <code>BaseRMQInformation</code></p> <p>A class to handle logic for RabbitMQ message consumption.</p> METHOD DESCRIPTION <code>__init__ </code> <p>Initializes the LogicHandler object</p> <code>add_call </code> <p>Adds a call to be handled by the LogicHandler</p> <code>start </code> <p>Starts consuming messages from the queue</p> <code>close </code> <p>Closes the consumer and cancels message consumption</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/rabbit/handler.py</code> <pre><code>class LogicHandler(AsyncHandler[aio_pika.IncomingMessage], BaseRMQInformation):\n    \"\"\"A class to handle logic for RabbitMQ message consumption.\n\n    Attributes:\n        queue : RabbitQueue object representing the queue to consume from\n        exchange : Optional RabbitExchange object representing the exchange to bind the queue to\n        consume_args : Additional arguments to pass when consuming from the queue\n        _consumer_tag : Optional string representing the consumer tag\n        _queue_obj : Optional aio_pika.RobustQueue object representing the declared queue\n\n    Methods:\n        __init__ : Initializes the LogicHandler object\n        add_call : Adds a call to be handled by the LogicHandler\n        start : Starts consuming messages from the queue\n        close : Closes the consumer and cancels message consumption\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    queue: RabbitQueue\n    exchange: Optional[RabbitExchange]\n    consume_args: AnyDict\n\n    _consumer_tag: Optional[str]\n    _queue_obj: Optional[aio_pika.RobustQueue]\n\n    def __init__(\n        self,\n        queue: RabbitQueue,\n        log_context_builder: Callable[[StreamMessage[Any]], Dict[str, str]],\n        # RMQ information\n        exchange: Optional[RabbitExchange] = None,\n        consume_args: Optional[AnyDict] = None,\n        # AsyncAPI information\n        description: Optional[str] = None,\n        title: Optional[str] = None,\n    ):\n        \"\"\"Initialize a RabbitMQ consumer.\n\n        Args:\n            queue: RabbitQueue object representing the queue to consume from\n            exchange: RabbitExchange object representing the exchange to bind the queue to (optional)\n            consume_args: Additional arguments for consuming from the queue (optional)\n            description: Description of the consumer (optional)\n            title: Title of the consumer (optional)\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        super().__init__(\n            log_context_builder=log_context_builder,\n            description=description,\n            title=title,\n        )\n\n        self.queue = queue\n        self.exchange = exchange\n        self.consume_args = consume_args or {}\n\n        self._consumer_tag = None\n        self._queue_obj = None\n\n    def add_call(\n        self,\n        *,\n        handler: HandlerCallWrapper[\n            aio_pika.IncomingMessage, P_HandlerParams, T_HandlerReturn\n        ],\n        dependant: CallModel[P_HandlerParams, T_HandlerReturn],\n        parser: Optional[CustomParser[aio_pika.IncomingMessage, RabbitMessage]],\n        decoder: Optional[CustomDecoder[RabbitMessage]],\n        filter: Filter[RabbitMessage],\n        middlewares: Optional[\n            Sequence[Callable[[aio_pika.IncomingMessage], BaseMiddleware]]\n        ],\n    ) -&gt; None:\n        \"\"\"Add a call to the handler.\n\n        Args:\n            handler: The handler for the call.\n            dependant: The dependant for the call.\n            parser: Optional custom parser for the call.\n            decoder: Optional custom decoder for the call.\n            filter: The filter for the call.\n            middlewares: Optional sequence of middlewares for the call.\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        super().add_call(\n            handler=handler,\n            parser=resolve_custom_func(parser, AioPikaParser.parse_message),\n            decoder=resolve_custom_func(decoder, AioPikaParser.decode_message),\n            filter=filter,  # type: ignore[arg-type]\n            dependant=dependant,\n            middlewares=middlewares,\n        )\n\n    @override\n    async def start(self, declarer: RabbitDeclarer) -&gt; None:  # type: ignore[override]\n        \"\"\"Starts the consumer for the RabbitMQ queue.\n\n        Args:\n            declarer: RabbitDeclarer object used to declare the queue and exchange\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        self._queue_obj = queue = await declarer.declare_queue(self.queue)\n\n        if self.exchange is not None:\n            exchange = await declarer.declare_exchange(self.exchange)\n            await queue.bind(\n                exchange,\n                routing_key=self.queue.routing,\n                arguments=self.queue.bind_arguments,\n            )\n\n        self._consumer_tag = await queue.consume(\n            # NOTE: aio-pika expects AbstractIncomingMessage, not IncomingMessage\n            self.consume,  # type: ignore[arg-type]\n            arguments=self.consume_args,\n        )\n\n    async def close(self) -&gt; None:\n        if self._queue_obj is not None:\n            if self._consumer_tag is not None:  # pragma: no branch\n                await self._queue_obj.cancel(self._consumer_tag)\n                self._consumer_tag = None\n            self._queue_obj = None\n</code></pre>"},{"location":"api/faststream/rabbit/handler/LogicHandler/#faststream.rabbit.handler.LogicHandler.consume_args","title":"consume_args  <code>instance-attribute</code>","text":"<pre><code>consume_args: AnyDict = consume_args or {}\n</code></pre>"},{"location":"api/faststream/rabbit/handler/LogicHandler/#faststream.rabbit.handler.LogicHandler.exchange","title":"exchange  <code>instance-attribute</code>","text":"<pre><code>exchange: Optional[RabbitExchange] = exchange\n</code></pre>"},{"location":"api/faststream/rabbit/handler/LogicHandler/#faststream.rabbit.handler.LogicHandler.queue","title":"queue  <code>instance-attribute</code>","text":"<pre><code>queue: RabbitQueue = queue\n</code></pre>"},{"location":"api/faststream/rabbit/handler/LogicHandler/#faststream.rabbit.handler.LogicHandler.add_call","title":"add_call","text":"<pre><code>add_call(\n    *,\n    handler: HandlerCallWrapper[\n        aio_pika.IncomingMessage,\n        P_HandlerParams,\n        T_HandlerReturn,\n    ],\n    dependant: CallModel[P_HandlerParams, T_HandlerReturn],\n    parser: Optional[\n        CustomParser[\n            aio_pika.IncomingMessage, RabbitMessage\n        ]\n    ],\n    decoder: Optional[CustomDecoder[RabbitMessage]],\n    filter: Filter[RabbitMessage],\n    middlewares: Optional[\n        Sequence[\n            Callable[\n                [aio_pika.IncomingMessage], BaseMiddleware\n            ]\n        ]\n    ]\n) -&gt; None\n</code></pre> <p>Add a call to the handler.</p> PARAMETER  DESCRIPTION <code>handler</code> <p>The handler for the call.</p> <p> TYPE: <code>HandlerCallWrapper[IncomingMessage, P_HandlerParams, T_HandlerReturn]</code> </p> <code>dependant</code> <p>The dependant for the call.</p> <p> TYPE: <code>CallModel[P_HandlerParams, T_HandlerReturn]</code> </p> <code>parser</code> <p>Optional custom parser for the call.</p> <p> TYPE: <code>Optional[CustomParser[IncomingMessage, RabbitMessage]]</code> </p> <code>decoder</code> <p>Optional custom decoder for the call.</p> <p> TYPE: <code>Optional[CustomDecoder[RabbitMessage]]</code> </p> <code>filter</code> <p>The filter for the call.</p> <p> TYPE: <code>Filter[RabbitMessage]</code> </p> <code>middlewares</code> <p>Optional sequence of middlewares for the call.</p> <p> TYPE: <code>Optional[Sequence[Callable[[IncomingMessage], BaseMiddleware]]]</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/rabbit/handler.py</code> <pre><code>def add_call(\n    self,\n    *,\n    handler: HandlerCallWrapper[\n        aio_pika.IncomingMessage, P_HandlerParams, T_HandlerReturn\n    ],\n    dependant: CallModel[P_HandlerParams, T_HandlerReturn],\n    parser: Optional[CustomParser[aio_pika.IncomingMessage, RabbitMessage]],\n    decoder: Optional[CustomDecoder[RabbitMessage]],\n    filter: Filter[RabbitMessage],\n    middlewares: Optional[\n        Sequence[Callable[[aio_pika.IncomingMessage], BaseMiddleware]]\n    ],\n) -&gt; None:\n    \"\"\"Add a call to the handler.\n\n    Args:\n        handler: The handler for the call.\n        dependant: The dependant for the call.\n        parser: Optional custom parser for the call.\n        decoder: Optional custom decoder for the call.\n        filter: The filter for the call.\n        middlewares: Optional sequence of middlewares for the call.\n\n    Returns:\n        None\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    super().add_call(\n        handler=handler,\n        parser=resolve_custom_func(parser, AioPikaParser.parse_message),\n        decoder=resolve_custom_func(decoder, AioPikaParser.decode_message),\n        filter=filter,  # type: ignore[arg-type]\n        dependant=dependant,\n        middlewares=middlewares,\n    )\n</code></pre>"},{"location":"api/faststream/rabbit/handler/LogicHandler/#faststream.rabbit.handler.LogicHandler.close","title":"close  <code>async</code>","text":"<pre><code>close() -&gt; None\n</code></pre> Source code in <code>faststream/rabbit/handler.py</code> <pre><code>async def close(self) -&gt; None:\n    if self._queue_obj is not None:\n        if self._consumer_tag is not None:  # pragma: no branch\n            await self._queue_obj.cancel(self._consumer_tag)\n            self._consumer_tag = None\n        self._queue_obj = None\n</code></pre>"},{"location":"api/faststream/rabbit/handler/LogicHandler/#faststream.rabbit.handler.LogicHandler.start","title":"start  <code>async</code>","text":"<pre><code>start(declarer: RabbitDeclarer) -&gt; None\n</code></pre> <p>Starts the consumer for the RabbitMQ queue.</p> PARAMETER  DESCRIPTION <code>declarer</code> <p>RabbitDeclarer object used to declare the queue and exchange</p> <p> TYPE: <code>RabbitDeclarer</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/rabbit/handler.py</code> <pre><code>@override\nasync def start(self, declarer: RabbitDeclarer) -&gt; None:  # type: ignore[override]\n    \"\"\"Starts the consumer for the RabbitMQ queue.\n\n    Args:\n        declarer: RabbitDeclarer object used to declare the queue and exchange\n\n    Returns:\n        None\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    self._queue_obj = queue = await declarer.declare_queue(self.queue)\n\n    if self.exchange is not None:\n        exchange = await declarer.declare_exchange(self.exchange)\n        await queue.bind(\n            exchange,\n            routing_key=self.queue.routing,\n            arguments=self.queue.bind_arguments,\n        )\n\n    self._consumer_tag = await queue.consume(\n        # NOTE: aio-pika expects AbstractIncomingMessage, not IncomingMessage\n        self.consume,  # type: ignore[arg-type]\n        arguments=self.consume_args,\n    )\n</code></pre>"},{"location":"api/faststream/rabbit/helpers/RabbitDeclarer/","title":"RabbitDeclarer","text":""},{"location":"api/faststream/rabbit/helpers/RabbitDeclarer/#faststream.rabbit.helpers.RabbitDeclarer","title":"faststream.rabbit.helpers.RabbitDeclarer","text":"<p>             Bases: <code>Singleton</code></p> <p>A class to declare RabbitMQ queues and exchanges.</p> METHOD DESCRIPTION <code>__init__</code> <p>aio_pika.RobustChannel) -&gt; None Initializes the RabbitDeclarer with a channel.</p> <code>declare_queue</code> <p>RabbitQueue) -&gt; aio_pika.RobustQueue Declares a queue and returns the declared queue object.</p> <code>declare_exchange</code> <p>RabbitExchange) -&gt; aio_pika.RobustExchange Declares an exchange and returns the declared exchange object.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/rabbit/helpers.py</code> <pre><code>class RabbitDeclarer(Singleton):\n    \"\"\"A class to declare RabbitMQ queues and exchanges.\n\n    Attributes:\n        channel : aio_pika.RobustChannel\n            The RabbitMQ channel to use for declaration.\n        queues : Dict[Union[RabbitQueue, str], aio_pika.RobustQueue]\n            A dictionary to store the declared queues.\n        exchanges : Dict[Union[RabbitExchange, str], aio_pika.RobustExchange]\n            A dictionary to store the declared exchanges.\n\n    Methods:\n        __init__(channel: aio_pika.RobustChannel) -&gt; None\n            Initializes the RabbitDeclarer with a channel.\n\n        declare_queue(queue: RabbitQueue) -&gt; aio_pika.RobustQueue\n            Declares a queue and returns the declared queue object.\n\n        declare_exchange(exchange: RabbitExchange) -&gt; aio_pika.RobustExchange\n            Declares an exchange and returns the declared exchange object.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    channel: aio_pika.RobustChannel\n    queues: Dict[Union[RabbitQueue, str], aio_pika.RobustQueue]\n    exchanges: Dict[Union[RabbitExchange, str], aio_pika.RobustExchange]\n\n    def __init__(self, channel: aio_pika.RobustChannel) -&gt; None:\n        \"\"\"Initialize the class.\n\n        Args:\n            channel: Aio_pika RobustChannel object\n\n        Attributes:\n            channel: Aio_pika RobustChannel object\n            queues: A dictionary to store queues\n            exchanges: A dictionary to store exchanges\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        self.channel = channel\n        self.queues = {}\n        self.exchanges = {}\n\n    async def declare_queue(\n        self,\n        queue: RabbitQueue,\n    ) -&gt; aio_pika.RobustQueue:\n        \"\"\"Declare a queue.\n\n        Args:\n            queue: RabbitQueue object representing the queue to be declared.\n\n        Returns:\n            aio_pika.RobustQueue: The declared queue.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        q = self.queues.get(queue)\n        if q is None:\n            q = cast(\n                aio_pika.RobustQueue,\n                await self.channel.declare_queue(\n                    **model_to_dict(\n                        queue,\n                        exclude={\n                            \"routing_key\",\n                            \"bind_arguments\",\n                        },\n                    )\n                ),\n            )\n            self.queues[queue] = q\n        return q\n\n    async def declare_exchange(\n        self,\n        exchange: RabbitExchange,\n    ) -&gt; aio_pika.RobustExchange:\n        \"\"\"Declare an exchange.\n\n        Args:\n            exchange: RabbitExchange object representing the exchange to be declared.\n\n        Returns:\n            aio_pika.RobustExchange: The declared exchange.\n\n        Raises:\n            NotImplementedError: If silent animals are not supported.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        exch = self.exchanges.get(exchange)\n\n        if exch is None:\n            exch = cast(\n                aio_pika.RobustExchange,\n                await self.channel.declare_exchange(\n                    **model_to_dict(\n                        exchange,\n                        exclude={\n                            \"routing_key\",\n                            \"bind_arguments\",\n                            \"bind_to\",\n                        },\n                    )\n                ),\n            )\n            self.exchanges[exchange] = exch\n\n        if exchange.bind_to is not None:\n            parent = await self.declare_exchange(exchange.bind_to)\n            await exch.bind(\n                exchange=parent,\n                routing_key=exchange.routing_key,\n                arguments=exchange.arguments,\n            )\n\n        return exch\n</code></pre>"},{"location":"api/faststream/rabbit/helpers/RabbitDeclarer/#faststream.rabbit.helpers.RabbitDeclarer.channel","title":"channel  <code>instance-attribute</code>","text":"<pre><code>channel: aio_pika.RobustChannel = channel\n</code></pre>"},{"location":"api/faststream/rabbit/helpers/RabbitDeclarer/#faststream.rabbit.helpers.RabbitDeclarer.exchanges","title":"exchanges  <code>instance-attribute</code>","text":"<pre><code>exchanges: Dict[\n    Union[RabbitExchange, str], aio_pika.RobustExchange\n] = {}\n</code></pre>"},{"location":"api/faststream/rabbit/helpers/RabbitDeclarer/#faststream.rabbit.helpers.RabbitDeclarer.queues","title":"queues  <code>instance-attribute</code>","text":"<pre><code>queues: Dict[\n    Union[RabbitQueue, str], aio_pika.RobustQueue\n] = {}\n</code></pre>"},{"location":"api/faststream/rabbit/helpers/RabbitDeclarer/#faststream.rabbit.helpers.RabbitDeclarer.declare_exchange","title":"declare_exchange  <code>async</code>","text":"<pre><code>declare_exchange(\n    exchange: RabbitExchange,\n) -&gt; aio_pika.RobustExchange\n</code></pre> <p>Declare an exchange.</p> PARAMETER  DESCRIPTION <code>exchange</code> <p>RabbitExchange object representing the exchange to be declared.</p> <p> TYPE: <code>RabbitExchange</code> </p> RETURNS DESCRIPTION <code>RobustExchange</code> <p>aio_pika.RobustExchange: The declared exchange.</p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>If silent animals are not supported.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/rabbit/helpers.py</code> <pre><code>async def declare_exchange(\n    self,\n    exchange: RabbitExchange,\n) -&gt; aio_pika.RobustExchange:\n    \"\"\"Declare an exchange.\n\n    Args:\n        exchange: RabbitExchange object representing the exchange to be declared.\n\n    Returns:\n        aio_pika.RobustExchange: The declared exchange.\n\n    Raises:\n        NotImplementedError: If silent animals are not supported.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    exch = self.exchanges.get(exchange)\n\n    if exch is None:\n        exch = cast(\n            aio_pika.RobustExchange,\n            await self.channel.declare_exchange(\n                **model_to_dict(\n                    exchange,\n                    exclude={\n                        \"routing_key\",\n                        \"bind_arguments\",\n                        \"bind_to\",\n                    },\n                )\n            ),\n        )\n        self.exchanges[exchange] = exch\n\n    if exchange.bind_to is not None:\n        parent = await self.declare_exchange(exchange.bind_to)\n        await exch.bind(\n            exchange=parent,\n            routing_key=exchange.routing_key,\n            arguments=exchange.arguments,\n        )\n\n    return exch\n</code></pre>"},{"location":"api/faststream/rabbit/helpers/RabbitDeclarer/#faststream.rabbit.helpers.RabbitDeclarer.declare_queue","title":"declare_queue  <code>async</code>","text":"<pre><code>declare_queue(queue: RabbitQueue) -&gt; aio_pika.RobustQueue\n</code></pre> <p>Declare a queue.</p> PARAMETER  DESCRIPTION <code>queue</code> <p>RabbitQueue object representing the queue to be declared.</p> <p> TYPE: <code>RabbitQueue</code> </p> RETURNS DESCRIPTION <code>RobustQueue</code> <p>aio_pika.RobustQueue: The declared queue.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/rabbit/helpers.py</code> <pre><code>async def declare_queue(\n    self,\n    queue: RabbitQueue,\n) -&gt; aio_pika.RobustQueue:\n    \"\"\"Declare a queue.\n\n    Args:\n        queue: RabbitQueue object representing the queue to be declared.\n\n    Returns:\n        aio_pika.RobustQueue: The declared queue.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    q = self.queues.get(queue)\n    if q is None:\n        q = cast(\n            aio_pika.RobustQueue,\n            await self.channel.declare_queue(\n                **model_to_dict(\n                    queue,\n                    exclude={\n                        \"routing_key\",\n                        \"bind_arguments\",\n                    },\n                )\n            ),\n        )\n        self.queues[queue] = q\n    return q\n</code></pre>"},{"location":"api/faststream/rabbit/message/RabbitMessage/","title":"RabbitMessage","text":""},{"location":"api/faststream/rabbit/message/RabbitMessage/#faststream.rabbit.message.RabbitMessage","title":"faststream.rabbit.message.RabbitMessage","text":"<p>             Bases: <code>StreamMessage[IncomingMessage]</code></p> <p>A message class for working with RabbitMQ messages.</p> <p>This class extends <code>StreamMessage</code> to provide additional functionality for acknowledging, rejecting, or nack-ing RabbitMQ messages.</p> METHOD DESCRIPTION <code>ack</code> <p>Acknowledge the RabbitMQ message.</p> <code>nack</code> <p>Negative Acknowledgment of the RabbitMQ message.</p> <code>reject</code> <p>Reject the RabbitMQ message.</p> Source code in <code>faststream/rabbit/message.py</code> <pre><code>class RabbitMessage(StreamMessage[aio_pika.IncomingMessage]):\n    \"\"\"\n    A message class for working with RabbitMQ messages.\n\n    This class extends `StreamMessage` to provide additional functionality for acknowledging, rejecting,\n    or nack-ing RabbitMQ messages.\n\n    Methods:\n        ack(**kwargs) -&gt; None:\n            Acknowledge the RabbitMQ message.\n\n        nack(**kwargs) -&gt; None:\n            Negative Acknowledgment of the RabbitMQ message.\n\n        reject(**kwargs) -&gt; None:\n            Reject the RabbitMQ message.\n\n    \"\"\"\n\n    async def ack(self, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Acknowledge the RabbitMQ message.\n\n        Acknowledgment indicates that the message has been successfully processed.\n\n        Args:\n            **kwargs (Any): Additional keyword arguments (not used).\n\n        \"\"\"\n        pika_message = self.raw_message\n        if (\n            pika_message._IncomingMessage__processed  # type: ignore[attr-defined]\n            or pika_message._IncomingMessage__no_ack  # type: ignore[attr-defined]\n        ):\n            return\n        await pika_message.ack()\n\n    async def nack(self, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Negative Acknowledgment of the RabbitMQ message.\n\n        Nack-ing a message indicates that the message processing has failed and should be requeued.\n\n        Args:\n            **kwargs (Any): Additional keyword arguments (not used).\n\n        \"\"\"\n        pika_message = self.raw_message\n        if (\n            pika_message._IncomingMessage__processed  # type: ignore[attr-defined]\n            or pika_message._IncomingMessage__no_ack  # type: ignore[attr-defined]\n        ):\n            return\n        await pika_message.nack()\n\n    async def reject(self, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Reject the RabbitMQ message.\n\n        Rejecting a message indicates that the message processing has failed, and it should not be requeued.\n\n        Args:\n            **kwargs (Any): Additional keyword arguments (not used).\n\n        \"\"\"\n        pika_message = self.raw_message\n        if (\n            pika_message._IncomingMessage__processed  # type: ignore[attr-defined]\n            or pika_message._IncomingMessage__no_ack  # type: ignore[attr-defined]\n        ):\n            return\n        await pika_message.reject()\n</code></pre>"},{"location":"api/faststream/rabbit/message/RabbitMessage/#faststream.rabbit.message.RabbitMessage.ack","title":"ack  <code>async</code>","text":"<pre><code>ack(**kwargs: Any) -&gt; None\n</code></pre> <p>Acknowledge the RabbitMQ message.</p> <p>Acknowledgment indicates that the message has been successfully processed.</p> PARAMETER  DESCRIPTION <code>**kwargs</code> <p>Additional keyword arguments (not used).</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>faststream/rabbit/message.py</code> <pre><code>async def ack(self, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Acknowledge the RabbitMQ message.\n\n    Acknowledgment indicates that the message has been successfully processed.\n\n    Args:\n        **kwargs (Any): Additional keyword arguments (not used).\n\n    \"\"\"\n    pika_message = self.raw_message\n    if (\n        pika_message._IncomingMessage__processed  # type: ignore[attr-defined]\n        or pika_message._IncomingMessage__no_ack  # type: ignore[attr-defined]\n    ):\n        return\n    await pika_message.ack()\n</code></pre>"},{"location":"api/faststream/rabbit/message/RabbitMessage/#faststream.rabbit.message.RabbitMessage.nack","title":"nack  <code>async</code>","text":"<pre><code>nack(**kwargs: Any) -&gt; None\n</code></pre> <p>Negative Acknowledgment of the RabbitMQ message.</p> <p>Nack-ing a message indicates that the message processing has failed and should be requeued.</p> PARAMETER  DESCRIPTION <code>**kwargs</code> <p>Additional keyword arguments (not used).</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>faststream/rabbit/message.py</code> <pre><code>async def nack(self, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Negative Acknowledgment of the RabbitMQ message.\n\n    Nack-ing a message indicates that the message processing has failed and should be requeued.\n\n    Args:\n        **kwargs (Any): Additional keyword arguments (not used).\n\n    \"\"\"\n    pika_message = self.raw_message\n    if (\n        pika_message._IncomingMessage__processed  # type: ignore[attr-defined]\n        or pika_message._IncomingMessage__no_ack  # type: ignore[attr-defined]\n    ):\n        return\n    await pika_message.nack()\n</code></pre>"},{"location":"api/faststream/rabbit/message/RabbitMessage/#faststream.rabbit.message.RabbitMessage.reject","title":"reject  <code>async</code>","text":"<pre><code>reject(**kwargs: Any) -&gt; None\n</code></pre> <p>Reject the RabbitMQ message.</p> <p>Rejecting a message indicates that the message processing has failed, and it should not be requeued.</p> PARAMETER  DESCRIPTION <code>**kwargs</code> <p>Additional keyword arguments (not used).</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>faststream/rabbit/message.py</code> <pre><code>async def reject(self, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Reject the RabbitMQ message.\n\n    Rejecting a message indicates that the message processing has failed, and it should not be requeued.\n\n    Args:\n        **kwargs (Any): Additional keyword arguments (not used).\n\n    \"\"\"\n    pika_message = self.raw_message\n    if (\n        pika_message._IncomingMessage__processed  # type: ignore[attr-defined]\n        or pika_message._IncomingMessage__no_ack  # type: ignore[attr-defined]\n    ):\n        return\n    await pika_message.reject()\n</code></pre>"},{"location":"api/faststream/rabbit/parser/AioPikaParser/","title":"AioPikaParser","text":""},{"location":"api/faststream/rabbit/parser/AioPikaParser/#faststream.rabbit.parser.AioPikaParser","title":"faststream.rabbit.parser.AioPikaParser","text":"<p>A class for parsing, encoding, and decoding messages using aio-pika.</p> METHOD DESCRIPTION <code>parse_message</code> <p>aio_pika.IncomingMessage) -&gt; StreamMessage[aio_pika.IncomingMessage]: Parses an incoming message and returns a StreamMessage object.</p> <code>decode_message</code> <p>StreamMessage[aio_pika.IncomingMessage]) -&gt; DecodedMessage: Decodes a StreamMessage object and returns a DecodedMessage object.</p> <code>encode_message</code> <p>AioPikaSendableMessage, persist: bool = False, callback_queue: Optional[aio_pika.abc.AbstractRobustQueue] = None, reply_to: Optional[str] = None, **message_kwargs: Any) -&gt; aio_pika.Message: Encodes a message into an aio_pika.Message object.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/rabbit/parser.py</code> <pre><code>class AioPikaParser:\n    \"\"\"A class for parsing, encoding, and decoding messages using aio-pika.\n\n    Methods:\n        parse_message(message: aio_pika.IncomingMessage) -&gt; StreamMessage[aio_pika.IncomingMessage]:\n            Parses an incoming message and returns a StreamMessage object.\n\n        decode_message(msg: StreamMessage[aio_pika.IncomingMessage]) -&gt; DecodedMessage:\n            Decodes a StreamMessage object and returns a DecodedMessage object.\n\n        encode_message(message: AioPikaSendableMessage, persist: bool = False, callback_queue: Optional[aio_pika.abc.AbstractRobustQueue] = None, reply_to: Optional[str] = None, **message_kwargs: Any) -&gt; aio_pika.Message:\n            Encodes a message into an aio_pika.Message object.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    @staticmethod\n    async def parse_message(\n        message: aio_pika.IncomingMessage,\n    ) -&gt; StreamMessage[aio_pika.IncomingMessage]:\n        \"\"\"Parses an incoming message and returns a RabbitMessage object.\n\n        Args:\n            message: The incoming message to parse.\n\n        Returns:\n            A StreamMessage object representing the parsed message.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        return RabbitMessage(\n            body=message.body,\n            headers=message.headers,\n            reply_to=message.reply_to or \"\",\n            content_type=message.content_type,\n            message_id=message.message_id or str(uuid4()),\n            correlation_id=message.correlation_id or str(uuid4()),\n            raw_message=message,\n        )\n\n    @staticmethod\n    async def decode_message(\n        msg: StreamMessage[aio_pika.IncomingMessage],\n    ) -&gt; DecodedMessage:\n        \"\"\"Decode a message.\n\n        Args:\n            msg: The message to decode.\n\n        Returns:\n            The decoded message.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        return decode_message(msg)\n\n    @staticmethod\n    def encode_message(\n        message: AioPikaSendableMessage,\n        persist: bool = False,\n        callback_queue: Optional[aio_pika.abc.AbstractRobustQueue] = None,\n        reply_to: Optional[str] = None,\n        **message_kwargs: Any,\n    ) -&gt; aio_pika.Message:\n        \"\"\"Encodes a message for sending using AioPika.\n\n        Args:\n            message (AioPikaSendableMessage): The message to encode.\n            persist (bool, optional): Whether to persist the message. Defaults to False.\n            callback_queue (aio_pika.abc.AbstractRobustQueue, optional): The callback queue to use for replies. Defaults to None.\n            reply_to (str, optional): The reply-to queue to use for replies. Defaults to None.\n            **message_kwargs (Any): Additional keyword arguments to include in the encoded message.\n\n        Returns:\n            aio_pika.Message: The encoded message.\n\n        Raises:\n            NotImplementedError: If the message is not an instance of aio_pika.Message.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        if not isinstance(message, aio_pika.Message):\n            message, content_type = encode_message(message)\n\n            delivery_mode = (\n                DeliveryMode.PERSISTENT if persist else DeliveryMode.NOT_PERSISTENT\n            )\n\n            message = aio_pika.Message(\n                message,\n                **{\n                    \"delivery_mode\": delivery_mode,\n                    \"content_type\": content_type,\n                    \"reply_to\": callback_queue or reply_to,\n                    \"correlation_id\": str(uuid4()),\n                    **message_kwargs,\n                },\n            )\n\n        return message\n</code></pre>"},{"location":"api/faststream/rabbit/parser/AioPikaParser/#faststream.rabbit.parser.AioPikaParser.decode_message","title":"decode_message  <code>async</code> <code>staticmethod</code>","text":"<pre><code>decode_message(\n    msg: StreamMessage[aio_pika.IncomingMessage],\n) -&gt; DecodedMessage\n</code></pre> <p>Decode a message.</p> PARAMETER  DESCRIPTION <code>msg</code> <p>The message to decode.</p> <p> TYPE: <code>StreamMessage[IncomingMessage]</code> </p> RETURNS DESCRIPTION <code>DecodedMessage</code> <p>The decoded message.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/rabbit/parser.py</code> <pre><code>@staticmethod\nasync def decode_message(\n    msg: StreamMessage[aio_pika.IncomingMessage],\n) -&gt; DecodedMessage:\n    \"\"\"Decode a message.\n\n    Args:\n        msg: The message to decode.\n\n    Returns:\n        The decoded message.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    return decode_message(msg)\n</code></pre>"},{"location":"api/faststream/rabbit/parser/AioPikaParser/#faststream.rabbit.parser.AioPikaParser.encode_message","title":"encode_message  <code>staticmethod</code>","text":"<pre><code>encode_message(\n    message: AioPikaSendableMessage,\n    persist: bool = False,\n    callback_queue: Optional[\n        aio_pika.abc.AbstractRobustQueue\n    ] = None,\n    reply_to: Optional[str] = None,\n    **message_kwargs: Any\n) -&gt; aio_pika.Message\n</code></pre> <p>Encodes a message for sending using AioPika.</p> PARAMETER  DESCRIPTION <code>message</code> <p>The message to encode.</p> <p> TYPE: <code>AioPikaSendableMessage</code> </p> <code>persist</code> <p>Whether to persist the message. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>callback_queue</code> <p>The callback queue to use for replies. Defaults to None.</p> <p> TYPE: <code>AbstractRobustQueue</code> DEFAULT: <code>None</code> </p> <code>reply_to</code> <p>The reply-to queue to use for replies. Defaults to None.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>**message_kwargs</code> <p>Additional keyword arguments to include in the encoded message.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Message</code> <p>aio_pika.Message: The encoded message.</p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>If the message is not an instance of aio_pika.Message.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/rabbit/parser.py</code> <pre><code>@staticmethod\ndef encode_message(\n    message: AioPikaSendableMessage,\n    persist: bool = False,\n    callback_queue: Optional[aio_pika.abc.AbstractRobustQueue] = None,\n    reply_to: Optional[str] = None,\n    **message_kwargs: Any,\n) -&gt; aio_pika.Message:\n    \"\"\"Encodes a message for sending using AioPika.\n\n    Args:\n        message (AioPikaSendableMessage): The message to encode.\n        persist (bool, optional): Whether to persist the message. Defaults to False.\n        callback_queue (aio_pika.abc.AbstractRobustQueue, optional): The callback queue to use for replies. Defaults to None.\n        reply_to (str, optional): The reply-to queue to use for replies. Defaults to None.\n        **message_kwargs (Any): Additional keyword arguments to include in the encoded message.\n\n    Returns:\n        aio_pika.Message: The encoded message.\n\n    Raises:\n        NotImplementedError: If the message is not an instance of aio_pika.Message.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    if not isinstance(message, aio_pika.Message):\n        message, content_type = encode_message(message)\n\n        delivery_mode = (\n            DeliveryMode.PERSISTENT if persist else DeliveryMode.NOT_PERSISTENT\n        )\n\n        message = aio_pika.Message(\n            message,\n            **{\n                \"delivery_mode\": delivery_mode,\n                \"content_type\": content_type,\n                \"reply_to\": callback_queue or reply_to,\n                \"correlation_id\": str(uuid4()),\n                **message_kwargs,\n            },\n        )\n\n    return message\n</code></pre>"},{"location":"api/faststream/rabbit/parser/AioPikaParser/#faststream.rabbit.parser.AioPikaParser.parse_message","title":"parse_message  <code>async</code> <code>staticmethod</code>","text":"<pre><code>parse_message(\n    message: aio_pika.IncomingMessage,\n) -&gt; StreamMessage[aio_pika.IncomingMessage]\n</code></pre> <p>Parses an incoming message and returns a RabbitMessage object.</p> PARAMETER  DESCRIPTION <code>message</code> <p>The incoming message to parse.</p> <p> TYPE: <code>IncomingMessage</code> </p> RETURNS DESCRIPTION <code>StreamMessage[IncomingMessage]</code> <p>A StreamMessage object representing the parsed message.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/rabbit/parser.py</code> <pre><code>@staticmethod\nasync def parse_message(\n    message: aio_pika.IncomingMessage,\n) -&gt; StreamMessage[aio_pika.IncomingMessage]:\n    \"\"\"Parses an incoming message and returns a RabbitMessage object.\n\n    Args:\n        message: The incoming message to parse.\n\n    Returns:\n        A StreamMessage object representing the parsed message.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    return RabbitMessage(\n        body=message.body,\n        headers=message.headers,\n        reply_to=message.reply_to or \"\",\n        content_type=message.content_type,\n        message_id=message.message_id or str(uuid4()),\n        correlation_id=message.correlation_id or str(uuid4()),\n        raw_message=message,\n    )\n</code></pre>"},{"location":"api/faststream/rabbit/producer/AioPikaFastProducer/","title":"AioPikaFastProducer","text":""},{"location":"api/faststream/rabbit/producer/AioPikaFastProducer/#faststream.rabbit.producer.AioPikaFastProducer","title":"faststream.rabbit.producer.AioPikaFastProducer","text":"<p>A class for fast producing messages using aio-pika.</p> METHOD DESCRIPTION <code>__init__</code> <p>Initializes the AioPikaFastProducer object.</p> <code>publish</code> <p>Publishes a message to a queue or exchange.</p> <code>_publish</code> <p>Publishes a message to an exchange.</p> <p>Note: This docstring is incomplete as it is difficult to understand the purpose and functionality of the class and its methods without more context.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/rabbit/producer.py</code> <pre><code>class AioPikaFastProducer:\n    \"\"\"A class for fast producing messages using aio-pika.\n\n    Attributes:\n        _channel : aio_pika.RobustChannel\n            The channel used for publishing messages.\n        _rpc_lock : anyio.Lock\n            Lock used for RPC calls.\n        _decoder : AsyncDecoder\n            Decoder used for decoding incoming messages.\n        _parser : AsyncParser[aio_pika.IncomingMessage]\n            Parser used for parsing incoming messages.\n        declarer : RabbitDeclarer\n            The declarer object used for declaring exchanges and queues.\n\n    Methods:\n        __init__(channel, declarer, parser, decoder): Initializes the AioPikaFastProducer object.\n        publish(message, queue, exchange, routing_key, mandatory, immediate, timeout, rpc, rpc_timeout, raise_timeout, persist, reply_to, **message_kwargs): Publishes a message to a queue or exchange.\n        _publish(message, exchange, routing_key, mandatory, immediate, timeout, persist, reply_to, **message_kwargs): Publishes a message to an exchange.\n\n    Note: This docstring is incomplete as it is difficult to understand the purpose and functionality of the class and its methods without more context.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    _channel: aio_pika.RobustChannel\n    _rpc_lock: anyio.Lock\n    _decoder: AsyncDecoder[Any]\n    _parser: AsyncParser[aio_pika.IncomingMessage, Any]\n    declarer: RabbitDeclarer\n\n    def __init__(\n        self,\n        channel: aio_pika.RobustChannel,\n        declarer: RabbitDeclarer,\n        parser: Optional[AsyncCustomParser[aio_pika.IncomingMessage, RabbitMessage]],\n        decoder: Optional[AsyncCustomDecoder[RabbitMessage]],\n    ):\n        \"\"\"Initialize a class instance.\n\n        Args:\n            channel: The aio_pika.RobustChannel object.\n            declarer: The RabbitDeclarer object.\n            parser: An optional AsyncCustomParser object for parsing incoming messages.\n            decoder: An optional AsyncCustomDecoder object for decoding incoming messages.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        self._channel = channel\n        self.declarer = declarer\n        self._parser = resolve_custom_func(parser, AioPikaParser.parse_message)\n        self._decoder = resolve_custom_func(decoder, AioPikaParser.decode_message)\n        self._rpc_lock = anyio.Lock()\n\n    async def publish(\n        self,\n        message: AioPikaSendableMessage = \"\",\n        queue: Union[RabbitQueue, str] = \"\",\n        exchange: Union[RabbitExchange, str, None] = None,\n        *,\n        routing_key: str = \"\",\n        mandatory: bool = True,\n        immediate: bool = False,\n        timeout: TimeoutType = None,\n        rpc: bool = False,\n        rpc_timeout: Optional[float] = 30.0,\n        raise_timeout: bool = False,\n        persist: bool = False,\n        reply_to: Optional[str] = None,\n        **message_kwargs: Any,\n    ) -&gt; Union[aiormq.abc.ConfirmationFrameType, SendableMessage]:\n        \"\"\"Publish a message to a RabbitMQ queue.\n\n        Args:\n            message (AioPikaSendableMessage): The message to be published.\n            queue (Union[RabbitQueue, str]): The queue to publish the message to.\n            exchange (Union[RabbitExchange, str, None]): The exchange to publish the message to.\n            routing_key (str): The routing key for the message.\n            mandatory (bool): Whether the message is mandatory.\n            immediate (bool): Whether the message should be delivered immediately.\n            timeout (TimeoutType): The timeout for the operation.\n            rpc (bool): Whether the message is for RPC.\n            rpc_timeout (Optional[float]): The timeout for RPC.\n            raise_timeout (bool): Whether to raise an exception on timeout.\n            persist (bool): Whether the message should be persisted.\n            reply_to (Optional[str]): The reply-to queue for RPC.\n            **message_kwargs (Any): Additional keyword arguments for the message.\n\n        Returns:\n            Union[aiormq.abc.ConfirmationFrameType, SendableMessage]: The result of the publish operation.\n\n        Raises:\n            WRONG_PUBLISH_ARGS: If reply_to is not None when rpc is True.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        p_queue = RabbitQueue.validate(queue)\n\n        context: AsyncContextManager[\n            Optional[MemoryObjectReceiveStream[aio_pika.IncomingMessage]]\n        ]\n        if rpc is True:\n            if reply_to is not None:\n                raise WRONG_PUBLISH_ARGS\n            else:\n                context = _RPCCallback(\n                    self._rpc_lock,\n                    self.declarer.queues[RABBIT_REPLY],\n                )\n        else:\n            context = _fake_context()\n\n        async with context as response_queue:\n            r = await self._publish(\n                message=message,\n                exchange=exchange,\n                routing_key=routing_key or p_queue.routing or \"\",\n                mandatory=mandatory,\n                immediate=immediate,\n                timeout=timeout,\n                persist=persist,\n                reply_to=RABBIT_REPLY if response_queue else reply_to,\n                **message_kwargs,\n            )\n\n            if response_queue is None:\n                return r\n\n            else:\n                msg: Optional[aio_pika.IncomingMessage] = None\n                with timeout_scope(rpc_timeout, raise_timeout):\n                    msg = await response_queue.receive()\n\n                if msg:\n                    return await self._decoder(await self._parser(msg))\n\n        return None\n\n    async def _publish(\n        self,\n        message: AioPikaSendableMessage = \"\",\n        exchange: Union[RabbitExchange, str, None] = None,\n        *,\n        routing_key: str = \"\",\n        mandatory: bool = True,\n        immediate: bool = False,\n        timeout: TimeoutType = None,\n        persist: bool = False,\n        reply_to: Optional[str] = None,\n        **message_kwargs: Any,\n    ) -&gt; Union[aiormq.abc.ConfirmationFrameType, SendableMessage]:\n        \"\"\"Publish a message to a RabbitMQ exchange.\n\n        Args:\n            message (AioPikaSendableMessage): The message to be published.\n            exchange (Union[RabbitExchange, str, None]): The exchange to publish the message to.\n            routing_key (str): The routing key for the message.\n            mandatory (bool): Whether the message is mandatory.\n            immediate (bool): Whether the message should be delivered immediately.\n            timeout (TimeoutType): The timeout for the operation.\n            persist (bool): Whether the message should be persisted.\n            reply_to (Optional[str]): The reply-to address for the message.\n            **message_kwargs (Any): Additional keyword arguments for the message.\n\n        Returns:\n            Union[aiormq.abc.ConfirmationFrameType, SendableMessage]: The result of the publish operation.\n\n        Raises:\n            NotImplementedError: If silent animals are not supported.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        p_exchange = RabbitExchange.validate(exchange)\n\n        if p_exchange is None:\n            exchange_obj = self._channel.default_exchange\n        else:\n            exchange_obj = await self.declarer.declare_exchange(p_exchange)\n\n        message = AioPikaParser.encode_message(\n            message=message,\n            persist=persist,\n            reply_to=reply_to,\n            **message_kwargs,\n        )\n\n        return await exchange_obj.publish(\n            message=message,\n            routing_key=routing_key,\n            mandatory=mandatory,\n            immediate=immediate,\n            timeout=timeout,\n        )\n</code></pre>"},{"location":"api/faststream/rabbit/producer/AioPikaFastProducer/#faststream.rabbit.producer.AioPikaFastProducer.declarer","title":"declarer  <code>instance-attribute</code>","text":"<pre><code>declarer: RabbitDeclarer = declarer\n</code></pre>"},{"location":"api/faststream/rabbit/producer/AioPikaFastProducer/#faststream.rabbit.producer.AioPikaFastProducer.publish","title":"publish  <code>async</code>","text":"<pre><code>publish(\n    message: AioPikaSendableMessage = \"\",\n    queue: Union[RabbitQueue, str] = \"\",\n    exchange: Union[RabbitExchange, str, None] = None,\n    *,\n    routing_key: str = \"\",\n    mandatory: bool = True,\n    immediate: bool = False,\n    timeout: TimeoutType = None,\n    rpc: bool = False,\n    rpc_timeout: Optional[float] = 30.0,\n    raise_timeout: bool = False,\n    persist: bool = False,\n    reply_to: Optional[str] = None,\n    **message_kwargs: Any\n) -&gt; Union[\n    aiormq.abc.ConfirmationFrameType, SendableMessage\n]\n</code></pre> <p>Publish a message to a RabbitMQ queue.</p> PARAMETER  DESCRIPTION <code>message</code> <p>The message to be published.</p> <p> TYPE: <code>AioPikaSendableMessage</code> DEFAULT: <code>''</code> </p> <code>queue</code> <p>The queue to publish the message to.</p> <p> TYPE: <code>Union[RabbitQueue, str]</code> DEFAULT: <code>''</code> </p> <code>exchange</code> <p>The exchange to publish the message to.</p> <p> TYPE: <code>Union[RabbitExchange, str, None]</code> DEFAULT: <code>None</code> </p> <code>routing_key</code> <p>The routing key for the message.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>mandatory</code> <p>Whether the message is mandatory.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>immediate</code> <p>Whether the message should be delivered immediately.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>timeout</code> <p>The timeout for the operation.</p> <p> TYPE: <code>TimeoutType</code> DEFAULT: <code>None</code> </p> <code>rpc</code> <p>Whether the message is for RPC.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>rpc_timeout</code> <p>The timeout for RPC.</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>30.0</code> </p> <code>raise_timeout</code> <p>Whether to raise an exception on timeout.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>persist</code> <p>Whether the message should be persisted.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>reply_to</code> <p>The reply-to queue for RPC.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>**message_kwargs</code> <p>Additional keyword arguments for the message.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Union[ConfirmationFrameType, SendableMessage]</code> <p>Union[aiormq.abc.ConfirmationFrameType, SendableMessage]: The result of the publish operation.</p> RAISES DESCRIPTION <code>WRONG_PUBLISH_ARGS</code> <p>If reply_to is not None when rpc is True.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/rabbit/producer.py</code> <pre><code>async def publish(\n    self,\n    message: AioPikaSendableMessage = \"\",\n    queue: Union[RabbitQueue, str] = \"\",\n    exchange: Union[RabbitExchange, str, None] = None,\n    *,\n    routing_key: str = \"\",\n    mandatory: bool = True,\n    immediate: bool = False,\n    timeout: TimeoutType = None,\n    rpc: bool = False,\n    rpc_timeout: Optional[float] = 30.0,\n    raise_timeout: bool = False,\n    persist: bool = False,\n    reply_to: Optional[str] = None,\n    **message_kwargs: Any,\n) -&gt; Union[aiormq.abc.ConfirmationFrameType, SendableMessage]:\n    \"\"\"Publish a message to a RabbitMQ queue.\n\n    Args:\n        message (AioPikaSendableMessage): The message to be published.\n        queue (Union[RabbitQueue, str]): The queue to publish the message to.\n        exchange (Union[RabbitExchange, str, None]): The exchange to publish the message to.\n        routing_key (str): The routing key for the message.\n        mandatory (bool): Whether the message is mandatory.\n        immediate (bool): Whether the message should be delivered immediately.\n        timeout (TimeoutType): The timeout for the operation.\n        rpc (bool): Whether the message is for RPC.\n        rpc_timeout (Optional[float]): The timeout for RPC.\n        raise_timeout (bool): Whether to raise an exception on timeout.\n        persist (bool): Whether the message should be persisted.\n        reply_to (Optional[str]): The reply-to queue for RPC.\n        **message_kwargs (Any): Additional keyword arguments for the message.\n\n    Returns:\n        Union[aiormq.abc.ConfirmationFrameType, SendableMessage]: The result of the publish operation.\n\n    Raises:\n        WRONG_PUBLISH_ARGS: If reply_to is not None when rpc is True.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    p_queue = RabbitQueue.validate(queue)\n\n    context: AsyncContextManager[\n        Optional[MemoryObjectReceiveStream[aio_pika.IncomingMessage]]\n    ]\n    if rpc is True:\n        if reply_to is not None:\n            raise WRONG_PUBLISH_ARGS\n        else:\n            context = _RPCCallback(\n                self._rpc_lock,\n                self.declarer.queues[RABBIT_REPLY],\n            )\n    else:\n        context = _fake_context()\n\n    async with context as response_queue:\n        r = await self._publish(\n            message=message,\n            exchange=exchange,\n            routing_key=routing_key or p_queue.routing or \"\",\n            mandatory=mandatory,\n            immediate=immediate,\n            timeout=timeout,\n            persist=persist,\n            reply_to=RABBIT_REPLY if response_queue else reply_to,\n            **message_kwargs,\n        )\n\n        if response_queue is None:\n            return r\n\n        else:\n            msg: Optional[aio_pika.IncomingMessage] = None\n            with timeout_scope(rpc_timeout, raise_timeout):\n                msg = await response_queue.receive()\n\n            if msg:\n                return await self._decoder(await self._parser(msg))\n\n    return None\n</code></pre>"},{"location":"api/faststream/rabbit/publisher/LogicPublisher/","title":"LogicPublisher","text":""},{"location":"api/faststream/rabbit/publisher/LogicPublisher/#faststream.rabbit.publisher.LogicPublisher","title":"faststream.rabbit.publisher.LogicPublisher  <code>dataclass</code>","text":"<p>             Bases: <code>ABCPublisher[IncomingMessage]</code></p> <p>A class to publish messages for logic processing.</p> METHOD DESCRIPTION <code>publish </code> <p>Publishes a message for logic processing.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/rabbit/publisher.py</code> <pre><code>@dataclass\nclass LogicPublisher(ABCPublisher[IncomingMessage]):\n    \"\"\"A class to publish messages for logic processing.\n\n    Attributes:\n        _producer : An optional AioPikaFastProducer object.\n\n    Methods:\n        publish : Publishes a message for logic processing.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    _producer: Optional[AioPikaFastProducer] = field(default=None, init=False)\n\n    @override\n    async def publish(  # type: ignore[override]\n        self,\n        message: AioPikaSendableMessage = \"\",\n        *,\n        rpc: bool = False,\n        rpc_timeout: Optional[float] = 30.0,\n        raise_timeout: bool = False,\n        correlation_id: Optional[str] = None,\n        **message_kwargs: Any,\n    ) -&gt; Union[aiormq.abc.ConfirmationFrameType, SendableMessage]:\n        \"\"\"Publish a message.\n\n        Args:\n            message: The message to be published.\n            rpc: Whether the message is for RPC (Remote Procedure Call).\n            rpc_timeout: Timeout for RPC.\n            raise_timeout: Whether to raise an exception if timeout occurs.\n            correlation_id: Correlation ID for the message.\n            **message_kwargs: Additional keyword arguments for the message.\n\n        Returns:\n            ConfirmationFrameType or SendableMessage: The result of the publish operation.\n\n        Raises:\n            AssertionError: If `_producer` is not set up.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        assert self._producer, \"Please, setup `_producer` first\"  # nosec B101\n        return await self._producer.publish(\n            message=message,\n            queue=self.queue,\n            exchange=self.exchange,\n            routing_key=self.routing_key,\n            mandatory=self.mandatory,\n            immediate=self.immediate,\n            timeout=self.timeout,\n            rpc=rpc,\n            rpc_timeout=rpc_timeout,\n            raise_timeout=raise_timeout,\n            persist=self.persist,\n            reply_to=self.reply_to,\n            correlation_id=correlation_id,\n            **self.message_kwargs,\n            **message_kwargs,\n        )\n</code></pre>"},{"location":"api/faststream/rabbit/publisher/LogicPublisher/#faststream.rabbit.publisher.LogicPublisher.name","title":"name","text":"<pre><code>name() -&gt; str\n</code></pre> Source code in <code>faststream/rabbit/publisher.py</code> <pre><code>    _producer : An optional AioPikaFastProducer object.\n\nMethods:\n</code></pre>"},{"location":"api/faststream/rabbit/publisher/LogicPublisher/#faststream.rabbit.publisher.LogicPublisher.publish","title":"publish  <code>async</code>","text":"<pre><code>publish(\n    message: AioPikaSendableMessage = \"\",\n    *,\n    rpc: bool = False,\n    rpc_timeout: Optional[float] = 30.0,\n    raise_timeout: bool = False,\n    correlation_id: Optional[str] = None,\n    **message_kwargs: Any\n) -&gt; Union[\n    aiormq.abc.ConfirmationFrameType, SendableMessage\n]\n</code></pre> <p>Publish a message.</p> PARAMETER  DESCRIPTION <code>message</code> <p>The message to be published.</p> <p> TYPE: <code>AioPikaSendableMessage</code> DEFAULT: <code>''</code> </p> <code>rpc</code> <p>Whether the message is for RPC (Remote Procedure Call).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>rpc_timeout</code> <p>Timeout for RPC.</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>30.0</code> </p> <code>raise_timeout</code> <p>Whether to raise an exception if timeout occurs.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>correlation_id</code> <p>Correlation ID for the message.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>**message_kwargs</code> <p>Additional keyword arguments for the message.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Union[ConfirmationFrameType, SendableMessage]</code> <p>ConfirmationFrameType or SendableMessage: The result of the publish operation.</p> RAISES DESCRIPTION <code>AssertionError</code> <p>If <code>_producer</code> is not set up.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/rabbit/publisher.py</code> <pre><code>@override\nasync def publish(  # type: ignore[override]\n    self,\n    message: AioPikaSendableMessage = \"\",\n    *,\n    rpc: bool = False,\n    rpc_timeout: Optional[float] = 30.0,\n    raise_timeout: bool = False,\n    correlation_id: Optional[str] = None,\n    **message_kwargs: Any,\n) -&gt; Union[aiormq.abc.ConfirmationFrameType, SendableMessage]:\n    \"\"\"Publish a message.\n\n    Args:\n        message: The message to be published.\n        rpc: Whether the message is for RPC (Remote Procedure Call).\n        rpc_timeout: Timeout for RPC.\n        raise_timeout: Whether to raise an exception if timeout occurs.\n        correlation_id: Correlation ID for the message.\n        **message_kwargs: Additional keyword arguments for the message.\n\n    Returns:\n        ConfirmationFrameType or SendableMessage: The result of the publish operation.\n\n    Raises:\n        AssertionError: If `_producer` is not set up.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    assert self._producer, \"Please, setup `_producer` first\"  # nosec B101\n    return await self._producer.publish(\n        message=message,\n        queue=self.queue,\n        exchange=self.exchange,\n        routing_key=self.routing_key,\n        mandatory=self.mandatory,\n        immediate=self.immediate,\n        timeout=self.timeout,\n        rpc=rpc,\n        rpc_timeout=rpc_timeout,\n        raise_timeout=raise_timeout,\n        persist=self.persist,\n        reply_to=self.reply_to,\n        correlation_id=correlation_id,\n        **self.message_kwargs,\n        **message_kwargs,\n    )\n</code></pre>"},{"location":"api/faststream/rabbit/router/RabbitRouter/","title":"RabbitRouter","text":""},{"location":"api/faststream/rabbit/router/RabbitRouter/#faststream.rabbit.router.RabbitRouter","title":"faststream.rabbit.router.RabbitRouter","text":"<p>             Bases: <code>RabbitRouter</code></p> <p>A class representing a RabbitMQ router for publishing messages.</p> METHOD DESCRIPTION <code>_get_publisher_key </code> <p>Returns the key for a given Publisher object</p> <code>_update_publisher_prefix </code> <p>Updates the prefix of a given Publisher object</p> <code>publisher </code> <p>Publishes a message to RabbitMQ</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/rabbit/router.py</code> <pre><code>class RabbitRouter(BaseRouter):\n    \"\"\"A class representing a RabbitMQ router for publishing messages.\n\n    Attributes:\n        _publishers : A dictionary mapping integer keys to Publisher objects\n\n    Methods:\n        _get_publisher_key : Returns the key for a given Publisher object\n        _update_publisher_prefix : Updates the prefix of a given Publisher object\n        publisher : Publishes a message to RabbitMQ\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    _publishers: Dict[int, Publisher]\n\n    @staticmethod\n    def _get_publisher_key(publisher: Publisher) -&gt; int:\n        \"\"\"Get the publisher key.\n\n        Args:\n            publisher: The publisher object.\n\n        Returns:\n            The publisher key as an integer.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        return get_routing_hash(publisher.queue, publisher.exchange)\n\n    @staticmethod\n    def _update_publisher_prefix(prefix: str, publisher: Publisher) -&gt; Publisher:\n        \"\"\"Updates the publisher prefix.\n\n        Args:\n            prefix (str): The prefix to be added to the publisher's queue name.\n            publisher (Publisher): The publisher object to be updated.\n\n        Returns:\n            Publisher: The updated publisher object.\n\n        Note:\n            This function is intended to be used as a decorator.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        publisher.queue = model_copy(\n            publisher.queue, update={\"name\": prefix + publisher.queue.name}\n        )\n        return publisher\n\n    @override\n    def publisher(  # type: ignore[override]\n        self,\n        queue: Union[RabbitQueue, str] = \"\",\n        exchange: Union[RabbitExchange, str, None] = None,\n        *,\n        routing_key: str = \"\",\n        mandatory: bool = True,\n        immediate: bool = False,\n        timeout: TimeoutType = None,\n        persist: bool = False,\n        reply_to: Optional[str] = None,\n        # AsyncAPI information\n        title: Optional[str] = None,\n        description: Optional[str] = None,\n        **message_kwargs: Any,\n    ) -&gt; Publisher:\n        \"\"\"Publishes a message to a RabbitMQ queue or exchange.\n\n        Args:\n            queue: The RabbitMQ queue to publish the message to. Can be either a RabbitQueue object or a string representing the queue name.\n            exchange: The RabbitMQ exchange to publish the message to. Can be either a RabbitExchange object, a string representing the exchange name, or None.\n            routing_key: The routing key to use when publishing the message.\n            mandatory: Whether the message is mandatory or not.\n            immediate: Whether the message should be delivered immediately or not.\n            timeout: The timeout for the publish operation.\n            persist: Whether the message should be persisted or not.\n            reply_to: The reply-to address for the message.\n            title: The title of the message (AsyncAPI information).\n            description: The description of the message (AsyncAPI information).\n            **message_kwargs: Additional keyword arguments to include in the message.\n\n        Returns:\n            The Publisher object used to publish the message.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        new_publisher = self._update_publisher_prefix(\n            self.prefix,\n            Publisher(\n                queue=RabbitQueue.validate(queue),\n                exchange=RabbitExchange.validate(exchange),\n                routing_key=routing_key,\n                mandatory=mandatory,\n                immediate=immediate,\n                timeout=timeout,\n                persist=persist,\n                reply_to=reply_to,\n                message_kwargs=message_kwargs,\n                title=title,\n                _description=description,\n            ),\n        )\n        key = self._get_publisher_key(new_publisher)\n        publisher = self._publishers[key] = self._publishers.get(key, new_publisher)\n        return publisher\n</code></pre>"},{"location":"api/faststream/rabbit/router/RabbitRouter/#faststream.rabbit.router.RabbitRouter.publisher","title":"publisher","text":"<pre><code>publisher(\n    queue: Union[RabbitQueue, str] = \"\",\n    exchange: Union[RabbitExchange, str, None] = None,\n    *,\n    routing_key: str = \"\",\n    mandatory: bool = True,\n    immediate: bool = False,\n    timeout: TimeoutType = None,\n    persist: bool = False,\n    reply_to: Optional[str] = None,\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n    **message_kwargs: Any\n) -&gt; Publisher\n</code></pre> <p>Publishes a message to a RabbitMQ queue or exchange.</p> PARAMETER  DESCRIPTION <code>queue</code> <p>The RabbitMQ queue to publish the message to. Can be either a RabbitQueue object or a string representing the queue name.</p> <p> TYPE: <code>Union[RabbitQueue, str]</code> DEFAULT: <code>''</code> </p> <code>exchange</code> <p>The RabbitMQ exchange to publish the message to. Can be either a RabbitExchange object, a string representing the exchange name, or None.</p> <p> TYPE: <code>Union[RabbitExchange, str, None]</code> DEFAULT: <code>None</code> </p> <code>routing_key</code> <p>The routing key to use when publishing the message.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>mandatory</code> <p>Whether the message is mandatory or not.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>immediate</code> <p>Whether the message should be delivered immediately or not.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>timeout</code> <p>The timeout for the publish operation.</p> <p> TYPE: <code>TimeoutType</code> DEFAULT: <code>None</code> </p> <code>persist</code> <p>Whether the message should be persisted or not.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>reply_to</code> <p>The reply-to address for the message.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>title</code> <p>The title of the message (AsyncAPI information).</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>description</code> <p>The description of the message (AsyncAPI information).</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>**message_kwargs</code> <p>Additional keyword arguments to include in the message.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Publisher</code> <p>The Publisher object used to publish the message.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/rabbit/router.py</code> <pre><code>@override\ndef publisher(  # type: ignore[override]\n    self,\n    queue: Union[RabbitQueue, str] = \"\",\n    exchange: Union[RabbitExchange, str, None] = None,\n    *,\n    routing_key: str = \"\",\n    mandatory: bool = True,\n    immediate: bool = False,\n    timeout: TimeoutType = None,\n    persist: bool = False,\n    reply_to: Optional[str] = None,\n    # AsyncAPI information\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n    **message_kwargs: Any,\n) -&gt; Publisher:\n    \"\"\"Publishes a message to a RabbitMQ queue or exchange.\n\n    Args:\n        queue: The RabbitMQ queue to publish the message to. Can be either a RabbitQueue object or a string representing the queue name.\n        exchange: The RabbitMQ exchange to publish the message to. Can be either a RabbitExchange object, a string representing the exchange name, or None.\n        routing_key: The routing key to use when publishing the message.\n        mandatory: Whether the message is mandatory or not.\n        immediate: Whether the message should be delivered immediately or not.\n        timeout: The timeout for the publish operation.\n        persist: Whether the message should be persisted or not.\n        reply_to: The reply-to address for the message.\n        title: The title of the message (AsyncAPI information).\n        description: The description of the message (AsyncAPI information).\n        **message_kwargs: Additional keyword arguments to include in the message.\n\n    Returns:\n        The Publisher object used to publish the message.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    new_publisher = self._update_publisher_prefix(\n        self.prefix,\n        Publisher(\n            queue=RabbitQueue.validate(queue),\n            exchange=RabbitExchange.validate(exchange),\n            routing_key=routing_key,\n            mandatory=mandatory,\n            immediate=immediate,\n            timeout=timeout,\n            persist=persist,\n            reply_to=reply_to,\n            message_kwargs=message_kwargs,\n            title=title,\n            _description=description,\n        ),\n    )\n    key = self._get_publisher_key(new_publisher)\n    publisher = self._publishers[key] = self._publishers.get(key, new_publisher)\n    return publisher\n</code></pre>"},{"location":"api/faststream/rabbit/router/RabbitRouter/#faststream.rabbit.router.RabbitRouter.subscriber","title":"subscriber","text":"<pre><code>subscriber(\n    queue: Union[str, RabbitQueue],\n    exchange: Union[str, RabbitExchange, None] = None,\n    *,\n    consume_args: Optional[AnyDict] = None,\n    dependencies: Sequence[Depends] = (),\n    filter: Filter[RabbitMessage] = default_filter,\n    parser: Optional[\n        CustomParser[\n            aio_pika.IncomingMessage, RabbitMessage\n        ]\n    ] = None,\n    decoder: Optional[CustomDecoder[RabbitMessage]] = None,\n    middlewares: Optional[\n        Sequence[\n            Callable[\n                [aio_pika.IncomingMessage], BaseMiddleware\n            ]\n        ]\n    ] = None,\n    retry: Union[bool, int] = False,\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n    **__service_kwargs: Any\n) -&gt; Callable[\n    [Callable[P_HandlerParams, T_HandlerReturn]],\n    HandlerCallWrapper[\n        aio_pika.IncomingMessage,\n        P_HandlerParams,\n        T_HandlerReturn,\n    ],\n]\n</code></pre> Source code in <code>faststream/rabbit/router.py</code> <pre><code>def _update_publisher_prefix(prefix: str, publisher: Publisher) -&gt; Publisher:\n    \"\"\"Updates the publisher prefix.\n\n    Args:\n        prefix (str): The prefix to be added to the publisher's queue name.\n        publisher (Publisher): The publisher object to be updated.\n\n    Returns:\n        Publisher: The updated publisher object.\n\n    Note:\n        This function is intended to be used as a decorator.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    publisher.queue = model_copy(\n        publisher.queue, update={\"name\": prefix + publisher.queue.name}\n    )\n    return publisher\n\n@override\ndef publisher(  # type: ignore[override]\n    self,\n    queue: Union[RabbitQueue, str] = \"\",\n    exchange: Union[RabbitExchange, str, None] = None,\n    *,\n    routing_key: str = \"\",\n    mandatory: bool = True,\n</code></pre>"},{"location":"api/faststream/rabbit/security/parse_security/","title":"Parse security","text":""},{"location":"api/faststream/rabbit/security/parse_security/#faststream.rabbit.security.parse_security","title":"faststream.rabbit.security.parse_security","text":"<pre><code>parse_security(\n    security: Optional[BaseSecurity],\n) -&gt; Dict[str, Any]\n</code></pre> Source code in <code>faststream/rabbit/security.py</code> <pre><code>def parse_security(security: Optional[BaseSecurity]) -&gt; Dict[str, Any]:\n    if security is None:\n        return {}\n    else:\n        raise NotImplementedError(f\"RabbitBroker does not support {type(security)}\")\n</code></pre>"},{"location":"api/faststream/rabbit/shared/constants/ExchangeType/","title":"ExchangeType","text":""},{"location":"api/faststream/rabbit/shared/constants/ExchangeType/#faststream.rabbit.shared.constants.ExchangeType","title":"faststream.rabbit.shared.constants.ExchangeType","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p> <p>A class to represent the exchange type.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/rabbit/shared/constants.py</code> <pre><code>@unique\nclass ExchangeType(str, Enum):\n    \"\"\"A class to represent the exchange type.\n\n    Attributes:\n        FANOUT : fanout exchange type\n        DIRECT : direct exchange type\n        TOPIC : topic exchange type\n        HEADERS : headers exchange type\n        X_DELAYED_MESSAGE : x-delayed-message exchange type\n        X_CONSISTENT_HASH : x-consistent-hash exchange type\n        X_MODULUS_HASH : x-modulus-hash exchange type\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    FANOUT = \"fanout\"\n    DIRECT = \"direct\"\n    TOPIC = \"topic\"\n    HEADERS = \"headers\"\n    X_DELAYED_MESSAGE = \"x-delayed-message\"\n    X_CONSISTENT_HASH = \"x-consistent-hash\"\n    X_MODULUS_HASH = \"x-modulus-hash\"\n</code></pre>"},{"location":"api/faststream/rabbit/shared/constants/ExchangeType/#faststream.rabbit.shared.constants.ExchangeType.DIRECT","title":"DIRECT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DIRECT = 'direct'\n</code></pre>"},{"location":"api/faststream/rabbit/shared/constants/ExchangeType/#faststream.rabbit.shared.constants.ExchangeType.FANOUT","title":"FANOUT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FANOUT = 'fanout'\n</code></pre>"},{"location":"api/faststream/rabbit/shared/constants/ExchangeType/#faststream.rabbit.shared.constants.ExchangeType.HEADERS","title":"HEADERS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>HEADERS = 'headers'\n</code></pre>"},{"location":"api/faststream/rabbit/shared/constants/ExchangeType/#faststream.rabbit.shared.constants.ExchangeType.TOPIC","title":"TOPIC  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TOPIC = 'topic'\n</code></pre>"},{"location":"api/faststream/rabbit/shared/constants/ExchangeType/#faststream.rabbit.shared.constants.ExchangeType.X_CONSISTENT_HASH","title":"X_CONSISTENT_HASH  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>X_CONSISTENT_HASH = 'x-consistent-hash'\n</code></pre>"},{"location":"api/faststream/rabbit/shared/constants/ExchangeType/#faststream.rabbit.shared.constants.ExchangeType.X_DELAYED_MESSAGE","title":"X_DELAYED_MESSAGE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>X_DELAYED_MESSAGE = 'x-delayed-message'\n</code></pre>"},{"location":"api/faststream/rabbit/shared/constants/ExchangeType/#faststream.rabbit.shared.constants.ExchangeType.X_MODULUS_HASH","title":"X_MODULUS_HASH  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>X_MODULUS_HASH = 'x-modulus-hash'\n</code></pre>"},{"location":"api/faststream/rabbit/shared/logging/RabbitLoggingMixin/","title":"RabbitLoggingMixin","text":""},{"location":"api/faststream/rabbit/shared/logging/RabbitLoggingMixin/#faststream.rabbit.shared.logging.RabbitLoggingMixin","title":"faststream.rabbit.shared.logging.RabbitLoggingMixin","text":"<p>             Bases: <code>LoggingMixin</code></p> <p>A class that extends the LoggingMixin class and adds additional functionality for logging RabbitMQ related information.</p> METHOD DESCRIPTION <code>__init__ </code> <p>Initializes the RabbitLoggingMixin object.</p> <code>_get_log_context </code> <p>Overrides the _get_log_context method of the LoggingMixin class to include RabbitMQ related context information.</p> <code>fmt </code> <p>Returns the log format string.</p> <code>_setup_log_context </code> <p>Sets up the log context by updating the maximum lengths of the queue and exchange names.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/rabbit/shared/logging.py</code> <pre><code>class RabbitLoggingMixin(LoggingMixin):\n    \"\"\"A class that extends the LoggingMixin class and adds additional functionality for logging RabbitMQ related information.\n\n    Attributes:\n        _max_queue_len : maximum length of the queue name\n        _max_exchange_len : maximum length of the exchange name\n\n    Methods:\n        __init__ : Initializes the RabbitLoggingMixin object.\n        _get_log_context : Overrides the _get_log_context method of the LoggingMixin class to include RabbitMQ related context information.\n        fmt : Returns the log format string.\n        _setup_log_context : Sets up the log context by updating the maximum lengths of the queue and exchange names.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    _max_queue_len: int\n    _max_exchange_len: int\n\n    def __init__(\n        self,\n        *args: Any,\n        logger: Optional[logging.Logger] = access_logger,\n        log_level: int = logging.INFO,\n        log_fmt: Optional[str] = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"Initialize the class.\n\n        Args:\n            *args: Variable length argument list\n            logger: Optional logger object\n            log_level: Logging level\n            log_fmt: Optional log format\n            **kwargs: Arbitrary keyword arguments\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        super().__init__(\n            *args,\n            logger=logger,\n            log_level=log_level,\n            log_fmt=log_fmt,\n            **kwargs,\n        )\n        self._max_queue_len = 4\n        self._max_exchange_len = 4\n\n    @override\n    def _get_log_context(  # type: ignore[override]\n        self,\n        message: Optional[StreamMessage[Any]],\n        queue: RabbitQueue,\n        exchange: Optional[RabbitExchange] = None,\n    ) -&gt; AnyDict:\n        \"\"\"Get the log context.\n\n        Args:\n            message: Optional stream message.\n            queue: RabbitQueue object.\n            exchange: Optional RabbitExchange object.\n\n        Returns:\n            Dictionary containing the log context.\n\n        Note:\n            This is a private method and should not be called directly.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        context = {\n            \"queue\": queue.name,\n            \"exchange\": exchange.name if exchange else \"default\",\n            **super()._get_log_context(message),\n        }\n        return context\n\n    @property\n    def fmt(self) -&gt; str:\n        return super().fmt or (\n            \"%(asctime)s %(levelname)s - \"\n            f\"%(exchange)-{self._max_exchange_len}s | \"\n            f\"%(queue)-{self._max_queue_len}s | \"\n            f\"%(message_id)-10s \"\n            \"- %(message)s\"\n        )\n\n    def _setup_log_context(\n        self,\n        queue: Optional[RabbitQueue] = None,\n        exchange: Optional[RabbitExchange] = None,\n    ) -&gt; None:\n        \"\"\"Set up log context.\n\n        Args:\n            queue: Optional RabbitQueue object representing the queue.\n            exchange: Optional RabbitExchange object representing the exchange.\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        if exchange is not None:\n            self._max_exchange_len = max(\n                self._max_exchange_len, len(exchange.name or \"\")\n            )\n\n        if queue is not None:  # pragma: no branch\n            self._max_queue_len = max(self._max_queue_len, len(queue.name))\n</code></pre>"},{"location":"api/faststream/rabbit/shared/logging/RabbitLoggingMixin/#faststream.rabbit.shared.logging.RabbitLoggingMixin.fmt","title":"fmt  <code>property</code>","text":"<pre><code>fmt: str\n</code></pre>"},{"location":"api/faststream/rabbit/shared/publisher/ABCPublisher/","title":"ABCPublisher","text":""},{"location":"api/faststream/rabbit/shared/publisher/ABCPublisher/#faststream.rabbit.shared.publisher.ABCPublisher","title":"faststream.rabbit.shared.publisher.ABCPublisher  <code>dataclass</code>","text":"<p>             Bases: <code>ABC</code>, <code>BasePublisher[MsgType]</code>, <code>BaseRMQInformation</code></p> <p>A class representing an ABCPublisher.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/rabbit/shared/publisher.py</code> <pre><code>@dataclass\nclass ABCPublisher(ABC, BasePublisher[MsgType], BaseRMQInformation):\n    \"\"\"A class representing an ABCPublisher.\n\n    Attributes:\n        routing_key : str, optional\n            The routing key for the publisher.\n        mandatory : bool, optional\n            Whether the message is mandatory or not.\n        immediate : bool, optional\n            Whether the message should be immediately delivered or not.\n        persist : bool, optional\n            Whether the message should be persisted or not.\n        timeout : TimeoutType, optional\n            The timeout for the message.\n        reply_to : str, optional\n            The reply-to address for the message.\n        message_kwargs : dict, optional\n            Additional keyword arguments for the message.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    routing_key: str = \"\"\n    mandatory: bool = True\n    immediate: bool = False\n    persist: bool = False\n    timeout: TimeoutType = None\n    reply_to: Optional[str] = None\n    message_kwargs: AnyDict = field(default_factory=dict)\n</code></pre>"},{"location":"api/faststream/rabbit/shared/publisher/ABCPublisher/#faststream.rabbit.shared.publisher.ABCPublisher.immediate","title":"immediate  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>immediate: bool = False\n</code></pre>"},{"location":"api/faststream/rabbit/shared/publisher/ABCPublisher/#faststream.rabbit.shared.publisher.ABCPublisher.mandatory","title":"mandatory  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mandatory: bool = True\n</code></pre>"},{"location":"api/faststream/rabbit/shared/publisher/ABCPublisher/#faststream.rabbit.shared.publisher.ABCPublisher.message_kwargs","title":"message_kwargs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>message_kwargs: AnyDict = field(default_factory=dict)\n</code></pre>"},{"location":"api/faststream/rabbit/shared/publisher/ABCPublisher/#faststream.rabbit.shared.publisher.ABCPublisher.persist","title":"persist  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>persist: bool = False\n</code></pre>"},{"location":"api/faststream/rabbit/shared/publisher/ABCPublisher/#faststream.rabbit.shared.publisher.ABCPublisher.reply_to","title":"reply_to  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>reply_to: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/rabbit/shared/publisher/ABCPublisher/#faststream.rabbit.shared.publisher.ABCPublisher.routing_key","title":"routing_key  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>routing_key: str = ''\n</code></pre>"},{"location":"api/faststream/rabbit/shared/publisher/ABCPublisher/#faststream.rabbit.shared.publisher.ABCPublisher.timeout","title":"timeout  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>timeout: TimeoutType = None\n</code></pre>"},{"location":"api/faststream/rabbit/shared/router/RabbitRouter/","title":"RabbitRouter","text":""},{"location":"api/faststream/rabbit/shared/router/RabbitRouter/#faststream.rabbit.shared.router.RabbitRouter","title":"faststream.rabbit.shared.router.RabbitRouter","text":"<p>             Bases: <code>BrokerRouter[int, IncomingMessage]</code></p> <p>A class representing a RabbitMQ router for handling incoming messages.</p> METHOD DESCRIPTION <code>__init__ </code> <p>initializes the RabbitRouter object</p> <code>subscriber </code> <p>decorator for subscribing to a queue and registering a handler function</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/rabbit/shared/router.py</code> <pre><code>class RabbitRouter(BrokerRouter[int, IncomingMessage]):\n    \"\"\"A class representing a RabbitMQ router for handling incoming messages.\n\n    Attributes:\n        prefix : prefix for the queue name\n        handlers : sequence of RabbitRoutes for handling incoming messages\n        kwargs : additional keyword arguments\n\n    Methods:\n        __init__ : initializes the RabbitRouter object\n        subscriber : decorator for subscribing to a queue and registering a handler function\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    def __init__(\n        self,\n        prefix: str = \"\",\n        handlers: Sequence[RabbitRoute[IncomingMessage, SendableMessage]] = (),\n        **kwargs: Any,\n    ):\n        \"\"\"Override the `__init__` method of the parent class.\n\n        Args:\n            prefix: A prefix string\n            handlers: A sequence of RabbitRoute objects\n            **kwargs: Additional keyword arguments\n\n        Raises:\n            NotImplementedError: If silent animals are not supported\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        for h in handlers:\n            if (q := h.kwargs.pop(\"queue\", None)) is None:\n                q, h.args = h.args[0], h.args[1:]\n            queue = RabbitQueue.validate(q)\n            new_q = model_copy(queue, update={\"name\": prefix + queue.name})\n            h.args = (new_q, *h.args)\n\n        super().__init__(prefix, handlers, **kwargs)\n\n    @override\n    def subscriber(  # type: ignore[override]\n        self,\n        queue: Union[str, RabbitQueue],\n        *broker_args: Any,\n        **broker_kwargs: Any,\n    ) -&gt; Callable[\n        [Callable[P_HandlerParams, T_HandlerReturn]],\n        HandlerCallWrapper[IncomingMessage, P_HandlerParams, T_HandlerReturn],\n    ]:\n        \"\"\"A function to subscribe to a RabbitMQ queue.\n\n        Args:\n            self : the instance of the class\n            queue : the queue to subscribe to, can be a string or a RabbitQueue object\n            *broker_args : additional arguments for the broker\n            **broker_kwargs : additional keyword arguments for the broker\n\n        Returns:\n            A callable object that wraps the handler function for the incoming messages from the queue.\n\n        Raises:\n            TypeError: If the queue is not a string or a RabbitQueue object\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        q = RabbitQueue.validate(queue)\n        new_q = model_copy(q, update={\"name\": self.prefix + q.name})\n        return self._wrap_subscriber(new_q, *broker_args, **broker_kwargs)\n</code></pre>"},{"location":"api/faststream/rabbit/shared/router/RabbitRouter/#faststream.rabbit.shared.router.RabbitRouter.subscriber","title":"subscriber","text":"<pre><code>subscriber(\n    queue: Union[str, RabbitQueue],\n    *broker_args: Any,\n    **broker_kwargs: Any\n) -&gt; Callable[\n    [Callable[P_HandlerParams, T_HandlerReturn]],\n    HandlerCallWrapper[\n        IncomingMessage, P_HandlerParams, T_HandlerReturn\n    ],\n]\n</code></pre> <p>A function to subscribe to a RabbitMQ queue.</p> PARAMETER  DESCRIPTION <code>self</code> <p>the instance of the class</p> <p> </p> <code>queue</code> <p>the queue to subscribe to, can be a string or a RabbitQueue object</p> <p> </p> <code>*broker_args</code> <p>additional arguments for the broker</p> <p> DEFAULT: <code>()</code> </p> <code>**broker_kwargs</code> <p>additional keyword arguments for the broker</p> <p> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Callable[[Callable[P_HandlerParams, T_HandlerReturn]], HandlerCallWrapper[IncomingMessage, P_HandlerParams, T_HandlerReturn]]</code> <p>A callable object that wraps the handler function for the incoming messages from the queue.</p> RAISES DESCRIPTION <code>TypeError</code> <p>If the queue is not a string or a RabbitQueue object</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/rabbit/shared/router.py</code> <pre><code>@override\ndef subscriber(  # type: ignore[override]\n    self,\n    queue: Union[str, RabbitQueue],\n    *broker_args: Any,\n    **broker_kwargs: Any,\n) -&gt; Callable[\n    [Callable[P_HandlerParams, T_HandlerReturn]],\n    HandlerCallWrapper[IncomingMessage, P_HandlerParams, T_HandlerReturn],\n]:\n    \"\"\"A function to subscribe to a RabbitMQ queue.\n\n    Args:\n        self : the instance of the class\n        queue : the queue to subscribe to, can be a string or a RabbitQueue object\n        *broker_args : additional arguments for the broker\n        **broker_kwargs : additional keyword arguments for the broker\n\n    Returns:\n        A callable object that wraps the handler function for the incoming messages from the queue.\n\n    Raises:\n        TypeError: If the queue is not a string or a RabbitQueue object\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    q = RabbitQueue.validate(queue)\n    new_q = model_copy(q, update={\"name\": self.prefix + q.name})\n    return self._wrap_subscriber(new_q, *broker_args, **broker_kwargs)\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/BaseRMQInformation/","title":"BaseRMQInformation","text":""},{"location":"api/faststream/rabbit/shared/schemas/BaseRMQInformation/#faststream.rabbit.shared.schemas.BaseRMQInformation","title":"faststream.rabbit.shared.schemas.BaseRMQInformation  <code>dataclass</code>","text":"<p>BaseRMQInformation.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/rabbit/shared/schemas.py</code> <pre><code>@dataclass\nclass BaseRMQInformation:\n    \"\"\"BaseRMQInformation.\n\n    Attributes:\n        queue : RabbitQueue object representing the queue\n        exchange : Optional RabbitExchange object representing the exchange\n        _description : Optional string describing the class\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    queue: RabbitQueue = field(default=RabbitQueue(\"\"))\n    exchange: Optional[RabbitExchange] = field(default=None)\n    _description: Optional[str] = field(default=None)\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/BaseRMQInformation/#faststream.rabbit.shared.schemas.BaseRMQInformation.exchange","title":"exchange  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>exchange: Optional[RabbitExchange] = field(default=None)\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/BaseRMQInformation/#faststream.rabbit.shared.schemas.BaseRMQInformation.queue","title":"queue  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>queue: RabbitQueue = field(default=RabbitQueue(''))\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/RabbitExchange/","title":"RabbitExchange","text":""},{"location":"api/faststream/rabbit/shared/schemas/RabbitExchange/#faststream.rabbit.shared.schemas.RabbitExchange","title":"faststream.rabbit.shared.schemas.RabbitExchange","text":"<p>             Bases: <code>NameRequired</code></p> <p>A class to represent a RabbitMQ exchange.</p> METHOD DESCRIPTION <code>__hash__ </code> <p>returns the hash value of the exchange</p> <code>__init__ </code> <p>initializes the RabbitExchange object</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/rabbit/shared/schemas.py</code> <pre><code>class RabbitExchange(NameRequired):\n    \"\"\"A class to represent a RabbitMQ exchange.\n\n    Attributes:\n        name : name of the exchange\n        type : type of the exchange\n        durable : whether the exchange is durable or not\n        auto_delete : whether the exchange is auto-deleted or not\n        internal : whether the exchange is internal or not\n        passive : whether the exchange is passive or not\n        arguments : additional arguments for the exchange\n        timeout : timeout for the exchange\n        robust : whether the exchange is robust or not\n        bind_to : exchange to bind to\n        bind_arguments : additional arguments for the binding\n        routing_key : routing key for the exchange\n\n    Methods:\n        __hash__ : returns the hash value of the exchange\n        __init__ : initializes the RabbitExchange object\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    type: str = ExchangeType.DIRECT.value\n    durable: bool = False\n    auto_delete: bool = False\n    internal: bool = False\n    passive: bool = False\n    arguments: Optional[AnyDict] = None\n    timeout: TimeoutType = None\n    robust: bool = True\n\n    bind_to: Optional[\"RabbitExchange\"] = None\n    bind_arguments: Optional[AnyDict] = None\n    routing_key: str = \"\"\n\n    def __hash__(self) -&gt; int:\n        return sum(\n            (\n                hash(self.name),\n                hash(self.type),\n                int(self.durable),\n                int(self.auto_delete),\n            )\n        )\n\n    def __init__(\n        self,\n        name: str,\n        type: ExchangeType = ExchangeType.DIRECT,\n        durable: bool = False,\n        auto_delete: bool = False,\n        internal: bool = False,\n        passive: bool = False,\n        arguments: Optional[AnyDict] = None,\n        timeout: TimeoutType = None,\n        robust: bool = True,\n        bind_to: Optional[\"RabbitExchange\"] = None,\n        bind_arguments: Optional[AnyDict] = None,\n        routing_key: str = \"\",\n    ):\n        \"\"\"Initialize a RabbitExchange object.\n\n        Args:\n            name (str): Name of the exchange.\n            type (ExchangeType, optional): Type of the exchange. Defaults to ExchangeType.DIRECT.\n            durable (bool, optional): Whether the exchange should survive broker restarts. Defaults to False.\n            auto_delete (bool, optional): Whether the exchange should be deleted when no longer in use. Defaults to False.\n            internal (bool, optional): Whether the exchange is used for internal purposes and should not be published to directly. Defaults to False.\n            passive (bool, optional): Whether to check if the exchange exists before creating it. Defaults to False.\n            arguments (Optional[AnyDict], optional): Additional arguments for the exchange. Defaults to None.\n            timeout (TimeoutType, optional): Timeout for the operation. Defaults to None.\n            robust (bool, optional): Whether to use robust mode for the exchange. Defaults to True.\n            bind_to (Optional[\"RabbitExchange\"], optional): Exchange to bind to. Defaults to None.\n            bind_arguments (Optional[AnyDict], optional): Arguments for the binding. Defaults to None.\n            routing_key (str, optional): Routing key for the exchange. Defaults to \"\".\n\n        Raises:\n            NotImplementedError:\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        super().__init__(\n            name=name,\n            type=type.value,\n            durable=durable,\n            auto_delete=auto_delete,\n            routing_key=routing_key,\n            bind_to=bind_to,\n            bind_arguments=bind_arguments,\n            robust=robust,\n            internal=internal,\n            passive=passive,\n            timeout=timeout,\n            arguments=arguments,\n        )\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/RabbitExchange/#faststream.rabbit.shared.schemas.RabbitExchange.arguments","title":"arguments  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>arguments: Optional[AnyDict] = None\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/RabbitExchange/#faststream.rabbit.shared.schemas.RabbitExchange.auto_delete","title":"auto_delete  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>auto_delete: bool = False\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/RabbitExchange/#faststream.rabbit.shared.schemas.RabbitExchange.bind_arguments","title":"bind_arguments  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bind_arguments: Optional[AnyDict] = None\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/RabbitExchange/#faststream.rabbit.shared.schemas.RabbitExchange.bind_to","title":"bind_to  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bind_to: Optional[RabbitExchange] = None\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/RabbitExchange/#faststream.rabbit.shared.schemas.RabbitExchange.durable","title":"durable  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>durable: bool = False\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/RabbitExchange/#faststream.rabbit.shared.schemas.RabbitExchange.internal","title":"internal  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>internal: bool = False\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/RabbitExchange/#faststream.rabbit.shared.schemas.RabbitExchange.passive","title":"passive  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>passive: bool = False\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/RabbitExchange/#faststream.rabbit.shared.schemas.RabbitExchange.robust","title":"robust  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>robust: bool = True\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/RabbitExchange/#faststream.rabbit.shared.schemas.RabbitExchange.routing_key","title":"routing_key  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>routing_key: str = ''\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/RabbitExchange/#faststream.rabbit.shared.schemas.RabbitExchange.timeout","title":"timeout  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>timeout: TimeoutType = None\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/RabbitExchange/#faststream.rabbit.shared.schemas.RabbitExchange.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>type: str = ExchangeType.DIRECT.value\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/RabbitQueue/","title":"RabbitQueue","text":""},{"location":"api/faststream/rabbit/shared/schemas/RabbitQueue/#faststream.rabbit.shared.schemas.RabbitQueue","title":"faststream.rabbit.shared.schemas.RabbitQueue","text":"<p>             Bases: <code>NameRequired</code></p> <p>A class to represent a RabbitMQ queue.</p> METHOD DESCRIPTION <code>__hash__ </code> <p>returns the hash value of the queue</p> <code>routing </code> <p>returns the routing key of the queue</p> <code>__init__ </code> <p>initializes the RabbitQueue object with the given parameters</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/rabbit/shared/schemas.py</code> <pre><code>class RabbitQueue(NameRequired):\n    \"\"\"A class to represent a RabbitMQ queue.\n\n    Attributes:\n        name : name of the queue\n        durable : whether the queue is durable or not\n        exclusive : whether the queue is exclusive or not\n        passive : whether the queue is passive or not\n        auto_delete : whether the queue is auto delete or not\n        arguments : additional arguments for the queue\n        timeout : timeout for the queue\n        robust : whether the queue is robust or not\n        routing_key : routing key for the queue\n        bind_arguments : additional arguments for binding the queue\n\n    Methods:\n        __hash__ : returns the hash value of the queue\n        routing : returns the routing key of the queue\n        __init__ : initializes the RabbitQueue object with the given parameters\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    name: str = \"\"\n    durable: bool = False\n    exclusive: bool = False\n    passive: bool = False\n    auto_delete: bool = False\n    arguments: Optional[AnyDict] = None\n    timeout: TimeoutType = None\n    robust: bool = True\n\n    routing_key: str = \"\"\n    bind_arguments: Optional[AnyDict] = None\n\n    def __hash__(self) -&gt; int:\n        return sum(\n            (\n                hash(self.name),\n                int(self.durable),\n                int(self.exclusive),\n                int(self.auto_delete),\n            )\n        )\n\n    @property\n    def routing(self) -&gt; Optional[str]:\n        return self.routing_key or self.name or None\n\n    def __init__(\n        self,\n        name: str,\n        durable: bool = False,\n        exclusive: bool = False,\n        passive: bool = False,\n        auto_delete: bool = False,\n        arguments: Optional[AnyDict] = None,\n        timeout: TimeoutType = None,\n        robust: bool = True,\n        bind_arguments: Optional[AnyDict] = None,\n        routing_key: str = \"\",\n    ):\n        \"\"\"Initialize a class object.\n\n        Args:\n            name (str): The name of the object.\n            durable (bool, optional): Whether the object is durable. Defaults to False.\n            exclusive (bool, optional): Whether the object is exclusive. Defaults to False.\n            passive (bool, optional): Whether the object is passive. Defaults to False.\n            auto_delete (bool, optional): Whether the object is auto delete. Defaults to False.\n            arguments (dict, optional): Additional arguments for the object. Defaults to None.\n            timeout (TimeoutType, optional): Timeout for the object. Defaults to None.\n            robust (bool, optional): Whether the object is robust. Defaults to True.\n            bind_arguments (dict, optional): Bind arguments for the object. Defaults to None.\n            routing_key (str, optional): Routing key for the object. Defaults to \"\".\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        super().__init__(\n            name=name,\n            durable=durable,\n            exclusive=exclusive,\n            bind_arguments=bind_arguments,\n            routing_key=routing_key,\n            robust=robust,\n            passive=passive,\n            auto_delete=auto_delete,\n            arguments=arguments,\n            timeout=timeout,\n        )\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/RabbitQueue/#faststream.rabbit.shared.schemas.RabbitQueue.arguments","title":"arguments  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>arguments: Optional[AnyDict] = None\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/RabbitQueue/#faststream.rabbit.shared.schemas.RabbitQueue.auto_delete","title":"auto_delete  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>auto_delete: bool = False\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/RabbitQueue/#faststream.rabbit.shared.schemas.RabbitQueue.bind_arguments","title":"bind_arguments  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bind_arguments: Optional[AnyDict] = None\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/RabbitQueue/#faststream.rabbit.shared.schemas.RabbitQueue.durable","title":"durable  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>durable: bool = False\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/RabbitQueue/#faststream.rabbit.shared.schemas.RabbitQueue.exclusive","title":"exclusive  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>exclusive: bool = False\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/RabbitQueue/#faststream.rabbit.shared.schemas.RabbitQueue.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str = ''\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/RabbitQueue/#faststream.rabbit.shared.schemas.RabbitQueue.passive","title":"passive  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>passive: bool = False\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/RabbitQueue/#faststream.rabbit.shared.schemas.RabbitQueue.robust","title":"robust  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>robust: bool = True\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/RabbitQueue/#faststream.rabbit.shared.schemas.RabbitQueue.routing","title":"routing  <code>property</code>","text":"<pre><code>routing: Optional[str]\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/RabbitQueue/#faststream.rabbit.shared.schemas.RabbitQueue.routing_key","title":"routing_key  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>routing_key: str = ''\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/RabbitQueue/#faststream.rabbit.shared.schemas.RabbitQueue.timeout","title":"timeout  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>timeout: TimeoutType = None\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/get_routing_hash/","title":"Get routing hash","text":""},{"location":"api/faststream/rabbit/shared/schemas/get_routing_hash/#faststream.rabbit.shared.schemas.get_routing_hash","title":"faststream.rabbit.shared.schemas.get_routing_hash","text":"<pre><code>get_routing_hash(\n    queue: RabbitQueue,\n    exchange: Optional[RabbitExchange] = None,\n) -&gt; int\n</code></pre> <p>Calculate the routing hash for a RabbitMQ queue and exchange.</p> PARAMETER  DESCRIPTION <code>queue</code> <p>The RabbitMQ queue.</p> <p> TYPE: <code>RabbitQueue</code> </p> <code>exchange</code> <p>The RabbitMQ exchange (optional).</p> <p> TYPE: <code>Optional[RabbitExchange]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>int</code> <p>The routing hash as an integer.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/rabbit/shared/schemas.py</code> <pre><code>def get_routing_hash(\n    queue: RabbitQueue,\n    exchange: Optional[RabbitExchange] = None,\n) -&gt; int:\n    \"\"\"Calculate the routing hash for a RabbitMQ queue and exchange.\n\n    Args:\n        queue: The RabbitMQ queue.\n        exchange: The RabbitMQ exchange (optional).\n\n    Returns:\n        The routing hash as an integer.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    return hash(queue) + hash(exchange or \"\")\n</code></pre>"},{"location":"api/faststream/rabbit/test/FakeProducer/","title":"FakeProducer","text":""},{"location":"api/faststream/rabbit/test/FakeProducer/#faststream.rabbit.test.FakeProducer","title":"faststream.rabbit.test.FakeProducer","text":"<p>             Bases: <code>AioPikaFastProducer</code></p> <p>A fake RabbitMQ producer for testing purposes.</p> <p>This class extends AioPikaFastProducer and is used to simulate RabbitMQ message publishing during tests.</p> Source code in <code>faststream/rabbit/test.py</code> <pre><code>class FakeProducer(AioPikaFastProducer):\n    \"\"\"\n    A fake RabbitMQ producer for testing purposes.\n\n    This class extends AioPikaFastProducer and is used to simulate RabbitMQ message publishing during tests.\n    \"\"\"\n\n    def __init__(self, broker: RabbitBroker):\n        \"\"\"\n        Initialize a FakeProducer instance.\n\n        Args:\n            broker (RabbitBroker): The RabbitBroker instance to be used for message publishing.\n        \"\"\"\n        self.broker = broker\n\n    async def publish(\n        self,\n        message: AioPikaSendableMessage = \"\",\n        queue: Union[RabbitQueue, str] = \"\",\n        exchange: Union[RabbitExchange, str, None] = None,\n        *,\n        routing_key: str = \"\",\n        mandatory: bool = True,\n        immediate: bool = False,\n        timeout: TimeoutType = None,\n        rpc: bool = False,\n        rpc_timeout: Optional[float] = 30.0,\n        raise_timeout: bool = False,\n        persist: bool = False,\n        reply_to: Optional[str] = None,\n        **message_kwargs: Any,\n    ) -&gt; Optional[SendableMessage]:\n        \"\"\"\n        Publish a message to a RabbitMQ queue or exchange.\n\n        Args:\n            message (AioPikaSendableMessage, optional): The message to be published.\n            queue (Union[RabbitQueue, str], optional): The target queue for the message.\n            exchange (Union[RabbitExchange, str, None], optional): The target exchange for the message.\n            routing_key (str, optional): The routing key for the message.\n            mandatory (bool, optional): Whether the message is mandatory.\n            immediate (bool, optional): Whether the message should be sent immediately.\n            timeout (TimeoutType, optional): The timeout for the message.\n            rpc (bool, optional): Whether the message is for RPC.\n            rpc_timeout (float, optional): The RPC timeout.\n            raise_timeout (bool, optional): Whether to raise a timeout exception.\n            persist (bool, optional): Whether to persist the message.\n            reply_to (str, optional): The reply-to address for RPC messages.\n            **message_kwargs (Any): Additional message properties and content.\n\n        Returns:\n            Optional[SendableMessage]: The published message if successful, or None if not.\n        \"\"\"\n        exch = RabbitExchange.validate(exchange)\n\n        incoming = build_message(\n            message=message,\n            queue=queue,\n            exchange=exch,\n            routing_key=routing_key,\n            reply_to=reply_to,\n            **message_kwargs,\n        )\n\n        for handler in self.broker.handlers.values():  # pragma: no branch\n            if handler.exchange == exch:\n                call: bool = False\n\n                if (\n                    handler.exchange is None\n                    or handler.exchange.type == ExchangeType.DIRECT\n                ):\n                    call = handler.queue.name == incoming.routing_key\n\n                elif handler.exchange.type == ExchangeType.FANOUT:\n                    call = True\n\n                elif handler.exchange.type == ExchangeType.TOPIC:\n                    call = bool(\n                        re.match(\n                            handler.queue.name.replace(\".\", r\"\\.\").replace(\"*\", \".*\"),\n                            incoming.routing_key or \"\",\n                        )\n                    )\n\n                elif handler.exchange.type == ExchangeType.HEADERS:  # pramga: no branch\n                    queue_headers = handler.queue.bind_arguments\n                    msg_headers = incoming.headers\n\n                    if not queue_headers:\n                        call = True\n\n                    else:\n                        matcher = queue_headers.pop(\"x-match\", \"all\")\n\n                        full = True\n                        none = True\n                        for k, v in queue_headers.items():\n                            if msg_headers.get(k) != v:\n                                full = False\n                            else:\n                                none = False\n\n                        if not none:\n                            call = (matcher == \"any\") or full\n\n                else:  # pragma: no cover\n                    raise AssertionError(\"unreachable\")\n\n                if call:\n                    r = await call_handler(\n                        handler=handler,\n                        message=incoming,\n                        rpc=rpc,\n                        rpc_timeout=rpc_timeout,\n                        raise_timeout=raise_timeout,\n                    )\n\n                    if rpc:  # pragma: no branch\n                        return r\n\n        return None\n</code></pre>"},{"location":"api/faststream/rabbit/test/FakeProducer/#faststream.rabbit.test.FakeProducer.broker","title":"broker  <code>instance-attribute</code>","text":"<pre><code>broker = broker\n</code></pre>"},{"location":"api/faststream/rabbit/test/FakeProducer/#faststream.rabbit.test.FakeProducer.publish","title":"publish  <code>async</code>","text":"<pre><code>publish(\n    message: AioPikaSendableMessage = \"\",\n    queue: Union[RabbitQueue, str] = \"\",\n    exchange: Union[RabbitExchange, str, None] = None,\n    *,\n    routing_key: str = \"\",\n    mandatory: bool = True,\n    immediate: bool = False,\n    timeout: TimeoutType = None,\n    rpc: bool = False,\n    rpc_timeout: Optional[float] = 30.0,\n    raise_timeout: bool = False,\n    persist: bool = False,\n    reply_to: Optional[str] = None,\n    **message_kwargs: Any\n) -&gt; Optional[SendableMessage]\n</code></pre> <p>Publish a message to a RabbitMQ queue or exchange.</p> PARAMETER  DESCRIPTION <code>message</code> <p>The message to be published.</p> <p> TYPE: <code>AioPikaSendableMessage</code> DEFAULT: <code>''</code> </p> <code>queue</code> <p>The target queue for the message.</p> <p> TYPE: <code>Union[RabbitQueue, str]</code> DEFAULT: <code>''</code> </p> <code>exchange</code> <p>The target exchange for the message.</p> <p> TYPE: <code>Union[RabbitExchange, str, None]</code> DEFAULT: <code>None</code> </p> <code>routing_key</code> <p>The routing key for the message.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>mandatory</code> <p>Whether the message is mandatory.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>immediate</code> <p>Whether the message should be sent immediately.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>timeout</code> <p>The timeout for the message.</p> <p> TYPE: <code>TimeoutType</code> DEFAULT: <code>None</code> </p> <code>rpc</code> <p>Whether the message is for RPC.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>rpc_timeout</code> <p>The RPC timeout.</p> <p> TYPE: <code>float</code> DEFAULT: <code>30.0</code> </p> <code>raise_timeout</code> <p>Whether to raise a timeout exception.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>persist</code> <p>Whether to persist the message.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>reply_to</code> <p>The reply-to address for RPC messages.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>**message_kwargs</code> <p>Additional message properties and content.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Optional[SendableMessage]</code> <p>Optional[SendableMessage]: The published message if successful, or None if not.</p> Source code in <code>faststream/rabbit/test.py</code> <pre><code>async def publish(\n    self,\n    message: AioPikaSendableMessage = \"\",\n    queue: Union[RabbitQueue, str] = \"\",\n    exchange: Union[RabbitExchange, str, None] = None,\n    *,\n    routing_key: str = \"\",\n    mandatory: bool = True,\n    immediate: bool = False,\n    timeout: TimeoutType = None,\n    rpc: bool = False,\n    rpc_timeout: Optional[float] = 30.0,\n    raise_timeout: bool = False,\n    persist: bool = False,\n    reply_to: Optional[str] = None,\n    **message_kwargs: Any,\n) -&gt; Optional[SendableMessage]:\n    \"\"\"\n    Publish a message to a RabbitMQ queue or exchange.\n\n    Args:\n        message (AioPikaSendableMessage, optional): The message to be published.\n        queue (Union[RabbitQueue, str], optional): The target queue for the message.\n        exchange (Union[RabbitExchange, str, None], optional): The target exchange for the message.\n        routing_key (str, optional): The routing key for the message.\n        mandatory (bool, optional): Whether the message is mandatory.\n        immediate (bool, optional): Whether the message should be sent immediately.\n        timeout (TimeoutType, optional): The timeout for the message.\n        rpc (bool, optional): Whether the message is for RPC.\n        rpc_timeout (float, optional): The RPC timeout.\n        raise_timeout (bool, optional): Whether to raise a timeout exception.\n        persist (bool, optional): Whether to persist the message.\n        reply_to (str, optional): The reply-to address for RPC messages.\n        **message_kwargs (Any): Additional message properties and content.\n\n    Returns:\n        Optional[SendableMessage]: The published message if successful, or None if not.\n    \"\"\"\n    exch = RabbitExchange.validate(exchange)\n\n    incoming = build_message(\n        message=message,\n        queue=queue,\n        exchange=exch,\n        routing_key=routing_key,\n        reply_to=reply_to,\n        **message_kwargs,\n    )\n\n    for handler in self.broker.handlers.values():  # pragma: no branch\n        if handler.exchange == exch:\n            call: bool = False\n\n            if (\n                handler.exchange is None\n                or handler.exchange.type == ExchangeType.DIRECT\n            ):\n                call = handler.queue.name == incoming.routing_key\n\n            elif handler.exchange.type == ExchangeType.FANOUT:\n                call = True\n\n            elif handler.exchange.type == ExchangeType.TOPIC:\n                call = bool(\n                    re.match(\n                        handler.queue.name.replace(\".\", r\"\\.\").replace(\"*\", \".*\"),\n                        incoming.routing_key or \"\",\n                    )\n                )\n\n            elif handler.exchange.type == ExchangeType.HEADERS:  # pramga: no branch\n                queue_headers = handler.queue.bind_arguments\n                msg_headers = incoming.headers\n\n                if not queue_headers:\n                    call = True\n\n                else:\n                    matcher = queue_headers.pop(\"x-match\", \"all\")\n\n                    full = True\n                    none = True\n                    for k, v in queue_headers.items():\n                        if msg_headers.get(k) != v:\n                            full = False\n                        else:\n                            none = False\n\n                    if not none:\n                        call = (matcher == \"any\") or full\n\n            else:  # pragma: no cover\n                raise AssertionError(\"unreachable\")\n\n            if call:\n                r = await call_handler(\n                    handler=handler,\n                    message=incoming,\n                    rpc=rpc,\n                    rpc_timeout=rpc_timeout,\n                    raise_timeout=raise_timeout,\n                )\n\n                if rpc:  # pragma: no branch\n                    return r\n\n    return None\n</code></pre>"},{"location":"api/faststream/rabbit/test/PatchedMessage/","title":"PatchedMessage","text":""},{"location":"api/faststream/rabbit/test/PatchedMessage/#faststream.rabbit.test.PatchedMessage","title":"faststream.rabbit.test.PatchedMessage","text":"<p>             Bases: <code>IncomingMessage</code></p> <p>Patched message class for testing purposes.</p> <p>This class extends aio_pika's IncomingMessage class and is used to simulate RabbitMQ message handling during tests.</p> Source code in <code>faststream/rabbit/test.py</code> <pre><code>class PatchedMessage(IncomingMessage):\n    \"\"\"\n    Patched message class for testing purposes.\n\n    This class extends aio_pika's IncomingMessage class and is used to simulate RabbitMQ message handling during tests.\n    \"\"\"\n\n    async def ack(self, multiple: bool = False) -&gt; None:\n        \"\"\"Asynchronously acknowledge a message.\n\n        Args:\n            multiple (bool, optional): Whether to acknowledge multiple messages at once. Defaults to False.\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        pass\n\n    async def nack(self, multiple: bool = False, requeue: bool = True) -&gt; None:\n        \"\"\"Nack the message.\n\n        Args:\n            multiple: Whether to nack multiple messages. Default is False.\n            requeue: Whether to requeue the message. Default is True.\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        pass\n\n    async def reject(self, requeue: bool = False) -&gt; None:\n        \"\"\"Rejects a task.\n\n        Args:\n            requeue: Whether to requeue the task if it fails (default: False)\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/faststream/rabbit/test/PatchedMessage/#faststream.rabbit.test.PatchedMessage.ack","title":"ack  <code>async</code>","text":"<pre><code>ack(multiple: bool = False) -&gt; None\n</code></pre> <p>Asynchronously acknowledge a message.</p> PARAMETER  DESCRIPTION <code>multiple</code> <p>Whether to acknowledge multiple messages at once. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/rabbit/test.py</code> <pre><code>async def ack(self, multiple: bool = False) -&gt; None:\n    \"\"\"Asynchronously acknowledge a message.\n\n    Args:\n        multiple (bool, optional): Whether to acknowledge multiple messages at once. Defaults to False.\n\n    Returns:\n        None\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/faststream/rabbit/test/PatchedMessage/#faststream.rabbit.test.PatchedMessage.nack","title":"nack  <code>async</code>","text":"<pre><code>nack(multiple: bool = False, requeue: bool = True) -&gt; None\n</code></pre> <p>Nack the message.</p> PARAMETER  DESCRIPTION <code>multiple</code> <p>Whether to nack multiple messages. Default is False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>requeue</code> <p>Whether to requeue the message. Default is True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/rabbit/test.py</code> <pre><code>async def nack(self, multiple: bool = False, requeue: bool = True) -&gt; None:\n    \"\"\"Nack the message.\n\n    Args:\n        multiple: Whether to nack multiple messages. Default is False.\n        requeue: Whether to requeue the message. Default is True.\n\n    Returns:\n        None\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/faststream/rabbit/test/PatchedMessage/#faststream.rabbit.test.PatchedMessage.reject","title":"reject  <code>async</code>","text":"<pre><code>reject(requeue: bool = False) -&gt; None\n</code></pre> <p>Rejects a task.</p> PARAMETER  DESCRIPTION <code>requeue</code> <p>Whether to requeue the task if it fails (default: False)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/rabbit/test.py</code> <pre><code>async def reject(self, requeue: bool = False) -&gt; None:\n    \"\"\"Rejects a task.\n\n    Args:\n        requeue: Whether to requeue the task if it fails (default: False)\n\n    Returns:\n        None\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/faststream/rabbit/test/TestRabbitBroker/","title":"TestRabbitBroker","text":""},{"location":"api/faststream/rabbit/test/TestRabbitBroker/#faststream.rabbit.test.TestRabbitBroker","title":"faststream.rabbit.test.TestRabbitBroker","text":"<p>A context manager for creating a test RabbitBroker instance with optional mocking.</p> <p>This class is designed to be used as a context manager for creating a RabbitBroker instance, optionally replacing some of its components with mocks for testing purposes. If the <code>with_real</code> attribute is set to True, it operates as a pass-through context manager, returning the original RabbitBroker instance without any modifications. If <code>with_real</code> is set to False, it replaces certain components like the channel, declarer, and start/connect/close methods with mock objects to isolate the broker for testing.</p> PARAMETER  DESCRIPTION <code>broker</code> <p>The RabbitBroker instance to be used in testing.</p> <p> TYPE: <code>RabbitBroker</code> </p> <code>with_real</code> <p>If True, the original broker is returned; if False, components are replaced with mock objects. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> METHOD DESCRIPTION <code>__aenter__</code> <p>Enter the context and return the RabbitBroker instance.</p> <code>__aexit__</code> <p>Any) -&gt; None: Exit the context.</p> <p>Example usage:</p> <pre><code>real_broker = RabbitBroker()\nwith TestRabbitBroker(real_broker, with_real=True) as broker:\n    # Use the real RabbitBroker instance for testing.\n\nwith TestRabbitBroker(real_broker, with_real=False) as broker:\n    # Use a mocked RabbitBroker instance for testing.\n</code></pre> Source code in <code>faststream/rabbit/test.py</code> <pre><code>class TestRabbitBroker:\n\n    \"\"\"\n    A context manager for creating a test RabbitBroker instance with optional mocking.\n\n    This class is designed to be used as a context manager for creating a RabbitBroker instance, optionally replacing some\n    of its components with mocks for testing purposes. If the `with_real` attribute is set to True, it operates as a\n    pass-through context manager, returning the original RabbitBroker instance without any modifications. If `with_real`\n    is set to False, it replaces certain components like the channel, declarer, and start/connect/close methods with mock\n    objects to isolate the broker for testing.\n\n    Args:\n        broker (RabbitBroker): The RabbitBroker instance to be used in testing.\n        with_real (bool, optional): If True, the original broker is returned; if False, components are replaced with\n            mock objects. Defaults to False.\n\n    Attributes:\n        broker (RabbitBroker): The RabbitBroker instance provided for testing.\n        with_real (bool): A boolean flag indicating whether to use the original broker (True) or replace components with\n            mocks (False).\n\n    Methods:\n        __aenter__(self) -&gt; RabbitBroker:\n            Enter the context and return the RabbitBroker instance.\n\n        __aexit__(self, *args: Any) -&gt; None:\n            Exit the context.\n\n    Example usage:\n\n    ```python\n    real_broker = RabbitBroker()\n    with TestRabbitBroker(real_broker, with_real=True) as broker:\n        # Use the real RabbitBroker instance for testing.\n\n    with TestRabbitBroker(real_broker, with_real=False) as broker:\n        # Use a mocked RabbitBroker instance for testing.\n    ```\n    \"\"\"\n\n    # This is set so pytest ignores this class\n    __test__ = False\n\n    def __init__(\n        self,\n        broker: RabbitBroker,\n        with_real: bool = False,\n        connect_only: bool = False,\n    ):\n        \"\"\"\n        Initialize a TestRabbitBroker instance.\n\n        Args:\n            broker (RabbitBroker): The RabbitBroker instance to be used in testing.\n            with_real (bool, optional): If True, the original broker is returned; if False, components are replaced with\n                mock objects. Defaults to False.\n        \"\"\"\n        self.with_real = with_real\n        self.broker = broker\n        self.connect_only = connect_only\n\n    @asynccontextmanager\n    async def _create_ctx(self) -&gt; AsyncGenerator[RabbitBroker, None]:\n        \"\"\"\n        Create the context for the context manager.\n\n        Yields:\n            RabbitBroker: The RabbitBroker instance for testing, either with or without mocks.\n        \"\"\"\n        if not self.with_real:\n            self.broker._channel = AsyncMock()\n            self.broker.declarer = AsyncMock()\n            self.broker.start = AsyncMock(wraps=partial(_fake_start, self.broker))  # type: ignore[method-assign]\n            self.broker._connect = MethodType(_fake_connect, self.broker)  # type: ignore[method-assign]\n            self.broker.close = AsyncMock()  # type: ignore[method-assign]\n        else:\n            _fake_start(self.broker)\n\n        async with self.broker:\n            try:\n                if not self.connect_only:\n                    await self.broker.start()\n                yield self.broker\n            finally:\n                _fake_close(self.broker)\n\n    async def __aenter__(self) -&gt; RabbitBroker:\n        \"\"\"\n        Enter the context and return the RabbitBroker instance.\n\n        Returns:\n            RabbitBroker: The RabbitBroker instance for testing, either with or without mocks.\n        \"\"\"\n        self._ctx = self._create_ctx()\n        return await self._ctx.__aenter__()\n\n    async def __aexit__(self, *args: Any) -&gt; None:\n        \"\"\"\n        Exit the context.\n\n        Args:\n            *args: Variable-length argument list.\n        \"\"\"\n        await self._ctx.__aexit__(*args)\n</code></pre>"},{"location":"api/faststream/rabbit/test/TestRabbitBroker/#faststream.rabbit.test.TestRabbitBroker.broker","title":"broker  <code>instance-attribute</code>","text":"<pre><code>broker = broker\n</code></pre>"},{"location":"api/faststream/rabbit/test/TestRabbitBroker/#faststream.rabbit.test.TestRabbitBroker.connect_only","title":"connect_only  <code>instance-attribute</code>","text":"<pre><code>connect_only = connect_only\n</code></pre>"},{"location":"api/faststream/rabbit/test/TestRabbitBroker/#faststream.rabbit.test.TestRabbitBroker.with_real","title":"with_real  <code>instance-attribute</code>","text":"<pre><code>with_real = with_real\n</code></pre>"},{"location":"api/faststream/rabbit/test/build_message/","title":"Build message","text":""},{"location":"api/faststream/rabbit/test/build_message/#faststream.rabbit.test.build_message","title":"faststream.rabbit.test.build_message","text":"<pre><code>build_message(\n    message: AioPikaSendableMessage = \"\",\n    queue: Union[RabbitQueue, str] = \"\",\n    exchange: Union[RabbitExchange, str, None] = None,\n    *,\n    routing_key: str = \"\",\n    reply_to: Optional[str] = None,\n    **message_kwargs: Any\n) -&gt; PatchedMessage\n</code></pre> <p>Build a patched RabbitMQ message for testing.</p> PARAMETER  DESCRIPTION <code>message</code> <p>The message content.</p> <p> TYPE: <code>AioPikaSendableMessage</code> DEFAULT: <code>''</code> </p> <code>queue</code> <p>The message queue.</p> <p> TYPE: <code>Union[RabbitQueue, str]</code> DEFAULT: <code>''</code> </p> <code>exchange</code> <p>The message exchange.</p> <p> TYPE: <code>Union[RabbitExchange, str, None]</code> DEFAULT: <code>None</code> </p> <code>routing_key</code> <p>The message routing key.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>reply_to</code> <p>The reply-to queue.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>**message_kwargs</code> <p>Additional message arguments.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>PatchedMessage</code> <p>A patched RabbitMQ message.</p> <p> TYPE: <code>PatchedMessage</code> </p> Source code in <code>faststream/rabbit/test.py</code> <pre><code>def build_message(\n    message: AioPikaSendableMessage = \"\",\n    queue: Union[RabbitQueue, str] = \"\",\n    exchange: Union[RabbitExchange, str, None] = None,\n    *,\n    routing_key: str = \"\",\n    reply_to: Optional[str] = None,\n    **message_kwargs: Any,\n) -&gt; PatchedMessage:\n    \"\"\"\n    Build a patched RabbitMQ message for testing.\n\n    Args:\n        message (AioPikaSendableMessage): The message content.\n        queue (Union[RabbitQueue, str]): The message queue.\n        exchange (Union[RabbitExchange, str, None]): The message exchange.\n        routing_key (str): The message routing key.\n        reply_to (Optional[str]): The reply-to queue.\n        **message_kwargs (Any): Additional message arguments.\n\n    Returns:\n        PatchedMessage: A patched RabbitMQ message.\n    \"\"\"\n    que = RabbitQueue.validate(queue)\n    exch = RabbitExchange.validate(exchange)\n    msg = AioPikaParser.encode_message(\n        message=message,\n        persist=False,\n        reply_to=reply_to,\n        callback_queue=None,\n        **message_kwargs,\n    )\n\n    routing = routing_key or (que.name if que else \"\")\n\n    return PatchedMessage(\n        aiormq.abc.DeliveredMessage(\n            delivery=spec.Basic.Deliver(\n                exchange=exch.name if exch and exch.name else \"\",\n                routing_key=routing,\n            ),\n            header=ContentHeader(\n                properties=spec.Basic.Properties(\n                    content_type=msg.content_type,\n                    message_id=str(uuid4()),\n                    headers=msg.headers,\n                    reply_to=reply_to,\n                )\n            ),\n            body=msg.body,\n            channel=AsyncMock(),\n        )\n    )\n</code></pre>"},{"location":"api/faststream/utils/classes/Singleton/","title":"Singleton","text":""},{"location":"api/faststream/utils/classes/Singleton/#faststream.utils.classes.Singleton","title":"faststream.utils.classes.Singleton","text":"<p>A class to implement the Singleton design pattern.</p> METHOD DESCRIPTION <code>__new__ </code> <p>creates a new instance of the class if it doesn't exist, otherwise returns the existing instance</p> <code>_drop </code> <p>sets the instance to None, allowing a new instance to be created</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/utils/classes.py</code> <pre><code>class Singleton:\n    \"\"\"A class to implement the Singleton design pattern.\n\n    Attributes:\n        _instance : the single instance of the class\n\n    Methods:\n        __new__ : creates a new instance of the class if it doesn't exist, otherwise returns the existing instance\n        _drop : sets the instance to None, allowing a new instance to be created\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    _instance = None\n\n    def __new__(cls, *args: Any, **kwargs: Any) -&gt; \"Singleton\":\n        \"\"\"Create a singleton instance of a class.\n\n        Args:\n            *args: Variable length argument list\n            **kwargs: Arbitrary keyword arguments\n\n        Returns:\n            The singleton instance of the class\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n        return cls._instance\n\n    @classmethod\n    def _drop(cls) -&gt; None:\n        \"\"\"Drop the instance of a class.\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        cls._instance = None\n</code></pre>"},{"location":"api/faststream/utils/context/main/ContextRepo/","title":"ContextRepo","text":""},{"location":"api/faststream/utils/context/main/ContextRepo/#faststream.utils.context.main.ContextRepo","title":"faststream.utils.context.main.ContextRepo","text":"<p>             Bases: <code>Singleton</code></p> <p>A class to represent a context repository.</p> METHOD DESCRIPTION <code>__init__ </code> <p>initializes the ContextRepo object</p> <code>set_global </code> <p>sets a global context variable</p> <code>reset_global </code> <p>resets a global context variable</p> <code>set_local </code> <p>sets a local context variable</p> <code>reset_local </code> <p>resets a local context variable</p> <code>get_local </code> <p>gets the value of a local context variable</p> <code>clear </code> <p>clears the global and scope context</p> <code>get </code> <p>gets the value of a context variable</p> <code>__getattr__ </code> <p>gets the value of a context variable using attribute access</p> <code>context </code> <p>gets the current context as a dictionary</p> <code>scope </code> <p>creates a context scope for a specific key and value</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/utils/context/main.py</code> <pre><code>class ContextRepo(Singleton):\n    \"\"\"A class to represent a context repository.\n\n    Attributes:\n        _global_context : dictionary representing the global context\n        _scope_context : dictionary representing the scope context\n\n    Methods:\n        __init__ : initializes the ContextRepo object\n        set_global : sets a global context variable\n        reset_global : resets a global context variable\n        set_local : sets a local context variable\n        reset_local : resets a local context variable\n        get_local : gets the value of a local context variable\n        clear : clears the global and scope context\n        get : gets the value of a context variable\n        __getattr__ : gets the value of a context variable using attribute access\n        context : gets the current context as a dictionary\n        scope : creates a context scope for a specific key and value\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    _global_context: AnyDict\n    _scope_context: Dict[str, ContextVar[Any]]\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize the class.\n\n        Attributes:\n            _global_context : a dictionary representing the global context\n            _scope_context : a dictionary representing the scope context\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        self._global_context = {\"context\": self}\n        self._scope_context = {}\n\n    def set_global(self, key: str, v: Any) -&gt; None:\n        \"\"\"Sets a value in the global context.\n\n        Args:\n            key: The key to set in the global context.\n            v: The value to set.\n\n        Returns:\n            None.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        self._global_context[key] = v\n\n    def reset_global(self, key: str) -&gt; None:\n        \"\"\"Resets a key in the global context.\n\n        Args:\n            key (str): The key to reset in the global context.\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        self._global_context.pop(key, None)\n\n    def set_local(self, key: str, value: T) -&gt; \"Token[T]\":\n        \"\"\"Set a local context variable.\n\n        Args:\n            key (str): The key for the context variable.\n            value (T): The value to set for the context variable.\n\n        Returns:\n            Token[T]: A token representing the context variable.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        context_var = self._scope_context.get(key)\n        if context_var is None:\n            context_var = ContextVar(key, default=None)\n            self._scope_context[key] = context_var\n        return context_var.set(value)\n\n    def reset_local(self, key: str, tag: \"Token[Any]\") -&gt; None:\n        \"\"\"Resets the local context for a given key.\n\n        Args:\n            key (str): The key to reset the local context for.\n            tag (Token[Any]): The tag associated with the local context.\n\n        Returns:\n            None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        self._scope_context[key].reset(tag)\n\n    def get_local(self, key: str, default: Any = None) -&gt; Any:\n        \"\"\"Get the value of a local variable.\n\n        Args:\n            key: The key of the local variable to retrieve.\n\n        Returns:\n            The value of the local variable.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        context_var = self._scope_context.get(key)\n        if context_var is not None:  # pragma: no branch\n            return context_var.get()\n        else:\n            return default\n\n    def clear(self) -&gt; None:\n        self._global_context = {\"context\": self}\n        self._scope_context = {}\n\n    def get(self, key: str, default: Any = None) -&gt; Any:\n        \"\"\"Get the value associated with a key.\n\n        Args:\n            key: The key to retrieve the value for.\n\n        Returns:\n            The value associated with the key.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        return self._global_context.get(key, self.get_local(key)) or default\n\n    def __getattr__(self, __name: str) -&gt; Any:\n        \"\"\"This is a function that is part of a class. It is used to get an attribute value using the `__getattr__` method.\n\n        Args:\n            __name: The name of the attribute to get.\n\n        Returns:\n            The value of the attribute.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        return self.get(__name)\n\n    @property\n    def context(self) -&gt; AnyDict:\n        return {\n            **self._global_context,\n            **{i: j.get() for i, j in self._scope_context.items()},\n        }\n\n    @contextmanager\n    def scope(self, key: str, value: Any) -&gt; Iterator[None]:\n        \"\"\"Sets a local variable and yields control to the caller. After the caller is done, the local variable is reset.\n\n        Args:\n            key: The key of the local variable\n            value: The value to set the local variable to\n\n        Yields:\n            None\n\n        Returns:\n            An iterator that yields None\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        token = self.set_local(key, value)\n        try:\n            yield\n        finally:\n            self.reset_local(key, token)\n</code></pre>"},{"location":"api/faststream/utils/context/main/ContextRepo/#faststream.utils.context.main.ContextRepo.context","title":"context  <code>property</code>","text":"<pre><code>context: AnyDict\n</code></pre>"},{"location":"api/faststream/utils/context/main/ContextRepo/#faststream.utils.context.main.ContextRepo.clear","title":"clear","text":"<pre><code>clear() -&gt; None\n</code></pre> Source code in <code>faststream/utils/context/main.py</code> <pre><code>def clear(self) -&gt; None:\n    self._global_context = {\"context\": self}\n    self._scope_context = {}\n</code></pre>"},{"location":"api/faststream/utils/context/main/ContextRepo/#faststream.utils.context.main.ContextRepo.get","title":"get","text":"<pre><code>get(key: str, default: Any = None) -&gt; Any\n</code></pre> <p>Get the value associated with a key.</p> PARAMETER  DESCRIPTION <code>key</code> <p>The key to retrieve the value for.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Any</code> <p>The value associated with the key.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/utils/context/main.py</code> <pre><code>def get(self, key: str, default: Any = None) -&gt; Any:\n    \"\"\"Get the value associated with a key.\n\n    Args:\n        key: The key to retrieve the value for.\n\n    Returns:\n        The value associated with the key.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    return self._global_context.get(key, self.get_local(key)) or default\n</code></pre>"},{"location":"api/faststream/utils/context/main/ContextRepo/#faststream.utils.context.main.ContextRepo.get_local","title":"get_local","text":"<pre><code>get_local(key: str, default: Any = None) -&gt; Any\n</code></pre> <p>Get the value of a local variable.</p> PARAMETER  DESCRIPTION <code>key</code> <p>The key of the local variable to retrieve.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Any</code> <p>The value of the local variable.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/utils/context/main.py</code> <pre><code>def get_local(self, key: str, default: Any = None) -&gt; Any:\n    \"\"\"Get the value of a local variable.\n\n    Args:\n        key: The key of the local variable to retrieve.\n\n    Returns:\n        The value of the local variable.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    context_var = self._scope_context.get(key)\n    if context_var is not None:  # pragma: no branch\n        return context_var.get()\n    else:\n        return default\n</code></pre>"},{"location":"api/faststream/utils/context/main/ContextRepo/#faststream.utils.context.main.ContextRepo.reset_global","title":"reset_global","text":"<pre><code>reset_global(key: str) -&gt; None\n</code></pre> <p>Resets a key in the global context.</p> PARAMETER  DESCRIPTION <code>key</code> <p>The key to reset in the global context.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/utils/context/main.py</code> <pre><code>def reset_global(self, key: str) -&gt; None:\n    \"\"\"Resets a key in the global context.\n\n    Args:\n        key (str): The key to reset in the global context.\n\n    Returns:\n        None\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    self._global_context.pop(key, None)\n</code></pre>"},{"location":"api/faststream/utils/context/main/ContextRepo/#faststream.utils.context.main.ContextRepo.reset_local","title":"reset_local","text":"<pre><code>reset_local(key: str, tag: Token[Any]) -&gt; None\n</code></pre> <p>Resets the local context for a given key.</p> PARAMETER  DESCRIPTION <code>key</code> <p>The key to reset the local context for.</p> <p> TYPE: <code>str</code> </p> <code>tag</code> <p>The tag associated with the local context.</p> <p> TYPE: <code>Token[Any]</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/utils/context/main.py</code> <pre><code>def reset_local(self, key: str, tag: \"Token[Any]\") -&gt; None:\n    \"\"\"Resets the local context for a given key.\n\n    Args:\n        key (str): The key to reset the local context for.\n        tag (Token[Any]): The tag associated with the local context.\n\n    Returns:\n        None\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    self._scope_context[key].reset(tag)\n</code></pre>"},{"location":"api/faststream/utils/context/main/ContextRepo/#faststream.utils.context.main.ContextRepo.scope","title":"scope","text":"<pre><code>scope(key: str, value: Any) -&gt; Iterator[None]\n</code></pre> <p>Sets a local variable and yields control to the caller. After the caller is done, the local variable is reset.</p> PARAMETER  DESCRIPTION <code>key</code> <p>The key of the local variable</p> <p> TYPE: <code>str</code> </p> <code>value</code> <p>The value to set the local variable to</p> <p> TYPE: <code>Any</code> </p> YIELDS DESCRIPTION <code>Iterator[None]</code> <p>None</p> RETURNS DESCRIPTION <code>Iterator[None]</code> <p>An iterator that yields None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/utils/context/main.py</code> <pre><code>@contextmanager\ndef scope(self, key: str, value: Any) -&gt; Iterator[None]:\n    \"\"\"Sets a local variable and yields control to the caller. After the caller is done, the local variable is reset.\n\n    Args:\n        key: The key of the local variable\n        value: The value to set the local variable to\n\n    Yields:\n        None\n\n    Returns:\n        An iterator that yields None\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    token = self.set_local(key, value)\n    try:\n        yield\n    finally:\n        self.reset_local(key, token)\n</code></pre>"},{"location":"api/faststream/utils/context/main/ContextRepo/#faststream.utils.context.main.ContextRepo.set_global","title":"set_global","text":"<pre><code>set_global(key: str, v: Any) -&gt; None\n</code></pre> <p>Sets a value in the global context.</p> PARAMETER  DESCRIPTION <code>key</code> <p>The key to set in the global context.</p> <p> TYPE: <code>str</code> </p> <code>v</code> <p>The value to set.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/utils/context/main.py</code> <pre><code>def set_global(self, key: str, v: Any) -&gt; None:\n    \"\"\"Sets a value in the global context.\n\n    Args:\n        key: The key to set in the global context.\n        v: The value to set.\n\n    Returns:\n        None.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    self._global_context[key] = v\n</code></pre>"},{"location":"api/faststream/utils/context/main/ContextRepo/#faststream.utils.context.main.ContextRepo.set_local","title":"set_local","text":"<pre><code>set_local(key: str, value: T) -&gt; Token[T]\n</code></pre> <p>Set a local context variable.</p> PARAMETER  DESCRIPTION <code>key</code> <p>The key for the context variable.</p> <p> TYPE: <code>str</code> </p> <code>value</code> <p>The value to set for the context variable.</p> <p> TYPE: <code>T</code> </p> RETURNS DESCRIPTION <code>Token[T]</code> <p>Token[T]: A token representing the context variable.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/utils/context/main.py</code> <pre><code>def set_local(self, key: str, value: T) -&gt; \"Token[T]\":\n    \"\"\"Set a local context variable.\n\n    Args:\n        key (str): The key for the context variable.\n        value (T): The value to set for the context variable.\n\n    Returns:\n        Token[T]: A token representing the context variable.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    context_var = self._scope_context.get(key)\n    if context_var is None:\n        context_var = ContextVar(key, default=None)\n        self._scope_context[key] = context_var\n    return context_var.set(value)\n</code></pre>"},{"location":"api/faststream/utils/context/types/Context/","title":"Context","text":""},{"location":"api/faststream/utils/context/types/Context/#faststream.utils.context.types.Context","title":"faststream.utils.context.types.Context","text":"<p>             Bases: <code>CustomField</code></p> <p>A class to represent a context.</p> METHOD DESCRIPTION <code>__init__ </code> <p>constructor method</p> <code>use </code> <p>method to use the context</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/utils/context/types.py</code> <pre><code>class Context(CustomField):\n    \"\"\"A class to represent a context.\n\n    Attributes:\n        param_name : name of the parameter\n\n    Methods:\n        __init__ : constructor method\n        use : method to use the context\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    param_name: str\n\n    def __init__(\n        self,\n        real_name: str = \"\",\n        *,\n        cast: bool = False,\n        default: Any = _empty,\n    ):\n        \"\"\"Initialize the object.\n\n        Args:\n            real_name: The real name of the object.\n            cast: Whether to cast the object.\n            default: The default value of the object.\n\n        Raises:\n            TypeError: If the default value is not provided.\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        self.name = real_name\n        self.default = default\n        super().__init__(\n            cast=cast,\n            required=(default is _empty),\n        )\n\n    def use(self, **kwargs: Any) -&gt; AnyDict:\n        \"\"\"Use the given keyword arguments.\n\n        Args:\n            **kwargs: Keyword arguments to be used\n\n        Returns:\n            A dictionary containing the updated keyword arguments\n\n        Raises:\n            KeyError: If the parameter name is not found in the keyword arguments\n            AttributeError: If the parameter name is not a valid attribute\n\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        name = self.name or self.param_name\n\n        try:\n            kwargs[self.param_name] = resolve_context(name)\n        except (KeyError, AttributeError):\n            if self.required is False:\n                kwargs[self.param_name] = self.default\n\n        return kwargs\n</code></pre>"},{"location":"api/faststream/utils/context/types/Context/#faststream.utils.context.types.Context.default","title":"default  <code>instance-attribute</code>","text":"<pre><code>default = default\n</code></pre>"},{"location":"api/faststream/utils/context/types/Context/#faststream.utils.context.types.Context.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name = real_name\n</code></pre>"},{"location":"api/faststream/utils/context/types/Context/#faststream.utils.context.types.Context.param_name","title":"param_name  <code>instance-attribute</code>","text":"<pre><code>param_name: str\n</code></pre>"},{"location":"api/faststream/utils/context/types/Context/#faststream.utils.context.types.Context.use","title":"use","text":"<pre><code>use(**kwargs: Any) -&gt; AnyDict\n</code></pre> <p>Use the given keyword arguments.</p> PARAMETER  DESCRIPTION <code>**kwargs</code> <p>Keyword arguments to be used</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>AnyDict</code> <p>A dictionary containing the updated keyword arguments</p> RAISES DESCRIPTION <code>KeyError</code> <p>If the parameter name is not found in the keyword arguments</p> <code>AttributeError</code> <p>If the parameter name is not a valid attribute</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/utils/context/types.py</code> <pre><code>def use(self, **kwargs: Any) -&gt; AnyDict:\n    \"\"\"Use the given keyword arguments.\n\n    Args:\n        **kwargs: Keyword arguments to be used\n\n    Returns:\n        A dictionary containing the updated keyword arguments\n\n    Raises:\n        KeyError: If the parameter name is not found in the keyword arguments\n        AttributeError: If the parameter name is not a valid attribute\n\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    name = self.name or self.param_name\n\n    try:\n        kwargs[self.param_name] = resolve_context(name)\n    except (KeyError, AttributeError):\n        if self.required is False:\n            kwargs[self.param_name] = self.default\n\n    return kwargs\n</code></pre>"},{"location":"api/faststream/utils/context/types/resolve_context/","title":"Resolve context","text":""},{"location":"api/faststream/utils/context/types/resolve_context/#faststream.utils.context.types.resolve_context","title":"faststream.utils.context.types.resolve_context","text":"<pre><code>resolve_context(argument: str) -&gt; Any\n</code></pre> <p>Resolve the context of an argument.</p> PARAMETER  DESCRIPTION <code>argument</code> <p>A string representing the argument.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Any</code> <p>The resolved context of the argument.</p> RAISES DESCRIPTION <code>AttributeError</code> <p>If the attribute does not exist in the context.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/utils/context/types.py</code> <pre><code>def resolve_context(argument: str) -&gt; Any:\n    \"\"\"Resolve the context of an argument.\n\n    Args:\n        argument: A string representing the argument.\n\n    Returns:\n        The resolved context of the argument.\n\n    Raises:\n        AttributeError: If the attribute does not exist in the context.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    keys = argument.split(\".\")\n\n    v = context.context[keys[0]]\n    for i in keys[1:]:\n        v = getattr(v, i)\n\n    return v\n</code></pre>"},{"location":"api/faststream/utils/data/filter_by_dict/","title":"Filter by dict","text":""},{"location":"api/faststream/utils/data/filter_by_dict/#faststream.utils.data.filter_by_dict","title":"faststream.utils.data.filter_by_dict","text":"<pre><code>filter_by_dict(\n    typed_dict: Type[TypedDictCls], data: AnyDict\n) -&gt; TypedDictCls\n</code></pre> <p>Filter a dictionary based on a typed dictionary.</p> PARAMETER  DESCRIPTION <code>typed_dict</code> <p>The typed dictionary to filter by.</p> <p> TYPE: <code>Type[TypedDictCls]</code> </p> <code>data</code> <p>The dictionary to filter.</p> <p> TYPE: <code>AnyDict</code> </p> RETURNS DESCRIPTION <code>TypedDictCls</code> <p>A new instance of the typed dictionary with only the keys present in the data dictionary.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/utils/data.py</code> <pre><code>def filter_by_dict(typed_dict: Type[TypedDictCls], data: AnyDict) -&gt; TypedDictCls:\n    \"\"\"Filter a dictionary based on a typed dictionary.\n\n    Args:\n        typed_dict: The typed dictionary to filter by.\n        data: The dictionary to filter.\n\n    Returns:\n        A new instance of the typed dictionary with only the keys present in the data dictionary.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    annotations = typed_dict.__annotations__\n    return typed_dict(  # type: ignore\n        {k: v for k, v in data.items() if k in annotations}\n    )\n</code></pre>"},{"location":"api/faststream/utils/functions/get_function_positional_arguments/","title":"Get function positional arguments","text":""},{"location":"api/faststream/utils/functions/get_function_positional_arguments/#faststream.utils.functions.get_function_positional_arguments","title":"faststream.utils.functions.get_function_positional_arguments","text":"<pre><code>get_function_positional_arguments(\n    func: AnyCallable,\n) -&gt; List[str]\n</code></pre> <p>Get the positional arguments of a function.</p> PARAMETER  DESCRIPTION <code>func</code> <p>The function to get the positional arguments from.</p> <p> TYPE: <code>AnyCallable</code> </p> RETURNS DESCRIPTION <code>List[str]</code> <p>A list of strings representing the names of the positional arguments.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/utils/functions.py</code> <pre><code>def get_function_positional_arguments(func: AnyCallable) -&gt; List[str]:\n    \"\"\"Get the positional arguments of a function.\n\n    Args:\n        func: The function to get the positional arguments from.\n\n    Returns:\n        A list of strings representing the names of the positional arguments.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    signature = inspect.signature(func)\n\n    arg_kinds = (\n        inspect.Parameter.POSITIONAL_ONLY,\n        inspect.Parameter.POSITIONAL_OR_KEYWORD,\n    )\n\n    return [\n        param.name for param in signature.parameters.values() if param.kind in arg_kinds\n    ]\n</code></pre>"},{"location":"api/faststream/utils/functions/timeout_scope/","title":"Timeout scope","text":""},{"location":"api/faststream/utils/functions/timeout_scope/#faststream.utils.functions.timeout_scope","title":"faststream.utils.functions.timeout_scope","text":"<pre><code>timeout_scope(\n    timeout: Optional[float] = 30,\n    raise_timeout: bool = False,\n) -&gt; ContextManager[anyio.CancelScope]\n</code></pre> Source code in <code>faststream/utils/functions.py</code> <pre><code>def timeout_scope(\n    timeout: Optional[float] = 30, raise_timeout: bool = False\n) -&gt; ContextManager[anyio.CancelScope]:\n    scope: Callable[[Optional[float]], ContextManager[anyio.CancelScope]]\n    if raise_timeout:\n        scope = anyio.fail_after\n    else:\n        scope = anyio.move_on_after\n\n    return scope(timeout)\n</code></pre>"},{"location":"api/faststream/utils/functions/to_async/","title":"To async","text":""},{"location":"api/faststream/utils/functions/to_async/#faststream.utils.functions.to_async","title":"faststream.utils.functions.to_async","text":"<pre><code>to_async(\n    func: Union[\n        Callable[F_Spec, F_Return],\n        Callable[F_Spec, Awaitable[F_Return]],\n    ]\n) -&gt; Callable[F_Spec, Awaitable[F_Return]]\n</code></pre> <p>Converts a synchronous function to an asynchronous function.</p> PARAMETER  DESCRIPTION <code>func</code> <p>The synchronous function to be converted.</p> <p> TYPE: <code>Union[Callable[F_Spec, F_Return], Callable[F_Spec, Awaitable[F_Return]]]</code> </p> RETURNS DESCRIPTION <code>Callable[F_Spec, Awaitable[F_Return]]</code> <p>The asynchronous version of the input function.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/utils/functions.py</code> <pre><code>def to_async(\n    func: Union[\n        Callable[F_Spec, F_Return],\n        Callable[F_Spec, Awaitable[F_Return]],\n    ]\n) -&gt; Callable[F_Spec, Awaitable[F_Return]]:\n    \"\"\"Converts a synchronous function to an asynchronous function.\n\n    Args:\n        func: The synchronous function to be converted.\n\n    Returns:\n        The asynchronous version of the input function.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    @wraps(func)\n    async def to_async_wrapper(*args: F_Spec.args, **kwargs: F_Spec.kwargs) -&gt; F_Return:\n        \"\"\"Wraps a function to make it asynchronous.\n\n        Args:\n            func: The function to be wrapped\n            args: Positional arguments to be passed to the function\n            kwargs: Keyword arguments to be passed to the function\n\n        Returns:\n            The result of the wrapped function\n\n        Raises:\n            Any exceptions raised by the wrapped function\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        return await call_or_await(func, *args, **kwargs)\n\n    return to_async_wrapper\n</code></pre>"},{"location":"api/faststream/utils/no_cast/NoCast/","title":"NoCast","text":""},{"location":"api/faststream/utils/no_cast/NoCast/#faststream.utils.no_cast.NoCast","title":"faststream.utils.no_cast.NoCast","text":"<p>             Bases: <code>CustomField</code></p> <p>A class that represents a custom field without casting.</p> METHOD DESCRIPTION <code>__init__ </code> <p>Initializes the NoCast object.</p> <code>use </code> <p>Returns the provided keyword arguments as a dictionary.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/utils/no_cast.py</code> <pre><code>class NoCast(CustomField):\n    \"\"\"A class that represents a custom field without casting.\n\n    Methods:\n        __init__ : Initializes the NoCast object.\n        use : Returns the provided keyword arguments as a dictionary.\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        super().__init__(cast=False)\n\n    def use(self, **kwargs: Any) -&gt; AnyDict:\n        \"\"\"Return a dictionary containing the keyword arguments passed to the function.\n\n        Args:\n            **kwargs: Keyword arguments\n\n        Returns:\n            Dictionary containing the keyword arguments\n        !!! note\n\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n        return kwargs\n</code></pre>"},{"location":"api/faststream/utils/no_cast/NoCast/#faststream.utils.no_cast.NoCast.use","title":"use","text":"<pre><code>use(**kwargs: Any) -&gt; AnyDict\n</code></pre> <p>Return a dictionary containing the keyword arguments passed to the function.</p> PARAMETER  DESCRIPTION <code>**kwargs</code> <p>Keyword arguments</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>AnyDict</code> <p>Dictionary containing the keyword arguments</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>faststream/utils/no_cast.py</code> <pre><code>def use(self, **kwargs: Any) -&gt; AnyDict:\n    \"\"\"Return a dictionary containing the keyword arguments passed to the function.\n\n    Args:\n        **kwargs: Keyword arguments\n\n    Returns:\n        Dictionary containing the keyword arguments\n    !!! note\n\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n    return kwargs\n</code></pre>"},{"location":"getting-started/","title":"QUICK START","text":"<p>Install using <code>pip</code>:</p> KafkaRabbitMQNATS <pre><code>pip install \"faststream[kafka]\"\n</code></pre> <p>Tip</p> <p>To start a new project, we need a test broker container <pre><code>docker run -d --rm -p 9092:9092 --name test-mq \\\n-e KAFKA_ENABLE_KRAFT=yes \\\n-e KAFKA_CFG_NODE_ID=1 \\\n-e KAFKA_CFG_PROCESS_ROLES=broker,controller \\\n-e KAFKA_CFG_CONTROLLER_LISTENER_NAMES=CONTROLLER \\\n-e KAFKA_CFG_LISTENERS=PLAINTEXT://:9092,CONTROLLER://:9093 \\\n-e KAFKA_CFG_LISTENER_SECURITY_PROTOCOL_MAP=CONTROLLER:PLAINTEXT,PLAINTEXT:PLAINTEXT \\\n-e KAFKA_CFG_ADVERTISED_LISTENERS=PLAINTEXT://127.0.0.1:9092 \\\n-e KAFKA_BROKER_ID=1 \\\n-e KAFKA_CFG_CONTROLLER_QUORUM_VOTERS=1@kafka:9093 \\\n-e ALLOW_PLAINTEXT_LISTENER=yes \\\nbitnami/kafka:3.5.0\n</code></pre></p> <pre><code>pip install \"faststream[rabbit]\"\n</code></pre> <p>Tip</p> <p>To start a new project, we need a test broker container <pre><code>docker run -d --rm -p 5672:5672 --name test-mq rabbitmq:alpine\n</code></pre></p> <pre><code>pip install \"faststream[nats]\"\n</code></pre> <p>Tip</p> <p>To start a new project, we need a test broker container <pre><code>bash docker run -d --rm -p 4222:4222 --name test-mq nats -js\n</code></pre></p>"},{"location":"getting-started/#basic-usage","title":"Basic Usage","text":"<p>To create a basic application, add the following code to a new file (e.g. <code>serve.py</code>):</p> KafkaRabbitMQNATS serve.py<pre><code>from faststream import FastStream\nfrom faststream.kafka import KafkaBroker\n\nbroker = KafkaBroker(\"localhost:9092\")\n\napp = FastStream(broker)\n\n\n@broker.subscriber(\"test\")\nasync def base_handler(body):\n    print(body)\n</code></pre> serve.py<pre><code>from faststream import FastStream\nfrom faststream.rabbit import RabbitBroker\n\nbroker = RabbitBroker(\"amqp://guest:guest@localhost:5672/\")\n\napp = FastStream(broker)\n\n\n@broker.subscriber(\"test\")\nasync def base_handler(body):\n    print(body)\n</code></pre> serve.py<pre><code>from faststream import FastStream\nfrom faststream.nats import NatsBroker\n\nbroker = NatsBroker(\"nats://localhost:4222\")\n\napp = FastStream(broker)\n\n\n@broker.subscriber(\"test\")\nasync def base_handler(body):\n    print(body)\n</code></pre> <p>And just run this command:</p> <pre><code>faststream run serve:app\n</code></pre> <p>After running the command, you should see the following output:</p> <pre><code>INFO     - FastStream app starting...\nINFO     - test |            - `BaseHandler` waiting for messages\nINFO     - FastStream app started successfully! To exit, press CTRL+C\n</code></pre> <p>Enjoy your new development experience!</p> Don't forget to stop the test broker container <pre><code>docker container stop test-mq\n</code></pre>"},{"location":"getting-started/logging/","title":"Application and Access Logging","text":"<p>FastStream uses two previously configured loggers:</p> <ul> <li><code>faststream</code> - used by <code>FastStream</code> app</li> <li><code>faststream.access</code> - used by the broker</li> </ul>"},{"location":"getting-started/logging/#logging-requests","title":"Logging Requests","text":"<p>To log requests, it is strongly recommended to use the <code>access_logger</code> of your broker, as it is available from the Context of your application.</p> <pre><code>from faststream import Logger\nfrom faststream.rabbit import RabbitBroker\n\nbroker = RabbitBroker()\n\n@broker.subscriber(\"test\")\nasync def func(logger: Logger):\n    logger.info(\"message received\")\n</code></pre> <p>This approach offers several advantages:</p> <ul> <li>The logger already contains the request context, including the message ID and broker-based parameters.</li> <li>By replacing the <code>logger</code> when initializing the broker, you will automatically replace all loggers inside your functions.</li> </ul>"},{"location":"getting-started/logging/#logging-levels","title":"Logging Levels","text":"<p>If you use the FastStream CLI, you can change the current logging level of the entire application directly from the command line.</p> <p>The <code>--log-level</code> flag sets the current logging level for both the broker and the <code>FastStream</code> app. This allows you to configure the levels of not only the default loggers but also your custom loggers, if you use them inside FastStream.</p> <pre><code>faststream run serve:app --log-level debug\n</code></pre> <p>If you want to completely disable the default logging of <code>FastStream</code>, you can set <code>logger=None</code></p> <pre><code>from faststream import FastStream\nfrom faststream.rabbit import RabbitBroker\n\nbroker = RabbitBroker(logger=None)  # Disables broker logs\napp = FastStream(broker, logger=None)  # Disables application logs\n</code></pre> <p>Warning</p> <p>Be careful: the <code>logger</code> that you get from the context will also have the value <code>None</code> if you turn off broker logging.</p> <p>If you don't want to lose access to the `logger' inside your context but want to disable the default logs of FastStream, you can lower the level of logs that the broker publishes itself.</p> <pre><code>import logging\nfrom faststream.rabbit import RabbitBroker\n\n# Sets the broker logs to the DEBUG level\nbroker = RabbitBroker(log_level=logging.DEBUG)\n</code></pre>"},{"location":"getting-started/logging/#formatting-logs","title":"Formatting Logs","text":"<p>If you are not satisfied with the current format of your application logs, you can change it directly in your broker's constructor.</p> <pre><code>from faststream.rabbit import RabbitBroker\nbroker = RabbitBroker(log_fmt=\"%(asctime)s %(levelname)s - %(message)s\")\n</code></pre>"},{"location":"getting-started/logging/#logger-access","title":"Logger Access","text":"<p>If you want to override default logger's behavior, you can access them directly via <code>logging</code>.</p> <pre><code>import logging\nlogger = logging.getLogger(\"faststream\")\naccess_logger = logging.getLogger(\"faststream.access\")\n</code></pre> <p>Or you can import them from FastStream.</p> <pre><code>from faststream.log import access_logger, logger\n</code></pre>"},{"location":"getting-started/logging/#using-your-own-loggers","title":"Using Your Own Loggers","text":"<p>Since FastStream works with the standard <code>logging.Logger</code> object, you can initiate an application and a broker using your own logger.</p> <pre><code>import logging\nfrom faststream import FastStream\nfrom faststream.rabbit import RabbitBroker\n\nlogger = logging.getLogger(\"my_logger\")\n\nbroker = RabbitBroker(logger=logger)\napp = FastStream(broker, logger=logger)\n</code></pre> <p>Note</p> <p>Doing this, you doesn't change the CLI logs behavior (multiprocessing and hot reload logs).  This was done to keep your log storage clear of unnecessary stuff.</p> <p>This logger will be used only for <code>FastStream</code> and <code>StreamBroker</code> service messages and will be passed to your function through the Context.</p> <p>By doing this, you will lose information about the context of the current request. However, you can retrieve it directly from the context anywhere in your code.</p> <pre><code>from faststream import context\nlog_context: dict[str, str] = context.get_local(\"log_context\")\n</code></pre> <p>This way, all broker handlers can get access to your broker logger right from the context:</p> <pre><code>from faststream import Logger\n\n@broker.subscriber(...)\nasync def handler(\n    msg,\n    logger: Logger,  # &lt;-- YOUR logger here\n):\n    logger.info(msg)\n</code></pre>"},{"location":"getting-started/logging/#structlog-example","title":"Structlog Example","text":"<p>Structlog is a production-ready logging solution for Python. It can be easely integrated with any log storage system, making it suitable for use in production projects.</p> <p>Here is a quick tutorial on integrating Structlog with FastStream:</p> <p>Start with the Structlog guide example:</p> <pre><code>import sys\nimport structlog\n\nshared_processors = [\n    structlog.processors.add_log_level,\n    structlog.processors.StackInfoRenderer(),\n    structlog.dev.set_exc_info,\n    structlog.processors.TimeStamper(fmt=\"iso\"),\n]\n\nif sys.stderr.isatty():\n    # terminal session\n    processors = shared_processors + [\n        structlog.dev.ConsoleRenderer()\n    ]\nelse:\n    # Docker container session\n    processors = shared_processors + [\n        structlog.processors.dict_tracebacks,\n        structlog.processors.JSONRenderer(),\n    ]\n\nstructlog.configure(\n    processors=processors,\n    logger_factory=structlog.PrintLoggerFactory(),\n    cache_logger_on_first_use=False,\n)\n\nlogger = structlog.get_logger()\n</code></pre> <p>We created a logger that prints messages to the console in a user-friendly format during development and uses JSON-formatted logs in production.</p> <p>To integrate this logger with our FastStream application, we just need to access it through context information and pass it to our objects:</p> <pre><code>import logging\n\nimport structlog\n\nfrom faststream import FastStream, context\nfrom faststream.kafka import KafkaBroker\n\ndef merge_contextvars(\n    logger: structlog.types.WrappedLogger,\n    method_name: str,\n    event_dict: structlog.types.EventDict,\n) -&gt; structlog.types.EventDict:\n    event_dict[\"extra\"] = event_dict.get(\n        \"extra\",\n        context.get(\"log_context\", {}),\n    )\n    return event_dict\n\nshared_processors = [\n    merge_contextvars,\n    ...\n]\n\n...\n\nbroker = KafkaBroker(logger=logger, log_level=logging.DEBUG)\napp = FastStream(broker, logger=logger)\n</code></pre> <p>And the job is done! Now you have a perfectly structured logs using Structlog.</p> <pre><code>TIMESPAMP [info     ] FastStream app starting...     extra={}\nTIMESPAMP [debug    ] `Handler` waiting for messages extra={'topic': 'topic', 'group_id': 'group', 'message_id': ''}\nTIMESPAMP [debug    ] `Handler` waiting for messages extra={'topic': 'topic', 'group_id': 'group2', 'message_id': ''}\nTIMESPAMP [info     ] FastStream app started successfully! To exit, press CTRL+C extra={'topic': '', 'group_id': '', 'message_id': ''}\n</code></pre>"},{"location":"getting-started/asyncapi/custom/","title":"Customizing AsyncAPI Documentation for FastStream","text":"<p>In this guide, we will explore how to customize AsyncAPI documentation for your FastStream application. Whether you want to add custom app info, broker information, handlers, or fine-tune payload details, we'll walk you through each step.</p>"},{"location":"getting-started/asyncapi/custom/#prerequisites","title":"Prerequisites","text":"<p>Before we dive into customization, ensure you have a basic FastStream application up and running. If you haven't done that yet, let's setup a simple appication right now.</p> <p>Copy the following code in your basic.py file:</p> <pre><code>    from faststream import FastStream\n    from faststream.kafka import KafkaBroker, KafkaMessage\n\n    broker = KafkaBroker(\"localhost:9092\")\n    app = FastStream(broker)\n\n    @broker.publisher(\"output_data\")\n    @broker.subscriber(\"input_data\")\n    async def on_input_data(msg):\n        # your processing logic\n        pass\n</code></pre> <p>Now, when you run <code>faststream docs serve basic:app</code> you should see the following documentation:</p> <p></p>"},{"location":"getting-started/asyncapi/custom/#setup-custom-faststream-app-info","title":"Setup Custom FastStream App Info","text":"<p>Let's start by customizing the app information that appears in your AsyncAPI documentation. This is a great way to give your documentation a personal touch. Here's how:</p> <ol> <li>Locate the app configuration in your FastStream application.</li> <li>Update the <code>title</code>, <code>version</code>, and <code>description</code> fields to reflect your application's details.</li> <li>Save the changes.</li> <li>Serve your FastStream app documentation.</li> </ol> <p>Copy the following code in your basic.py file, we have highligted the additional info passed to FastStream app:</p> <pre><code>    from faststream import FastStream\n    from faststream.kafka import KafkaBroker, KafkaMessage\n    from faststream.asyncapi.schema import Contact, ExternalDocs, License, Tag\n\n    broker = KafkaBroker(\"localhost:9092\")\n    app = FastStream(broker,\n                title=\"My App\",\n                version=\"1.0.0\",\n                description=\"Test description\",\n                license=License(name=\"MIT\", url=\"https://opensource.org/license/mit/\"),\n                terms_of_service=\"https://my-terms.com/\",\n                contact=Contact(name=\"support\", url=\"https://help.com/\"),\n            )\n\n    @broker.publisher(\"output_data\")\n    @broker.subscriber(\"input_data\")\n    async def on_input_data(msg):\n        # your processing logic\n        pass\n</code></pre> <p>Now, when you run <code>faststream docs serve basic:app</code> you should see the following in your general app documentation:</p> <p></p> <p>Now, your documentation reflects your application's identity and purpose.</p>"},{"location":"getting-started/asyncapi/custom/#setup-custom-broker-information","title":"Setup Custom Broker Information","text":"<p>The next step is to customize broker information. This helps users understand the messaging system your application uses. Follow these steps:</p> <ol> <li>Locate the broker configuration in your FastStream application.</li> <li>Update the <code>description</code> field.</li> <li>Save the changes.</li> <li>Serve your FastStream app.</li> </ol> <p>Copy the following code in your basic.py file, we have highligted the additional info passed to the FastStream app broker:</p> <pre><code>    from faststream import FastStream\n    from faststream.kafka import KafkaBroker, KafkaMessage\n    from faststream.asyncapi.schema import Tag\n\n    broker = KafkaBroker(\"localhost:9092\", description=\"Kafka broker running locally\")\n    app = FastStream(broker)\n\n    @broker.publisher(\"output_data\")\n    @broker.subscriber(\"input_data\")\n    async def on_input_data(msg):\n        # your processing logic\n        pass\n</code></pre> <p>Now, when you run <code>faststream docs serve basic:app</code> you should see the description in your broker documentation:</p> <p></p> <p>Your AsyncAPI documentation now provides clear insights into the messaging infrastructure you're using.</p>"},{"location":"getting-started/asyncapi/custom/#setup-custom-handler-information","title":"Setup Custom Handler Information","text":"<p>Customizing handler information helps users comprehend the purpose and behavior of each message handler. Here's how to do it:</p> <ol> <li>Navigate to your handler definitions in your FastStream application.</li> <li>Add descriptions to each handler using <code>description</code> field.</li> <li>Save the changes.</li> <li>Serve your FastStream app.</li> </ol> <p>Copy the following code in your basic.py file, we have highligted the additional info passed to the FastStream app handlers:</p> <pre><code>    from faststream import FastStream\n    from faststream.kafka import KafkaBroker, KafkaMessage\n\n    broker = KafkaBroker(\"localhost:9092\")\n    app = FastStream(broker)\n\n    @broker.publisher(\"output_data\", description=\"My publisher description\")\n    @broker.subscriber(\"input_data\", description=\"My subscriber description\")\n    async def on_input_data(msg):\n        # your processing logic\n        pass\n</code></pre> <p>Now, when you run <code>faststream docs serve basic:app</code> you should see the descriptions in your handlers:</p> <p></p> <p>Now, your documentation is enriched with meaningful details about each message handler.</p>"},{"location":"getting-started/asyncapi/custom/#setup-payload-information-via-pydantic-model","title":"Setup Payload Information via Pydantic Model","text":"<p>To describe your message payload effectively, you can use Pydantic models. Here's how:</p> <ol> <li>Define Pydantic models for your message payloads.</li> <li>Annotate these models with descriptions and examples.</li> <li>Use these models as argument types or return types in your handlers.</li> <li>Save the changes.</li> <li>Serve your FastStream app.</li> </ol> <p>Copy the following code in your basic.py file, we have highligted the creation of payload info and you can see it being passed to the return type and the <code>msg</code> argument type in the <code>on_input_data</code> function:</p> <pre><code>    from pydantic import BaseModel, Field, NonNegativeFloat\n\n    from faststream import FastStream\n    from faststream.kafka import KafkaBroker\n\n\n    class DataBasic(BaseModel):\n        data: NonNegativeFloat = Field(\n            ..., examples=[0.5], description=\"Float data example\"\n        )\n\n\n    broker = KafkaBroker(\"localhost:9092\")\n    app = FastStream(broker)\n\n\n    @broker.publisher(\"output_data\")\n    @broker.subscriber(\"input_data\")\n    async def on_input_data(msg: DataBasic) -&gt; DataBasic:\n        # your processing logic\n        pass\n</code></pre> <p>Now, when you run <code>faststream docs serve basic:app</code> you should see the payload schema described in your documentation:</p> <p></p> <p>Your AsyncAPI documentation now showcases well-structured payload information.</p>"},{"location":"getting-started/asyncapi/custom/#generate-schemajson-customize-manually-and-serve-it","title":"Generate Schema.json, Customize Manually, and Serve It","text":"<p>To take customization to the next level, you can manually modify the schema.json file. Follow these steps:</p> <ol> <li>Generate the initial schema.json by running <code>faststream docs gen basic:app</code>.</li> <li>Manually edit the asyncapi.json file to add custom fields, descriptions, and details.</li> <li>Save your changes.</li> <li>Serve your FastStream app with the updated asyncapi.json by running <code>faststream docs serve asyncapi.json</code>.</li> </ol> <p>Now, you have fine-tuned control over your AsyncAPI documentation.</p>"},{"location":"getting-started/asyncapi/custom/#conclusion","title":"Conclusion","text":"<p>Customizing AsyncAPI documentation for your FastStream application not only enhances its appearance but also provides valuable insights to users. With these steps, you can create documentation that's not only informative but also uniquely yours.</p> <p>Happy coding with your customized FastStream AsyncAPI documentation!</p>"},{"location":"getting-started/asyncapi/export/","title":"How to Generate and Serve AsyncAPI Documentation","text":"<p>In this guide, let's explore how to generate and serve AsyncAPI documentation for our FastStream application.</p>"},{"location":"getting-started/asyncapi/export/#writing-the-faststream-application","title":"Writing the FastStream Application","text":"<p>Here's an example Python application using FastStream that consumes data from a topic, increments the value, and outputs the data to another topic. Save it in a file called <code>basic.py</code>.</p> <pre><code>from pydantic import BaseModel, Field, NonNegativeFloat\n\nfrom faststream import FastStream, Logger\nfrom faststream.kafka import KafkaBroker\n\n\nclass DataBasic(BaseModel):\n    data: NonNegativeFloat = Field(\n        ..., examples=[0.5], description=\"Float data example\"\n    )\n\n\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\n\n\n@broker.publisher(\"output_data\")\n@broker.subscriber(\"input_data\")\nasync def on_input_data(msg: DataBasic, logger: Logger) -&gt; DataBasic:\n    logger.info(msg)\n    return DataBasic(data=msg.data + 1.0)\n</code></pre>"},{"location":"getting-started/asyncapi/export/#generating-the-asyncapi-specification","title":"Generating the AsyncAPI Specification","text":"<p>Now that we have a FastStream application, we can proceed with generating the AsyncAPI specification using a CLI command.</p> <pre><code>faststream docs gen basic:app\n</code></pre> <p>The above command will generate the AsyncAPI specification and save it in a file called <code>asyncapi.json</code>.</p> <p>If you prefer <code>yaml</code> instead of <code>json</code>, please run the following command to generate <code>asyncapi.yaml</code>.</p> <pre><code>faststream docs gen --yaml basic:app\n</code></pre> <p>Note</p> <p>To generate the documentation in yaml format, please install the necessary dependency to work with YAML file format at first.</p> <pre><code>pip install PyYAML\n</code></pre>"},{"location":"getting-started/asyncapi/hosting/","title":"Serving the AsyncAPI Documentation","text":"<p>FastStream provides a command to serve the AsyncAPI documentation.</p> <p>Note</p> <p>This feature requires an Internet connection to obtain the AsyncAPI HTML via CDN.</p> <pre><code>faststream docs serve basic:app\n</code></pre> <p>In the above command, we are providing the path in the format of <code>python_module:FastStream</code>. Alternatively, you can also specify <code>asyncapi.json</code> or <code>asyncapi.yaml</code> to serve the AsyncAPI documentation.</p> <pre><code>faststream docs serve asyncapi.json\n# or\nfaststream docs serve asyncapi.yaml\n</code></pre> <p>After running the command, it should serve the AsyncAPI documentation on port 8000 and display the following logs in the terminal.</p> <pre><code>INFO:     Started server process [2364992]\nINFO:     Waiting for application startup.\nINFO:     Application startup complete.\nINFO:     Uvicorn running on http://localhost:8000 (Press CTRL+C to quit)\n</code></pre> <p>And you should be able to see the following page in your browser:</p> ShortExpand <p></p> <p></p> <p>Tip</p> <p>The command also offers options to serve the documentation on a different host and port.</p>"},{"location":"getting-started/cli/","title":"CLI","text":"<p>FastStream has its own built-in CLI tool for your maximum comfort as a developer.</p> <p>Thanks to typer and watchfiles. Their work is the basis of this tool.</p> <pre><code>faststream --help\n</code></pre> <pre><code>Usage: faststream [OPTIONS] COMMAND [ARGS]...\n\n  Generate, run and manage FastStream apps to greater development experience\n\nOptions:\n  -v, --version                   Show current platform, python and FastStream\n                                  version\n  --install-completion [bash|zsh|fish|powershell|pwsh]\n                                  Install completion for the specified shell.\n  --show-completion [bash|zsh|fish|powershell|pwsh]\n                                  Show completion for the specified shell, to\n                                  copy it or customize the installation.\n  --help                          Show this message and exit.\n\nCommands:\n  docs  AsyncAPI schema commands\n  run   Run [MODULE:APP] FastStream application\n</code></pre>"},{"location":"getting-started/cli/#running-the-project","title":"Running the Project","text":""},{"location":"getting-started/cli/#multiprocessing-scaling","title":"Multiprocessing Scaling","text":"<p>FastStream allows you to scale application right from the command line by running you application in the Process pool.</p> <p>Just set the <code>--worker</code> option to scale your application:</p> <pre><code>faststream run serve:app --workers 2\n</code></pre> <pre><code>INFO     - Started parent process [7591]\nINFO     - Started child process [7593]\nINFO     - Started child process [7594]\nINFO     - test |            - `Handle` waiting for messages\nINFO     - test |            - `Handle` waiting for messages\n</code></pre>"},{"location":"getting-started/cli/#hot-reload","title":"Hot Reload","text":"<p>Thanks to watchfiles, written in Rust, you can work with your project easily. Edit the code as much as you like - the new version has already been launched and is waiting for your requests!</p> <pre><code>faststream run serve:app --reload\n</code></pre> <pre><code>INFO     - Started reloader process [7902] using WatchFiles\nINFO     - FastStream app starting...\nINFO     - test |            - `Handle` waiting for messages\nINFO     - FastStream app started successfully! To exit press CTRL+C\n</code></pre>"},{"location":"getting-started/cli/#environment-management","title":"Environment Management","text":"<p>You can pass any custom flags and launch options to the FastStream CLI even without first registering them. Just use them when launching the application - and they will be right in your environment.</p> <p>Use this option to select environment files, configure logging, or at your discretion.</p> <p>For example, we will pass the .env file to the context of our application:</p> <pre><code>faststream run serve:app --env=.env.dev\n</code></pre> <pre><code>INFO     - FastStream app starting...\nINFO     - test |            - `Handle` waiting for messages\nINFO     - FastStream app started successfully! To exit press CTRL+C\n</code></pre> KafkaRabbitMQNATS <pre><code>from faststream import FastStream, ContextRepo\nfrom faststream.kafka import KafkaBroker\nfrom pydantic_settings import BaseSettings\n\nbroker = KafkaBroker()\n\napp = FastStream(broker)\n\nclass Settings(BaseSettings):\n    host: str = \"localhost:9092\"\n\n@app.on_startup\nasync def setup(env: str, context: ContextRepo):\n    settings = Settings(_env_file=env)\n    await broker.connect(settings.host)\n    context.set_global(\"settings\", settings)\n</code></pre> <pre><code>from faststream import FastStream, ContextRepo\nfrom faststream.rabbit import RabbitBroker\nfrom pydantic_settings import BaseSettings\n\nbroker = RabbitBroker()\n\napp = FastStream(broker)\n\nclass Settings(BaseSettings):\n    host: str = \"amqp://guest:guest@localhost:5672/\" # pragma: allowlist secret\n\n@app.on_startup\nasync def setup(env: str, context: ContextRepo):\n    settings = Settings(_env_file=env)\n    await broker.connect(settings.host)\n    context.set_global(\"settings\", settings)\n</code></pre> <pre><code>from faststream import FastStream, ContextRepo\nfrom faststream.nats import NatsBroker\nfrom pydantic_settings import BaseSettings\n\nbroker = NatsBroker()\n\napp = FastStream(broker)\n\nclass Settings(BaseSettings):\n    host: str = \"nats://localhost:4222\"\n\n@app.on_startup\nasync def setup(env: str, context: ContextRepo):\n    settings = Settings(_env_file=env)\n    await broker.connect(settings.host)\n    context.set_global(\"settings\", settings)\n</code></pre> <p>Note</p> <p>Note that the <code>env</code> parameter was passed to the <code>setup</code> function directly from the command line</p> <p>All passed values can be of type <code>bool</code>, <code>str</code> or <code>list[str]</code>.</p> <p>In this case, the flags will be interpreted as follows:</p> <pre><code>faststream run app:app --flag       # flag = True\nfaststream run app:app --no-flag    # flag = False\nfaststream run app:app --my-flag    # my_flag = True\nfaststream run app:app --key value  # key = \"value\"\nfaststream run app:app --key 1 2    # key = [\"1\", \"2\"]\n</code></pre> <p>You can use them both individually and together in unlimited quantities.</p>"},{"location":"getting-started/cli/#asyncapi-schema","title":"AsyncAPI Schema","text":"<p>Also, the FastStream CLI allows you to work with the AsyncAPI schema in a simple way.</p> <p>You are able to generate <code>.json</code> or <code>.yaml</code> files by your application code or host HTML representation directly:</p> <pre><code>faststream docs --help\n</code></pre> <pre><code>Usage: faststream docs [OPTIONS] COMMAND [ARGS]...\n\n  AsyncAPI schema commands\n\nOptions:\n  --help  Show this message and exit.\n\nCommands:\n  gen    Generate project AsyncAPI schema\n  serve  Serve project AsyncAPI schema\n</code></pre> <p>To learn more about the commands above, please visit AsyncAPI export and AsyncAPI hosting.</p>"},{"location":"getting-started/config/","title":"Settings and Environment Variables","text":"<p>In many cases, your application may require external settings or configurations, such as a broker connection or database credentials.</p> <p>To manage these settings effectively, it's common to provide them through environment variables that can be read by the application.</p>"},{"location":"getting-started/config/#pydantic-settings","title":"Pydantic <code>Settings</code>","text":"<p>Fortunately, Pydantic  provides a useful utility for handling settings coming from environment variables with Pydantic: Settings management.</p>"},{"location":"getting-started/config/#install-pydantic-settings","title":"Install <code>pydantic-settings</code>","text":"<p>First, install the <code>pydantic-settings</code> package:</p> <pre><code>pip install pydantic-settings\n</code></pre> <p>Info</p> <p>In Pydantic v1, this functionality was included with the main package. Now it is distributed as an independent package so that you can choose not to install it if you don't need that functionality.</p>"},{"location":"getting-started/config/#create-the-settings-object","title":"Create the <code>Settings</code> Object","text":"<p>Import <code>BaseSettings</code> from Pydantic and create a subclass, similar to what you would do with a Pydantic model.</p> <p>Just like with Pydantic models, you declare class attributes with type annotations and can use all the same validation features and tools, including different data types and additional validations with <code>Field()</code>.</p> Pydantic v2Pydantic v1 config.py<pre><code>from pydantic_settings import BaseSettings\n\n\nclass Settings(BaseSettings):\n    url: str = \"\"\n    queue: str = \"test-queue\"\n\n\nsettings = Settings()\n</code></pre> <p>Info</p> <p>In Pydantic v1 you would import <code>BaseSettings</code> directly from <code>pydantic</code> instead of from <code>pydantic_settings</code>.</p> config.py<pre><code>from pydantic import BaseSettings\n\n\nclass Settings(BaseSettings):\n    url: str = \"\"\n    queue: str = \"test-queue\"\n\n\nsettings = Settings()\n</code></pre> <p>When you create an instance of that <code>Settings</code> class (in this case, in the <code>settings</code> object), Pydantic will read the environment variables in a case-insensitive way. For example, an upper-case variable <code>APP_NAME</code> will still be read for the attribute <code>app_name</code>.</p> <p>It will also convert and validate the data, so when you use that <code>settings</code> object, you will have data of the type you declared (e.g. <code>items_per_user</code> will be an <code>int</code>).</p>"},{"location":"getting-started/config/#using-the-settings","title":"Using the <code>settings</code>","text":"<p>Now you can use the new <code>settings</code> object in your application:</p> serve.py<pre><code>import os\n\nfrom pydantic_settings import BaseSettings\n\nfrom faststream import FastStream\nfrom faststream.rabbit import RabbitBroker\n\n\nclass Settings(BaseSettings):\n    url: str\n    queue: str = \"test-queue\"\n\n\nsettings = Settings(_env_file=os.getenv(\"ENV\", \".env\"))\n\nbroker = RabbitBroker(settings.url)\napp = FastStream(broker)\n\n\n@broker.subscriber(settings.queue)\nasync def handler(msg):\n    ...\n</code></pre>"},{"location":"getting-started/config/#running-the-application","title":"Running the Application","text":"<p>You can run the application while passing the configuration parameters as environment variables. For example, you could set an <code>URL</code>:</p> <pre><code>URL=\"amqp://guest:guest@localhost:5672\" faststream run serve:app\n</code></pre> <p>Tip</p> <p>To set multiple environment variables for a single command, separate them with spaces and put them all before the command.</p>"},{"location":"getting-started/config/#reading-a-env-file","title":"Reading a <code>.env</code> File","text":"<p>If you have many settings that may change frequently, especially in different environments, it might be useful to store them in a file and then read them as if they were environment variables.</p> <p>This practice is common enough that it has a name; these environment variables are typically placed in a file named <code>.env</code>, commonly referred to as a \"dotenv\" file.</p> <p>Tip</p> <p>In Unix-like systems like Linux and macOS, a file starting with a dot (<code>.</code>) is considered a hidden file.</p> <p>But a dotenv file doesn't really have to have that exact filename.</p> <p>Pydantic supports reading from these types of files using an external library. You can learn more at Pydantic Settings: Dotenv (.env) support.</p> <p>Tip</p> <p>To use this feature, you need to install the <code>python-dotenv</code> library.</p>"},{"location":"getting-started/config/#the-env-file","title":"The <code>.env</code> File","text":"<p>You can create a <code>.env</code> file with contents like this:</p> <pre><code>URL=\"amqp://guest:guest@localhost:5672\"\nQUEUE=\"test-queue\"\n</code></pre>"},{"location":"getting-started/config/#reading-settings-from-env","title":"Reading Settings from <code>.env</code>","text":"<p>Then update your <code>config.py</code> as follows:</p> <pre><code>import os\n\nfrom pydantic_settings import BaseSettings\n\n\nclass Settings(BaseSettings):\n    url: str\n    queue: str = \"test-queue\"\n\n\nsettings = Settings(_env_file=os.getenv(\"ENV\", \".env\"))\n</code></pre> <p>This way, you can specify different <code>.env</code> files directly from your terminal, which can be extremely helpful for various testing and production scenarios.</p> <p>Note</p> <p>By default, Pydantic will attempt to find a <code>.env</code> file. If it's not present, Pydantic will use the default field values.</p>"},{"location":"getting-started/config/#choosing-the-env-file-at-startup","title":"Choosing the <code>.env</code> File at Startup","text":"<p>Now you can run the apllication with different <code>.env</code> files like so:</p> <pre><code>ENV=.local.env faststream run serve:app\n</code></pre> <p>Or, for a production environment:</p> <pre><code>ENV=.production.env faststream run serve:app\n</code></pre> <p>Or even for a test environment:</p> <pre><code>ENV=.test.env pytest\n</code></pre>"},{"location":"getting-started/context/","title":"Application Context","text":"<p>FastStreams has its own Dependency Injection container - Context, used to store application runtime objects and variables.</p> <p>With this container, you can access both application scope and message processing scope objects. This functionality is similar to <code>Depends</code> usage.</p> KafkaRabbitMQNATS <pre><code>from faststream import Context, FastStream\nfrom faststream.kafka import KafkaBroker\n\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\n\n\n@broker.subscriber(\"test\")\nasync def base_handler(\n    body: str,\n    message=Context(),  # get access to raw message\n):\n    ...\n</code></pre> <pre><code>from faststream import Context, FastStream\nfrom faststream.rabbit import RabbitBroker\n\nbroker = RabbitBroker(\"amqp://guest:guest@localhost:5672/\")\napp = FastStream(broker)\n\n\n@broker.subscriber(\"test\")\nasync def base_handler(\n    body: str,\n    message=Context(),  # get access to raw message\n):\n    ...\n</code></pre> <pre><code>from faststream import Context, FastStream\nfrom faststream.nats import NatsBroker\n\nbroker = NatsBroker(\"nats://localhost:4222\")\napp = FastStream(broker)\n\n\n@broker.subscriber(\"test\")\nasync def base_handler(\n    body: str,\n    message=Context(),  # get access to raw message\n):\n    ...\n</code></pre> <p>But, with the <code>Annotated</code> Python feature usage, it is much closer to <code>@pytest.fixture</code>.</p> KafkaRabbitMQNATS <pre><code>from typing import Annotated\n\nfrom faststream import Context, FastStream\nfrom faststream.kafka import KafkaBroker, KafkaMessage\n\nMessage = Annotated[KafkaMessage, Context()]\n\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\n\n\n@broker.subscriber(\"test\")\nasync def base_handler(\n    body: str,\n    message: Message,  # get access to raw message\n):\n    ...\n</code></pre> <pre><code>from typing import Annotated\n\nfrom faststream import Context, FastStream\nfrom faststream.rabbit import RabbitBroker, RabbitMessage\n\nMessage = Annotated[RabbitMessage, Context()]\n\nbroker = RabbitBroker(\"amqp://guest:guest@localhost:5672/\")\napp = FastStream(broker)\n\n\n@broker.subscriber(\"test\")\nasync def base_handler(\n    body: str,\n    message: Message,  # get access to raw message\n):\n    ...\n</code></pre> <pre><code>from typing import Annotated\n\nfrom faststream import Context, FastStream\nfrom faststream.nats import NatsBroker, NatsMessage\n\nMessage = Annotated[NatsMessage, Context()]\n\nbroker = NatsBroker(\"nats://localhost:4222\")\napp = FastStream(broker)\n\n\n@broker.subscriber(\"test\")\nasync def base_handler(\n    body: str,\n    message: Message,  # get access to raw message\n):\n    ...\n</code></pre>"},{"location":"getting-started/context/#usages","title":"Usages","text":"<p>By default, the context is available in the same place as <code>Depends</code>:</p> <ul> <li>at lifespan hooks</li> <li>message subscribers</li> <li>nested dependencies</li> </ul> <p>Tip</p> <p>Fields obtained from the <code>Context</code> are editable, so editing them in a function means editing them everywhere.</p>"},{"location":"getting-started/context/#compatibility-with-regular-functions","title":"Compatibility with Regular Functions","text":"<p>To use context in other functions, use the <code>@apply_types</code> decorator. In this case, the context of the called function will correspond to the context of the event handler from which it was called.</p> <pre><code>from faststream import Context, apply_types\n\n\n@broker.subscriber(\"test\")\nasync def handler(body):\n    nested_func(body)\n\n\n@apply_types\ndef nested_func(body, logger=Context()):\n    logger.info(body)\n</code></pre> <p>In the example above, we did not pass the <code>logger</code> function at calling it; it was placed outside of context.</p>"},{"location":"getting-started/context/custom/","title":"Context Fields Declaration","text":"<p>You can also store your own objects in the <code>Context</code>.</p>"},{"location":"getting-started/context/custom/#global","title":"Global","text":"<p>To declare an application-level context field, you need to call the <code>context.set_global</code> method with with a key to indicate where the object will be placed in the context.</p> KafkaRabbitMQNATS <pre><code>from faststream import FastStream, ContextRepo, Context\nfrom faststream.kafka import KafkaBroker\n\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\n\n\n@app.on_startup\nasync def set_global(context: ContextRepo):\n    context.set_global(\"secret_str\", \"my-perfect-secret\")\n</code></pre> <pre><code>from faststream import FastStream, ContextRepo, Context\nfrom faststream.rabbit import RabbitBroker\n\nbroker = RabbitBroker(\"amqp://guest:guest@localhost:5672/\")\napp = FastStream(broker)\n\n\n@app.on_startup\nasync def set_global(context: ContextRepo):\n    context.set_global(\"secret_str\", \"my-perfect-secret\")\n</code></pre> <pre><code>from faststream import FastStream, ContextRepo, Context\nfrom faststream.nats import NatsBroker\n\nbroker = NatsBroker(\"nats://localhost:4222\")\napp = FastStream(broker)\n\n\n@app.on_startup\nasync def set_global(context: ContextRepo):\n    context.set_global(\"secret_str\", \"my-perfect-secret\")\n</code></pre> <p>Afterward, you can access your <code>secret</code> field in the usual way:</p> KafkaRabbitMQNATS <pre><code>@broker.subscriber(\"test-topic\")\nasync def handle(\n    msg: str,\n    secret_str: str=Context(),\n):\n    assert secret_str == \"my-perfect-secret\" # pragma: allowlist secret\n</code></pre> <pre><code>@broker.subscriber(\"test-queue\")\nasync def handle(\n    msg: str,\n    secret_str: str=Context(),\n):\n    assert secret_str == \"my-perfect-secret\" # pragma: allowlist secret\n</code></pre> <pre><code>@broker.subscriber(\"test-subject\")\nasync def handle(\n    msg: str,\n    secret_str: str=Context(),\n):\n    assert secret_str == \"my-perfect-secret\" # pragma: allowlist secret\n</code></pre> <p>In this case, the field becomes a global context field: it does not depend on the current message handler (unlike <code>message</code>)</p> <p>To remove a field from the context use the <code>reset_global</code> method:</p> <pre><code>context.reset_global(\"my_key\")\n</code></pre>"},{"location":"getting-started/context/custom/#local","title":"Local","text":"<p>To set a local context (available only within the message processing scope), use the context manager <code>scope</code></p> KafkaRabbitMQNATS <pre><code>from faststream import Context, FastStream, apply_types\nfrom faststream.kafka import KafkaBroker\nfrom faststream.kafka.annotations import ContextRepo, KafkaMessage\n\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\n\n\n@broker.subscriber(\"test-topic\")\nasync def handle(\n    msg: str,\n    message: KafkaMessage,\n    context: ContextRepo,\n):\n    with context.scope(\"correlation_id\", message.correlation_id):\n        call()\n\n\n@apply_types\ndef call(\n    message: KafkaMessage,\n    correlation_id=Context(),\n):\n    assert correlation_id == message.correlation_id\n</code></pre> <pre><code>from faststream import Context, FastStream, apply_types\nfrom faststream.rabbit import RabbitBroker\nfrom faststream.rabbit.annotations import ContextRepo, RabbitMessage\n\nbroker = RabbitBroker(\"amqp://guest:guest@localhost:5672/\")\napp = FastStream(broker)\n\n\n@broker.subscriber(\"test-queue\")\nasync def handle(\n    msg: str,\n    message: RabbitMessage,\n    context: ContextRepo,\n):\n    with context.scope(\"correlation_id\", message.correlation_id):\n        call()\n\n\n@apply_types\ndef call(\n    message: RabbitMessage,\n    correlation_id=Context(),\n):\n    assert correlation_id == message.correlation_id\n</code></pre> <pre><code>from faststream import Context, FastStream, apply_types\nfrom faststream.nats import NatsBroker\nfrom faststream.nats.annotations import ContextRepo, NatsMessage\n\nbroker = NatsBroker(\"nats://localhost:4222\")\napp = FastStream(broker)\n\n\n@broker.subscriber(\"test-subject\")\nasync def handle(\n    msg: str,\n    message: NatsMessage,\n    context: ContextRepo,\n):\n    with context.scope(\"correlation_id\", message.correlation_id):\n        call()\n\n\n@apply_types\ndef call(\n    message: NatsMessage,\n    correlation_id=Context(),\n):\n    assert correlation_id == message.correlation_id\n</code></pre> <p>You can also set the context yourself, and it will remain within the current call stack until you clear it.</p> KafkaRabbitMQNATS <pre><code>from faststream import Context, FastStream, apply_types, context\nfrom faststream.kafka import KafkaBroker\nfrom faststream.kafka.annotations import KafkaMessage\n\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\n\n\n@broker.subscriber(\"test-topic\")\nasync def handle(\n    msg: str,\n    message: KafkaMessage,\n):\n    tag = context.set_local(\"correlation_id\", message.correlation_id)\n    call(tag)\n\n\n@apply_types\ndef call(\n    tag,\n    message: KafkaMessage,\n    correlation_id=Context(),\n):\n    assert correlation_id == message.correlation_id\n    context.reset_local(\"correlation_id\", tag)\n</code></pre> <pre><code>from faststream import Context, FastStream, apply_types, context\nfrom faststream.rabbit import RabbitBroker\nfrom faststream.rabbit.annotations import RabbitMessage\n\nbroker = RabbitBroker(\"amqp://guest:guest@localhost:5672/\")\napp = FastStream(broker)\n\n\n@broker.subscriber(\"test-queue\")\nasync def handle(\n    msg: str,\n    message: RabbitMessage,\n):\n    tag = context.set_local(\"correlation_id\", message.correlation_id)\n    call(tag)\n\n\n@apply_types\ndef call(\n    tag,\n    message: RabbitMessage,\n    correlation_id=Context(),\n):\n    assert correlation_id == message.correlation_id\n    context.reset_local(\"correlation_id\", tag)\n</code></pre> <pre><code>from faststream import Context, FastStream, apply_types, context\nfrom faststream.nats import NatsBroker\nfrom faststream.nats.annotations import NatsMessage\n\nbroker = NatsBroker(\"nats://localhost:4222\")\napp = FastStream(broker)\n\n\n@broker.subscriber(\"test-subject\")\nasync def handle(\n    msg: str,\n    message: NatsMessage,\n):\n    tag = context.set_local(\"correlation_id\", message.correlation_id)\n    call(tag)\n\n\n@apply_types\ndef call(\n    tag,\n    message: NatsMessage,\n    correlation_id=Context(),\n):\n    assert correlation_id == message.correlation_id\n    context.reset_local(\"correlation_id\", tag)\n</code></pre>"},{"location":"getting-started/context/existed/","title":"Existing Fields","text":"<p>Context already contains some global objects that you can always access:</p> <ul> <li>broker - the current broker</li> <li>context - the context itself, in which you can write your own fields</li> <li>logger - the logger used for your broker (tags messages with message_id)</li> <li>message - the raw message (if you need access to it)</li> </ul> <p>At the same time, thanks to <code>contextlib.ContextVar</code>, message is local for you current consumer scope.</p>"},{"location":"getting-started/context/existed/#access-to-context-fields","title":"Access to Context Fields","text":"<p>By default, the context searches for an object based on the argument name.</p> KafkaRabbitMQNATS <pre><code>from faststream import Context, FastStream\nfrom faststream.kafka import KafkaBroker\n\n\nbroker_object = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker_object)\n\n\n@broker_object.subscriber(\"test-topic\")\nasync def handle(\n    msg: str,\n    logger=Context(),\n    message=Context(),\n    broker=Context(),\n    context=Context(),\n):\n    logger.info(message)\n    await broker.publish(\"test\", \"response\")\n</code></pre> <pre><code>from faststream import Context, FastStream\nfrom faststream.rabbit import RabbitBroker\n\n\nbroker_object = RabbitBroker(\"amqp://guest:guest@localhost:5672/\")\napp = FastStream(broker_object)\n\n\n@broker_object.subscriber(\"test-queue\")\nasync def handle(\n    msg: str,\n    logger=Context(),\n    message=Context(),\n    broker=Context(),\n    context=Context(),\n):\n    logger.info(message)\n    await broker.publish(\"test\", \"response\")\n</code></pre> <pre><code>from faststream import Context, FastStream\nfrom faststream.nats import NatsBroker\n\n\nbroker_object = NatsBroker(\"nats://localhost:4222\")\napp = FastStream(broker_object)\n\n\n@broker_object.subscriber(\"test-subject\")\nasync def handle(\n    msg: str,\n    logger=Context(),\n    message=Context(),\n    broker=Context(),\n    context=Context(),\n):\n    logger.info(message)\n    await broker.publish(\"test\", \"response\")\n</code></pre>"},{"location":"getting-started/context/existed/#annotated-aliases","title":"Annotated Aliases","text":"<p>Also, FastStream has already created <code>Annotated</code> aliases to provide you with comfortable access to existing objects. You can import them directly from <code>faststream</code> or your broker-specific modules:</p> <ul> <li>Shared aliases</li> </ul> <pre><code>from faststream import Logger, ContextRepo\n</code></pre> <ul> <li>Kafka aliases</li> </ul> <pre><code>from faststream.kafka.annotations import (\n    Logger, ContextRepo, KafkaMessage, KafkaBroker, KafkaProducer\n)\n</code></pre> <ul> <li>RabbitMQ aliases</li> </ul> <pre><code>from faststream.rabbit.annotations import (\n    Logger, ContextRepo, RabbitMessage, RabbitBroker, RabbitProducer\n)\n</code></pre> <ul> <li>NATS aliases</li> </ul> <pre><code>from faststream.rabbit.annotations import (\n    Logger, ContextRepo, NatsMessage,\n    NatsBroker, NatsProducer, NatsJsProducer,\n    Client, JsClient,\n)\n</code></pre> <p>To use them, simply import and use them as subscriber argument annotations.</p> KafkaRabbitMQNATS <pre><code>from faststream import Context, FastStream\nfrom faststream.kafka import KafkaBroker\nfrom faststream.kafka.annotations import (\n    ContextRepo,\n    KafkaMessage,\n    Logger,\n    KafkaBroker as BrokerAnnotation,\n)\n\nbroker_object = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker_object)\n\n\n@broker_object.subscriber(\"response-topic\")\nasync def handle_response(\n    msg: str,\n    logger: Logger,\n    message: KafkaMessage,\n    context: ContextRepo,\n    broker: BrokerAnnotation,\n):\n    logger.info(message)\n    await broker.publish(\"test\", \"response\")\n</code></pre> <pre><code>from faststream import Context, FastStream\nfrom faststream.rabbit import RabbitBroker\nfrom faststream.rabbit.annotations import (\n    ContextRepo,\n    RabbitMessage,\n    Logger,\n    RabbitBroker as BrokerAnnotation,\n)\n\nbroker_object = RabbitBroker(\"amqp://guest:guest@localhost:5672/\")\napp = FastStream(broker_object)\n\n\n@broker_object.subscriber(\"response-queue\")\nasync def handle_response(\n    msg: str,\n    logger: Logger,\n    message: RabbitMessage,\n    context: ContextRepo,\n    broker: BrokerAnnotation,\n):\n    logger.info(message)\n    await broker.publish(\"test\", \"response\")\n</code></pre> <pre><code>from faststream import Context, FastStream\nfrom faststream.nats import NatsBroker\nfrom faststream.nats.annotations import (\n    ContextRepo,\n    NatsMessage,\n    Logger,\n    NatsBroker as BrokerAnnotation,\n)\n\nbroker_object = NatsBroker(\"nats://localhost:4222\")\napp = FastStream(broker_object)\n\n\n@broker_object.subscriber(\"response-subject\")\nasync def handle_response(\n    msg: str,\n    logger: Logger,\n    message: NatsMessage,\n    context: ContextRepo,\n    broker: BrokerAnnotation,\n):\n    logger.info(message)\n    await broker.publish(\"test\", \"response\")\n</code></pre>"},{"location":"getting-started/context/extra/","title":"Context Extra Options","text":"<p>Additionally, <code>Context</code> provides you with some extra capabilities for working with containing objects.</p>"},{"location":"getting-started/context/extra/#default-values","title":"Default Values","text":"<p>For instance, if you attempt to access a field that doesn't exist in the global context, you will receive a <code>pydantic.ValidationError</code> exception.</p> <p>However, you can set default values if needed.</p> KafkaRabbitMQNATS <pre><code>@broker.subscriber(\"test-topic\")\nasync def handle(\n    not_existed: None = Context(\"not_existed\", default=None),\n):\n    assert not_existed is None\n</code></pre> <pre><code>@broker.subscriber(\"test-queue\")\nasync def handle(\n    not_existed: None = Context(\"not_existed\", default=None),\n):\n    assert not_existed is None\n</code></pre> <pre><code>@broker.subscriber(\"test-subject\")\nasync def handle(\n    not_existed: None = Context(\"not_existed\", default=None),\n):\n    assert not_existed is None\n</code></pre>"},{"location":"getting-started/context/extra/#cast-context-types","title":"Cast Context Types","text":"<p>By default, context fields are NOT CAST to the type specified in their annotation.</p> KafkaRabbitMQNATS <pre><code>from faststream import Context, FastStream, context\nfrom faststream.kafka import KafkaBroker\n\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\ncontext.set_global(\"secret\", \"1\")\n\n@broker.subscriber(\"test-topic\")\nasync def handle(\n    secret: int = Context(),\n):\n    assert secret == \"1\"\n</code></pre> <pre><code>from faststream import Context, FastStream, context\nfrom faststream.rabbit import RabbitBroker\n\nbroker = RabbitBroker(\"amqp://guest:guest@localhost:5672/\")\napp = FastStream(broker)\ncontext.set_global(\"secret\", \"1\")\n\n@broker.subscriber(\"test-queue\")\nasync def handle(\n    secret: int = Context(),\n):\n    assert secret == \"1\"\n</code></pre> <pre><code>from faststream import Context, FastStream, context\nfrom faststream.nats import NatsBroker\n\nbroker = NatsBroker(\"nats://localhost:4222\")\napp = FastStream(broker)\ncontext.set_global(\"secret\", \"1\")\n\n@broker.subscriber(\"test-subject\")\nasync def handle(\n    secret: int = Context(),\n):\n    assert secret == \"1\"\n</code></pre> <p>If you require this functionality, you can enable the appropriate flag.</p> KafkaRabbitMQNATS <pre><code>@broker.subscriber(\"test-topic2\")\nasync def handle_int(\n    secret: int = Context(cast=True),\n):\n    assert secret == 1\n</code></pre> <pre><code>@broker.subscriber(\"test-queue2\")\nasync def handle_int(\n    secret: int = Context(cast=True),\n):\n    assert secret == 1\n</code></pre> <pre><code>@broker.subscriber(\"test-subject2\")\nasync def handle_int(\n    secret: int = Context(cast=True),\n):\n    assert secret == 1\n</code></pre>"},{"location":"getting-started/context/fields/","title":"Access by Name","text":"<p>Sometimes, you may need to use a different name for the argument (not the one under which it is stored in the context) or get access to specific parts of the object. To do this, simply specify the name of what you want to access, and the context will provide you with the object.</p> KafkaRabbitMQNATS <pre><code>from faststream import Context, FastStream\nfrom faststream.kafka import KafkaBroker, KafkaMessage\n\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\n\n\n@broker.subscriber(\"test-topic\")\nasync def handle(\n    msg: KafkaMessage = Context(\"message\"),\n    correlation_id: str = Context(\"message.correlation_id\"),\n):\n    assert msg.correlation_id == correlation_id\n</code></pre> <pre><code>from faststream import Context, FastStream\nfrom faststream.rabbit import RabbitBroker, RabbitMessage\n\nbroker = RabbitBroker(\"amqp://guest:guest@localhost:5672/\")\napp = FastStream(broker)\n\n\n@broker.subscriber(\"test-queue\")\nasync def handle(\n    msg: RabbitMessage = Context(\"message\"),\n    correlation_id: str = Context(\"message.correlation_id\"),\n):\n    assert msg.correlation_id == correlation_id\n</code></pre> <pre><code>from faststream import Context, FastStream\nfrom faststream.nats import NatsBroker, NatsMessage\n\nbroker = NatsBroker(\"nats://localhost:4222\")\napp = FastStream(broker)\n\n\n@broker.subscriber(\"test-subject\")\nasync def handle(\n    msg: NatsMessage = Context(\"message\"),\n    correlation_id: str = Context(\"message.correlation_id\"),\n):\n    assert msg.correlation_id == correlation_id\n</code></pre> <p>This way you can get access to context object by its name</p> KafkaRabbitMQNATS <pre><code>    msg: KafkaMessage = Context(\"message\"),\n</code></pre> <pre><code>    msg: RabbitMessage = Context(\"message\"),\n</code></pre> <pre><code>    msg: NatsMessage = Context(\"message\"),\n</code></pre> <p>This way you can get access to context object specific field</p> KafkaRabbitMQNATS <pre><code>    correlation_id: str = Context(\"message.correlation_id\"),\n</code></pre> <pre><code>    correlation_id: str = Context(\"message.correlation_id\"),\n</code></pre> <pre><code>    correlation_id: str = Context(\"message.correlation_id\"),\n</code></pre>"},{"location":"getting-started/contributing/CONTRIBUTING/","title":"Development","text":"<p>After cloning the project, you'll need to set up the development environment. Here are the guidelines on how to do this.</p>"},{"location":"getting-started/contributing/CONTRIBUTING/#virtual-environment-with-venv","title":"Virtual Environment with <code>venv</code>","text":"<p>Create a virtual environment in a directory using Python's <code>venv</code> module:</p> <pre><code>python -m venv venv\n</code></pre> <p>That will create a <code>./venv/</code> directory with Python binaries, allowing you to install packages in an isolated environment.</p>"},{"location":"getting-started/contributing/CONTRIBUTING/#activate-the-environment","title":"Activate the Environment","text":"<p>Activate the new environment with:</p> <pre><code>source ./venv/bin/activate\n</code></pre> <p>Ensure you have the latest pip version in your virtual environment:</p> <pre><code>python -m pip install --upgrade pip\n</code></pre>"},{"location":"getting-started/contributing/CONTRIBUTING/#installing-dependencies","title":"Installing Dependencies","text":"<p>After activating the virtual environment as described above, run:</p> <pre><code>pip install -e \".[dev]\"\n</code></pre> <p>This will install all the dependencies and your local FastStream in your virtual environment.</p>"},{"location":"getting-started/contributing/CONTRIBUTING/#using-your-local-faststream","title":"Using Your local FastStream","text":"<p>If you create a Python file that imports and uses FastStream, and run it with the Python from your local environment, it will use your local FastStream source code.</p> <p>Whenever you update your local FastStream source code, it will automatically use the latest version when you run your Python file again. This is because it is installed with <code>-e</code>.</p> <p>This way, you don't have to \"install\" your local version to be able to test every change.</p> <p>To use your local FastStream CLI, type:</p> <pre><code>python -m faststream ...\n</code></pre>"},{"location":"getting-started/contributing/CONTRIBUTING/#running-tests","title":"Running Tests","text":""},{"location":"getting-started/contributing/CONTRIBUTING/#pytest","title":"Pytest","text":"<p>To run tests with your current FastStream application and Python environment, use:</p> <pre><code>pytest tests\n# or\n./scripts/test.sh\n# with coverage output\n./scripts/test-cov.sh\n</code></pre> <p>In your project, you'll find some pytest marks:</p> <ul> <li>slow</li> <li>rabbit</li> <li>kafka</li> <li>nats</li> <li>all</li> </ul> <p>By default, running pytest will execute \"not slow\" tests.</p> <p>To run all tests use:</p> <pre><code>pytest -m 'all'\n</code></pre> <p>If you don't have a local broker instance running, you can run tests without those dependencies:</p> <pre><code>pytest -m 'not rabbit and not kafka and not nats'\n</code></pre> <p>To run tests based on RabbitMQ, Kafka, or other dependencies, the following dependencies are needed to be started as docker containers:</p> <pre><code>version: \"3\"\nservices:\n  # nosemgrep: yaml.docker-compose.security.writable-filesystem-service.writable-filesystem-service\n  rabbitmq:\n    image: rabbitmq:alpine\n    ports:\n      - \"5672:5672\"\n    # https://semgrep.dev/r?q=yaml.docker-compose.security.no-new-privileges.no-new-privileges\n    security_opt:\n      - no-new-privileges:true\n  # nosemgrep: yaml.docker-compose.security.writable-filesystem-service.writable-filesystem-service\n  kafka:\n    image: bitnami/kafka:3.5.0\n    ports:\n      - \"9092:9092\"\n    environment:\n      KAFKA_ENABLE_KRAFT: \"true\"\n      KAFKA_CFG_NODE_ID: \"1\"\n      KAFKA_CFG_PROCESS_ROLES: \"broker,controller\"\n      KAFKA_CFG_CONTROLLER_LISTENER_NAMES: \"CONTROLLER\"\n      KAFKA_CFG_LISTENERS: \"PLAINTEXT://:9092,CONTROLLER://:9093\"\n      KAFKA_CFG_LISTENER_SECURITY_PROTOCOL_MAP: \"CONTROLLER:PLAINTEXT,PLAINTEXT:PLAINTEXT\"\n      KAFKA_CFG_ADVERTISED_LISTENERS: \"PLAINTEXT://127.0.0.1:9092\"\n      KAFKA_BROKER_ID: \"1\"\n      KAFKA_CFG_CONTROLLER_QUORUM_VOTERS: \"1@kafka:9093\"\n      ALLOW_PLAINTEXT_LISTENER: \"true\"\n    # https://semgrep.dev/r?q=yaml.docker-compose.security.no-new-privileges.no-new-privileges\n    security_opt:\n      - no-new-privileges:true\n  # nosemgrep: yaml.docker-compose.security.writable-filesystem-service.writable-filesystem-service\n  nats:\n    image: nats\n    command: -js\n    ports:\n      - 4222:4222\n      - 8222:8222  # management\n    # https://semgrep.dev/r?q=yaml.docker-compose.security.no-new-privileges.no-new-privileges\n    security_opt:\n      - no-new-privileges:true\n</code></pre> <p>You can start the dependencies easily using provided script by running:</p> <pre><code>./scripts/start_test_env.sh\n</code></pre> <p>Once you are done with development and running tests, you can stop the dependencies' docker containers by running:</p> <pre><code>./scripts/stop_test_env.sh\n</code></pre>"},{"location":"getting-started/contributing/docs/","title":"Documentation","text":""},{"location":"getting-started/contributing/docs/#how-to-help","title":"How to help","text":"<p>You will be of invaluable help if you contribute to the documentation.</p> <p>Such a contribution can be:</p> <ul> <li>Indications of inaccuracies, errors, typos</li> <li>Suggestions for editing specific sections</li> <li>Making additions</li> </ul> <p>You can report all this in discussions on GitHub, start issue, or write about it in our discord group.</p> <p>Note</p> <p>Special thanks to those who are ready to offer help with the case and help in developing documentation, as well as translating it into other languages.</p>"},{"location":"getting-started/contributing/docs/#how-to-get-started","title":"How to get started","text":"<p>To develop the documentation, you don't even need to install the entire FastStream project as a whole.</p> <p>Enough:</p> <ol> <li>Clone the project repository</li> <li>Create a virtual environment     <pre><code>python -m venv venv\n</code></pre></li> <li>Activate it     <pre><code>source venv/bin/activate\n</code></pre></li> <li>Install documentation dependencies     <pre><code>pip install \".[devdocs]\"\n</code></pre></li> <li>Go to the <code>docs/</code> directory</li> <li>Start the local documentation server     <pre><code>mkdocs serve\n</code></pre></li> </ol> <p>Now all changes in the documentation files will be reflected on your local version of the site. After making all the changes, you can issue a <code>PR</code> with them - and we will gladly accept it!</p>"},{"location":"getting-started/dependencies/","title":"Dependencies","text":"<p>FastStream uses the secondary library FastDepends for dependency management. This dependency system is literally borrowed from FastAPI, so if you know how to work with that framework, you'll be comfortable with dependencies in FastStream.</p> <p>You can visit the FastDepends documentation for more details, but the key points and additions are covered here.</p>"},{"location":"getting-started/dependencies/#type-casting","title":"Type Casting","text":"<p>The key function in the dependency management and type conversion system in FastStream is the decorator <code>@apply_types</code> (also known as <code>@inject</code> in FastDepends).</p> <p>By default, it applies to all event handlers, unless you disabled the same option when creating the broker.</p> KafkaRabbitMQNATS <pre><code>from faststream.kafka import KafkaBroker\nbroker = KafkaBroker(..., apply_types=False)\n</code></pre> <pre><code>from faststream.rabbit import RabbitBroker\nbroker = RabbitBroker(..., apply_types=False)\n</code></pre> <pre><code>from faststream.nats import NatsBroker\nbroker = NatsBroker(..., apply_types=False)\n</code></pre> <p>Warning</p> <p>Setting the <code>apply_types=False</code> flag not only disables type casting but also <code>Depends</code> and <code>Context</code>.</p> <p>This flag can be useful if you are using FastStream within another framework and you need to use its native dependency system.</p>"},{"location":"getting-started/dependencies/#dependency-injection","title":"Dependency Injection","text":"<p>To implement dependencies in FastStream, a special class called Depends is used</p> KafkaRabbitMQNATS <pre><code>from faststream import FastStream, Depends\nfrom faststream.kafka import KafkaBroker\n\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\n\ndef simple_dependency():\n    return 1\n\n@broker.subscriber(\"test\")\nasync def handler(body: dict, d: int = Depends(simple_dependency)):\n    assert d == 1\n</code></pre> <pre><code>from faststream import FastStream, Depends\nfrom faststream.rabbit import RabbitBroker\n\nbroker = RabbitBroker(\"amqp://guest:guest@localhost:5672/\")\napp = FastStream(broker)\n\ndef simple_dependency():\n    return 1\n\n@broker.subscriber(\"test\")\nasync def handler(body: dict, d: int = Depends(simple_dependency)):\n    assert d == 1\n</code></pre> <pre><code>from faststream import FastStream, Depends\nfrom faststream.nats import NatsBroker\n\nbroker = NatsBroker(\"nats://localhost:4222\")\napp = FastStream(broker)\n\ndef simple_dependency():\n    return 1\n\n@broker.subscriber(\"test\")\nasync def handler(body: dict, d: int = Depends(simple_dependency)):\n    assert d == 1\n</code></pre> <p>The first step: You need to declare a dependency, which can be any <code>Callable</code> object.</p> Callable <p>A \"Callable\" is an object that can be \"called\". It can be a function, a class, or a class method.</p> <p>In other words, if you can write code like <code>my_object()</code> - <code>my_object</code> is <code>Callable</code></p> KafkaRabbitMQNATS <pre><code>async def handler(body: dict, d: int = Depends(simple_dependency)):\n    assert d == 1\n</code></pre> <pre><code>async def handler(body: dict, d: int = Depends(simple_dependency)):\n    assert d == 1\n</code></pre> <pre><code>async def handler(body: dict, d: int = Depends(simple_dependency)):\n    assert d == 1\n</code></pre> <p>Second step: Declare which dependencies you need using <code>Depends</code></p> KafkaRabbitMQNATS <pre><code>async def handler(body: dict, d: int = Depends(simple_dependency)):\n    assert d == 1\n</code></pre> <pre><code>async def handler(body: dict, d: int = Depends(simple_dependency)):\n    assert d == 1\n</code></pre> <pre><code>async def handler(body: dict, d: int = Depends(simple_dependency)):\n    assert d == 1\n</code></pre> <p>The last step: Just use the result of executing your dependency!</p> <p>It's easy, isn't it?</p> <p>Auto <code>@apply_types</code></p> <p>In the code above, we didn't use this decorator for our dependencies. However, it still applies to all functions used as dependencies. Please keep this in your mind.</p>"},{"location":"getting-started/dependencies/#top-level-dependencies","title":"Top-level Dependencies","text":"<p>If you don't need a dependency result, you can use the following code:</p> <pre><code>@broker.subscriber(\"test\")\ndef method(_ = Depends(...)): ...\n</code></pre> <p>But, using a special <code>subscriber</code> parameter is much more suitable:</p> <pre><code>@broker.subscriber(\"test\", dependencies=[Depends(...)])\ndef method(): ...\n</code></pre> <p>You can also declare broker-level dependencies, which will be applied to all broker's handlers:</p> <pre><code>broker = RabbitBroker(dependencies=[Depends(...)])\n</code></pre>"},{"location":"getting-started/dependencies/#nested-dependencies","title":"Nested Dependencies","text":"<p>Dependencies can also contain other dependencies. This works in a very predictable way: just declare <code>Depends</code> in the dependent function.</p> KafkaRabbitMQNATS <pre><code>from faststream import FastStream, Depends\nfrom faststream.kafka import KafkaBroker\n\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\n\ndef another_dependency():\n    return 1\n\ndef simple_dependency(b: int = Depends(another_dependency)): # (1)\n    return b * 2\n\n@broker.subscriber(\"test\")\nasync def handler(\n    body: dict,\n    a: int = Depends(another_dependency),\n    b: int = Depends(simple_dependency)):\n    assert (a + b) == 3\n</code></pre> <ol> <li>A nested dependency is called here</li> </ol> <pre><code>from faststream import FastStream, Depends\nfrom faststream.rabbit import RabbitBroker\n\nbroker = RabbitBroker(\"amqp://guest:guest@localhost:5672/\")\napp = FastStream(broker)\n\ndef another_dependency():\n    return 1\n\ndef simple_dependency(b: int = Depends(another_dependency)): # (1)\n    return b * 2\n\n@broker.subscriber(\"test\")\nasync def handler(\n    body: dict,\n    a: int = Depends(another_dependency),\n    b: int = Depends(simple_dependency)):\n    assert (a + b) == 3\n</code></pre> <ol> <li>A nested dependency is called here</li> </ol> <pre><code>from faststream import FastStream, Depends\nfrom faststream.nats import NatsBroker\n\nbroker = NatsBroker(\"nats://localhost:4222\")\napp = FastStream(broker)\n\ndef another_dependency():\n    return 1\n\ndef simple_dependency(b: int = Depends(another_dependency)): # (1)\n    return b * 2\n\n@broker.subscriber(\"test\")\nasync def handler(\n    body: dict,\n    a: int = Depends(another_dependency),\n    b: int = Depends(simple_dependency)):\n    assert (a + b) == 3\n</code></pre> <ol> <li>A nested dependency is called here</li> </ol> <p>Caching</p> <p>In the example above, the <code>another_dependency</code> function will be called at ONCE! FastDepends caches all dependency execution results within ONE <code>@apply_types</code> call stack. This means that all nested dependencies will receive the cached result of dependency execution. But, between different calls of the main function, these results will be different.</p> <p>To prevent this behavior, just use <code>Depends(..., cache=False)</code>. In this case, the dependency will be used for each function in the call stack where it is used.</p>"},{"location":"getting-started/dependencies/#use-with-regular-functions","title":"Use with Regular Functions","text":"<p>You can use the decorator <code>@apply_types</code> not only with <code>@broker.subscriber(...)</code>, but also with regular functions, both synchronous and asynchronous.</p> SyncAsync <pre><code>from faststream import Depends, apply_types\n\ndef simple_dependency(a: int, b: int = 3):\n    return a + b\n\n@apply_types\ndef method(a: int, d: int = Depends(simple_dependency)):\n    return a + d\n\nassert method(\"1\") == 5\n</code></pre> <pre><code>import asyncio\nfrom faststream import Depends, apply_types\n\nasync def simple_dependency(a: int, b: int = 3):\n    return a + b\n\ndef another_dependency(a: int):\n    return a\n\n@apply_types\nasync def method(\n    a: int,\n    b: int = Depends(simple_dependency),\n    c: int = Depends(another_dependency),\n):\n    return a + b + c\n\nassert asyncio.run(method(\"1\")) == 6\n</code></pre> <p>Be careful</p> <p>In asynchronous code, you can use both synchronous and asynchronous dependencies. But in synchronous code, only synchronous dependencies are available to you.</p>"},{"location":"getting-started/dependencies/#casting-dependency-types","title":"Casting Dependency Types","text":"<p>FastDepends, used by FastStream, also gives the type <code>return</code>. This means that the value returned by the dependency will be be cast to the type twice: as <code>return</code> for dependencies and as the input argument of the main function. This does not incur additional costs if these types have the same annotation. Just keep it in mind. Or not... Anyway, I've warned you.</p> <pre><code>from faststream import Depends, apply_types\n\ndef simple_dependency(a: int, b: int = 3) -&gt; str:\n    return a + b  # 'return' is cast to `str` for the first time\n\n@inject\ndef method(a: int, d: int = Depends(simple_dependency)):\n    # 'd' is cast to `int` for the second time\n    return a + d\n\nassert method(\"1\") == 5\n</code></pre> <p>Also, the result of executing the dependency is cached. If you use this dependency in <code>N</code> functions, this cached result will be converted to type <code>N</code> times (at the input to the function being used).</p> <p>To avoid problems with this, use mypy or just be careful with the annotation of types in your project.</p>"},{"location":"getting-started/dependencies/global/","title":"Global","text":"<ul> <li>Broker-level dependencies</li> <li>Subscriber-level dependencies</li> </ul>"},{"location":"getting-started/dependencies/testing/","title":"Testing","text":"<p>https://lancetnik.github.io/FastDepends/tutorial/overrides/</p>"},{"location":"getting-started/integrations/fastapi/","title":"FastAPI Plugin","text":""},{"location":"getting-started/integrations/fastapi/#handling-messages","title":"Handling messages","text":"<p>FastStream can be used as a part of FastAPI.</p> <p>Just import a StreamRouter you need and declare the message handler in the same way as with a regular FastStream application.</p> <p>Tip</p> <p>When used in this way, FastStream does not use its own dependency system but integrates into FastAPI. That is, you can use <code>Depends</code>, <code>BackgroundTasks</code> and other original FastAPI features as if it were a regular HTTP endpoint, but you can't use <code>faststream.Context</code> and <code>faststream.Depends</code>.</p> <p>Note that the code below uses <code>fastapi.Depends</code>, not <code>faststream.Depends</code>.</p> KafkaRabbitMQNATS <pre><code>from fastapi import Depends, FastAPI\nfrom pydantic import BaseModel\n\nfrom faststream.kafka.fastapi import KafkaRouter\n\nrouter = KafkaRouter(\"localhost:9092\")\n\n\nclass Incoming(BaseModel):\n    m: dict\n\n\ndef call():\n    return True\n\n\n@router.subscriber(\"test\")\n@router.publisher(\"response\")\nasync def hello(m: Incoming, d=Depends(call)):\n    return {\"response\": \"Hello, Kafka!\"}\n\n\n@router.get(\"/\")\nasync def hello_http():\n    return \"Hello, HTTP!\"\n\n\napp = FastAPI(lifespan=router.lifespan_context)\napp.include_router(router)\n</code></pre> <pre><code>from fastapi import Depends, FastAPI\nfrom pydantic import BaseModel\n\nfrom faststream.rabbit.fastapi import RabbitRouter\n\nrouter = RabbitRouter(\"amqp://guest:guest@localhost:5672/\")\n\n\nclass Incoming(BaseModel):\n    m: dict\n\n\ndef call():\n    return True\n\n\n@router.subscriber(\"test\")\n@router.publisher(\"response\")\nasync def hello(m: Incoming, d=Depends(call)):\n    return {\"response\": \"Hello, Rabbit!\"}\n\n\n@router.get(\"/\")\nasync def hello_http():\n    return \"Hello, HTTP!\"\n\n\napp = FastAPI(lifespan=router.lifespan_context)\napp.include_router(router)\n</code></pre> <pre><code>from fastapi import Depends, FastAPI\nfrom pydantic import BaseModel\n\nfrom faststream.nats.fastapi import NatsRouter\n\nrouter = NatsRouter(\"nats://localhost:4222\")\n\n\nclass Incoming(BaseModel):\n    m: dict\n\n\ndef call():\n    return True\n\n\n@router.subscriber(\"test\")\n@router.publisher(\"response\")\nasync def hello(m: Incoming, d=Depends(call)):\n    return {\"response\": \"Hello, NATS!\"}\n\n\n@router.get(\"/\")\nasync def hello_http():\n    return \"Hello, HTTP!\"\n\n\napp = FastAPI(lifespan=router.lifespan_context)\napp.include_router(router)\n</code></pre> <p>When processing a message from a broker, the entire message body is placed simultaneously in both the <code>body</code> and <code>path</code> request parameters. You can access them in any way convenient for you. The message header is placed in <code>headers</code>.</p> <p>Also, this router can be fully used as an <code>HttpRouter</code> (of which it is the inheritor). So, you can use it to declare any <code>get</code>, <code>post</code>, <code>put</code> and other HTTP methods. For example, this is done at line 19.</p> <p>Warning</p> <p>If your ASGI server does not support installing state inside lifespan, you can disable this behavior as follows:</p> <pre><code>router = StreamRouter(..., setup_state=False)\n</code></pre> <p>However, after that, you will not be able to access the broker from your application's state (but it is still available as the <code>router.broker</code>).</p>"},{"location":"getting-started/integrations/fastapi/#accessing-the-broker-object","title":"Accessing the Broker Object","text":"<p>Inside each router, there is a broker. You can easily access it if you need to send a message to MQ:</p> KafkaRabbitMQNATS <pre><code>from fastapi import FastAPI\n\nfrom faststream.kafka.fastapi import KafkaRouter\n\nrouter = KafkaRouter(\"localhost:9092\")\n\napp = FastAPI(lifespan=router.lifespan_context)\n\n\n@router.get(\"/\")\nasync def hello_http():\n    await router.broker.publish(\"Hello, Kafka!\", \"test\")\n    return \"Hello, HTTP!\"\n\n\napp.include_router(router)\n</code></pre> <pre><code>from fastapi import FastAPI\n\nfrom faststream.rabbit.fastapi import RabbitRouter\n\nrouter = RabbitRouter(\"amqp://guest:guest@localhost:5672/\")\n\napp = FastAPI(lifespan=router.lifespan_context)\n\n\n@router.get(\"/\")\nasync def hello_http():\n    await router.broker.publish(\"Hello, Rabbit!\", \"test\")\n    return \"Hello, HTTP!\"\n\n\napp.include_router(router)\n</code></pre> <pre><code>from fastapi import FastAPI\n\nfrom faststream.nats.fastapi import NatsRouter\n\nrouter = NatsRouter(\"nats://localhost:4222\")\n\napp = FastAPI(lifespan=router.lifespan_context)\n\n\n@router.get(\"/\")\nasync def hello_http():\n    await router.broker.publish(\"Hello, NATS!\", \"test\")\n    return \"Hello, HTTP!\"\n\n\napp.include_router(router)\n</code></pre> <p>Also, you can use the following <code>Depends</code> to access the broker if you want to use it at different parts of your program:</p> KafkaRabbitMQNATS <pre><code>from fastapi import Depends, FastAPI\nfrom typing_extensions import Annotated\n\nfrom faststream.kafka import KafkaBroker, fastapi\n\nrouter = fastapi.KafkaRouter(\"localhost:9092\")\n\napp = FastAPI(lifespan=router.lifespan_context)\n\n\ndef broker():\n    return router.broker\n\n\n@router.get(\"/\")\nasync def hello_http(broker: Annotated[KafkaBroker, Depends(broker)]):\n    await broker.publish(\"Hello, Kafka!\", \"test\")\n    return \"Hello, HTTP!\"\n\n\napp.include_router(router)\n</code></pre> <pre><code>from fastapi import Depends, FastAPI\nfrom typing_extensions import Annotated\n\nfrom faststream.rabbit import RabbitBroker, fastapi\n\nrouter = fastapi.RabbitRouter(\"amqp://guest:guest@localhost:5672/\")\n\napp = FastAPI(lifespan=router.lifespan_context)\n\n\ndef broker():\n    return router.broker\n\n\n@router.get(\"/\")\nasync def hello_http(broker: Annotated[RabbitBroker, Depends(broker)]):\n    await broker.publish(\"Hello, Rabbit!\", \"test\")\n    return \"Hello, HTTP!\"\n\n\napp.include_router(router)\n</code></pre> <pre><code>from fastapi import Depends, FastAPI\nfrom typing_extensions import Annotated\n\nfrom faststream.nats import NatsBroker, fastapi\n\nrouter = fastapi.NatsRouter(\"nats://localhost:4222\")\n\napp = FastAPI(lifespan=router.lifespan_context)\n\n\ndef broker():\n    return router.broker\n\n\n@router.get(\"/\")\nasync def hello_http(broker: Annotated[NatsBroker, Depends(broker)]):\n    await broker.publish(\"Hello, NATS!\", \"test\")\n    return \"Hello, HTTP!\"\n\n\napp.include_router(router)\n</code></pre> <p>Or you can access the broker from a FastAPI application state (if you don't disable it with <code>setup_state=False</code>):</p> <pre><code>from fastapi import Request\n\n@app.get(\"/\")\ndef main(request: Request):\n    broker = request.state.broker\n</code></pre>"},{"location":"getting-started/integrations/fastapi/#after_startup","title":"<code>@after_startup</code>","text":"<p>The <code>FastStream</code> application has the <code>@after_startup</code> hook, which allows you to perform operations with your message broker after the connection is established. This can be extremely convenient for managing your brokers' objects and/or sending messages. This hook is also available for your FastAPI StreamRouter</p> KafkaRabbitMQNATS <pre><code>from fastapi import FastAPI\n\nfrom faststream.kafka.fastapi import KafkaRouter\n\nrouter = KafkaRouter(\"localhost:9092\")\n\n\n@router.subscriber(\"test\")\nasync def hello(msg: str):\n    return {\"response\": \"Hello, Kafka!\"}\n\n\n@router.after_startup\nasync def test(app: FastAPI):\n    await router.broker.publish(\"Hello!\", \"test\")\n\n\napp = FastAPI(lifespan=router.lifespan_context)\napp.include_router(router)\n</code></pre> <pre><code>from fastapi import FastAPI\n\nfrom faststream.rabbit.fastapi import RabbitRouter\n\nrouter = RabbitRouter(\"amqp://guest:guest@localhost:5672/\")\n\n\n@router.subscriber(\"test\")\nasync def hello(msg: str):\n    return {\"response\": \"Hello, Rabbit!\"}\n\n\n@router.after_startup\nasync def test(app: FastAPI):\n    await router.broker.publish(\"Hello!\", \"test\")\n\n\napp = FastAPI(lifespan=router.lifespan_context)\napp.include_router(router)\n</code></pre> <pre><code>from fastapi import FastAPI\n\nfrom faststream.nats.fastapi import NatsRouter\n\nrouter = NatsRouter(\"nats://localhost:4222\")\n\n\n@router.subscriber(\"test\")\nasync def hello(msg: str):\n    return {\"response\": \"Hello, NATS!\"}\n\n\n@router.after_startup\nasync def test(app: FastAPI):\n    await router.broker.publish(\"Hello!\", \"test\")\n\n\napp = FastAPI(lifespan=router.lifespan_context)\napp.include_router(router)\n</code></pre>"},{"location":"getting-started/integrations/fastapi/#documentation","title":"Documentation","text":"<p>When using FastStream as a router for FastAPI, the framework automatically registers endpoints for hosting AsyncAPI documentation into your application with the following default values:</p> KafkaRabbitMQNATS <pre><code>from faststream.kafka.fastapi import KafkaRouter\n\nrouter = KafkaRouter(\n    ...,\n    schema_url=\"/asyncapi\",\n    include_in_schema=True,\n)\n</code></pre> <pre><code>from faststream.rabbit.fastapi import RabbitRouter\n\nrouter = RabbitRouter(\n    ...,\n    schema_url=\"/asyncapi\",\n    include_in_schema=True,\n)\n</code></pre> <pre><code>from faststream.nats.fastapi import NatsRouter\n\nrouter = NatsRouter(\n    ...,\n    schema_url=\"/asyncapi\",\n    include_in_schema=True,\n)\n</code></pre> <p>This way, you will have three routes to interact with your application's AsyncAPI schema:</p> <ul> <li><code>/asyncapi</code> - the same as the CLI created page</li> <li><code>/asyncapi.json</code> - download the JSON schema representation</li> <li><code>/asyncapi.yaml</code> - download the YAML schema representation</li> </ul>"},{"location":"getting-started/integrations/fastapi/#testing","title":"Testing","text":"<p>To test your FastAPI StreamRouter, you can still use it with the TestClient:</p> KafkaRabbitMQNATS <pre><code>import pytest\n\nfrom faststream.kafka import TestKafkaBroker, fastapi\n\nrouter = fastapi.KafkaRouter()\n\n\n@router.subscriber(\"test\")\nasync def handler(msg: str):\n    ...\n\n\n@pytest.mark.asyncio\nasync def test_router():\n    async with TestKafkaBroker(router.broker) as br:\n        await br.publish(\"Hi!\", \"test\")\n\n        handler.mock.assert_called_once_with(\"Hi!\")\n</code></pre> <pre><code>import pytest\n\nfrom faststream.rabbit import TestRabbitBroker, fastapi\n\nrouter = fastapi.RabbitRouter()\n\n\n@router.subscriber(\"test\")\nasync def handler(msg: str):\n    ...\n\n\n@pytest.mark.asyncio\nasync def test_router():\n    async with TestRabbitBroker(router.broker) as br:\n        await br.publish(\"Hi!\", \"test\")\n\n        handler.mock.assert_called_once_with(\"Hi!\")\n</code></pre> <pre><code>import pytest\n\nfrom faststream.nats import TestNatsBroker, fastapi\n\nrouter = fastapi.NatsRouter()\n\n\n@router.subscriber(\"test\")\nasync def handler(msg: str):\n    ...\n\n\n@pytest.mark.asyncio\nasync def test_router():\n    async with TestNatsBroker(router.broker) as br:\n        await br.publish(\"Hi!\", \"test\")\n\n        handler.mock.assert_called_once_with(\"Hi!\")\n</code></pre>"},{"location":"getting-started/integrations/frameworks/","title":"INTEGRATIONS","text":"<p>FastStream brokers are very easy to integrate with any of your applications: it is enough to initialize the broker at startup and close it correctly at the end of your application.</p> <p>Most HTTP frameworks have built-in lifecycle hooks for this.</p> FastAPILitestartAiohttpBlacksheepFalconQuartSanic <p>Tip</p> <p>If you want to use FastStream in conjunction with FastAPI, perhaps you should use a special plugin</p> <pre><code>from contextlib import asynccontextmanager\n\nfrom fastapi import FastAPI\n\nfrom faststream.kafka import KafkaBroker\n\nbroker = KafkaBroker(\"localhost:9092\")\n\napp = FastAPI()\n\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    await broker.start()\n    yield\n    await broker.close()\n\n\n@broker.subscriber(\"test\")\nasync def base_handler(body):\n    print(body)\n\n\n@app.get(\"/\")\ndef read_root():\n    return {\"Hello\": \"World\"}\n</code></pre> <pre><code>from litestar import Litestar, get\nfrom faststream.rabbit import RabbitBroker\n\nbroker = RabbitBroker(\"amqp://guest:guest@localhost:5672/\")\n\n@broker.subscriber(\"queue\")\nasync def handle(msg):\n    print(msg)\n\n@get(\"/\")\nasync def index() -&gt; str:\n    return \"Hello, world!\"\n\napp = Litestar(\n    [index],\n    on_startup=(broker.start,),\n    on_shutdown=(broker.close,),\n)\n</code></pre> <pre><code>from aiohttp import web\n\nfrom faststream.kafka import KafkaBroker\n\nbroker = KafkaBroker(\"localhost:9092\")\n\n\n@broker.subscriber(\"test\")\nasync def base_handler(body):\n    print(body)\n\n\nasync def start_broker(app):\n    await broker.start()\n\n\nasync def stop_broker(app):\n    await broker.close()\n\n\nasync def hello(request):\n    return web.Response(text=\"Hello, world\")\n\n\napp = web.Application()\napp.add_routes([web.get(\"/\", hello)])\napp.on_startup.append(start_broker)\napp.on_cleanup.append(stop_broker)\n\n\nif __name__ == \"__main__\":\n    web.run_app(app)\n</code></pre> <pre><code>from blacksheep import Application\n\nfrom faststream.kafka import KafkaBroker\n\nbroker = KafkaBroker(\"localhost:9092\")\n\napp = Application()\n\n\n@broker.subscriber(\"test\")\nasync def base_handler(body):\n    print(body)\n\n\n@app.on_start\nasync def start_broker(application: Application) -&gt; None:\n    await broker.start()\n\n\n@app.on_stop\nasync def stop_broker(application: Application) -&gt; None:\n    await broker.close()\n\n\n@app.route(\"/\")\nasync def home():\n    return \"Hello, World!\"\n</code></pre> <pre><code>import falcon\nimport falcon.asgi\n\nfrom faststream.kafka import KafkaBroker\n\nbroker = KafkaBroker(\"localhost:9092\")\n\n\n@broker.subscriber(\"test\")\nasync def base_handler(body):\n    print(body)\n\n\nclass ThingsResource:\n    async def on_get(self, req, resp):\n        resp.status = falcon.HTTP_200\n        resp.content_type = falcon.MEDIA_TEXT\n        resp.text = (\n            \"\\nTwo things awe me most, the starry sky \"\n            \"above me and the moral law within me.\\n\"\n            \"\\n\"\n            \"    ~ Immanuel Kant\\n\\n\"\n        )\n\n\nclass PropanMiddleware:\n    async def process_startup(self, scope, event):\n        await broker.start()\n\n    async def process_shutdown(self, scope, event):\n        await broker.close()\n\n\napp = falcon.asgi.App()\napp.add_middleware(PropanMiddleware())\napp.add_route(\"/things\", ThingsResource())\n</code></pre> <pre><code>from quart import Quart\n\nfrom faststream.kafka import KafkaBroker\n\nbroker = KafkaBroker(\"localhost:9092\")\n\napp = Quart(__name__)\n\n\n@broker.subscriber(\"test\")\nasync def base_handler(body):\n    print(body)\n\n\n@app.before_serving\nasync def start_broker():\n    await broker.start()\n\n\n@app.after_serving\nasync def stop_broker():\n    await broker.close()\n\n\n@app.route(\"/\")\nasync def json():\n    return {\"hello\": \"world\"}\n</code></pre> <pre><code>from sanic import Sanic\nfrom sanic.response import text\n\nfrom faststream.kafka import KafkaBroker\n\nbroker = KafkaBroker(\"localhost:9092\")\n\napp = Sanic(\"MyHelloWorldApp\")\n\n\n@broker.subscriber(\"test\")\nasync def base_handler(body):\n    print(body)\n\n\n@app.after_server_start\nasync def start_broker(app, loop):\n    await broker.start()\n\n\n@app.after_server_stop\nasync def stop_broker(app, loop):\n    await broker.close()\n\n\n@app.get(\"/\")\nasync def hello_world(request):\n    return text(\"Hello, world.\")\n</code></pre> <p>However, even if such a hook is not provided, you can do it yourself.</p> Tornado <pre><code>import asyncio\n\nimport tornado.web\n\nfrom faststream.kafka import KafkaBroker\n\nbroker = KafkaBroker(\"localhost:9092\")\n\n\n@broker.subscriber(\"test\")\nasync def base_handler(body):\n    print(body)\n\n\nclass MainHandler(tornado.web.RequestHandler):\n    def get(self):\n        self.write(\"Hello, world\")\n\n\ndef make_app():\n    return tornado.web.Application(\n        [\n            (r\"/\", MainHandler),\n        ]\n    )\n\n\nasync def main():\n    app = make_app()\n    app.listen(8888)\n\n    await broker.start()\n    try:\n        await asyncio.Event().wait()\n    finally:\n        await broker.close()\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"getting-started/lifespan/","title":"Lifespan Events","text":"<p>Sometimes you need to define the logic that should be executed before launching the application. This means that the code will be executed once - even before your application starts receiving messages.</p> <p>Also, you may need to terminate some processes after stopping the application. In this case, your code will also be executed exactly once: but after the completion of the main application.</p> <p>Since this code is executed before the application starts and after it stops, it covers the entire lifecycle (lifespan) of the application.</p> <p>This can be very useful for initializing your application settings at startup, raising a pool of connections to a database, or running machine learning models.</p>"},{"location":"getting-started/lifespan/hooks/","title":"Lifespan Hooks","text":""},{"location":"getting-started/lifespan/hooks/#usage-example","title":"Usage example","text":"<p>Let's imagine that your application uses pydantic as your settings manager.</p> <p>I highly recommend using pydantic for these purposes, because this dependency is already used at FastStream and you don't have to install an additional package</p> <p>Also, let's imagine that you have several <code>.env</code>, <code>.env.development</code>, <code>.env.test</code>, <code>.env.production</code> files with your application settings, and you want to switch them at startup without any code changes.</p> <p>By passing optional arguments with the command line to your code FastStream allows you to do this easily.</p>"},{"location":"getting-started/lifespan/hooks/#lifespan","title":"Lifespan","text":"<p>Let's write some code for our example</p> KafkaRabbitMQNATS <pre><code>from pydantic_settings import BaseSettings\n\nfrom faststream import ContextRepo, FastStream\nfrom faststream.kafka import KafkaBroker\n\nbroker = KafkaBroker()\napp = FastStream(broker)\n\n\nclass Settings(BaseSettings):\n    host: str = \"localhost:9092\"\n\n\n@app.on_startup\nasync def setup(context: ContextRepo, env: str = \".env\"):\n    settings = Settings(_env_file=env)\n    context.set_global(\"settings\", settings)\n    await broker.connect(settings.host)\n</code></pre> <pre><code>from pydantic_settings import BaseSettings\n\nfrom faststream import ContextRepo, FastStream\nfrom faststream.rabbit import RabbitBroker\n\nbroker = RabbitBroker()\napp = FastStream(broker)\n\n\nclass Settings(BaseSettings):\n    host: str = \"amqp://guest:guest@localhost:5672/\" # pragma: allowlist secret\n\n\n@app.on_startup\nasync def setup(context: ContextRepo, env: str = \".env\"):\n    settings = Settings(_env_file=env)\n    context.set_global(\"settings\", settings)\n    await broker.connect(settings.host)\n</code></pre> <pre><code>from pydantic_settings import BaseSettings\n\nfrom faststream import ContextRepo, FastStream\nfrom faststream.nats import NatsBroker\n\nbroker = NatsBroker()\napp = FastStream(broker)\n\n\nclass Settings(BaseSettings):\n    host: str = \"nats://localhost:4222\"\n\n\n@app.on_startup\nasync def setup(context: ContextRepo, env: str = \".env\"):\n    settings = Settings(_env_file=env)\n    context.set_global(\"settings\", settings)\n    await broker.connect(settings.host)\n</code></pre> <p>Now this application can be run using the following command to manage the environment:</p> <pre><code>faststream run serve:app --env .env.test\n</code></pre>"},{"location":"getting-started/lifespan/hooks/#details","title":"Details","text":"<p>Now let's look into a little more detail</p> <p>To begin with, we used a decorator</p> KafkaRabbitMQNATS <pre><code>@app.on_startup\nasync def setup(context: ContextRepo, env: str = \".env\"):\n    settings = Settings(_env_file=env)\n    context.set_global(\"settings\", settings)\n    await broker.connect(settings.host)\n</code></pre> <pre><code>@app.on_startup\nasync def setup(context: ContextRepo, env: str = \".env\"):\n    settings = Settings(_env_file=env)\n    context.set_global(\"settings\", settings)\n    await broker.connect(settings.host)\n</code></pre> <pre><code>@app.on_startup\nasync def setup(context: ContextRepo, env: str = \".env\"):\n    settings = Settings(_env_file=env)\n    context.set_global(\"settings\", settings)\n    await broker.connect(settings.host)\n</code></pre> <p>to declare a function that should run when our application starts</p> <p>The next step is to declare the arguments that our function will receive</p> KafkaRabbitMQNATS <pre><code>@app.on_startup\nasync def setup(context: ContextRepo, env: str = \".env\"):\n    settings = Settings(_env_file=env)\n    context.set_global(\"settings\", settings)\n    await broker.connect(settings.host)\n</code></pre> <pre><code>@app.on_startup\nasync def setup(context: ContextRepo, env: str = \".env\"):\n    settings = Settings(_env_file=env)\n    context.set_global(\"settings\", settings)\n    await broker.connect(settings.host)\n</code></pre> <pre><code>@app.on_startup\nasync def setup(context: ContextRepo, env: str = \".env\"):\n    settings = Settings(_env_file=env)\n    context.set_global(\"settings\", settings)\n    await broker.connect(settings.host)\n</code></pre> <p>In this case, the <code>env</code> field will be passed to the <code>setup</code> function from the arguments with the command line</p> <p>Tip</p> <p>The default lifecycle functions are used with the decorator <code>@apply_types</code>, therefore, all context fields and dependencies are available in them</p> <p>Then, we initialized the settings of our application using the file passed to us from the command line</p> KafkaRabbitMQNATS <pre><code>@app.on_startup\nasync def setup(context: ContextRepo, env: str = \".env\"):\n    settings = Settings(_env_file=env)\n    context.set_global(\"settings\", settings)\n    await broker.connect(settings.host)\n</code></pre> <pre><code>@app.on_startup\nasync def setup(context: ContextRepo, env: str = \".env\"):\n    settings = Settings(_env_file=env)\n    context.set_global(\"settings\", settings)\n    await broker.connect(settings.host)\n</code></pre> <pre><code>@app.on_startup\nasync def setup(context: ContextRepo, env: str = \".env\"):\n    settings = Settings(_env_file=env)\n    context.set_global(\"settings\", settings)\n    await broker.connect(settings.host)\n</code></pre> <p>And put these settings in a global context</p> KafkaRabbitMQNATS <pre><code>@app.on_startup\nasync def setup(context: ContextRepo, env: str = \".env\"):\n    settings = Settings(_env_file=env)\n    context.set_global(\"settings\", settings)\n    await broker.connect(settings.host)\n</code></pre> <pre><code>@app.on_startup\nasync def setup(context: ContextRepo, env: str = \".env\"):\n    settings = Settings(_env_file=env)\n    context.set_global(\"settings\", settings)\n    await broker.connect(settings.host)\n</code></pre> <pre><code>@app.on_startup\nasync def setup(context: ContextRepo, env: str = \".env\"):\n    settings = Settings(_env_file=env)\n    context.set_global(\"settings\", settings)\n    await broker.connect(settings.host)\n</code></pre> Note <p>Now we can access our settings anywhere in the application right from the context</p> <pre><code>from faststream import Context, apply_types\n@apply_types\nasync def func(settings = Context()): ...\n</code></pre> <p>The last step we initialized our broker: now, when the application starts, it will be ready to receive messages</p> KafkaRabbitMQNATS <pre><code>@app.on_startup\nasync def setup(context: ContextRepo, env: str = \".env\"):\n    settings = Settings(_env_file=env)\n    context.set_global(\"settings\", settings)\n    await broker.connect(settings.host)\n</code></pre> <pre><code>@app.on_startup\nasync def setup(context: ContextRepo, env: str = \".env\"):\n    settings = Settings(_env_file=env)\n    context.set_global(\"settings\", settings)\n    await broker.connect(settings.host)\n</code></pre> <pre><code>@app.on_startup\nasync def setup(context: ContextRepo, env: str = \".env\"):\n    settings = Settings(_env_file=env)\n    context.set_global(\"settings\", settings)\n    await broker.connect(settings.host)\n</code></pre>"},{"location":"getting-started/lifespan/hooks/#another-example","title":"Another example","text":"<p>Now let's imagine that we have a machine learning model that needs to process messages from some broker.</p> <p>Initialization of such models usually takes a long time. It would be wise to do this at the start of the application, and not when processing each message.</p> <p>You can initialize your model somewhere at the top of your module/file. However, in this case, this code will be run even just in case of importing this module, for example, during testing. It is unlikely that you want to run your model on every test run...</p> <p>Therefore, it is worth initializing the model in the <code>@app.on_startup</code> hook.</p> <p>Also, we don't want the model to finish its work incorrectly when the application is stopped. To avoid this, we need the hook <code>@app.on_shutdown</code></p> KafkaRabbitMQNATS <pre><code>from faststream import Context, ContextRepo, FastStream\nfrom faststream.kafka import KafkaBroker\n\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\n\nml_models = {}  # fake ML model\n\n\ndef fake_answer_to_everything_ml_model(x: float):\n    return x * 42\n\n\n@app.on_startup\nasync def setup_model(context: ContextRepo):\n    # Load the ML model\n    ml_models[\"answer_to_everything\"] = fake_answer_to_everything_ml_model\n    context.set_global(\"model\", ml_models)\n\n\n@app.on_shutdown\nasync def shutdown_model(model: dict = Context()):\n    # Clean up the ML models and release the resources\n    model.clear()\n\n\n@broker.subscriber(\"test\")\nasync def predict(x: float, model=Context()):\n    result = model[\"answer_to_everything\"](x)\n    return {\"result\": result}\n</code></pre> <pre><code>from faststream import Context, ContextRepo, FastStream\nfrom faststream.rabbit import RabbitBroker\n\nbroker = RabbitBroker(\"amqp://guest:guest@localhost:5672/\")\napp = FastStream(broker)\n\nml_models = {}  # fake ML model\n\n\ndef fake_answer_to_everything_ml_model(x: float):\n    return x * 42\n\n\n@app.on_startup\nasync def setup_model(context: ContextRepo):\n    # Load the ML model\n    ml_models[\"answer_to_everything\"] = fake_answer_to_everything_ml_model\n    context.set_global(\"model\", ml_models)\n\n\n@app.on_shutdown\nasync def shutdown_model(model: dict = Context()):\n    # Clean up the ML models and release the resources\n    model.clear()\n\n\n@broker.subscriber(\"test\")\nasync def predict(x: float, model=Context()):\n    result = model[\"answer_to_everything\"](x)\n    return {\"result\": result}\n</code></pre> <pre><code>from faststream import Context, ContextRepo, FastStream\nfrom faststream.nats import NatsBroker\n\nbroker = NatsBroker(\"nats://localhost:4222\")\napp = FastStream(broker)\n\nml_models = {}  # fake ML model\n\n\ndef fake_answer_to_everything_ml_model(x: float):\n    return x * 42\n\n\n@app.on_startup\nasync def setup_model(context: ContextRepo):\n    # Load the ML model\n    ml_models[\"answer_to_everything\"] = fake_answer_to_everything_ml_model\n    context.set_global(\"model\", ml_models)\n\n\n@app.on_shutdown\nasync def shutdown_model(model: dict = Context()):\n    # Clean up the ML models and release the resources\n    model.clear()\n\n\n@broker.subscriber(\"test\")\nasync def predict(x: float, model=Context()):\n    result = model[\"answer_to_everything\"](x)\n    return {\"result\": result}\n</code></pre>"},{"location":"getting-started/lifespan/hooks/#multiple-hooks","title":"Multiple hooks","text":"<p>If you want to declare multiple lifecycle hooks, they will be used in the order they are registered:</p> <pre><code>from faststream import Context, ContextRepo, FastStream\n\napp = FastStream()\n\n\n@app.on_startup\nasync def setup(context: ContextRepo):\n    context.set_global(\"field\", 1)\n\n\n@app.on_startup\nasync def setup_later(field: int = Context()):\n    assert field == 1\n</code></pre>"},{"location":"getting-started/lifespan/hooks/#some-more-details","title":"Some more details","text":""},{"location":"getting-started/lifespan/hooks/#async-or-not-async","title":"Async or not async","text":"<p>In the asynchronous version of the application, both asynchronous and synchronous methods can be used as hooks. In the synchronous version, only synchronous methods are available.</p>"},{"location":"getting-started/lifespan/hooks/#command-line-arguments","title":"Command line arguments","text":"<p>Command line arguments are available in all <code>@app.on_startup</code> hooks. To use them in other parts of the application, put them in the <code>ContextRepo</code>.</p>"},{"location":"getting-started/lifespan/hooks/#broker-initialization","title":"Broker initialization","text":"<p>The <code>@app.on_startup</code> hooks are called BEFORE the broker is launched by the application. The <code>@app.after_shutdown</code> hooks are triggered AFTER stopping the broker.</p> <p>If you want to perform some actions AFTER initializing the broker: send messages, initialize objects, etc., you should use the <code>@app.after_startup</code> hook.</p>"},{"location":"getting-started/lifespan/test/","title":"Events Testing","text":"<p>In the most cases you are testing your subsriber/publisher functions, but sometimes you need to trigger some lifespan hooks in your tests too.</p> <p>For this reason, FastStream has a special TestApp patcher working as a regular async context manager.</p> KafkaRabbitMQNATS <pre><code>import pytest\n\nfrom faststream import FastStream, TestApp\nfrom faststream.kafka import KafkaBroker, TestKafkaBroker\n\napp = FastStream(KafkaBroker())\n\n\n@app.after_startup\nasync def handle():\n    print(\"Calls in tests too!\")\n\n\n@pytest.mark.asyncio\nasync def test_lifespan():\n    async with TestKafkaBroker(app.broker, connect_only=True):\n        async with TestApp(app):\n            # test something\n            pass\n</code></pre> <pre><code>import pytest\n\nfrom faststream import FastStream, TestApp\nfrom faststream.rabbit import RabbitBroker, TestRabbitBroker\n\napp = FastStream(RabbitBroker())\n\n\n@app.after_startup\nasync def handle():\n    print(\"Calls in tests too!\")\n\n\n@pytest.mark.asyncio\nasync def test_lifespan():\n    async with TestRabbitBroker(app.broker, connect_only=True):\n        async with TestApp(app):\n            # test something\n            pass\n</code></pre> <pre><code>import pytest\n\nfrom faststream import FastStream, TestApp\nfrom faststream.nats import NatsBroker, TestNatsBroker\n\napp = FastStream(NatsBroker())\n\n\n@app.after_startup\nasync def handle():\n    print(\"Calls in tests too!\")\n\n\n@pytest.mark.asyncio\nasync def test_lifespan():\n    async with TestNatsBroker(app.broker, connect_only=True):\n        async with TestApp(app):\n            # test something\n            pass\n</code></pre> <p>Tip</p> <p>If you are using a connected broker inside withing your lifespan hooks, it's advisable to patch the broker first (before applying the application patch).</p> <p>Also, because <code>FastStream</code> calls <code>broker.start()</code> inside, you need to prevent <code>TestClient</code> broker starting to respect the original lifespan hooks ordering by <code>connect_only=True</code> option. Without this one, all <code>FastStream</code> hooks will be called after broker was started, what can breaks some <code>@app.on_startup</code> logic.</p>"},{"location":"getting-started/middlewares/","title":"Middlewares","text":"<p>Middlewares are a powerful mechanism that allows you to add additional logic to any stage of the message processing pipeline.</p> <p>This way, you can greatly extend your FastStream application with features such as:</p> <ul> <li>Integration with any logging/metrics systems</li> <li>Application-level message serialization logic</li> <li>Rich publishing of messages with extra information</li> <li>And many other capabilities</li> </ul> <p>Middlewares have several methods to override. You can implement some or all of them and use middlewares at the broker, router, or subscriber level. Thus, middlewares are the most flexible  FastStream feature.</p>"},{"location":"getting-started/middlewares/#message-receive-wrapper","title":"Message Receive Wrapper","text":"<p>Unfortunately, this powerful feature has a somewhat complex signature too.</p> <p>Using middlewares, you can wrap the entire message processing pipeline. In this case, you need to specify <code>on_receive</code> and <code>after_processed</code> methods:</p> <pre><code>from faststream import BaseMiddleware\n\nclass MyMiddleware(BaseMiddleware):\n    async def on_receive(self):\n        print(f\"Received: {self.message}\")\n        return await super().on_receive()\n\n    async def after_processed(self, exc_type, exc_val, exec_tb):\n        return await super().after_processed(exc_type, exc_val, exec_tb)\n</code></pre> <p>These methods should be overwritten only in a broker-level middlewares.</p> <pre><code>Broker(middlewares=[MyMiddleware])\n</code></pre> <p>In other cases, <code>on_receive</code> will be called at every subscriber filter function call.</p> <p>Tip</p> <p>Please always call <code>super()</code> methods at the end of your function; this is important for correct error processing.</p>"},{"location":"getting-started/middlewares/#message-consuming-wrapper","title":"Message Consuming Wrapper","text":"<p>Also, using middlewares, you are able to wrap consumer function calls directly.</p> <p>In this case, you need to specify <code>on_receive</code> and <code>after_processed</code> methods:</p> <pre><code>from typing import Optional\n\nfrom faststream import BaseMiddleware:\nfrom faststream.types import DecodedMessage\n\nclass MyMiddleware(BaseMiddleware):\n    async def on_consume(self, msg: DecodedMessage) -&gt; DecodedMessage:\n        return await super().on_consume(msg)\n\n    async def after_consume(self, err: Optional[Exception]) -&gt; None:\n        return await super().after_consume(err)\n</code></pre> <p>This way, you can patch the incoming message body right before passing it to your consumer subscriber.</p> <p>Also, if you have multiple filters for one subscriber, these methods will be called at once when the filtering is completed successfully.</p>"},{"location":"getting-started/middlewares/#message-publishing-wrapper","title":"Message Publishing Wrapper","text":"<p>Finally, using middlewares, you are able to patch outgoing messages too. For example, you can compress/encode outgoing messages at the application level.</p> <p>In this, case you need to specify <code>on_publish</code> and <code>after_publish</code> methods:</p> <pre><code>from typing import Optional\n\nfrom faststream import BaseMiddleware:\nfrom faststream.types import SendableMessage\n\nclass MyMiddleware(BaseMiddleware):\n    async def on_publish(self, msg: SendableMessage) -&gt; SendableMessage:\n        return await super().on_publish(msg)\n\n    async def after_publish(self, err: Optional[Exception]) -&gt; None:\n        return await super().after_publish(err)\n</code></pre>"},{"location":"getting-started/publishing/","title":"Publishing Basics","text":"<p>FastStream is broker-agnostic and easy to use, even as a client in non-FastStream applications.</p> <p>It offers several use cases for publishing messages:</p> <ul> <li>Using `broker.publish``</li> <li>Using a decorator</li> <li>Using a publisher object decorator</li> <li>Using a publisher object directly</li> </ul> <p>FastStream allows you to publish any JSON-serializable messages (Python types, Pydantic models, etc.) or raw bytes.</p> <p>It automatically sets up all required headers, especially the correlation_id, which is used to trace message processing pipelines across all services.</p> <p>To publish a message, simply set up the message content and a routing key:</p> KafkaRabbitMQNATS <pre><code>async with KafkaBroker() as br:\n    await br.publish(\"message\", \"topic\")\n</code></pre> <pre><code>async with RabbitBroker() as br:\n    await br.publish(\"message\", \"queue\")\n</code></pre> <pre><code>async with NatsBroker() as br:\n    await br.publish(\"message\", \"queue\")\n</code></pre>"},{"location":"getting-started/publishing/broker/","title":"Broker Publishing","text":"<p>The easiest way to publish a message is to use a Broker, which allows you to use it as a publisher client in any applications.</p> <p>In the FastStream project, this call is not represented in the AsyncAPI scheme. You can use it to send rarely-publishing messages, such as startup or shutdown events.</p> KafkaRabbitMQNATS <pre><code>from faststream import FastStream\nfrom faststream.kafka import KafkaBroker\n\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\n\n\n@broker.subscriber(\"test-topic\")\nasync def handle():\n    await broker.publish(\"Hi!\", topic=\"another-topic\")\n\n\n@broker.subscriber(\"another-topic\")\nasync def handle_next(msg: str):\n    assert msg == \"Hi!\"\n\n\n@app.after_startup\nasync def test():\n    await broker.publish(\"\", topic=\"test-topic\")\n</code></pre> <pre><code>from faststream import FastStream\nfrom faststream.rabbit import RabbitBroker\n\nbroker = RabbitBroker(\"amqp://guest:guest@localhost:5672/\")\napp = FastStream(broker)\n\n\n@broker.subscriber(\"test-queue\")\nasync def handle():\n    await broker.publish(\"Hi!\", queue=\"another-queue\")\n\n\n@broker.subscriber(\"another-queue\")\nasync def handle_next(msg: str):\n    assert msg == \"Hi!\"\n\n\n@app.after_startup\nasync def test():\n    await broker.publish(\"\", queue=\"test-queue\")\n</code></pre> <pre><code>from faststream import FastStream\nfrom faststream.nats import NatsBroker\n\nbroker = NatsBroker(\"nats://localhost:4222\")\napp = FastStream(broker)\n\n\n@broker.subscriber(\"test-subject\")\nasync def handle():\n    await broker.publish(\"Hi!\", subject=\"another-subject\")\n\n\n@broker.subscriber(\"another-subject\")\nasync def handle_next(msg: str):\n    assert msg == \"Hi!\"\n\n\n@app.after_startup\nasync def test():\n    await broker.publish(\"\", subject=\"test-subject\")\n</code></pre>"},{"location":"getting-started/publishing/decorator/","title":"Publisher Decorator","text":"<p>The second easiest way to publish messages is by using the Publisher Decorator. This method has an AsyncAPI representation and is suitable for quickly creating applications. However, it doesn't provide all testing features.</p> <p>It creates a structured DataPipeline unit with an input and output. The order of Subscriber and Publisher decorators doesn't matter, but they can only be used with functions decorated by a <code>subscriber</code> as well.</p> <p>It uses the handler function's return type annotation to cast the function's return value before sending, so be accurate with it:</p> KafkaRabbitMQNATS <pre><code>from faststream import FastStream\nfrom faststream.kafka import KafkaBroker\n\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\n\n\n@broker.subscriber(\"test-topic\")\n@broker.publisher(\"another-topic\")\nasync def handle() -&gt; str:\n    return \"Hi!\"\n\n\n@broker.subscriber(\"another-topic\")\nasync def handle_next(msg: str):\n    assert msg == \"Hi!\"\n\n\n@app.after_startup\nasync def test():\n    await broker.publish(\"\", topic=\"test-topic\")\n</code></pre> <pre><code>from faststream import FastStream\nfrom faststream.rabbit import RabbitBroker\n\nbroker = RabbitBroker(\"amqp://guest:guest@localhost:5672/\")\napp = FastStream(broker)\n\n\n@broker.subscriber(\"test-queue\")\n@broker.publisher(\"another-queue\")\nasync def handle() -&gt; str:\n    return \"Hi!\"\n\n\n@broker.subscriber(\"another-queue\")\nasync def handle_next(msg: str):\n    assert msg == \"Hi!\"\n\n\n@app.after_startup\nasync def test():\n    await broker.publish(\"\", queue=\"test-queue\")\n</code></pre> <pre><code>from faststream import FastStream\nfrom faststream.nats import NatsBroker\n\nbroker = NatsBroker(\"nats://localhost:4222\")\napp = FastStream(broker)\n\n\n@broker.subscriber(\"test-subject\")\n@broker.publisher(\"another-subject\")\nasync def handle() -&gt; str:\n    return \"Hi!\"\n\n\n@broker.subscriber(\"another-subject\")\nasync def handle_next(msg: str):\n    assert msg == \"Hi!\"\n\n\n@app.after_startup\nasync def test():\n    await broker.publish(\"\", subject=\"test-subject\")\n</code></pre> <p>It can be used multiple times with one function to broadcast the function's return:</p> <pre><code>@broker.subscriber(\"in\")\n@broker.publisher(\"first-out\")\n@broker.publisher(\"second-out\")\nasync def handle(msg) -&gt; str:\n    return \"Response\"\n</code></pre> <p>Additionally, it automatically sends a message with the same <code>correlation_id</code> as the incoming message. This way, you get the same <code>correlation_id</code> for the entire message pipeline process across all services, allowing you to collect a trace.</p>"},{"location":"getting-started/publishing/direct/","title":"Publisher Direct Usage","text":"<p>The Publisher Direct Usage is a full-featured way to publish messages. It has AsyncAPI representation and includes testable features. This method creates a reusable Publisher object that can be used directly to publish a message:</p> KafkaRabbitMQNATS <pre><code>from faststream import FastStream\nfrom faststream.kafka import KafkaBroker\n\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\n\npublisher = broker.publisher(\"another-topic\")\n\n@broker.subscriber(\"test-topic\")\nasync def handle():\n    await publisher.publish(\"Hi!\")\n\n\n@broker.subscriber(\"another-topic\")\nasync def handle_next(msg: str):\n    assert msg == \"Hi!\"\n\n\n@app.after_startup\nasync def test():\n    await broker.publish(\"\", topic=\"test-topic\")\n</code></pre> <pre><code>from faststream import FastStream\nfrom faststream.rabbit import RabbitBroker\n\nbroker = RabbitBroker(\"amqp://guest:guest@localhost:5672/\")\napp = FastStream(broker)\n\npublisher = broker.publisher(\"another-queue\")\n\n@broker.subscriber(\"test-queue\")\nasync def handle():\n    await publisher.publish(\"Hi!\")\n\n\n@broker.subscriber(\"another-queue\")\nasync def handle_next(msg: str):\n    assert msg == \"Hi!\"\n\n\n@app.after_startup\nasync def test():\n    await broker.publish(\"\", queue=\"test-queue\")\n</code></pre> <pre><code>from faststream import FastStream\nfrom faststream.nats import NatsBroker\n\nbroker = NatsBroker(\"nats://localhost:4222\")\napp = FastStream(broker)\n\npublisher = broker.publisher(\"another-subject\")\n\n@broker.subscriber(\"test-subject\")\nasync def handle():\n    await publisher.publish(\"Hi!\")\n\n\n@broker.subscriber(\"another-subject\")\nasync def handle_next(msg: str):\n    assert msg == \"Hi!\"\n\n\n@app.after_startup\nasync def test():\n    await broker.publish(\"\", subject=\"test-subject\")\n</code></pre> <p>It is suitable for publishing different messages to different outputs within the same processing function:</p> <pre><code>@broker.subscriber(\"in\")\nasync def handle(msg) -&gt; str:\n    await publisher1.publish(\"Response-1\")\n    await publisher2.publish(\"Response-2\")\n</code></pre>"},{"location":"getting-started/publishing/object/","title":"Publisher Object","text":"<p>The Publisher Object provides a full-featured way to publish messages. It has AsyncAPI representation and includes testable features. This method creates a reusable Publisher object.</p> <p>It can be used as a function decorator. The order of Subscriber and Publisher decorators doesn't matter, but they can only be used with functions decorated by a <code>subscriber</code> decorator.</p> <p>It also uses the handler function's return type annotation to cast the function's return value before sending, so be accurate with it:</p> KafkaRabbitMQNATS <pre><code>from faststream import FastStream\nfrom faststream.kafka import KafkaBroker\n\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\n\npublisher = broker.publisher(\"another-topic\")\n\n@publisher\n@broker.subscriber(\"test-topic\")\nasync def handle() -&gt; str:\n    return \"Hi!\"\n\n\n@broker.subscriber(\"another-topic\")\nasync def handle_next(msg: str):\n    assert msg == \"Hi!\"\n\n\n@app.after_startup\nasync def test():\n    await broker.publish(\"\", topic=\"test-topic\")\n</code></pre> <pre><code>from faststream import FastStream\nfrom faststream.rabbit import RabbitBroker\n\nbroker = RabbitBroker(\"amqp://guest:guest@localhost:5672/\")\napp = FastStream(broker)\n\npublisher = broker.publisher(\"another-queue\")\n\n@publisher\n@broker.subscriber(\"test-queue\")\nasync def handle() -&gt; str:\n    return \"Hi!\"\n\n\n@broker.subscriber(\"another-queue\")\nasync def handle_next(msg: str):\n    assert msg == \"Hi!\"\n\n\n@app.after_startup\nasync def test():\n    await broker.publish(\"\", queue=\"test-queue\")\n</code></pre> <pre><code>from faststream import FastStream\nfrom faststream.nats import NatsBroker\n\nbroker = NatsBroker(\"nats://localhost:4222\")\napp = FastStream(broker)\n\npublisher = broker.publisher(\"another-subject\")\n\n@publisher\n@broker.subscriber(\"test-subject\")\nasync def handle() -&gt; str:\n    return \"Hi!\"\n\n\n@broker.subscriber(\"another-subject\")\nasync def handle_next(msg: str):\n    assert msg == \"Hi!\"\n\n\n@app.after_startup\nasync def test():\n    await broker.publish(\"\", subject=\"test-subject\")\n</code></pre> <p>You can use it multiple times with one function to broadcast the function's return:</p> <pre><code>@publisher1\n@publisher2\n@broker.subscriber(\"in\")\nasync def handle(msg) -&gt; str:\n    return \"Response\"\n</code></pre> <p>Additionally, it automatically sends a message with the same <code>correlation_id</code> as the incoming message. This way, you get the same correlation_id for the entire message pipeline process across all services, allowing you to collect a trace.</p>"},{"location":"getting-started/publishing/test/","title":"Publisher Testing","text":"<p>If you are working with a Publisher object (either decorator or direct), you can check outgoing messages as well. There are several testing features available:</p> <ul> <li>In-memory TestClient</li> <li>Publishing (including error handling)</li> <li>Checking the incoming message body</li> <li>Note about mock clearing after the context exits</li> </ul>"},{"location":"getting-started/publishing/test/#base-application","title":"Base application","text":"DecoratorDirect KafkaRabbitMQNATS <pre><code>publisher = broker.publisher(\"another-topic\")\n\n@publisher\n@broker.subscriber(\"test-topic\")\nasync def handle() -&gt; str:\n    return \"Hi!\"\n</code></pre> <pre><code>publisher = broker.publisher(\"another-queue\")\n\n@publisher\n@broker.subscriber(\"test-queue\")\nasync def handle() -&gt; str:\n    return \"Hi!\"\n</code></pre> <pre><code>publisher = broker.publisher(\"another-subject\")\n\n@publisher\n@broker.subscriber(\"test-subject\")\nasync def handle() -&gt; str:\n    return \"Hi!\"\n</code></pre> KafkaRabbitMQNATS <pre><code>publisher = broker.publisher(\"another-topic\")\n\n@broker.subscriber(\"test-topic\")\nasync def handle():\n    await publisher.publish(\"Hi!\")\n</code></pre> <pre><code>publisher = broker.publisher(\"another-queue\")\n\n@broker.subscriber(\"test-queue\")\nasync def handle():\n    await publisher.publish(\"Hi!\")\n</code></pre> <pre><code>publisher = broker.publisher(\"another-subject\")\n\n@broker.subscriber(\"test-subject\")\nasync def handle():\n    await publisher.publish(\"Hi!\")\n</code></pre>"},{"location":"getting-started/publishing/test/#testing","title":"Testing","text":"KafkaRabbitMQNATS <pre><code>import pytest\n\nfrom faststream.kafka import TestKafkaBroker\n\n\n\n@pytest.mark.asyncio\nasync def test_handle():\n    async with TestKafkaBroker(broker) as br:\n        await br.publish(\"\", topic=\"test-topic\")\n</code></pre> <pre><code>import pytest\n\nfrom faststream.rabbit import TestRabbitBroker\n\n\n\n@pytest.mark.asyncio\nasync def test_handle():\n    async with TestRabbitBroker(broker) as br:\n        await br.publish(\"\", queue=\"test-queue\")\n</code></pre> <pre><code>import pytest\n\nfrom faststream.nats import TestNatsBroker\n\n\n\n@pytest.mark.asyncio\nasync def test_handle():\n    async with TestNatsBroker(broker) as br:\n        await br.publish(\"\", subject=\"test-subject\")\n</code></pre> <ul> <li>Testing with a real broker</li> <li>Waiting for the consumer to be called</li> </ul>"},{"location":"getting-started/routers/","title":"Broker Router","text":"<p>Sometimes you want to:</p> <ul> <li>split an application into includable modules</li> <li>separate business logic from your handler registration</li> <li>apply some decoder/middleware/dependencies to a subscribers group</li> </ul> <p>For these reasons, FastStream has a special Broker Router.</p>"},{"location":"getting-started/routers/#router-usage","title":"Router Usage","text":"<p>First, you need to import the Broker Router from the same module from where you imported the broker.</p> <p>When creating a Broker Router, you can specify a prefix that will be automatically applied to all subscribers and publishers of this router.</p> KafkaRabbitMQNATS <pre><code>from faststream import FastStream\nfrom faststream.kafka import KafkaBroker, KafkaRouter\n\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\nrouter = KafkaRouter(prefix=\"prefix_\")\n</code></pre> <pre><code>from faststream import FastStream\nfrom faststream.rabbit import RabbitBroker, RabbitRouter\n\nbroker = RabbitBroker(\"amqp://guest:guest@localhost:5672/\")\napp = FastStream(broker)\nrouter = RabbitRouter(prefix=\"prefix_\")\n</code></pre> <pre><code>from faststream import FastStream\nfrom faststream.nats import NatsBroker, NatsRouter\n\nbroker = NatsBroker(\"nats://localhost:4222\")\napp = FastStream(broker)\nrouter = NatsRouter(prefix=\"prefix_\")\n</code></pre> <p>Now you can use the created router to register handlers and publishers as if it were a regular broker</p> KafkaRabbitMQNATS <pre><code>@router.subscriber(\"test-topic\")\n@router.publisher(\"another-topic\")\nasync def handle(name: str, user_id: int) -&gt; str:\n    assert name == \"John\"\n    assert user_id == 1\n    return \"Hi!\"\n\n\n@router.subscriber(\"another-topic\")\nasync def handle_response(msg: str):\n    assert msg == \"Hi!\"\n</code></pre> <pre><code>@router.subscriber(\"test-queue\")\n@router.publisher(\"another-queue\")\nasync def handle(name: str, user_id: int) -&gt; str:\n    assert name == \"John\"\n    assert user_id == 1\n    return \"Hi!\"\n\n\n@router.subscriber(\"another-queue\")\nasync def handle_response(msg: str):\n    assert msg == \"Hi!\"\n</code></pre> <pre><code>@router.subscriber(\"test-subject\")\n@router.publisher(\"another-subject\")\nasync def handle(name: str, user_id: int) -&gt; str:\n    assert name == \"John\"\n    assert user_id == 1\n    return \"Hi!\"\n\n\n@router.subscriber(\"another-subject\")\nasync def handle_response(msg: str):\n    assert msg == \"Hi!\"\n</code></pre> <p>Then you can simply include all the handlers declared using the router in your broker</p> KafkaRabbitMQNATS <pre><code>broker.include_router(router)\n</code></pre> <pre><code>broker.include_router(router)\n</code></pre> <pre><code>broker.include_router(router)\n</code></pre> <p>Please note that when publishing a message, you now need to specify the same prefix that you used when creating the router</p> KafkaRabbitMQNATS <pre><code>    await broker.publish(\n        {\"name\": \"John\", \"user_id\": 1},\n        topic=\"prefix_test-topic\",\n    )\n</code></pre> <pre><code>    await broker.publish(\n        {\"name\": \"John\", \"user_id\": 1},\n        queue=\"prefix_test-queue\",\n    )\n</code></pre> <pre><code>    await broker.publish(\n        {\"name\": \"John\", \"user_id\": 1},\n        subject=\"prefix_test-subject\",\n    )\n</code></pre> <p>Tip</p> <p>Also, when creating a Broker Router, you can specify middleware, dependencies, parser and decoder to apply them to all subscribers declared via this router.</p>"},{"location":"getting-started/routers/#delay-handler-registration","title":"Delay Handler Registration","text":"<p>If you want to separate your application's core logic from FastStream's routing logic, you can write some core functions and use them as Broker Router <code>handlers</code> later:</p> KafkaRabbitMQNATS <pre><code>from faststream import FastStream\nfrom faststream.kafka import KafkaBroker, KafkaRoute, KafkaRouter\n\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\n\n\nasync def handle(name: str, user_id: int):\n    assert name == \"John\"\n    assert user_id == 1\n\n\nrouter = KafkaRouter(handlers=(KafkaRoute(handle, \"test-topic\"),))\n\nbroker.include_router(router)\n</code></pre> <pre><code>from faststream import FastStream\nfrom faststream.rabbit import RabbitBroker, RabbitRoute, RabbitRouter\n\nbroker = RabbitBroker(\"amqp://guest:guest@localhost:5672/\")\napp = FastStream(broker)\n\n\nasync def handle(name: str, user_id: int):\n    assert name == \"John\"\n    assert user_id == 1\n\n\nrouter = RabbitRouter(handlers=(RabbitRoute(handle, \"test-queue\"),))\n\nbroker.include_router(router)\n</code></pre> <pre><code>from faststream import FastStream\nfrom faststream.nats import NatsBroker, NatsRoute, NatsRouter\n\nbroker = NatsBroker(\"nats://localhost:4222\")\napp = FastStream(broker)\n\n\nasync def handle(name: str, user_id: int):\n    assert name == \"John\"\n    assert user_id == 1\n\n\nrouter = NatsRouter(handlers=(NatsRoute(handle, \"test-subject\"),))\n\nbroker.include_router(router)\n</code></pre> <p>Warning</p> <p>Be careful, this way you won't be able to test your handlers with a <code>mock</code> object.</p>"},{"location":"getting-started/serialization/","title":"Custom Serialization","text":"<p>By default, FastStream uses the JSON format to send and receive messages. However, if you need to handle messages in other formats or with additional serialization steps, such as gzip, lz4, Avro, Protobuf or Msgpack, you can easily modify the serialization logic.</p>"},{"location":"getting-started/serialization/#serialization-steps","title":"Serialization Steps","text":"<p>Before the message reaches your subscriber, FastStream applies two functions to it sequentially: <code>parse_message</code> and <code>decode_message</code>. You can modify one or both stages depending on your needs.</p>"},{"location":"getting-started/serialization/#message-parsing","title":"Message Parsing","text":"<p>At this stage, FastStream serializes an incoming message from the broker's framework into a general format called - StreamMessage. During this stage, the message body remains in the form of raw bytes.</p> <p>This stage is closely related to the features of the broker used, and in most cases, redefining it is not necessary.</p> <p>The parser declared at the <code>broker</code> level will be applied to all subscribers. The parser declared at the <code>subscriber</code> level is applied only to that specific subscriber and overrides the `broker' parser if specified.</p>"},{"location":"getting-started/serialization/#message-decoding","title":"Message Decoding","text":"<p>At this stage, the body of the StreamMessage is transformed into a format suitable for processing within your subscriber function. This is the stage you may need to redefine more often.</p>"},{"location":"getting-started/serialization/decoder/","title":"Custom Decoder","text":"<p>At this stage, the body of a StreamMessage is transformed into the format that it will take when it enters your handler function. This stage is the one you will need to redefine more often.</p>"},{"location":"getting-started/serialization/decoder/#signature","title":"Signature","text":"<p>The original decoder function has a relatively simple signature (this is a simplified version):</p> KafkaRabbitMQNATS <pre><code>from faststream.types import DecodedMessage\nfrom faststream.kafka import KafkaMessage\n\ndef decoder(msg: KafkaMessage) -&gt; DecodedMessage:\n    ...\n</code></pre> <pre><code>from faststream.types import DecodedMessage\nfrom faststream.rabbit import RabbitMessage\n\ndef decoder(msg: RabbitMessage) -&gt; DecodedMessage:\n    ...\n</code></pre> <pre><code>from faststream.types import DecodedMessage\nfrom faststream.nats import NatsMessage\n\ndef decoder(msg: NatsMessage) -&gt; DecodedMessage:\n    ...\n</code></pre> <p>Alternatively, you can reuse the original decoder function with the following signature:</p> KafkaRabbitMQNATS <pre><code>from types import Callable, Awaitable\nfrom faststream.types import DecodedMessage\nfrom faststream.kafka import KafkaMessage\n\nasync def decoder(\n    msg: KafkaMessage,\n    original_decoder: Callable[[KafkaMessage], Awaitable[DecodedMessage]],\n) -&gt; DecodedMessage:\n    return await original_decoder(msg)\n</code></pre> <pre><code>from types import Callable, Awaitable\nfrom faststream.types import DecodedMessage\nfrom faststream.rabbit import RabbitMessage\n\nasync def decoder(\n    msg: RabbitMessage,\n    original_decoder: Callable[[RabbitMessage], Awaitable[DecodedMessage]],\n) -&gt; DecodedMessage:\n    return await original_decoder(msg)\n</code></pre> <pre><code>from types import Callable, Awaitable\nfrom faststream.types import DecodedMessage\nfrom faststream.nats import NatsMessage\n\nasync def decoder(\n    msg: NatsMessage,\n    original_decoder: Callable[[NatsMessage], Awaitable[DecodedMessage]],\n) -&gt; DecodedMessage:\n    return await original_decoder(msg)\n</code></pre> <p>Note</p> <p>The original decoder is always an asynchronous function, so your custom decoder should also be asynchronous.</p> <p>Afterward, you can set this custom decoder at the broker or subscriber level.</p>"},{"location":"getting-started/serialization/decoder/#example","title":"Example","text":"<p>You can find examples of Protobuf and Msgpack serialization in the next article.</p>"},{"location":"getting-started/serialization/examples/","title":"Serialization examples","text":""},{"location":"getting-started/serialization/examples/#protobuf","title":"Protobuf","text":"<p>In this section, we will explore an example using Protobuf. However, this approach is also applicable to other serialization methods.</p> Protobuf <p>Protobuf is an alternative message serialization method commonly used in GRPC.  Its main advantage is that it results in much smaller message sizes<sup>1</sup> compared to JSON, but it requires a message schema (<code>.proto</code> files) on both the client and server sides.</p> <p>To begin, install the necessary dependencies:</p> <pre><code>pip install grpcio-tools\n</code></pre> <p>Next, let's define the schema for our message:</p> message.proto<pre><code>syntax = \"proto3\";\n\nmessage Person {\n    string name = 1;\n    float age = 2;\n}\n</code></pre> <p>Now, generate a Python class to work with messages in Protobuf format:</p> <pre><code>python -m grpc_tools.protoc --python_out=. --pyi_out=. -I . message.proto\n</code></pre> <p>This generates two files: <code>message_pb2.py</code> and <code>message_pb2.pyi</code>. We can use the generated class to serialize our messages:</p> <pre><code>from message_pb2 import Person\n\nfrom faststream import FastStream, Logger, NoCast\nfrom faststream.rabbit import RabbitBroker, RabbitMessage\n\nbroker = RabbitBroker()\napp = FastStream(broker)\n\n\nasync def decode_message(msg: RabbitMessage) -&gt; Person:\n    decoded = Person()\n    decoded.ParseFromString(msg.body)\n    return decoded\n\n\n@broker.subscriber(\"test\", decoder=decode_message)\nasync def consume(body: NoCast[Person], logger: Logger):\n    logger.info(body)\n\n\n@app.after_startup\nasync def publish():\n    body = Person(name=\"John\", age=25).SerializeToString()\n    await broker.publish(body, \"test\")\n</code></pre> <p>Note that we used the <code>NoCast</code> annotation to exclude the message from the <code>pydantic</code> representation of our handler.</p> <pre><code>async def consume(body: NoCast[Person], logger: Logger):\n</code></pre>"},{"location":"getting-started/serialization/examples/#msgpack","title":"Msgpack","text":"<p>Msgpack is another alternative binary data format. Its main advantage is that it results in smaller message sizes<sup>2</sup> compared to JSON, although slightly larger than Protobuf. The key advantage is that it doesn't require a message schema, making it easy to use in most cases.</p> <p>To get started, install the necessary dependencies:</p> <pre><code>pip install msgpack\n</code></pre> <p>Since there is no need for a schema, you can easily write a Msgpack decoder:</p> <pre><code>import msgpack\n\nfrom faststream import FastStream, Logger\nfrom faststream.rabbit import RabbitBroker, RabbitMessage\n\nbroker = RabbitBroker()\napp = FastStream(broker)\n\n\nasync def decode_message(msg: RabbitMessage):\n    return msgpack.loads(msg.body)\n\n\n@broker.subscriber(\"test\", decoder=decode_message)\nasync def consume(name: str, age: int, logger: Logger):\n    logger.info(f\"{name}: {age}\")\n\n\n@app.after_startup\nasync def publish():\n    body = msgpack.dumps({\"name\": \"John\", \"age\": 25}, use_bin_type=True)\n    await broker.publish(body, \"test\")\n</code></pre> <p>Using Msgpack is much simpler than using Protobuf schemas. Therefore, if you don't have strict message size limitations, you can use Msgpack serialization in most cases.</p>"},{"location":"getting-started/serialization/examples/#tips","title":"Tips","text":""},{"location":"getting-started/serialization/examples/#data-compression","title":"Data Compression","text":"<p>If you are dealing with very large messages, consider compressing them as well. You can explore libraries such as lz4 or zstd for compression algorithms.</p> <p>Compression can significantly reduce message size, especially if there are repeated blocks. However, in the case of small message bodies, data compression may increase the message size. Therefore, you should assess the compression impact based on your specific application requirements.</p>"},{"location":"getting-started/serialization/examples/#broker-level-serialization","title":"Broker-Level Serialization","text":"<p>You can still set a custom <code>decoder</code> at the Broker or Router level. However, if you want to automatically encode publishing messages as well, you should explore Middleware for serialization implimentation.</p> <ol> <li> <p>For example, a message like <code>{ \"name\": \"John\", \"age\": 25 }</code> in JSON takes 27 bytes, while in Protobuf, it takes only 11 bytes. With lists and more complex structures, the savings can be even more significant (up to 20x times).\u00a0\u21a9</p> </li> <li> <p>A message with Msgpack serialization, such as <code>{ \"name\": \"John\", \"age\": 25 }</code>, takes 16 bytes.\u00a0\u21a9</p> </li> </ol>"},{"location":"getting-started/serialization/parser/","title":"Custom Parser","text":"<p>At this stage, FastStream serializes an incoming message from the broker's framework into a general format called StreamMessage. During this stage, the message body remains in the form of raw bytes.</p> <p>StreamMessage is a general representation of a message within FastStream. It contains all the information required for message processing within FastStreams.  It is even used to represent message batches, so the primary reason to customize it is to redefine the metadata associated with FastStream messages.</p> <p>For example, you can specify your own header with the <code>message_id</code> semantic. This allows you to inform FastStream about this custom header through parser customization.</p>"},{"location":"getting-started/serialization/parser/#signature","title":"Signature","text":"<p>To create a custom message parser, you should write a regular Python function (synchronous or asynchronous) with the following signature:</p> KafkaRabbitMQNATS <pre><code>from aiokafka import ConsumerRecord\nfrom faststream.kafka import KafkaMessage\n\ndef parser(msg: ConsumerRecord) -&gt; KafkaMessage:\n    ...\n</code></pre> <pre><code>from aio_pika import IncomingMessage\nfrom faststream.rabbit import RabbitMessage\n\ndef parser(msg: IncomingMessage) -&gt; RabbitMessage:\n    ...\n</code></pre> <pre><code>from nats.aio.msg import Msg\nfrom faststream.nats import NatsMessage\n\ndef parser(msg: Msg) -&gt; NatsMessage:\n    ...\n</code></pre> <p>Alternatively, you can reuse the original parser function with the following signature:</p> KafkaRabbitMQNATS <pre><code>from types import Callable, Awaitable\nfrom aiokafka import ConsumerRecord\nfrom faststream.kafka import KafkaMessage\n\nasync def parser(\n    msg: ConsumerRecord,\n    original_parser: Callable[[ConsumerRecord], Awaitable[KafkaMessage]],\n) -&gt; KafkaMessage:\n    return await original_parser(msg)\n</code></pre> <pre><code>from types import Callable, Awaitable\nfrom aio_pika import IncomingMessage\nfrom faststream.rabbit import RabbitMessage\n\nasync def parser(\n    msg: IncomingMessage,\n    original_parser: Callable[[IncomingMessage], Awaitable[RabbitMessage]],\n) -&gt; RabbitMessage:\n    return await original_parser(msg)\n</code></pre> <pre><code>from types import Callable, Awaitable\nfrom nats.aio.msg import Msg\nfrom faststream.nats import NatsMessage\n\nasync def parser(\n    msg: Msg,\n    original_parser: Callable[[Msg], Awaitable[NatsMessage]],\n) -&gt; RabbitMessage:\n    return await original_parser(msg)\n</code></pre> <p>The argument naming doesn't matter; the parser will always be placed as the second argument.</p> <p>Note</p> <p>The original parser is always an asynchronous function, so your custom parser should also be asynchronous.</p> <p>Afterward, you can set this custom parser at the broker or subscriber level.</p>"},{"location":"getting-started/serialization/parser/#example","title":"Example","text":"<p>As an example, let's redefine <code>message_id</code> to a custom header:</p> KafkaRabbitMQNATS <pre><code>from typing import Awaitable, Callable\n\nfrom aiokafka import ConsumerRecord\n\nfrom faststream import FastStream\nfrom faststream.kafka import KafkaBroker, KafkaMessage\n\n\nasync def custom_parser(\n    msg: ConsumerRecord,\n    original_parser: Callable[[ConsumerRecord], Awaitable[KafkaMessage]],\n) -&gt; KafkaMessage:\n    parsed_msg = await original_parser(msg)\n    parsed_msg.message_id = parsed_msg.headers[\"custom_message_id\"]\n    return parsed_msg\n\n\nbroker = KafkaBroker(parser=custom_parser)\napp = FastStream(broker)\n\n\n@broker.subscriber(\"test\")\nasync def handle():\n    ...\n\n\n@app.after_startup\nasync def test():\n    await broker.publish(\"\", \"test\", headers={\"custom_message_id\": \"1\"})\n</code></pre> <pre><code>from typing import Awaitable, Callable\n\nfrom aio_pika import IncomingMessage\n\nfrom faststream import FastStream\nfrom faststream.rabbit import RabbitBroker, RabbitMessage\n\n\nasync def custom_parser(\n    msg: IncomingMessage,\n    original_parser: Callable[[IncomingMessage], Awaitable[RabbitMessage]],\n) -&gt; RabbitMessage:\n    parsed_msg = await original_parser(msg)\n    parsed_msg.message_id = parsed_msg.headers[\"custom_message_id\"]\n    return parsed_msg\n\n\nbroker = RabbitBroker(parser=custom_parser)\napp = FastStream(broker)\n\n\n@broker.subscriber(\"test\")\nasync def handle():\n    ...\n\n\n@app.after_startup\nasync def test():\n    await broker.publish(\"\", \"test\", headers={\"custom_message_id\": \"1\"})\n</code></pre> <pre><code>from typing import Awaitable, Callable\n\nfrom nats.aio.msg import Msg\n\nfrom faststream import FastStream\nfrom faststream.nats import NatsBroker, NatsMessage\n\n\nasync def custom_parser(\n    msg: Msg,\n    original_parser: Callable[[Msg], Awaitable[NatsMessage]],\n) -&gt; NatsMessage:\n    parsed_msg = await original_parser(msg)\n    parsed_msg.message_id = parsed_msg.headers[\"custom_message_id\"]\n    return parsed_msg\n\n\nbroker = NatsBroker(parser=custom_parser)\napp = FastStream(broker)\n\n\n@broker.subscriber(\"test\")\nasync def handle():\n    ...\n\n\n@app.after_startup\nasync def test():\n    await broker.publish(\"\", \"test\", headers={\"custom_message_id\": \"1\"})\n</code></pre>"},{"location":"getting-started/subscription/","title":"Subscription Basics","text":"<p>FastStream provides a Message Broker agnostic way to subscribe to event streams.</p> <p>You need not even know about topics/queues/subjects or any broker inner objects you use. The basic syntax is the same for all brokers:</p> KafkaRabbitMQNATS <pre><code>from faststream.kafka import KafkaBroker\n\nbroker = KafkaBroker()\n\n@broker.subscriber(\"test\")  # topic name\nasync def handle_msg(msg_body):\n    ...\n</code></pre> <pre><code>from faststream.rabbit import RabbitBroker\n\nbroker = RabbitBroker()\n\n@broker.subscriber(\"test\")  # queue name\nasync def handle_msg(msg_body):\n    ...\n</code></pre> <pre><code>from faststream.nats import NatsBroker\n\nbroker = NatsBroker()\n\n@broker.subscriber(\"test\")  # subject name\nasync def handle_msg(msg_body):\n    ...\n</code></pre> <p>Tip</p> <p>If you want to use Message Broker specific features, please visit the corresponding broker documentation section. In the Tutorial section, the general features are described.</p> <p>Also, synchronous functions are supported as well:</p> KafkaRabbitMQNATS <pre><code>from faststream.kafka import KafkaBroker\n\nbroker = KafkaBroker()\n\n@broker.subscriber(\"test\")  # topic name\ndef handle_msg(msg_body):\n    ...\n</code></pre> <pre><code>from faststream.rabbit import RabbitBroker\n\nbroker = RabbitBroker()\n\n@broker.subscriber(\"test\")  # queue name\ndef handle_msg(msg_body):\n    ...\n</code></pre> <pre><code>from faststream.nats import NatsBroker\n\nbroker = NatsBroker()\n\n@broker.subscriber(\"test\")  # subject name\ndef handle_msg(msg_body):\n    ...\n</code></pre>"},{"location":"getting-started/subscription/#message-body-serialization","title":"Message Body Serialization","text":"<p>Generally, FastStream uses your function type annotation to serialize incoming message body with Pydantic. This is similar to how FastAPI works (if you are familiar with it).</p> <pre><code>@broker.subscriber(\"test\")\nasync def handle_str(msg_body: str):\n    ...\n</code></pre> <p>You can also access some extra features through the function arguments, such as Depends and Context if required.</p> <p>However, you can easily disable Pydantic validation by creating a broker with the following option <code>Broker(apply_types=False)</code> (this also disables Context and Depends features).</p> <p>This way FastStream still consumes <code>json.loads</code> result, but without pydantic validation and casting.</p> KafkaRabbitMQNATS <pre><code>from faststream.kafka import KafkaBroker\n\nbroker = KafkaBroker(apply_types=False)\n\n@broker.subscriber(\"test\")\nasync def handle_msg(msg_body: str):  # just an annotation, has no real effect\n    ...\n</code></pre> <pre><code>from faststream.rabbit import RabbitBroker\n\nbroker = RabbitBroker(apply_types=False)\n\n@broker.subscriber(\"test\")\nasync def handle_msg(msg_body: str):  # just an annotation, has no real effect\n    ...\n</code></pre> <pre><code>from faststream.nats import NatsBroker\n\nbroker = NatsBroker(apply_types=False)\n\n@broker.subscriber(\"test\")\nasync def handle_msg(msg_body: str):  # just an annotation, has no real effect\n    ...\n</code></pre>"},{"location":"getting-started/subscription/#multiple-subscriptions","title":"Multiple Subscriptions","text":"<p>You can also subscribe to multiple event streams at the same time with one function. Just wrap it with multiple <code>@broker.subscriber(...)</code> decorators (they have no effect on each other).</p> <pre><code>@broker.subscriber(\"first_sub\")\n@broker.subscriber(\"second_sub\")\nasync def handler(msg):\n    ...\n</code></pre>"},{"location":"getting-started/subscription/annotation/","title":"Annotation Serialization","text":""},{"location":"getting-started/subscription/annotation/#basic-usage","title":"Basic usage","text":"<p>As you already know, FastStream serializes your incoming message body according to the function type annotations using Pydantic.</p> <p>So, there are some valid usecases:</p> <pre><code>@broker.subscriber(\"test\")\nasync def handle(msg: str):\n    ...\n\n@broker.subscriber(\"test\")\nasync def handle(msg: bytes):\n    ...\n\n@broker.subscriber(\"test\")\nasync def handle(msg: int):\n    ...\n</code></pre> <p>As with other Python primitive types as well (<code>float</code>, <code>bool</code>, <code>datetime</code>, etc)</p> <p>Note</p> <p>If the incoming message cannot be serialized by the described schema, FastStream raises a <code>pydantic.ValidationError</code> with a correct log message.</p> <p>Also, thanks to Pydantic (again), FastStream is able to serialize (and validate) more complex types like <code>pydantic.HttpUrl</code>, <code>pydantic.PostitiveInt</code>, etc.</p>"},{"location":"getting-started/subscription/annotation/#json-basic-serialization","title":"JSON Basic Serialization","text":"<p>But how can we serialize more complex message, like <code>{ \"name\": \"John\", \"user_id\": 1 }</code> ?</p> <p>For sure, we can serialize it as a simple <code>dict</code></p> <pre><code>from typing import Dict, Any\n\n@broker.subscriber(\"test\")\nasync def handle(msg: dict[str, Any]):\n    ...\n</code></pre> <p>But it doesn't looks like a correct message validation, does it?</p> <p>For this reason, FastStream supports per-argument message serialization: you can declare multiple arguments with various types and your message will unpack to them:</p> KafkaRabbitMQNATS <pre><code>@broker.subscriber(\"test-topic\")\nasync def handle(name: str, user_id: int):\n    assert name == \"John\"\n    assert user_id == 1\n</code></pre> <pre><code>@broker.subscriber(\"test-queue\")\nasync def handle(name: str, user_id: int):\n    assert name == \"John\"\n    assert user_id == 1\n</code></pre> <pre><code>@broker.subscriber(\"test-subject\")\nasync def handle(name: str, user_id: int):\n    assert name == \"John\"\n    assert user_id == 1\n</code></pre>"},{"location":"getting-started/subscription/filtering/","title":"Application-level Filtering","text":"<p>FastStream also allows you to specify the message processing way using message headers, body type or something else. The <code>filter</code> feature enables you to consume various messages with different schemas within a single event stream.</p> <p>Tip</p> <p>Message must be consumed at ONCE (crossing filters are not allowed)</p> <p>As an example, let's create a subscriber for both <code>JSON</code> and non-<code>JSON</code> messages:</p> KafkaRabbitMQNATS <pre><code>from faststream import FastStream\nfrom faststream.kafka import KafkaBroker\n\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\n\n\n@broker.subscriber(\n    \"test-topic\",\n    filter=lambda msg: msg.content_type == \"application/json\",\n)\nasync def handle(name: str, user_id: int):\n    assert name == \"John\"\n    assert user_id == 1\n\n\n@broker.subscriber(\"test-topic\")\nasync def default_handler(msg: str):\n    assert msg == \"Hello, FastStream!\"\n</code></pre> <pre><code>from faststream import FastStream\nfrom faststream.rabbit import RabbitBroker\n\nbroker = RabbitBroker(\"amqp://guest:guest@localhost:5672/\")\napp = FastStream(broker)\n\n\n@broker.subscriber(\n    \"test-queue\",\n    filter=lambda msg: msg.content_type == \"application/json\",\n)\nasync def handle(name: str, user_id: int):\n    assert name == \"John\"\n    assert user_id == 1\n\n\n@broker.subscriber(\"test-queue\")\nasync def default_handler(msg: str):\n    assert msg == \"Hello, FastStream!\"\n</code></pre> <pre><code>from faststream import FastStream\nfrom faststream.nats import NatsBroker\n\nbroker = NatsBroker(\"nats://localhost:4222\")\napp = FastStream(broker)\n\n\n@broker.subscriber(\n    \"test-subject\",\n    filter=lambda msg: msg.content_type == \"application/json\",\n)\nasync def handle(name: str, user_id: int):\n    assert name == \"John\"\n    assert user_id == 1\n\n\n@broker.subscriber(\"test-subject\")\nasync def default_handler(msg: str):\n    assert msg == \"Hello, FastStream!\"\n</code></pre> <p>Note</p> <p>A subscriber without a filter is a default subscriber. It consumes messages that have not been consumed yet.</p> <p>For now, the following message will be delivered to the <code>handle</code> function</p> KafkaRabbitMQNATS <pre><code>    await broker.publish(\n        {\"name\": \"John\", \"user_id\": 1},\n        topic=\"test-topic\",\n    )\n</code></pre> <pre><code>    await broker.publish(\n        {\"name\": \"John\", \"user_id\": 1},\n        queue=\"test-queue\",\n    )\n</code></pre> <pre><code>    await broker.publish(\n        {\"name\": \"John\", \"user_id\": 1},\n        subject=\"test-subject\",\n    )\n</code></pre> <p>And this one will be delivered to the <code>default_handler</code></p> KafkaRabbitMQNATS <pre><code>    await broker.publish(\n        \"Hello, FastStream!\",\n        topic=\"test-topic\",\n    )\n</code></pre> <pre><code>    await broker.publish(\n        \"Hello, FastStream!\",\n        queue=\"test-queue\",\n    )\n</code></pre> <pre><code>    await broker.publish(\n        \"Hello, FastStream!\",\n        subject=\"test-subject\",\n    )\n</code></pre>"},{"location":"getting-started/subscription/pydantic/","title":"Pydantic Serialization","text":""},{"location":"getting-started/subscription/pydantic/#pydanticfield","title":"pydantic.Field","text":"<p>Besides, FastStream uses your handlers' annotations to collect information about the application schema and generate AsyncAPI schema.</p> <p>You can access this information with extra details using <code>pydantic.Field</code> (such as title, description and examples). Additionally, Fields usage allows you to add extra validations to your message schema.</p> <p>Just use <code>pydantic.Field</code> as a function default argument:</p> KafkaRabbitMQNATS <pre><code>from pydantic import Field, NonNegativeInt\n\nfrom faststream import FastStream\nfrom faststream.kafka import KafkaBroker\n\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\n\n\n@broker.subscriber(\"test-topic\")\nasync def handle(\n    name: str = Field(\n        ..., examples=[\"John\"], description=\"Registered user name\"\n    ),\n    user_id: NonNegativeInt = Field(\n        ..., examples=[1], description=\"Registered user id\"\n    ),\n):\n    assert name == \"John\"\n    assert user_id == 1\n</code></pre> <pre><code>from pydantic import Field, NonNegativeInt\n\nfrom faststream import FastStream\nfrom faststream.rabbit import RabbitBroker\n\nbroker = RabbitBroker(\"amqp://guest:guest@localhost:5672/\")\napp = FastStream(broker)\n\n\n@broker.subscriber(\"test-queue\")\nasync def handle(\n    name: str = Field(\n        ..., examples=[\"John\"], description=\"Registered user name\"\n    ),\n    user_id: NonNegativeInt = Field(\n        ..., examples=[1], description=\"Registered user id\"\n    ),\n):\n    assert name == \"John\"\n    assert user_id == 1\n</code></pre> <pre><code>from pydantic import Field, NonNegativeInt\n\nfrom faststream import FastStream\nfrom faststream.nats import NatsBroker\n\nbroker = NatsBroker(\"nats://localhost:4222\")\napp = FastStream(broker)\n\n\n@broker.subscriber(\"test-subject\")\nasync def handle(\n    name: str = Field(\n        ..., examples=[\"John\"], description=\"Registered user name\"\n    ),\n    user_id: NonNegativeInt = Field(\n        ..., examples=[1], description=\"Registered user id\"\n    ),\n):\n    assert name == \"John\"\n    assert user_id == 1\n</code></pre>"},{"location":"getting-started/subscription/pydantic/#pydanticbasemodel","title":"pydantic.BaseModel","text":"<p>To make your message schema reusable between different subscribers and publishers, you can decalre it as a <code>pydantic.BaseModel</code> and use it as a single message annotation:</p> KafkaRabbitMQNATS <pre><code>from pydantic import BaseModel, Field, NonNegativeInt\n\nfrom faststream import FastStream\nfrom faststream.kafka import KafkaBroker\n\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\n\n\nclass UserInfo(BaseModel):\n    name: str = Field(\n        ..., examples=[\"John\"], description=\"Registered user name\"\n    )\n    user_id: NonNegativeInt = Field(\n        ..., examples=[1], description=\"Registered user id\"\n    )\n\n\n@broker.subscriber(\"test-topic\")\nasync def handle(user: UserInfo):\n    assert user.name == \"John\"\n    assert user.user_id == 1\n</code></pre> <pre><code>from pydantic import BaseModel, Field, NonNegativeInt\n\nfrom faststream import FastStream\nfrom faststream.rabbit import RabbitBroker\n\nbroker = RabbitBroker(\"amqp://guest:guest@localhost:5672/\")\napp = FastStream(broker)\n\n\nclass UserInfo(BaseModel):\n    name: str = Field(\n        ..., examples=[\"John\"], description=\"Registered user name\"\n    )\n    user_id: NonNegativeInt = Field(\n        ..., examples=[1], description=\"Registered user id\"\n    )\n\n\n@broker.subscriber(\"test-queue\")\nasync def handle(user: UserInfo):\n    assert user.name == \"John\"\n    assert user.user_id == 1\n</code></pre> <pre><code>from pydantic import BaseModel, Field, NonNegativeInt\n\nfrom faststream import FastStream\nfrom faststream.nats import NatsBroker\n\nbroker = NatsBroker(\"nats://localhost:4222\")\napp = FastStream(broker)\n\n\nclass UserInfo(BaseModel):\n    name: str = Field(\n        ..., examples=[\"John\"], description=\"Registered user name\"\n    )\n    user_id: NonNegativeInt = Field(\n        ..., examples=[1], description=\"Registered user id\"\n    )\n\n\n@broker.subscriber(\"test-subject\")\nasync def handle(user: UserInfo):\n    assert user.name == \"John\"\n    assert user.user_id == 1\n</code></pre>"},{"location":"getting-started/subscription/test/","title":"Subscriber Testing","text":"<p>Testability is a crucial part of any application, and FastStream provides you with the tools to test your code easily.</p>"},{"location":"getting-started/subscription/test/#original-application","title":"Original Application","text":"<p>Let's take a look at the original application to test</p> KafkaRabbitMQNATS annotation_kafka.py<pre><code>from faststream import FastStream\nfrom faststream.kafka import KafkaBroker\n\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\n\n\n@broker.subscriber(\"test-topic\")\nasync def handle(name: str, user_id: int):\n    assert name == \"John\"\n    assert user_id == 1\n</code></pre> annotation_rabbit.py<pre><code>from faststream import FastStream\nfrom faststream.rabbit import RabbitBroker\n\nbroker = RabbitBroker(\"amqp://guest:guest@localhost:5672/\")\napp = FastStream(broker)\n\n\n@broker.subscriber(\"test-queue\")\nasync def handle(name: str, user_id: int):\n    assert name == \"John\"\n    assert user_id == 1\n</code></pre> annotation_rabbit.py<pre><code>from faststream import FastStream\nfrom faststream.nats import NatsBroker\n\nbroker = NatsBroker(\"nats://localhost:4222\")\napp = FastStream(broker)\n\n\n@broker.subscriber(\"test-subject\")\nasync def handle(name: str, user_id: int):\n    assert name == \"John\"\n    assert user_id == 1\n</code></pre> <p>It consumes JSON messages like <code>{ \"name\": \"username\", \"user_id\": 1 }</code></p> <p>You can test your consume function like a regular one, for sure:</p> <pre><code>@pytest.mark.asyncio\nasync def test_handler():\n    await handle(\"John\", 1)\n</code></pre> <p>But if you want to test your function closer to your real runtime, you should use the special FastStream test client.</p>"},{"location":"getting-started/subscription/test/#in-memory-testing","title":"In-Memory Testing","text":"<p>Deploying a whole service with a Message Broker is a bit too much just for testing purposes, especially in your CI environment. Not to mention the possible loss of messages due to network failures when working with real brokers.</p> <p>For this reason, FastStream has a special <code>TestClient</code> to make your broker work in <code>InMemory</code> mode.</p> <p>Just use it like a regular async context manager - all published messages will be routed in-memory (without any external dependencies) and consumed by the correct handler.</p> KafkaRabbitMQNATS <pre><code>import pytest\nfrom pydantic import ValidationError\n\nfrom faststream.kafka import TestKafkaBroker\n\nfrom .annotation_kafka import broker, handle\n\n\n@pytest.mark.asyncio\nasync def test_handle():\n    async with TestKafkaBroker(broker) as br:\n        await br.publish({\"name\": \"John\", \"user_id\": 1}, topic=\"test-topic\")\n</code></pre> <pre><code>import pytest\nfrom pydantic import ValidationError\n\nfrom faststream.rabbit import TestRabbitBroker\n\nfrom .annotation_rabbit import broker, handle\n\n\n@pytest.mark.asyncio\nasync def test_handle():\n    async with TestRabbitBroker(broker) as br:\n        await br.publish({\"name\": \"John\", \"user_id\": 1}, queue=\"test-queue\")\n</code></pre> <pre><code>import pytest\nfrom pydantic import ValidationError\n\nfrom faststream.nats import TestNatsBroker\n\nfrom .annotation_nats import broker, handle\n\n\n@pytest.mark.asyncio\nasync def test_handle():\n    async with TestNatsBroker(broker) as br:\n        await br.publish({\"name\": \"John\", \"user_id\": 1}, subject=\"test-subject\")\n</code></pre>"},{"location":"getting-started/subscription/test/#catching-exceptions","title":"Catching Exceptions","text":"<p>This way you can catch any exceptions that occur inside your handler:</p> KafkaRabbitMQNATS <pre><code>@pytest.mark.asyncio\nasync def test_validation_error():\n    async with TestKafkaBroker(broker) as br:\n        with pytest.raises(ValidationError):\n            await br.publish(\"wrong message\", topic=\"test-topic\")\n</code></pre> <pre><code>@pytest.mark.asyncio\nasync def test_validation_error():\n    async with TestRabbitBroker(broker) as br:\n        with pytest.raises(ValidationError):\n            await br.publish(\"wrong message\", queue=\"test-queue\")\n</code></pre> <pre><code>@pytest.mark.asyncio\nasync def test_validation_error():\n    async with TestNatsBroker(broker) as br:\n        with pytest.raises(ValidationError):\n            await br.publish(\"wrong message\", subject=\"test-subject\")\n</code></pre>"},{"location":"getting-started/subscription/test/#validates-input","title":"Validates Input","text":"<p>Also, your handler has a mock object to validate your input or call counts.</p> KafkaRabbitMQNATS <pre><code>@pytest.mark.asyncio\nasync def test_handle():\n    async with TestKafkaBroker(broker) as br:\n        await br.publish({\"name\": \"John\", \"user_id\": 1}, topic=\"test-topic\")\n\n        handle.mock.assert_called_once_with({\"name\": \"John\", \"user_id\": 1})\n</code></pre> <pre><code>@pytest.mark.asyncio\nasync def test_handle():\n    async with TestRabbitBroker(broker) as br:\n        await br.publish({\"name\": \"John\", \"user_id\": 1}, queue=\"test-queue\")\n\n        handle.mock.assert_called_once_with({\"name\": \"John\", \"user_id\": 1})\n</code></pre> <pre><code>@pytest.mark.asyncio\nasync def test_handle():\n    async with TestNatsBroker(broker) as br:\n        await br.publish({\"name\": \"John\", \"user_id\": 1}, subject=\"test-subject\")\n\n        handle.mock.assert_called_once_with({\"name\": \"John\", \"user_id\": 1})\n</code></pre> <p>Note</p> <p>The Handler mock has a not-serialized JSON message body. This way you can validate the incoming message view, not python arguments.</p> <p>Thus our example checks not <code>mock.assert_called_with(name=\"John\", user_id=1)</code>, but <code>mock.assert_called_with({ \"name\": \"John\", \"user_id\": 1 })</code>.</p> <p>You should be careful with this feature: all mock objects will be cleared when the context manager exits.</p> KafkaRabbitMQNATS <pre><code>@pytest.mark.asyncio\nasync def test_handle():\n    async with TestKafkaBroker(broker) as br:\n        await br.publish({\"name\": \"John\", \"user_id\": 1}, topic=\"test-topic\")\n\n        handle.mock.assert_called_once_with({\"name\": \"John\", \"user_id\": 1})\n\n    assert handle.mock.call_count == 0\n</code></pre> <pre><code>@pytest.mark.asyncio\nasync def test_handle():\n    async with TestRabbitBroker(broker) as br:\n        await br.publish({\"name\": \"John\", \"user_id\": 1}, queue=\"test-queue\")\n\n        handle.mock.assert_called_once_with({\"name\": \"John\", \"user_id\": 1})\n\n    assert handle.mock.call_count == 0\n</code></pre> <pre><code>@pytest.mark.asyncio\nasync def test_handle():\n    async with TestNatsBroker(broker) as br:\n        await br.publish({\"name\": \"John\", \"user_id\": 1}, subject=\"test-subject\")\n\n        handle.mock.assert_called_once_with({\"name\": \"John\", \"user_id\": 1})\n\n    assert handle.mock.call_count == 0\n</code></pre>"},{"location":"getting-started/subscription/test/#real-broker-testing","title":"Real Broker Testing","text":"<p>If you want to test your application in a real environment, you shouldn't have to rewrite all you tests: just pass <code>with_real</code> optional parameter to your <code>TestClient</code> context manager. This way, <code>TestClient</code> supports all the testing features but uses an unpatched broker to send and consume messages.</p> KafkaRabbitMQNATS <pre><code>import pytest\nfrom pydantic import ValidationError\n\nfrom faststream.kafka import TestKafkaBroker\n\nfrom .pydantic_fields_kafka import broker, handle\n\n\n@pytest.mark.asyncio\nasync def test_handle():\n    async with TestKafkaBroker(broker, with_real=True) as br:\n        await br.publish({\"name\": \"John\", \"user_id\": 1}, topic=\"test-topic\")\n        await handle.wait_call(timeout=3)\n        handle.mock.assert_called_once_with({\"name\": \"John\", \"user_id\": 1})\n\n    assert handle.mock.call_count == 0\n\n@pytest.mark.asyncio\nasync def test_validation_error():\n    async with TestKafkaBroker(broker, with_real=True) as br:\n        with pytest.raises(ValidationError):\n            await br.publish(\"wrong message\", topic=\"test-topic\")\n            await handle.wait_call(timeout=3)\n\n        handle.mock.assert_called_once_with(\"wrong message\")\n</code></pre> <pre><code>import pytest\nfrom pydantic import ValidationError\n\nfrom faststream.rabbit import TestRabbitBroker\n\nfrom .pydantic_fields_rabbit import broker, handle\n\n\n@pytest.mark.asyncio\nasync def test_handle():\n    async with TestRabbitBroker(broker, with_real=True) as br:\n        await br.publish({\"name\": \"John\", \"user_id\": 1}, queue=\"test-queue\")\n        await handle.wait_call(timeout=3)\n        handle.mock.assert_called_once_with({\"name\": \"John\", \"user_id\": 1})\n\n    assert handle.mock.call_count == 0\n\n@pytest.mark.asyncio\nasync def test_validation_error():\n    async with TestRabbitBroker(broker, with_real=True) as br:\n        with pytest.raises(ValidationError):\n            await br.publish(\"wrong message\", queue=\"test-queue\")\n            await handle.wait_call(timeout=3)\n\n        handle.mock.assert_called_once_with(\"wrong message\")\n</code></pre> <pre><code>import pytest\nfrom pydantic import ValidationError\n\nfrom faststream.nats import TestNatsBroker\n\nfrom .pydantic_fields_nats import broker, handle\n\n\n@pytest.mark.asyncio\nasync def test_handle():\n    async with TestNatsBroker(broker, with_real=True) as br:\n        await br.publish({\"name\": \"John\", \"user_id\": 1}, subject=\"test-subject\")\n        await handle.wait_call(timeout=3)\n        handle.mock.assert_called_once_with({\"name\": \"John\", \"user_id\": 1})\n\n    assert handle.mock.call_count == 0\n\n@pytest.mark.asyncio\nasync def test_validation_error():\n    async with TestNatsBroker(broker, with_real=True) as br:\n        with pytest.raises(ValidationError):\n            await br.publish(\"wrong message\", subject=\"test-subject\")\n            await handle.wait_call(timeout=3)\n\n        handle.mock.assert_called_once_with(\"wrong message\")\n</code></pre> <p>Tip</p> <p>When you're using a patched broker to test your consumers, the publish method is called synchronously with a consumer one, so you need not wait until your message is consumed. But in the real broker's case, it doesn't.</p> <p>For this reason, you have to wait for message consumption manually with the special <code>handler.wait_call(timeout)</code> method. Also, inner handler exceptions will be raised in this function, not <code>broker.publish(...)</code>.</p>"},{"location":"getting-started/subscription/test/#a-little-tip","title":"A Little Tip","text":"<p>It can be very helpful to set the <code>with_real</code> flag using an environment variable. This way, you will be able to choose the testing mode right from the command line:</p> <pre><code>WITH_REAL=True/False pytest tests/\n</code></pre> <p>To learn more about managing your application configiruation visit this page.</p>"},{"location":"getting-started/template/","title":"FastStream Template","text":"<p>FastStream Template is a versatile repository that provides a solid foundation for your Python projects. It comes with a basic application, testing infrastructure, linting scripts, and various development tools to kickstart your development process. Whether you're building a new application from scratch or want to enhance an existing one, this template will save you time and help you maintain high code quality.</p>"},{"location":"getting-started/template/#features","title":"Features","text":"<ul> <li> <p>Basic Application: FastStream Template includes a basic Python application as a starting point for your project. You can easily replace it with your own code.</p> </li> <li> <p>Testing Framework: We've set up <code>pytest</code> for running unit tests. Write your tests in the tests directory and use the provided workflow for automated testing.</p> </li> <li> <p>Linting: Keep your code clean and consistent with linting tools. The repository includes linting scripts and configurations for <code>mypy</code>, <code>black</code>, <code>ruff</code> and <code>bandit</code></p> </li> <li> <p>Docker Support: The included Dockerfile allows you to containerize your <code>FastStream</code> application. Build and run your application in a containerized environment with ease.</p> </li> <li> <p>Dependency Management: All application requirements and development dependencies are specified in the <code>pyproject.toml</code> file. This includes not only your project's dependencies but also configurations for various tools like <code>pytest</code>, <code>mypy</code>, <code>black</code>, <code>ruff</code>, and <code>bandit</code>.</p> </li> <li> <p>Continuous Integration (CI): FastStream Template comes with three GitHub Actions workflows under the <code>.github/workflows</code> directory:</p> </li> <li> <p>Static Analysis and Testing: This workflow consists of two jobs. The first job runs static analysis tools (<code>mypy</code> and <code>bandit</code>) to check your code for potential issues. If successful, the second job runs <code>pytest</code> to execute your test suite.</p> </li> <li> <p>Docker Build and Push: This workflow automates the process of building a <code>Docker</code> image for your <code>FastStream</code> application and pushing it to the GitHub Container Registry.</p> </li> <li> <p>AsyncAPI Documentation: The third workflow builds <code>AsyncAPI</code> documentation for your <code>FastStream</code> application and deploys it to GitHub Pages. This is useful for documenting your API and making it accessible to others.</p> </li> </ul>"},{"location":"getting-started/template/#getting-started","title":"Getting Started","text":"<p>To set up your development environment, follow these steps:</p> <ol> <li> <p>In the FastStream Template repository, click on Use this template -&gt; Create a new repository:    In the next screen, fill out details such as repository name, description, etc:</p> </li> <li> <p>Clone this repository to your local machine:    <pre><code>git clone https://github.com/&lt;username&gt;/&lt;repo-name&gt;.git\ncd &lt;repo-name&gt;\n</code></pre></p> <p>NOTE: Replace <code>&lt;username&gt;</code> with your GitHub username and <code>&lt;repo-name&gt;</code> with the name of your repository.</p> </li> <li> <p>Install all development requirements using pip:    <pre><code>pip install -e \".[dev]\"\n</code></pre></p> </li> </ol>"},{"location":"getting-started/template/#development","title":"Development","text":"<p>The application code is located in the <code>app/</code> directory. You can add new features or fix bugs in this directory. However, remember that code changes must be accompanied by corresponding updates to the tests located in the <code>tests/</code> directory.</p>"},{"location":"getting-started/template/#running-tests","title":"Running Tests","text":"<p>Once you have updated tests, you can execute the tests using <code>pytest</code>:</p> <pre><code>pytest\n</code></pre>"},{"location":"getting-started/template/#running-faststream-application-locally","title":"Running FastStream Application Locally","text":"<p>To run the <code>FastStream</code> application locally, follow these steps:</p> <ol> <li> <p>Start the Kafka Docker container locally using the provided script:    <pre><code>./scripts/start_kafka_broker_locally.sh\n</code></pre></p> </li> <li> <p>Start the <code>FastStream</code> application with the following command:    <pre><code>faststream run app.application:app --workers 1\n</code></pre></p> </li> <li> <p>You can now send messages to the Kafka topic and can test the application. Optionally, if you want to view messages in a topic, you can subscribe to it using the provided script:    <pre><code>./scripts/subscribe_to_kafka_broker_locally.sh &lt;topic_name&gt;\n</code></pre></p> </li> <li> <p>To stop the <code>FastStream</code> application, press <code>Ctrl+C</code>.</p> </li> <li> <p>Finally, stop the Kafka Docker container by running the script:    <pre><code>./scripts/stop_kafka_broker_locally.sh\n</code></pre></p> </li> </ol>"},{"location":"getting-started/template/#building-and-testing-docker-image-locally","title":"Building and Testing Docker Image Locally","text":"<p>If you'd like to build and test the <code>Docker</code> image locally, follow these steps:</p> <ol> <li> <p>Run the provided script to build the <code>Docker</code> image locally. Use the following command:    <pre><code>./scripts/build_docker.sh &lt;username&gt; &lt;repo-name&gt;\n</code></pre>    This script will build the <code>Docker</code> image locally with the same name as the one built in <code>CI</code>.</p> </li> <li> <p>Before starting the <code>Docker</code> container, ensure that a Kafka <code>Docker</code> container is running locally. You can start it using the provided script:    <pre><code>./scripts/start_kafka_broker_locally.sh\n</code></pre></p> </li> <li> <p>Once Kafka is up and running, you can start the local <code>Docker</code> container using the following command:    <pre><code>docker run --rm --name faststream-app --net=host ghcr.io/&lt;username&gt;/&lt;repo-name&gt;:latest\n</code></pre> <code>--rm</code>: This flag removes the container once it stops running, ensuring that it doesn't clutter your system with unused containers.    <code>--name faststream-app</code>: Assigns a name to the running container, in this case, \"faststream-app\".    <code>--net=host</code>: This flag allows the <code>Docker</code> container to share the host's network namespace.</p> </li> <li> <p>To stop the local <code>Docker</code> container, simply press <code>Ctrl+C</code> in your terminal.</p> </li> <li> <p>Finally, stop the Kafka <code>Docker</code> container by running the provided script:    <pre><code>./scripts/stop_kafka_broker_locally.sh\n</code></pre></p> </li> </ol> <p>NOTE: Replace <code>&lt;username&gt;</code> with your GitHub username and <code>&lt;repo-name&gt;</code> with the name of your repository in the above commands.</p>"},{"location":"getting-started/template/#code-linting","title":"Code Linting","text":"<p>After making changes to the code, it's essential to ensure it adheres to coding standards. We provide a script to help you with code formatting and linting. Run the following script to automatically fix linting issues:</p> <pre><code>./scripts/lint.sh\n</code></pre>"},{"location":"getting-started/template/#static-analysis","title":"Static Analysis","text":"<p>Static analysis tools <code>mypy</code> and <code>bandit</code> can help identify potential issues in your code. To run static analysis, use the following script:</p> <pre><code>./scripts/static-analysis.sh\n</code></pre> <p>If there are any static analysis errors, resolve them in your code and rerun the script until it passes successfully.</p>"},{"location":"getting-started/template/#viewing-asyncapi-documentation","title":"Viewing AsyncAPI Documentation","text":"<p><code>FastStream</code> framework supports <code>AsyncAPI</code> documentation. To ensure that your changes are reflected in the <code>AsyncAPI</code> documentation, follow these steps:</p> <ol> <li> <p>Run the following command to view the <code>AsyncAPI</code> documentation:    <pre><code>faststream docs serve app.application:app\n</code></pre>    This command builds the <code>AsyncAPI</code> specification file, generates <code>AsyncAPI</code> documentation based on the specification, and serves it at <code>localhost:8000</code>.</p> </li> <li> <p>Open your web browser and navigate to http://localhost:8000 to view the <code>AsyncAPI</code> documentation reflecting your changes.</p> </li> <li> <p>To stop the <code>AsyncAPI</code> documentation server, press <code>Ctrl+C</code>.</p> </li> </ol>"},{"location":"getting-started/template/#contributing","title":"Contributing","text":"<p>Once you have successfully completed all the above steps, you are ready to contribute your changes:</p> <ol> <li> <p>Add and commit your changes:    <pre><code>git add .\ngit commit -m \"Your commit message\"\n</code></pre></p> </li> <li> <p>Push your changes to GitHub:    <pre><code>git push origin your-branch\n</code></pre></p> </li> <li> <p>Create a merge request on GitHub.</p> </li> </ol>"},{"location":"getting-started/template/#continuous-integration-ci","title":"Continuous Integration (CI)","text":"<p>This repository is equipped with GitHub Actions that automate static analysis and pytest in the CI pipeline. Even if you forget to perform any of the required steps, CI will catch any issues before merging your changes.</p> <p>This repository has three workflows, each triggered when code is pushed:</p> <ol> <li> <p>Tests Workflow: This workflow is named \"Tests\" and consists of two jobs. The first job runs static analysis tools <code>mypy</code> and <code>bandit</code> to identify potential issues in the codebase. The second job runs tests using <code>pytest</code> to ensure the functionality of the application. Both jobs run simultaneously to expedite the <code>CI</code> process.</p> </li> <li> <p>Build Docker Image Workflow: This workflow is named \"Build Docker Image\" and has one job. In this job, a <code>Docker</code> image is built based on the provided Dockerfile. The built image is then pushed to the GitHub Container Registry, making it available for deployment or other purposes.</p> </li> <li> <p>Deploy FastStream AsyncAPI Docs Workflow: The final workflow is named \"Deploy FastStream AsyncAPI Docs\" and also consists of a single job. In this job, the <code>AsyncAPI</code> documentation is built from the specification, and the resulting documentation is deployed to GitHub Pages. This allows for easy access and sharing of the <code>AsyncAPI</code> documentation with the project's stakeholders.</p> </li> </ol>"},{"location":"getting-started/template/#viewing-asyncapi-documentation-hosted-at-github-pages","title":"Viewing AsyncAPI Documentation Hosted at GitHub Pages","text":"<p>After the Deploy FastStream AsyncAPI Docs workflow in <code>CI</code> has been successfully completed, the <code>AsyncAPI</code> documentation is automatically deployed to GitHub Pages. This provides a convenient way to access and share the documentation with project stakeholders.</p> <p>To view the deployed <code>AsyncAPI</code> documentation, open your web browser and navigate to the following URL:</p> <pre><code>https://&lt;username&gt;.github.io/&lt;repo-name&gt;/\n</code></pre> <p>NOTE: Replace <code>&lt;username&gt;</code> with your GitHub username and <code>&lt;repo-name&gt;</code> with the name of your repository.</p> <p>You will be directed to the GitHub Pages site where your <code>AsyncAPI</code> documentation is hosted. This hosted documentation allows you to easily share your <code>AsyncAPI</code> specifications with others and provides a centralized location for reviewing the <code>AsyncAPI</code> documentation.</p>"},{"location":"getting-started/template/#deploying-docker-container","title":"Deploying Docker Container","text":"<p>Once the Build Docker Image workflow in <code>CI</code> has successfully completed, the built <code>Docker</code> image is pushed to the GitHub Container Registry. You can then deploy this image on your server by following these steps:</p> <ol> <li> <p>Pull the <code>Docker</code> image from the GitHub Container Registry to your server using the following command:    <pre><code>docker pull ghcr.io/&lt;username&gt;/&lt;repo-name&gt;:latest\n</code></pre></p> <p>NOTE: Replace <code>&lt;username&gt;</code> with your GitHub username and <code>&lt;repo-name&gt;</code> with the name of your repository.</p> </li> <li> <p>After successfully pulling the image, start the <code>Docker</code> container using the following command:    <pre><code>docker run --rm --name faststream-app --env-file /path/to/env-file ghcr.io/&lt;username&gt;/&lt;repo-name&gt;:latest\n</code></pre> <code>--rm</code>: This flag removes the container once it stops running, ensuring that it doesn't clutter your system with unused containers.    <code>--name faststream-app</code>: Assigns a name to the running container, in this case, \"faststream-app\".    <code>--env-file /path/to/env-file</code>: Specifies the path to an environment file (commonly a <code>.env</code> file) that contains environment variables required by your <code>FastStream</code> application. Storing secrets and configuration in an environment file is a secure and best practice for handling sensitive information such as Kafka host, port, and authentication details.</p> </li> </ol> <p>By following these steps, you can easily deploy your <code>FastStream</code> application as a <code>Docker</code> container on your server. Remember to customize the <code>env-file</code> and other environment variables as needed to suit your specific application requirements.</p>"},{"location":"kafka/","title":"Kafka Routing","text":""},{"location":"kafka/#kafka-overview","title":"Kafka Overview","text":""},{"location":"kafka/#what-is-kafka","title":"What is Kafka?","text":"<p>Kafka is an open-source distributed streaming platform developed by the Apache Software Foundation. It is designed to handle high-throughput, fault-tolerant, real-time data streaming. Kafka is widely used for building real-time data pipelines and streaming applications.</p>"},{"location":"kafka/#key-kafka-concepts","title":"Key Kafka Concepts","text":""},{"location":"kafka/#1-publish-subscribe-model","title":"1. Publish-Subscribe Model","text":"<p>Kafka is built around the publish-subscribe messaging model. In this model, data is published to topics, and multiple consumers can subscribe to these topics to receive the data. This decouples the producers of data from the consumers, allowing for flexibility and scalability.</p>"},{"location":"kafka/#2-topics","title":"2. Topics","text":"<p>A topic in Kafka is a logical channel or category to which messages are published by producers and from which messages are consumed by consumers. Topics are used to organize and categorize data streams. Each topic can have multiple partitions, which enable Kafka to distribute data and provide parallelism for both producers and consumers.</p>"},{"location":"kafka/#kafka-topics","title":"Kafka Topics","text":""},{"location":"kafka/#understanding-kafka-topics","title":"Understanding Kafka Topics","text":"<p>Topics are fundamental to Kafka and serve as the central point of data distribution. Here are some key points about topics:</p> <ul> <li>Topics allow you to logically group and categorize messages.</li> <li>Each message sent to Kafka is associated with a specific topic.</li> <li>Topics can have one or more partitions to enable parallel processing and scaling.</li> <li>Consumers subscribe to topics to receive messages.</li> </ul>"},{"location":"kafka/#faststream-kafkabroker","title":"FastStream KafkaBroker","text":"<p>The FastStream KafkaBroker is a key component of the FastStream framework that enables seamless integration with Apache Kafka. With the KafkaBroker, developers can easily connect to Kafka brokers, produce messages to Kafka topics, and consume messages from Kafka topics within their FastStream applications.</p>"},{"location":"kafka/#establishing-a-connection","title":"Establishing a Connection","text":"<p>To connect to Kafka using the FastStream KafkaBroker module, follow these steps:</p> <ol> <li> <p>Initialize the KafkaBroker instance: Start by initializing a KafkaBroker instance with the necessary configuration, including Kafka broker address.</p> </li> <li> <p>Create your processing logic: Write a function that will consume the incoming messages in the defined format and produce a response to the defined topic</p> </li> <li> <p>Decorate your processing function: To connect your processing function to the desired Kafka topics you need to decorate it with <code>@broker.subscriber</code> and <code>@broker.publisher</code> decorators. Now, after you start your application, your processing function will be called whenever a new message in the subscribed topic is available and produce the function return value to the topic defined in the publisher decorator.</p> </li> </ol> <p>Here's a simplified code example demonstrating how to establish a connection to Kafka using FastStream's KafkaBroker module:</p> <pre><code>from faststream import FastStream\nfrom faststream.kafka import KafkaBroker\n\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\n\n@broker.subscriber(\"in-topic\")\n@broker.publisher(\"out-topic\")\nasync def handle_msg(user: str, user_id: int) -&gt; str:\n    return f\"User: {user_id} - {user} registered\"\n</code></pre> <p>This minimal example illustrates how FastStream simplifies the process of connecting to Kafka and performing basic message processing from the in_topic to the out-topic. Depending on your specific use case and requirements, you can further customize your Kafka integration with FastStream to build robust and efficient streaming applications.</p> <p>For more advanced configuration options and detailed usage instructions, please refer to the FastStream Kafka documentation and the offical Kafka documentation.</p>"},{"location":"kafka/message/","title":"Access to Message Information","text":"<p>As you may know, FastStream serializes a message body and provides you access to it through function arguments. However, there are times when you need to access additional message attributes such as offsets, headers, or other metadata.</p>"},{"location":"kafka/message/#message-access","title":"Message Access","text":"<p>You can easily access this information by referring to the message object in the Context!</p> <p>This object serves as a unified FastStream wrapper around the native broker library message (for example, <code>aiokafka.ConsumerRecord</code> in the case of Kafka). It contains most of the required information, including:</p> <ul> <li><code>body: bytes</code></li> <li><code>checksum: int</code></li> <li><code>headers: Sequence[Tuple[str, bytes]]</code></li> <li><code>key: Optional[aiokafka.structs.KT]</code></li> <li><code>offset: int</code></li> <li><code>partition: int</code></li> <li><code>serialized_key_size: int</code></li> <li><code>serialized_value_size: int</code></li> <li><code>timestamp: int</code></li> <li><code>timestamp_type: int</code></li> <li><code>topic: str</code></li> <li><code>value: Optional[aiokafka.structs.VT]</code></li> </ul> <p>For example, if you would like to access the headers of an incoming message, you would do so like this:</p> <pre><code>from faststream.kafka.annotations import KafkaMessage\n\n@broker.subscriber(\"test\")\nasync def base_handler(\n    body: str,\n    msg: KafkaMessage,\n):\n    print(msg.headers)\n</code></pre>"},{"location":"kafka/message/#message-fields-access","title":"Message Fields Access","text":"<p>In most cases, you don't need all message fields; you need to know just a part of them. You can use Context Fields access feature for this.</p> <p>For example, you can get access to the <code>headers</code> like this:</p> <pre><code>from faststream import Context\n\n@broker.subscriber(\"test\")\nasync def base_handler(\n    body: str,\n    headers: str = Context(\"message.headers\"),\n):\n    print(headers)\n</code></pre>"},{"location":"kafka/Publisher/","title":"Publishing","text":"<p>The FastStream KafkaBroker supports all regular publishing use cases, and you can use them without any changes.</p> <p>However, if you wish to further customize the publishing logic, you should take a closer look at specific KafkaBroker parameters.</p>"},{"location":"kafka/Publisher/#basic-kafka-publishing","title":"Basic Kafka Publishing","text":"<p>The <code>KafkaBroker</code> uses the unified <code>publish</code> method (from a <code>producer</code> object) to send messages.</p> <p>In this case, you can use Python primitives and <code>pydantic.BaseModel</code> to define the content of the message you want to publish to the Kafka broker.</p> <p>You can specify the topic to send by its name.</p> <ol> <li>Create your KafkaBroker instance</li> </ol> <pre><code>broker = KafkaBroker(\"localhost:9092\")\n</code></pre> <ol> <li>Publish a message using the <code>publish</code> method</li> </ol> <pre><code>        msg = Data(data=0.5)\n\n        await broker.publish(\n            model_to_json(msg),\n            \"input_data\",\n            headers={\"content-type\": \"application/json\"},\n        )\n</code></pre> <p>This is the most basic way of using the KafkaBroker to publish a message.</p>"},{"location":"kafka/Publisher/#creating-a-publisher-object","title":"Creating a publisher object","text":"<p>The simplest way to use a KafkaBroker for publishing has a significant limitation: your publishers won't be documented in the AsyncAPI documentation. This might be acceptable for sending occasional one-off messages. However, if you're building a comprehensive service, it's recommended to create publisher objects. These objects can then be parsed and documented in your service's AsyncAPI documentation. Let's go ahead and create those publisher objects!</p> <ol> <li>Create your KafkaBroker instance</li> </ol> <pre><code>broker = KafkaBroker(\"localhost:9092\")\n</code></pre> <ol> <li>Create a publisher instance</li> </ol> <pre><code>prepared_publisher = broker.publisher(\"input_data\")\n</code></pre> <ol> <li>Publish a message using the <code>publish</code> method of the prepared publisher</li> </ol> <pre><code>        msg = Data(data=0.5)\n\n        await prepared_publisher.publish(\n            model_to_json(msg),\n            headers={\"content-type\": \"application/json\"},\n        )\n</code></pre> <p>Now, when you wrap your broker into a FastStream object, the publisher will be exported to the AsyncAPI documentation.</p>"},{"location":"kafka/Publisher/#decorating-your-publishing-functions","title":"Decorating your publishing functions","text":"<p>To publish messages effectively in the Kafka context, consider utilizing the Publisher Decorator. This approach offers an AsyncAPI representation and is ideal for rapidly developing applications.</p> <p>The Publisher Decorator creates a structured DataPipeline unit with both input and output components. The sequence in which you apply Subscriber and Publisher decorators does not affect their functionality. However, note that these decorators can only be applied to functions decorated by a Subscriber as well.</p> <p>This method relies on the return type annotation of the handler function to properly interpret the function's return value before sending it. Hence, it's important to ensure accuracy in defining the return type.</p> <p>Let's start by examining the entire application that utilizes the Publisher Decorator and then proceed to walk through it step by step.</p> <pre><code>from pydantic import BaseModel, Field, NonNegativeFloat\n\nfrom faststream import FastStream\nfrom faststream.kafka import KafkaBroker\n\n\nclass Data(BaseModel):\n    data: NonNegativeFloat = Field(\n        ..., examples=[0.5], description=\"Float data example\"\n    )\n\n\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\n\n\nto_output_data = broker.publisher(\"output_data\")\n\n\n@to_output_data\n@broker.subscriber(\"input_data\")\nasync def on_input_data(msg: Data) -&gt; Data:\n    return Data(data=msg.data + 1.0)\n</code></pre> <ol> <li>Initialize the KafkaBroker instance: Start by initializing a KafkaBroker instance with the necessary configuration, including Kafka broker address.</li> </ol> <pre><code>broker = KafkaBroker(\"localhost:9092\")\n</code></pre> <ol> <li>Prepare your publisher object to use later as a decorator:</li> </ol> <pre><code>to_output_data = broker.publisher(\"output_data\")\n</code></pre> <ol> <li>Create your processing logic: Write a function that will consume the incoming messages in the defined format and produce a response to the defined topic</li> </ol> <pre><code>async def on_input_data(msg: Data) -&gt; Data:\n    return Data(data=msg.data + 1.0)\n</code></pre> <ol> <li>Decorate your processing function: To connect your processing function to the desired Kafka topics you need to decorate it with <code>@broker.subscriber</code> and <code>@broker.publisher</code> decorators. Now, after you start your application, your processing function will be called whenever a new message in the subscribed topic is available and produce the function return value to the topic defined in the publisher decorator.</li> </ol> <pre><code>@to_output_data\n@broker.subscriber(\"input_data\")\nasync def on_input_data(msg: Data) -&gt; Data:\n    return Data(data=msg.data + 1.0)\n</code></pre>"},{"location":"kafka/Publisher/batch_publisher/","title":"Publishing in Batches","text":""},{"location":"kafka/Publisher/batch_publisher/#general-overview","title":"General overview","text":"<p>If you need to send your data in batches, the @broker.publisher(...) decorator offers a convenient way to achieve this. To enable batch production, you need to perform two crucial steps:</p> <p>Step 1: When creating your publisher, set the batch argument to True. This configuration tells the publisher that you intend to send messages in batches.</p> <p>Step 2: In your producer function, return a tuple containing the messages you want to send as a batch. This action triggers the producer to gather the messages and transmit them as a batch to a Kafka broker.</p> <p>Let's delve into a detailed example illustrating how to produce messages in batches to the output_data topic while consuming from the input_data_1 topic.</p>"},{"location":"kafka/Publisher/batch_publisher/#code-example","title":"Code example","text":"<p>First, lets take a look at the whole app creation and then dive deep into the steps for producing in batches, here is the application code:</p> <pre><code>from typing import Tuple\n\nfrom pydantic import BaseModel, Field, NonNegativeFloat\n\nfrom faststream import FastStream, Logger\nfrom faststream.kafka import KafkaBroker\n\n\nclass Data(BaseModel):\n    data: NonNegativeFloat = Field(\n        ..., examples=[0.5], description=\"Float data example\"\n    )\n\n\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\n\n\ndecrease_and_increase = broker.publisher(\"output_data\", batch=True)\n\n\n@decrease_and_increase\n@broker.subscriber(\"input_data_1\")\nasync def on_input_data_1(msg: Data, logger: Logger) -&gt; Tuple[Data, Data]:\n    logger.info(msg)\n    return Data(data=(msg.data * 0.5)), Data(data=(msg.data * 2.0))\n\n\n@broker.subscriber(\"input_data_2\")\nasync def on_input_data_2(msg: Data, logger: Logger) -&gt; None:\n    logger.info(msg)\n    await decrease_and_increase.publish(\n        Data(data=(msg.data * 0.5)), Data(data=(msg.data * 2.0))\n    )\n</code></pre> <p>Below, we have highlighted key lines of code that demonstrate the steps involved in creating and using a batch publisher:</p> <p>Step 1: Creation of the Publisher</p> <pre><code>decrease_and_increase = broker.publisher(\"output_data\", batch=True)\n</code></pre> <p>Step 2: Publishing an Actual Batch of Messages</p> <p>You can publish a batch by directly calling the publisher with a batch of messages you want to publish, like shown here:</p> <pre><code>    await decrease_and_increase.publish(\n        Data(data=(msg.data * 0.5)), Data(data=(msg.data * 2.0))\n    )\n</code></pre> <p>Or you can decorate your processing function and return a batch of messages like shown here:</p> <pre><code>@decrease_and_increase\n@broker.subscriber(\"input_data_1\")\nasync def on_input_data_1(msg: Data, logger: Logger) -&gt; Tuple[Data, Data]:\n    logger.info(msg)\n    return Data(data=(msg.data * 0.5)), Data(data=(msg.data * 2.0))\n</code></pre> <p>The application in the example imelements both of these ways, feel free to use whatever option fits your needs better.</p>"},{"location":"kafka/Publisher/batch_publisher/#why-publish-in-batches","title":"Why publish in batches?","text":"<p>In this example, we've explored how to leverage the @broker.publisher decorator to efficiently publish messages in batches using FastStream and Kafka. By following the two key steps outlined in the previous sections, you can significantly enhance the performance and reliability of your Kafka-based applications.</p> <p>Publishing messages in batches offers several advantages when working with Kafka:</p> <ol> <li> <p>Improved Throughput: Batch publishing allows you to send multiple messages in a single transmission, reducing the overhead associated with individual message delivery. This leads to improved throughput and lower latency in your Kafka applications.</p> </li> <li> <p>Reduced Network and Broker Load: Sending messages in batches reduces the number of network calls and broker interactions. This optimization minimizes the load on the Kafka brokers and network resources, making your Kafka cluster more efficient.</p> </li> <li> <p>Atomicity: Batches ensure that a group of related messages is processed together or not at all. This atomicity can be crucial in scenarios where message processing needs to maintain data consistency and integrity.</p> </li> <li> <p>Enhanced Scalability: With batch publishing, you can efficiently scale your Kafka applications to handle high message volumes. By sending messages in larger chunks, you can make the most of Kafka's parallelism and partitioning capabilities.</p> </li> </ol>"},{"location":"kafka/Publisher/using_a_key/","title":"Using a Partition Key","text":"<p>Partition keys are a crucial concept in Apache Kafka, enabling you to determine the appropriate partition for a message. This ensures that related messages are kept together in the same partition, which can be invaluable for maintaining order or grouping related messages for efficient processing. Additionally, Kafka utilizes partitioning to distribute load across multiple brokers and scale horizontally, while replicating data across brokers provides fault tolerance.</p> <p>You can specify your partition keys when utilizing the <code>@KafkaBroker.publisher(...)</code> decorator in FastStream. This guide will walk you through the process of using partition keys effectively.</p>"},{"location":"kafka/Publisher/using_a_key/#publishing-with-a-partition-key","title":"Publishing with a Partition Key","text":"<p>To publish a message to a Kafka topic using a partition key, follow these steps:</p>"},{"location":"kafka/Publisher/using_a_key/#step-1-define-the-publisher","title":"Step 1: Define the Publisher","text":"<p>In your FastStream application, define the publisher using the <code>@KafkaBroker.publisher(...)</code> decorator. This decorator allows you to configure various aspects of message publishing, including the partition key.</p> <pre><code>to_output_data = broker.publisher(\"output_data\")\n</code></pre>"},{"location":"kafka/Publisher/using_a_key/#step-2-pass-the-key","title":"Step 2: Pass the Key","text":"<p>When you're ready to publish a message with a specific key, simply include the <code>key</code> parameter in the <code>publish</code> function call. This key parameter is used to determine the appropriate partition for the message.</p> <pre><code>    await to_output_data.publish(Data(data=msg.data + 1.0), key=b\"key\")\n</code></pre>"},{"location":"kafka/Publisher/using_a_key/#example-application","title":"Example Application","text":"<p>Let's examine a complete application example that consumes messages from the input_data topic and publishes them with a specified key to the output_data topic. This example will illustrate how to incorporate partition keys into your Kafka-based applications:</p> <pre><code>from pydantic import BaseModel, Field, NonNegativeFloat\n\nfrom faststream import Context, FastStream, Logger\nfrom faststream.kafka import KafkaBroker\n\n\nclass Data(BaseModel):\n    data: NonNegativeFloat = Field(\n        ..., examples=[0.5], description=\"Float data example\"\n    )\n\n\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\n\n\nto_output_data = broker.publisher(\"output_data\")\n\n\n@broker.subscriber(\"input_data\")\nasync def on_input_data(\n    msg: Data, logger: Logger, key: bytes = Context(\"message.raw_message.key\")\n) -&gt; None:\n    logger.info(f\"on_input_data({msg=})\")\n    await to_output_data.publish(Data(data=msg.data + 1.0), key=b\"key\")\n</code></pre> <p>As you can see, the primary difference from standard publishing is the inclusion of the <code>key</code> parameter in the <code>publish</code> call. This key parameter is essential for controlling how Kafka partitions and processes your messages.</p> <p>In summary, using partition keys in Apache Kafka is a fundamental practice for optimizing message distribution, maintaining order, and achieving efficient processing. It is a key technique for ensuring that your Kafka-based applications scale gracefully and handle large volumes of data effectively.</p>"},{"location":"kafka/Subscriber/","title":"Basic Subscriber","text":"<p>To start consuming from a Kafka topic, just decorate your consuming function with a <code>@broker.subscriber(...)</code> decorator, passing a string as a topic key.</p> <p>In the folowing example, we will create a simple FastStream app that will consume <code>HelloWorld</code> messages from a hello_world topic.</p> <p>The full app code looks like this:</p> <pre><code>from pydantic import BaseModel, Field\n\nfrom faststream import FastStream, Logger\nfrom faststream.kafka import KafkaBroker\n\n\nclass HelloWorld(BaseModel):\n    msg: str = Field(\n        ...,\n        examples=[\"Hello\"],\n        description=\"Demo hello world message\",\n    )\n\n\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\n\n\n@broker.subscriber(\"hello_world\")\nasync def on_hello_world(msg: HelloWorld, logger: Logger):\n    logger.info(msg)\n</code></pre>"},{"location":"kafka/Subscriber/#import-faststream-and-kafkabroker","title":"Import FastStream and KafkaBroker","text":"<p>To use the <code>@broker.subscriber(...)</code> decorator, first we need to import the base FastStream app KafkaBroker to create our broker.</p> <pre><code>from faststream import FastStream, Logger\nfrom faststream.kafka import KafkaBroker\n</code></pre>"},{"location":"kafka/Subscriber/#define-the-helloworld-message-structure","title":"Define the HelloWorld Message Structure","text":"<p>Next, you need to define the structure of the messages you want to consume from the topic using Pydantic. For the guide, we\u2019ll stick to something basic, but you are free to define any complex message structure you wish in your project.</p> <pre><code>class HelloWorld(BaseModel):\n    msg: str = Field(\n        ...,\n        examples=[\"Hello\"],\n        description=\"Demo hello world message\",\n    )\n</code></pre>"},{"location":"kafka/Subscriber/#create-a-kafkabroker","title":"Create a KafkaBroker","text":"<p>Next, we will create a <code>KafkaBroker</code> object and wrap it into the <code>FastStream</code> object so that we can start our app using CLI later.</p> <pre><code>broker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\n</code></pre>"},{"location":"kafka/Subscriber/#create-a-function-that-will-consume-messages-from-a-kafka-hello-world-topic","title":"Create a Function that will Consume Messages from a Kafka hello-world Topic","text":"<p>Let\u2019s create a consumer function that will consume <code>HelloWorld</code> messages from hello_world topic and log them.</p> <pre><code>@broker.subscriber(\"hello_world\")\nasync def on_hello_world(msg: HelloWorld, logger: Logger):\n    logger.info(msg)\n</code></pre> <p>The function decorated with the <code>@broker.subscriber(...)</code> decorator will be called when a message is produced to Kafka.</p> <p>The message will then be injected into the typed <code>msg</code> argument of the function, and its type will be used to parse the message.</p> <p>In this example case, when the message is sent to a hello_world topic, it will be parsed into a <code>HelloWorld</code> class, and the <code>on_hello_world</code> function will be called with the parsed class as the <code>msg</code> argument value.</p>"},{"location":"kafka/Subscriber/batch_subscriber/","title":"Batch Subscriber","text":"<p>If you want to consume data in batches, the <code>@broker.subscriber(...)</code> decorator makes it possible. By defining your consumed <code>msg</code> object as a list of messages and setting the <code>batch</code> parameter to <code>True</code>, the subscriber will call your consuming function with a batch of messages consumed from a single partition. Let's walk through how to achieve this.</p>"},{"location":"kafka/Subscriber/batch_subscriber/#using-the-subscriber-with-batching","title":"Using the Subscriber with Batching","text":"<p>To consume messages in batches, follow these steps:</p>"},{"location":"kafka/Subscriber/batch_subscriber/#step-1-define-your-subscriber","title":"Step 1: Define Your Subscriber","text":"<p>In your FastStream application, define the subscriber using the <code>@broker.subscriber(...)</code> decorator. Ensure that you configure the <code>msg</code> object as a list and set the <code>batch</code> parameter to <code>True</code>. This configuration tells the subscriber to handle message consumption in batches.</p> <pre><code>@broker.subscriber(\"test_batch\", batch=True)\n</code></pre>"},{"location":"kafka/Subscriber/batch_subscriber/#step-2-implement-your-consuming-function","title":"Step 2: Implement Your Consuming Function","text":"<p>Create a consuming function that accepts the list of messages. The <code>@broker.subscriber(...)</code> decorator will take care of collecting and grouping messages into batches based on the partition.</p> <pre><code>@broker.subscriber(\"test_batch\", batch=True)\nasync def handle_batch(msg: List[HelloWorld], logger: Logger):\n    logger.info(msg)\n</code></pre>"},{"location":"kafka/Subscriber/batch_subscriber/#example-of-consuming-in-batches","title":"Example of Consuming in Batches","text":"<p>Let's illustrate how to consume messages in batches from the test_batch topic with a practical example:</p> <pre><code>from typing import List\n\nfrom pydantic import BaseModel, Field\n\nfrom faststream import FastStream, Logger\nfrom faststream.kafka import KafkaBroker\n\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\n\n\nclass HelloWorld(BaseModel):\n    msg: str = Field(\n        ...,\n        examples=[\"Hello\"],\n        description=\"Demo hello world message\",\n    )\n\n\n@broker.subscriber(\"test_batch\", batch=True)\nasync def handle_batch(msg: List[HelloWorld], logger: Logger):\n    logger.info(msg)\n</code></pre> <p>In this example, the subscriber is configured to process messages in batches, and the consuming function is designed to handle these batches efficiently.</p> <p>Consuming messages in batches is a valuable technique when you need to optimize the processing of high volumes of data in your Kafka-based applications. It allows for more efficient resource utilization and can enhance the overall performance of your data pipelines.</p>"},{"location":"nats/","title":"NATS","text":"<p>FastStream NATS support is implemented on top of nats-py. You can always get access to objects of it if you need to use some low-level methods not represented in FastStream.</p>"},{"location":"nats/#advantages-and-disadvantages","title":"Advantages and Disadvantages","text":"<p>NATS is an easy-to-use, high-performance message broker written in Golang. If your application does not require complex routing logic, can cope with high loads, scales, and does not require large hardware costs, NATS will be an excellent choice for you.</p> <p>Also NATS has a zero-cost new entities creation (to be honest, all <code>subjects</code> are just routing fields), so it can be used as a RPC over MQ tool.</p> <p>Note</p> <p>More information about NATS can be found on the official website.</p> <p>However, NATS has disadvantages that you should be aware of:</p> <ul> <li>Messages are not persistent. If a message is published while your consumer is disconnected, it will be lost.</li> <li>There are no complex routing mechanisms.</li> <li>There are no mechanisms for confirming receipt and processing of messages from the consumer.</li> </ul>"},{"location":"nats/#nats-jetstream","title":"NATS JetStream","text":"<p>These shortcomings are corrected by using the persistent level - JetStream. If you need strict guarantees for the delivery and processing of messages at the small detriment of speed and resources consumed, you can use NatsJS.</p> <p>Also, NatsJS supports some high-level features like Key-Value and Object storages (with subscription to changes on it) and provides you with rich abilities to build your logic on top of it.</p>"},{"location":"nats/#routing-rules","title":"Routing Rules","text":"<p>NATS does not have the ability to configure complex routing rules. The only entity in NATS is <code>subject</code>, which can be subscribed to either directly by name or by a regular expression pattern.</p> <p>Both examples are discussed a little further.</p> <p>In order to support the ability to scale consumers horizontally, NATS supports the <code>queue group</code> functionality: a message sent to <code>subject</code> will be processed by a random consumer from the <code>queue group</code> subscribed to this <code>subject</code>. This approach allows you to increase the processing speed of <code>subject</code> by N times when starting N consumers with one group.</p>"},{"location":"nats/message/","title":"Access to Message Information","text":"<p>As you know, FastStream serializes a message body and provides you access to it through function arguments. But sometimes you want access to message_id, headers, or other meta-information.</p>"},{"location":"nats/message/#message-access","title":"Message Access","text":"<p>You can get it in a simple way: just acces the message object in the Context!</p> <p>It contains the required information such as:</p> <ul> <li><code>body: bytes</code></li> <li><code>decoded_body: Any</code></li> <li><code>content_type: str</code></li> <li><code>reply_to: str</code></li> <li><code>headers: dict[str, Any]</code></li> <li><code>message_id: str</code></li> <li><code>correlation_id: str</code></li> </ul> <p>It is a FastStream wrapper around a native broker library message (<code>nats.aio.msg.Msg</code> in the NATS' case), you can access with <code>raw_message</code>.</p> <pre><code>from faststream.nats.annotations import NatsMessage\n\n@broker.subscriber(\"test\")\nasync def base_handler(\n    body: str,\n    msg: NatsMessage,\n):\n    print(msg.correlation_id)\n</code></pre> <p>Also, if you can't find the information you reqiure, you can get access directly to the wrapped <code>nats.aio.msg.Msg</code>, which contains complete message information.</p> <pre><code>from nats.aio.msg import Msg\nfrom faststream.nats.annotations import NatsMessage\n\n@broker.subscriber(\"test\")\nasync def base_handler(body: str, msg: NatsMessage):\n    raw: Msg = msg.raw_message\n    print(raw)\n</code></pre>"},{"location":"nats/message/#message-fields-access","title":"Message Fields Access","text":"<p>But in most cases, you don't need all message fields; you need to access some of them. You can use Context Fields access feature for this reason.</p> <p>For example, you can get access to the <code>correlation_id</code> like this:</p> <pre><code>from faststream import Context\n\n@broker.subscriber(\"test\")\nasync def base_handler(\n    body: str,\n    cor_id: str = Context(\"message.correlation_id\"),\n):\n    print(cor_id)\n</code></pre> <p>Or even directly from the raw message:</p> <pre><code>from faststream import Context\n\n@broker.subscriber(\"test\")\nasync def base_handler(\n    body: str,\n    cor_id: str = Context(\"message.raw_message.correlation_id\"),\n):\n    print(cor_id)\n</code></pre> <p>But this code is too long to reuse everywhere. In this case, you can use a Python <code>Annotated</code> feature:</p> python 3.9+python 3.6+ <pre><code>from types import Annotated\nfrom faststream import Context\n\nCorrelationId = Annotated[str, Context(\"message.correlation_id\")]\n\n@broker.subscriber(\"test\")\nasync def base_handler(\n    body: str,\n    cor_id: CorrelationId,\n):\n    print(cor_id)\n</code></pre> <pre><code>from typing_extensions import Annotated\nfrom faststream import Context\n\nCorrelationId = Annotated[str, Context(\"message.correlation_id\")]\n\n@broker.subscriber(\"test\")\nasync def base_handler(\n    body: str,\n    cor_id: CorrelationId,\n):\n    print(cor_id)\n</code></pre>"},{"location":"nats/rpc/","title":"RPC over NATS","text":"<p>Because NATS has zero cost for creating new subjects, we can easily set up a new subject consumer just for the one response message. This way, your request message will be published to one topic, and the response message will be consumed from another one (temporary subject), which allows you to use regular FastStream RPC syntax in the NATS case too.</p> <p>Tip</p> <p>FastStream RPC over NATS works in both the NATS-Core and NATS-JS cases as well, but in the NATS-JS case, you have to specify the expected <code>stream</code> as a publish argument.</p>"},{"location":"nats/rpc/#blocking-request","title":"Blocking Request","text":"<p>FastStream provides you with the ability to send a blocking RPC request over NATS in a very simple way.</p> <p>Just send a message like a regular one and get a response synchronously.</p> <p>It is very close to the common requests syntax:</p> <pre><code>msg = await broker.publish(\n    \"Hi!\",\n    subject=\"test\",\n    rpc=True,\n)\n</code></pre> <p>Also, you have two extra options to control this behavior:</p> <ul> <li><code>rpc_timeout: Optional[float] = 30.0</code> - controls how long you are waiting for a response.</li> <li><code>raise_timeout: bool = False</code> - by default, a timeout request returns <code>None</code>, but if you need to raise a <code>TimeoutException</code> directly, you can specify this option.</li> </ul>"},{"location":"nats/rpc/#reply-to","title":"Reply-To","text":"<p>Also, if you want to create a permanent request-reply data flow, probably, you should create a permanent subject to consume responses.</p> <p>So, if you have such one, you can specify it with the <code>reply_to</code> argument. This way, FastStream will send a response to this subject automatically.</p> <pre><code>@broker.subscriber(\"response-subject\")\nasync def consume_responses(msg):\n    ...\n\nmsg = await broker.publish(\n    \"Hi!\",\n    subject=\"test\",\n    reply_to=\"response-subject\",\n)\n</code></pre>"},{"location":"nats/examples/direct/","title":"Direct","text":"<p>The Direct Subject is the basic way to route messages in NATS. Its essence is very simple: a <code>subject</code> sends messages to all consumers subscribed to it.</p>"},{"location":"nats/examples/direct/#scaling","title":"Scaling","text":"<p>If one <code>subject</code> is being listened to by several consumers with the same <code>queue group</code>, the message will go to a random consumer each time.</p> <p>Thus, NATS can independently balance the load on queue consumers. You can increase the processing speed of the message flow from the queue by simply launching additional instances of the consumer service. You don't need to make changes to the current infrastructure configuration: NATS will take care of how to distribute messages between your services.</p>"},{"location":"nats/examples/direct/#example","title":"Example","text":"<p>The Direct Subject is the type used in FastStream by default: you can simply declare it as follows</p> <pre><code>@broker.handler(\"test_subject\")\nasync def handler():\n...\n</code></pre> <p>Full example:</p> <pre><code>from faststream import FastStream, Logger\nfrom faststream.nats import NatsBroker\n\nbroker = NatsBroker()\napp = FastStream(broker)\n\n@broker.subscriber(\"test-subj-1\", \"workers\")\nasync def base_handler1(logger: Logger):\n    logger.info(\"base_handler1\")\n\n@broker.subscriber(\"test-subj-1\", \"workers\")\nasync def base_handler2(logger: Logger):\n    logger.info(\"base_handler2\")\n\n@broker.subscriber(\"test-subj-2\", \"workers\")\nasync def base_handler3(logger: Logger):\n    logger.info(\"base_handler3\")\n\n@app.after_startup\nasync def send_messages():\n    await broker.publish(\"\", \"test-subj-1\")  # handlers: 1 or 2\n    await broker.publish(\"\", \"test-subj-1\")  # handlers: 1 or 2\n    await broker.publish(\"\", \"test-subj-2\")  # handlers: 3\n</code></pre>"},{"location":"nats/examples/direct/#consumer-announcement","title":"Consumer Announcement","text":"<p>To begin with, we have declared several consumers for two <code>subjects</code>: <code>test-subj-1</code> and <code>test-subj-2</code>:</p> <pre><code>@broker.subscriber(\"test-subj-1\", \"workers\")\nasync def base_handler1(logger: Logger):\n    logger.info(\"base_handler1\")\n\n@broker.subscriber(\"test-subj-1\", \"workers\")\nasync def base_handler2(logger: Logger):\n    logger.info(\"base_handler2\")\n\n@broker.subscriber(\"test-subj-2\", \"workers\")\nasync def base_handler3(logger: Logger):\n    logger.info(\"base_handler3\")\n</code></pre> <p>Note</p> <p>Note that all consumers are subscribed using the same <code>queue_group</code>. Within the same service, this does not make sense, since messages will come to these handlers in turn. Here, we emulate the work of several consumers and load balancing between them.</p>"},{"location":"nats/examples/direct/#message-distribution","title":"Message Distribution","text":"<p>Now the distribution of messages between these consumers will look like this:</p> <pre><code>    await broker.publish(\"\", \"test-subj-1\")  # handlers: 1 or 2\n</code></pre> <p>The message <code>1</code> will be sent to <code>handler1</code> or <code>handler2</code> because they are listening to one <code>subject</code> within one <code>queue group</code>.</p> <pre><code>    await broker.publish(\"\", \"test-subj-1\")  # handlers: 1 or 2\n</code></pre> <p>Message <code>2</code> will be sent similarly to message <code>1</code>.</p> <pre><code>    await broker.publish(\"\", \"test-subj-2\")  # handlers: 3\n</code></pre> <p>The message <code>3</code> will be sent to <code>handler3</code> because it is the only one listening to <code>test-subj-2</code>.</p>"},{"location":"nats/examples/pattern/","title":"Pattern","text":"<p>Pattern Subject is a powerful NATS routing engine. This type of <code>subject</code> routes messages to consumers based on the pattern specified when they connect to the <code>subject</code> and a message key.</p>"},{"location":"nats/examples/pattern/#scaling","title":"Scaling","text":"<p>If one <code>subject</code> is being listened to by several consumers with the same <code>queue group</code>, the message will go to a random consumer each time.</p> <p>Thus, NATS can independently balance the load on queue consumers. You can increase the processing speed of the message flow from the queue by simply launching additional instances of the consumer service. You don't need to make changes to the current infrastructure configuration: NATS will take care of how to distribute messages between your services.</p>"},{"location":"nats/examples/pattern/#example","title":"Example","text":"<pre><code>from faststream import FastStream, Logger\nfrom faststream.nats import NatsBroker\n\nbroker = NatsBroker()\napp = FastStream(broker)\n\n@broker.subscriber(\"*.info\", \"workers\")\nasync def base_handler1(logger: Logger):\n    logger.info(\"base_handler1\")\n\n@broker.subscriber(\"*.info\", \"workers\")\nasync def base_handler2(logger: Logger):\n    logger.info(\"base_handler2\")\n\n@broker.subscriber(\"*.error\", \"workers\")\nasync def base_handler3(logger: Logger):\n    logger.info(\"base_handler3\")\n\n@app.after_startup\nasync def send_messages():\n    await broker.publish(\"\", \"logs.info\")  # handlers: 1 or 2\n    await broker.publish(\"\", \"logs.info\")  # handlers: 1 or 2\n    await broker.publish(\"\", \"logs.error\") # handlers: 3\n</code></pre>"},{"location":"nats/examples/pattern/#consumer-announcement","title":"Consumer Announcement","text":"<p>To begin with, we have announced several consumers for two <code>subjects</code>: <code>*.info</code> and <code>*.error</code>:</p> <pre><code>@broker.subscriber(\"*.info\", \"workers\")\nasync def base_handler1(logger: Logger):\n    logger.info(\"base_handler1\")\n\n@broker.subscriber(\"*.info\", \"workers\")\nasync def base_handler2(logger: Logger):\n    logger.info(\"base_handler2\")\n\n@broker.subscriber(\"*.error\", \"workers\")\nasync def base_handler3(logger: Logger):\n    logger.info(\"base_handler3\")\n</code></pre> <p>At the same time, in the <code>subject</code> of our consumers, we specify the pattern that will be processed by these consumers.</p> <p>Note</p> <p>Note that all consumers are subscribed using the same <code>queue_group</code>. Within the same service, this does not make sense, since messages will come to these handlers in turn. Here, we emulate the work of several consumers and load balancing between them.</p>"},{"location":"nats/examples/pattern/#message-distribution","title":"Message Distribution","text":"<p>Now the distribution of messages between these consumers will look like this:</p> <pre><code>    await broker.publish(\"\", \"logs.info\")  # handlers: 1 or 2\n</code></pre> <p>The message <code>1</code> will be sent to <code>handler1</code> or <code>handler2</code> because they listen to the same <code>subject</code> template within the same <code>queue group</code>.</p> <pre><code>    await broker.publish(\"\", \"logs.info\")  # handlers: 1 or 2\n</code></pre> <p>Message <code>2</code> will be sent similarly to message <code>1</code>.</p> <pre><code>    await broker.publish(\"\", \"logs.error\") # handlers: 3\n</code></pre> <p>The message <code>3</code> will be sent to <code>handler3</code> because it is the only one listening to the pattern <code>*.error*</code>.</p>"},{"location":"nats/jetstream/","title":"NATS JetStream","text":"<p>The default NATS usage is suitable for scenarios where:</p> <ul> <li>The <code>publisher</code> and <code>consumer</code> are always online.</li> <li>The system can tolerate messages loss.</li> </ul> <p>If you need stricter restrictions, like:</p> <ul> <li>An availability of a message processing confirmation mechanism (<code>ack</code>/<code>nack</code>).</li> <li>Message persistence (messages will accumulate in the queue when the <code>consumer</code> is offline).</li> </ul> <p>You should use the NATS JetStream extension.</p> <p>In fact, the JetStream extension is the same as NATS, with the addition of a persistent layer above the file system. Therefore, all interfaces for publishing and consuming messages are similar to regular NATS usage.</p> <p>However, the JetStream layer has many possibilities for configuration, from the policy of deleting old messages to the maximum stored messages number limit. You can find out more about all JetStream features in the official documentation.</p> <p>If you have worked with other message brokers, then you should know that the logic of JS is closer to Kafka than to RabbitMQ: messages, after confirmation, are not deleted from the queue but remain there until the queue is full, and it will start deleting old messages (or in accordance with other logic that you can configure yourself).</p> <p>When connecting a <code>consumer</code> (and, especially, when reconnecting), you must determine for yourself according to what logic it will consume messages: from the subject beginning, starting with some message, starting from some time, only new ones, etc. Don't be surprised if a connection is restored, and your <code>consumer</code> starts to process all messages received earlier again - you haven't defined the rule.</p> <p>Also, NATS JetStream has built-in <code>key-value</code> (similar to Redis) and <code>object</code> (similar to Minio) storages, which, in addition to the interface for put/get, have the ability to subscribe to events, which can be extremely useful in various scenarios.</p> <p>FastStream does not provide access to this functionality directly, but it is covered by the nats-py library used. You can access the JS object from the application context:</p> <pre><code>from faststream import FastStream, Logger\nfrom faststream.nats import JStream, NatsBroker\n\nbroker = NatsBroker()\napp = FastStream(broker)\n\nstream = JStream(name=\"stream\")\n\n@broker.subscriber(\n    \"js-subject\",\n    stream=stream,\n    deliver_policy=\"new\",\n)\nasync def handler(msg: str, logger: Logger):\n    logger.info(msg)\n\n@app.after_startup\nasync def test_send():\n    await broker.publish(\"Hi!\", \"js-subject\")\n    # publish with stream verification\n    await broker.publish(\"Hi!\", \"js-subject\", stream=\"stream\")\n</code></pre> <p>Tip</p> <p>Using <code>JStream</code> object FastStream is trying to create/update stream with the object settings. To prevent this behavior and just get already created stream, please use <code>JStream(..., declare=False)</code> option.</p>"},{"location":"nats/jetstream/ack/","title":"Consuming Acknowledgements","text":"<p>As you may know, Nats employs a rather extensive Acknowledgement policy.</p> <p>In most cases, FastStream automatically acknowledges (acks) messages on your behalf. When your function executes correctly, including sending all responses, a message will be acknowledged (and rejected in case of an exception).</p> <p>However, there are situations where you might want to use different acknowledgement logic.</p>"},{"location":"nats/jetstream/ack/#retries","title":"Retries","text":"<p>If you prefer to use a nack instead of a reject when there's an error in message processing, you can specify the <code>retry</code> flag in the <code>@broker.subscriber(...)</code> method, which is responsible for error handling logic.</p> <p>By default, this flag is set to <code>False</code>, indicating that if an error occurs during message processing, the message can still be retrieved from the queue:</p> <pre><code>@broker.subscriber(\"test\", retry=False) # don't handle exceptions\nasync def base_handler(body: str):\n    ...\n</code></pre> <p>If this flag is set to <code>True</code>, the message will be nacked and placed back in the queue each time an error occurs. In this scenario, the message can be processed by another consumer (if there are several of them) or by the same one:</p> <pre><code>@broker.subscriber(\"test\", retry=True)  # try again indefinitely\nasync def base_handler(body: str):\n    ...\n</code></pre> <p>Tip</p> <p>For more complex error handling cases, you can use tenacity</p>"},{"location":"nats/jetstream/ack/#manual-acknowledgement","title":"Manual Acknowledgement","text":"<p>If you want to acknowledge a message manually, you can get access directy to the message object via the Context and call the method.</p> <pre><code>from faststream.nats.annotations import NatsMessage\n\n@broker.subscriber(\"test\")\nasync def base_handler(body: str, msg: NatsMessage):\n    await msg.ack()\n    # or\n    await msg.nack()\n    # or\n    await msg.reject()\n</code></pre> <p>FastStream will see that the message was already acknowledged and will do nothing at the end of the process.</p>"},{"location":"nats/jetstream/ack/#interrupt-process","title":"Interrupt Process","text":"<p>If you want to interrupt message processing at any call stack, you can raise <code>faststream.exceptions.AckMessage</code></p> <pre><code>from faststream import FastStream\nfrom faststream.exceptions import AckMessage\nfrom faststream.nats import NatsBroker\n\nbroker = NatsBroker(\"nats://localhost:4222\")\napp = FastStream(broker)\n\n\n@broker.subscriber(\"test-subject\")\nasync def handle(body):\n    smth_processing(body)\n\n\ndef smth_processing(body):\n    if True:\n        raise AckMessage()\n\n\n@app.after_startup\nasync def test_publishing():\n    await broker.publish(\"Hello!\", \"test-subject\")\n</code></pre> <p>This way, FastStream interrupts the current message proccessing and acknowledges it immediately. Also, you can raise <code>NackMessage</code> and <code>RejectMessage</code> too.</p>"},{"location":"nats/jetstream/key-value/","title":"Key-Value Storage","text":""},{"location":"nats/jetstream/key-value/#overview","title":"Overview","text":"<p>Key-Value storage is just a high-level interface on top of NatsJS.</p> <p>It is a regular JetStream, where the KV key is a subject.</p> <p><code>Put</code>/<code>Update</code> an object to KV by key - it's like publishing a new message to the corresponding subject in the stream.</p> <p>Thus, the <code>Get</code> command returns not only the current key value but the latest one with an offset of it. Additionally, you can ask for a specific value based on its offset in the KV stream.</p> <p>This interface provides you with rich abilities to use it like a regular KV storage (ignoring offset) + subscribe to KV key changes + ask for an old KV value revision. So you can use this feature in your application in a really different way. You can find some examples on the NATS developers' official YouTube channel</p>"},{"location":"nats/jetstream/key-value/#faststream-details","title":"FastStream Details","text":"<p>FastStream has no native interfaces to this NatsJS functionality (yet), but it allows you to get access into the inner <code>JetStream</code> object to create it manually.</p> <p>First of all, you need to create a Key-Value storage object and pass it into the context:</p> <pre><code>from faststream import Context, FastStream, Logger\nfrom faststream.nats import NatsBroker\nfrom faststream.nats.annotations import ContextRepo\n\n\nbroker = NatsBroker()\napp = FastStream(broker)\n\n\n@app.on_startup\nasync def setup_broker(context: ContextRepo):\n    await broker.connect()\n\n    kv = await broker.stream.create_key_value(bucket=\"bucket\")\n    context.set_global(\"kv\", kv)\n</code></pre> <p>Tip</p> <p>We placed this code in <code>@app.on_startup</code> hook because <code>@app.after_startup</code> will be triggered AFTER your handlers start consuming messages. So, if you need to have access to any custom context objects, you should set them up in the <code>@app.on_startup</code> hook.</p> <p>Also, we call <code>await broker.connect()</code> method manually to establish the connection to be able to create a storage.</p> <p>Next, we are ready to use this object right in our handlers.</p> <p>Let's create an annotated object to shorten context object access:</p> <pre><code>from nats.js.kv import KeyValue as KV\nfrom typing_extensions import Annotated\n\n\nKeyValue = Annotated[KV, Context(\"kv\")]\n</code></pre> <p>And just use it in a handler:</p> <pre><code>from faststream import Logger\n\n\n@broker.subscriber(\"subject\")\nasync def handler(msg: str, kv: KeyValue, logger: Logger):\n    logger.info(msg)\n    kv_data = await kv.get(\"key\")\n    assert kv_data.value == b\"Hello!\"\n</code></pre> <p>Finally, let's test our code behavior by putting something into the KV storage and sending a message:</p> <pre><code>@app.after_startup\nasync def test_send(kv: KeyValue):\n    await kv.put(\"key\", b\"Hello!\")\n    await broker.publish(\"Hi!\", \"subject\")\n</code></pre> Full listing <pre><code>from nats.js.kv import KeyValue as KV\nfrom typing_extensions import Annotated\n\nfrom faststream import Logger\nfrom faststream import Context, FastStream, Logger\nfrom faststream.nats import NatsBroker\nfrom faststream.nats.annotations import ContextRepo\n\nKeyValue = Annotated[KV, Context(\"kv\")]\n\nbroker = NatsBroker()\napp = FastStream(broker)\n\n\n@broker.subscriber(\"subject\")\nasync def handler(msg: str, kv: KeyValue, logger: Logger):\n    logger.info(msg)\n    kv_data = await kv.get(\"key\")\n    assert kv_data.value == b\"Hello!\"\n\n\n@app.on_startup\nasync def setup_broker(context: ContextRepo):\n    await broker.connect()\n\n    kv = await broker.stream.create_key_value(bucket=\"bucket\")\n    context.set_global(\"kv\", kv)\n\n\n@app.after_startup\nasync def test_send(kv: KeyValue):\n    await kv.put(\"key\", b\"Hello!\")\n    await broker.publish(\"Hi!\", \"subject\")\n</code></pre>"},{"location":"nats/jetstream/object/","title":"Object Storage","text":"<p>Object storage is almost identical to the Key-Value stroge concept, so you can reuse the guide.</p>"},{"location":"nats/jetstream/object/#overview","title":"Overview","text":"<p>Object Storage is just a high-level interface on top of NatsJS.</p> <p>It is a regular JetStream, where the Object key is a subject.</p> <p>The main difference between KV and Object storages is that in the Object storage, you can store files greater than 1MB (a limitation of KV). It has no limit on the maximum object size and stores it in chunks (each message is an object chunk), so you can literally stream huge objects through NATS.</p>"},{"location":"nats/jetstream/object/#faststream-details","title":"FastStream Details","text":"<p>FastStream has no native interfaces to this NatsJS functionality (yet), but it allows you to access the inner <code>JetStream</code> object to create in manually.</p> <p>First of all, you need to create an Object storage object and pass in to the context:</p> <pre><code>from faststream import Context, FastStream\nfrom faststream.nats import NatsBroker\nfrom faststream.nats.annotations import ContextRepo\n\n\nbroker = NatsBroker()\napp = FastStream(broker)\n\n\n@app.on_startup\nasync def setup_broker(context: ContextRepo):\n    await broker.connect()\n\n    os = await broker.stream.create_object_store(\"bucket\")\n    context.set_global(\"OS\", os)\n</code></pre> <p>Tip</p> <p>We placed this code in the <code>@app.on_startup</code> hook because <code>@app.after_startup</code> will be triggered AFTER your handlers start consuming messages. So, if you need to have access to any custom context objects, you should set them up in the <code>@app.on_startup</code> hook.</p> <p>Also, we call <code>await broker.connect()</code> method manually to establish the connection to be able to create a storage.</p> <p>Next, we are ready to use this object right in the our handlers.</p> <p>Let's create an Annotated object to shorten <code>Context</code> object access:</p> <pre><code>from nats.js.object_store import ObjectStore as OS\nfrom typing_extensions import Annotated\n\n\nObjectStorage = Annotated[OS, Context(\"OS\")]\n</code></pre> <p>And just use it in a handler:</p> <pre><code>from io import BytesIO\n\n\nfrom faststream import Logger\n\n\n@broker.subscriber(\"subject\")\nasync def handler(msg: str, os: ObjectStorage, logger: Logger):\n    logger.info(msg)\n    obj = await os.get(\"file\")\n    assert obj.data == b\"File mock\"\n</code></pre> <p>Finally, let's test our code behavior by putting something into the Object storage and sending a message:</p> <pre><code>@app.after_startup\nasync def test_send(os: ObjectStorage):\n    await os.put(\"file\", BytesIO(b\"File mock\"))\n    await broker.publish(\"Hi!\", \"subject\")\n</code></pre> <p>Tip</p> <p><code>BytesIO</code> - is a Readable object used to emulate a file opened for reading.</p> Full listing <pre><code>from io import BytesIO\n\nfrom nats.js.object_store import ObjectStore as OS\nfrom typing_extensions import Annotated\n\nfrom faststream import Logger\nfrom faststream import Context, FastStream\nfrom faststream.nats import NatsBroker\nfrom faststream.nats.annotations import ContextRepo\n\nObjectStorage = Annotated[OS, Context(\"OS\")]\n\nbroker = NatsBroker()\napp = FastStream(broker)\n\n\n@broker.subscriber(\"subject\")\nasync def handler(msg: str, os: ObjectStorage, logger: Logger):\n    logger.info(msg)\n    obj = await os.get(\"file\")\n    assert obj.data == b\"File mock\"\n\n\n@app.on_startup\nasync def setup_broker(context: ContextRepo):\n    await broker.connect()\n\n    os = await broker.stream.create_object_store(\"bucket\")\n    context.set_global(\"OS\", os)\n\n\n@app.after_startup\nasync def test_send(os: ObjectStorage):\n    await os.put(\"file\", BytesIO(b\"File mock\"))\n    await broker.publish(\"Hi!\", \"subject\")\n</code></pre>"},{"location":"nats/publishing/","title":"Publishing","text":"<p>FastStream <code>NatsBroker</code> supports all regular publishing usecases. You can use them without any changes.</p> <p>However, if you wish to further customize the publishing logic, you should take a deeper look at specific <code>NatsBroker</code> parameters.</p>"},{"location":"nats/publishing/#nats-publishing","title":"NATS Publishing","text":"<p><code>NatsBroker</code> also uses the unified <code>publish</code> method (from a <code>publisher</code> object) to send messages.</p> <pre><code>import asyncio\nfrom faststream.nats import NatsBroker\n\nasync def pub():\n    async with NatsBroker() as broker:\n        await broker.publish(\n            \"Hi!\",\n            subject=\"test\",\n        )\n\nasyncio.run(pub())\n</code></pre>"},{"location":"nats/publishing/#basic-arguments","title":"Basic Arguments","text":"<p>The <code>publish</code> method accepts the following arguments:</p> <ul> <li><code>message = \"\"</code> - message to send.</li> <li><code>subject: str</code> - subject where the message will be sent.</li> </ul>"},{"location":"nats/publishing/#message-parameters","title":"Message Parameters","text":"<ul> <li><code>headers: dict[str, str] | None = None</code> - headers of the message being sent (used by consumers).</li> <li><code>correlation_id: str | None = None</code> - message id, which helps to match the original message with the reply to it (generated automatically).</li> </ul>"},{"location":"nats/publishing/#natsjs-parameters","title":"NatsJS Parameters","text":"<ul> <li><code>stream: str | None = None</code> - validate that the subject is in the stream.</li> <li><code>timeout: float | None = None</code> - wait for the NATS server response.</li> </ul>"},{"location":"rabbit/","title":"Rabbit Routing","text":"<p>FastStream RabbitMQ support is implemented on top of aio-pika. You can always get access to objects of it, if you need to use some low-level methods, not represented in FastStream.</p>"},{"location":"rabbit/#advantages","title":"Advantages","text":"<p>The advantage of RabbitMQ is the ability to configure flexible and complex message routing scenarios.</p> <p>RabbitMQ covers the whole range of routing: from one queue - one consumer, to a queue retrieved from several sources, including message prioritization.</p> <p>Note</p> <p>For more information about RabbitMQ, please visit the official documentation</p> <p>It supports the ability to successfully process messages, mark them as processed with an error, remove them from the queue (it is also impossible to re-receive processed messages, unlike Kafka), lock it for the processing duration, and monitor its current status.</p> <p>Having to keep track of the current status of all messages is a cause of the RabbitMQ performance issues. With really large message volumes, RabbitMQ starts to degrade. However, if this was a \"one-time influx\", then consumers will free the queue of messages and the \"health\" of RabbitMQ will be stable.</p> <p>If your scenario is not based on processing millions of messages and also requires building complex routing logic, RabbitMQ will be the right choice.</p>"},{"location":"rabbit/#basic-concepts","title":"Basic Concepts","text":"<p>If you want to totally understand how RabbitMQ works, you should visit their official website. There you will find top-level comments about the basic concepts and usage examples.</p>"},{"location":"rabbit/#entities","title":"Entities","text":"<p>RabbitMQ works with three main entities:</p> <ul> <li><code>Exchange</code> - the point of receiving messages from publisher</li> <li><code>Queue</code> - the point of pushing messages to consumer</li> <li><code>Binding</code> - the relationship between queue-exchange or exchange-exchange</li> </ul>"},{"location":"rabbit/#routing-rules","title":"Routing Rules","text":"<p>The rules for delivering messages to consumers depend on the type of exchange and binding parameters. All the main options will be discussed at examples.</p> <p>In general, the message path looks so:</p> <ol> <li>Publisher sends a message to <code>exchange</code>, specify its <code>routing_key</code> and headers according to which routing will take place.</li> <li><code>Exchange</code>, depending on the message parameters, determines which of the subscribed <code>bindings</code> to send the message to.</li> <li><code>Binding</code> delivers the message to <code>queue</code> or another <code>exchange</code> (in this case it will send it further by its own rules).</li> <li><code>Queue</code>, after receiving a message, sends it to one of subscribed consumers (PUSH API).</li> </ol> <p>Tip</p> <p>By default, all queues have a <code>binding</code> to the <code>default exchange</code> (Direct type) with a routing key corresponding to their name. In FastStream, queues are connected to this <code>exchange</code>, and messages are sent by default unless another <code>exchange</code> is explicitly specified.</p> <p>Connecting the queue to any other <code>exchange</code> will still leave it subscribed to the `default exchange'. Be careful with this.</p> <p>At this stage, the message gets into your application - and you start processing it.</p>"},{"location":"rabbit/#message-statuses","title":"Message Statuses","text":"<p>RabbitMQ requires confirmation of message processing: only after that, it will be removed from the queue.</p> <p>Confirmation can be either positive (<code>Acknowledgment - ack</code>) if the message was successfully processed or negative (<code>Negative Acknowledgment - nack</code>) if the message was processed with an error.</p> <p>At the same time, in case of an error, the message can also be extracted from the queue (<code>reject</code>); otherwise, after a negative confirmation, it will be requeued for processing again.</p> <p>In most cases, FastStream performs all the necessary actions by itself. However, if you want to manage the message lifecycle directly, you can access the message object itself and call the appropriate methods directly. This can be useful if you want to implement an \"at most once\" policy and you need to confirm the consuming of the message before it is actually processed.</p>"},{"location":"rabbit/#faststream-specific","title":"FastStream Specific","text":"<p>FastStream omits the ability to create <code>bindings</code> directly, since in most cases, you do not need to subscribe one queue to several <code>exchanges</code> or subscribe <code>exchanges</code> to each other. On the contrary, this practice leads to over-complication of the message routing scheme, which makes it difficult to maintain and further develop the entire infrastructure of services.</p> <p>FastStream suggests you adhere to the scheme <code>exchange:queue</code> as <code>1:N</code>, which will greatly simplify the scheme of interaction between your services. It is better to create an additional queue for a new <code>exchange</code> than to subscribe to an existing one.</p> <p>However, if you want to reduce the number of entities in your RabbitMQ, and thereby optimize its performance (or you know exactly what you are doing), FastStream leaves you the option to create <code>bindings</code> directly. In other cases, the connection parameters are an integral part of the entities RabbitQueue and RabbitExchange in FastStream.</p>"},{"location":"rabbit/ack/","title":"Consuming Acknowledgements","text":"<p>As you may know, RabbitMQ employs a rather extensive Acknowledgement policy.</p> <p>In most cases, FastStream automatically acknowledges (acks) messages on your behalf. When your function executes correctly, including sending all responses, a message will be acknowledged (and rejected in case of an exception).</p> <p>However, there are situations where you might want to use a different acknowledgement logic.</p>"},{"location":"rabbit/ack/#retries","title":"Retries","text":"<p>If you prefer to use a nack instead of a reject when there's an error in message processing, you can specify the <code>retry</code> flag in the <code>@broker.subscriber(...)</code> method, which is responsible for error handling logic.</p> <p>By default, this flag is set to <code>False</code>, indicating that if an error occurs during message processing, the message can still be retrieved from the queue:</p> <pre><code>@broker.subscriber(\"test\", retry=False) # don't handle exceptions\nasync def base_handler(body: str):\n    ...\n</code></pre> <p>If this flag is set to <code>True</code>, the message will be nacked and placed back in the queue each time an error occurs. In this scenario, the message can be processed by another consumer (if there are several of them) or by the same one:</p> <pre><code>@broker.subscriber(\"test\", retry=True)  # try again indefinitely\nasync def base_handler(body: str):\n    ...\n</code></pre> <p>If the <code>retry</code> flag is set to an <code>int</code>, the message will be placed back in the queue, and the number of retries will be limited to this number:</p> <pre><code>@broker.subscriber(\"test\", retry=3)     # make up to 3 attempts\nasync def base_handler(body: str):\n    ...\n</code></pre> <p>Bug</p> <p>At the moment, attempts are counted only by the current consumer. If the message goes to another consumer, it will have its own counter. Subsequently, this logic will be reworked.</p> <p>Tip</p> <p>For more complex error handling cases, you can use tenacity</p>"},{"location":"rabbit/ack/#manual-acknowledgement","title":"Manual acknowledgement","text":"<p>If you want to acknowledge a message manually, you can get access directy to the message object via the Context and call the method.</p> <pre><code>from faststream.rabbit.annotations import RabbitMessage\n\n@broker.subscriber(\"test\")\nasync def base_handler(body: str, msg: RabbitMessage):\n    await msg.ack()\n    # or\n    await msg.nack()\n    # or\n    await msg.reject()\n</code></pre> <p>FastStream will see that the message was already acknowledged and will do nothing at process end.</p>"},{"location":"rabbit/ack/#interrupt-process","title":"Interrupt Process","text":"<p>If you want to interrupt message processing at any call stack, you can raise <code>faststream.exceptions.AckMessage</code></p> <pre><code>from faststream import FastStream\nfrom faststream.exceptions import AckMessage\nfrom faststream.rabbit import RabbitBroker\n\nbroker = RabbitBroker(\"amqp://guest:guest@localhost:5672/\")\napp = FastStream(broker)\n\n\n@broker.subscriber(\"test-queue\")\nasync def handle(body):\n    smth_processing(body)\n\n\ndef smth_processing(body):\n    if True:\n        raise AckMessage()\n\n\n@app.after_startup\nasync def test_publishing():\n    await broker.publish(\"Hello!\", \"test-queue\")\n</code></pre> <p>This way, FastStream interrupts the current message proccessing and acknowledges it immediately. Also, you can raise <code>NackMessage</code> and <code>RejectMessage</code> too.</p>"},{"location":"rabbit/declare/","title":"RabbitMQ Queue/Exchange Declaration","text":"<p>FastStream declares and validates all exchanges and queues using publishers and subscribers RabbitMQ objects, but sometimes you need to declare them manually.</p> <p>RabbitBroker provides a way to achieve this easily.</p> <pre><code>from faststream import FastStream\nfrom faststream.rabbit import (\n    ExchangeType,\n    RabbitBroker,\n    RabbitExchange,\n    RabbitQueue,\n)\n\nbroker = RabbitBroker()\napp = FastStream(broker)\n\n\n@app.after_startup\nasync def declare_smth():\n    await broker.declare_exchange(\n        RabbitExchange(\n            name=\"some-exchange\",\n            type=ExchangeType.FANOUT,\n        )\n    )\n\n    await broker.declare_queue(\n        RabbitQueue(\n            name=\"some-queue\",\n            durable=True,\n        )\n    )\n</code></pre> <p>These methods require just one argument (<code>RabbitQueue</code>/<code>RabbitExchange</code>) containing information about your RabbitMQ required objects. They declare/validate RabbitMQ objects and return low-level aio-pika robust objects to interact with.</p> <p>Tip</p> <p>Also, these methods are idempotent, so you can call them with the same arguments multiple times, but the objects will be created once; next time the method will return an already stored object. This way you can get access to any queue/exchange created automatically.</p>"},{"location":"rabbit/message/","title":"Access to Message Information","text":"<p>As you know, FastStream serializes a message body and provides you access to it through function arguments. But sometimes you want access to a message_id, headers, or other meta-information.</p>"},{"location":"rabbit/message/#message-access","title":"Message Access","text":"<p>You can get it in a simple way: just acces to the message object in the Context!</p> <p>This message contains the required information such as:</p> <ul> <li><code>body: bytes</code></li> <li><code>decoded_body: Any</code></li> <li><code>content_type: str</code></li> <li><code>reply_to: str</code></li> <li><code>headers: dict[str, Any]</code></li> <li><code>message_id: str</code></li> <li><code>correlation_id: str</code></li> </ul> <p>Also, it is a FastStream wrapper around a native broker library message (<code>aio_pika.IncomingMessage</code> in the RabbitMQ case), you can access with <code>raw_message</code>.</p> <pre><code>from faststream.rabbit.annotations import RabbitMessage\n\n@broker.subscriber(\"test\")\nasync def base_handler(\n    body: str,\n    msg: RabbitMessage,\n):\n    print(msg.correlation_id)\n</code></pre> <p>Also, if you can't find the information you reqiure, you can get access directly to the wrapped <code>aio_pika.IncomingMessage</code>, which contains complete message information.</p> <pre><code>from aio_pika import IncomingMessage\nfrom faststream.rabbit.annotations import RabbitMessage\n\n@broker.subscriber(\"test\")\nasync def base_handler(body: str, msg: RabbitMessage):\n    raw: IncomingMessage = msg.raw_message\n    print(raw)\n</code></pre>"},{"location":"rabbit/message/#message-fields-access","title":"Message Fields Access","text":"<p>But in the most cases, you don't need all message fields; you need to access some of them. You can use Context Fields access feature for this reason.</p> <p>For example, you can get access to the <code>correlation_id</code> like this:</p> <pre><code>from faststream import Context\n\n@broker.subscriber(\"test\")\nasync def base_handler(\n    body: str,\n    cor_id: str = Context(\"message.correlation_id\"),\n):\n    print(cor_id)\n</code></pre> <p>Or even directly from the raw message:</p> <pre><code>from faststream import Context\n\n@broker.subscriber(\"test\")\nasync def base_handler(\n    body: str,\n    cor_id: str = Context(\"message.raw_message.correlation_id\"),\n):\n    print(cor_id)\n</code></pre> <p>But this code is too long to be reused everywhere. In this case, you can use a Python <code>Annotated</code> feature:</p> python 3.9+python 3.6+ <pre><code>from types import Annotated\nfrom faststream import Context\n\nCorrelationId = Annotated[str, Context(\"message.correlation_id\")]\n\n@broker.subscriber(\"test\")\nasync def base_handler(\n    body: str,\n    cor_id: CorrelationId,\n):\n    print(cor_id)\n</code></pre> <pre><code>from typing_extensions import Annotated\nfrom faststream import Context\n\nCorrelationId = Annotated[str, Context(\"message.correlation_id\")]\n\n@broker.subscriber(\"test\")\nasync def base_handler(\n    body: str,\n    cor_id: CorrelationId,\n):\n    print(cor_id)\n</code></pre>"},{"location":"rabbit/publishing/","title":"Publishing","text":"<p>FastStream <code>RabbitBroker</code> supports all regular publishing usecases. you can use them without any changes.</p> <p>However, if you wish to further customize the publishing logic further, you should take a more deep-dive look at specific RabbitBroker parameters.</p>"},{"location":"rabbit/publishing/#rabbit-publishing","title":"Rabbit Publishing","text":"<p><code>RabbitBroker</code> also uses the unified <code>publish</code> method (from a <code>publisher</code> object) to send messages.</p> <p>However, in this case, an object of the <code>aio_pika.Message</code> class (if necessary) can be used as a message (in addition to python primitives and <code>pydantic.BaseModel</code>).</p> <p>You can specify queue (used as a routing_key) and exchange (optionally) to send by their name.</p> <pre><code>import asyncio\nfrom faststream.rabbit import RabbitBroker\n\nasync def pub():\n    async with RabbitBroker() as broker:\n        await broker.publish(\n            \"Hi!\",\n            queue=\"test\",\n            exchange=\"test\"\n        )\n\nasyncio.run(pub())\n</code></pre> <p>If you don't specify any exchange, the message will be send to the default one.</p> <p>Also, you are able to use special RabbitQueue and RabbitExchange objects as <code>queue</code> and <code>exchange</code> arguments:</p> <pre><code>from faststream.rabbit import RabbitExchange, RabbitQueue\n\nawait broker.publish(\n    \"Hi!\",\n    queue=RabbitQueue(\"test\"),\n    exchange=RabbitExchange(\"test\")\n)\n</code></pre> <p>If you specify exchange that doesn't exist, RabbitBroker will create a required one and then publish a message to it.</p> <p>Tip</p> <p>Be accurate with it: if you have already created an Exchange with specific parameters and try to send a message by exchange name to it, the broker will try to create it. So, Exchange parameters conflict will occur.</p> <p>If you are trying to send a message to a specific Exchange, sending it with a defined RabbitExchange object is the preffered way.</p>"},{"location":"rabbit/publishing/#basic-arguments","title":"Basic Arguments","text":"<p>The <code>publish</code> method takes the following arguments:</p> <ul> <li><code>message = \"\"</code> - message to send</li> <li><code>exchange: str | RabbitExchange | None = None</code> - the exchange where the message will be sent to. If not specified - default is used</li> <li><code>queue: str | RabbitQueue = \"\"</code> - the queue where the message will be sent (since most queues use their name as the routing key, this is a human-readable version of <code>routing_key</code>)</li> <li><code>routing_key: str = \"\"</code> - also a message routing key, if not specified, the <code>queue</code> argument will be used</li> </ul>"},{"location":"rabbit/publishing/#message-parameters","title":"Message Parameters","text":"<p>You can read more about all the available flags in the RabbitMQ documentation</p> <ul> <li><code>headers: dict[str, Any] | None = None</code> - message headers (used by consumers)</li> <li><code>content_type: str | None = None</code> - the content_type of the message being sent (set automatically, used by consumers)</li> <li><code>content_encoding: str | None = None</code> - encoding of the message (used by consumers)</li> <li><code>persist: bool = False</code> - restore messages on RabbitMQ reboot</li> <li><code>priority: int | None = None</code> - the priority of the message</li> <li><code>correlation_id: str | None = None</code> - message id, which helps to match the original message with the reply to it (generated automatically)</li> <li><code>message_id: str | None = None</code> - message ID (generated automatically)</li> <li><code>timestamp: int | float | time delta | datetime | None = None</code> - message sending time (set automatically)</li> <li><code>expiration: int | float | time delta | datetime | None = None</code> - message lifetime (in seconds)</li> <li><code>type: str | None = None</code> - the type of message (used by consumers)</li> <li><code>user_id: str | None = None</code> - ID of the RabbitMQ user who sent the message</li> <li><code>app_id: str | None = None</code> - ID of the application that sent the message (used by consumers)</li> </ul>"},{"location":"rabbit/publishing/#send-flags","title":"Send Flags","text":"<p>Arguments for sending a message:</p> <ul> <li><code>mandatory: bool = True</code> - the client is waiting for confirmation that the message will be placed in some queue (if there are no queues, return it to the sender)</li> <li><code>immediate: bool = False</code> - the client expects that there is a consumer ready to take the message to work \"right now\" (if there is no consumer, return it to the sender)</li> <li><code>timeout: int | float | None = None</code> - send confirmation time from RabbitMQ</li> </ul>"},{"location":"rabbit/rpc/","title":"RPC over RMQ","text":""},{"location":"rabbit/rpc/#blocking-request","title":"Blocking Request","text":"<p>FastStream provides you with the ability to send a blocking RPC request over RabbitMQ in a very simple way.</p> <p>It uses the Direct Reply-To RabbitMQ feature, so you don't need to create any queues to consume a response.</p> <p>Just send a message like a regular one and get a response synchronously.</p> <p>It is very close to common requests syntax:</p> <pre><code>msg = await broker.publish(\n    \"Hi!\",\n    queue=\"test\",\n    rpc=True,\n)\n</code></pre> <p>Also, you have two extra options to control this behavior:</p> <ul> <li><code>rpc_timeout: Optional[float] = 30.0</code> - controls how long you are waiting for a response</li> <li><code>raise_timeout: bool = False</code> - by default, a timeout request returns <code>None</code>, but if you need to raise a <code>TimeoutException</code> directly, you can specify this option</li> </ul>"},{"location":"rabbit/rpc/#reply-to","title":"Reply-To","text":"<p>Also, if you want to create a permanent request-reply data flow, probably, you should create a permanent queue to consume responses.</p> <p>So, if you have such one, you can specify it with the <code>reply_to</code> argument. This way, FastStream will send a response to this queue automatically.</p> <pre><code>@broker.subscriber(\"response-queue\")\nasync def consume_responses(msg):\n    ...\n\nmsg = await broker.publish(\n    \"Hi!\",\n    queue=\"test\",\n    reply_to=\"response-queue\",\n)\n</code></pre>"},{"location":"rabbit/examples/","title":"Basic Subscriber","text":"<p>If you know nothing about RabbitMQ and how it works, you will still able to use FastStream RabbitBroker.</p> <p>Just use the <code>@broker.subscriber(...)</code> method with a string as a routing key.</p> <pre><code>from faststream import FastStream\nfrom faststream.rabbit import RabbitBroker\n\nbroker = RabbitBroker()\napp = FastStream(broker)\n\n\n@broker.subscriber(\"routing_key\")  # handle messages by routing key\nasync def handle(msg):\n    print(msg)\n\n\n@app.after_startup\nasync def test_publish():\n    await broker.publish(\n        \"message\",\n        \"routing_key\",  # publish message with routing key\n    )\n</code></pre> <p>This is the principle all FastStream brokers work by: you don't need to learn them in-depth if you want to just send a message.</p>"},{"location":"rabbit/examples/#rabbitmq-details","title":"RabbitMQ Details","text":"<p>If you are already familiar with RabbitMQ logic, you should also be acquainted with the inner workings of the example mentioned above.</p> <p>In this case, FastStream either creates or validates a queue with a specified routing_key and binds it to the default RabbitMQ exchange.</p> <p>If you want to specify a queue-exchange pair with additional arguments, FastStream provides you with the ability to do so. You can use special <code>RabbitQueue</code> and <code>RabbitExchange</code> objects to configure RabbitMQ queues, exchanges, and binding properties. For examples of using various types of exchanges, please refer to the following articles.</p>"},{"location":"rabbit/examples/direct/","title":"Direct Exchange","text":"<p>The Direct Exchange is the basic way to route messages in RabbitMQ. Its core is very simple: the <code>exchange</code> sends messages to those queues whose <code>routing_key</code> matches the <code>routing_key</code> of the message being sent.</p> <p>Note</p> <p>The Default Exchange, to which all queues in RabbitMQ are subscribed, has the Direct type by default.</p>"},{"location":"rabbit/examples/direct/#scaling","title":"Scaling","text":"<p>If several consumers are listening to the same queue, messages will be distributed to one of them (round-robin). This behavior is common for all types of <code>exchange</code> because it refers to the queue itself. The type of <code>exchange</code> affects which queues the message gets into.</p> <p>Thus, RabbitMQ can independently balance the load on queue consumers. You can increase the processing speed of the message flow from the queue by launching additional instances of a consumer service. You don't need to make changes to the current infrastructure configuration: RabbitMQ will take care of how to distribute messages between your services.</p>"},{"location":"rabbit/examples/direct/#example","title":"Example","text":"<p>Tip</p> <p>The Direct Exchange is the type used in FastStream by default. You can simply declare it as follows:</p> <pre><code>@broker.subscriber(\"test_queue\", \"test_exchange\")\nasync def handler():\n    ...\n</code></pre> <p>The argument <code>auto_delete=True</code> in this and subsequent examples is used only to clear the state of RabbitMQ after example runs.</p> <pre><code>from faststream import FastStream, Logger\nfrom faststream.rabbit import RabbitBroker, RabbitExchange, RabbitQueue\n\nbroker = RabbitBroker()\napp = FastStream(broker)\n\nexch = RabbitExchange(\"exchange\", auto_delete=True)\n\nqueue_1 = RabbitQueue(\"test-q-1\", auto_delete=True)\nqueue_2 = RabbitQueue(\"test-q-2\", auto_delete=True)\n\n\n@broker.subscriber(queue_1, exch)\nasync def base_handler1(logger: Logger):\n    logger.info(\"base_handler1\")\n\n\n@broker.subscriber(queue_1, exch)\nasync def base_handler2(logger: Logger):\n    logger.info(\"base_handler2\")\n\n\n@broker.subscriber(queue_2, exch)\nasync def base_handler3(logger: Logger):\n    logger.info(\"base_handler3\")\n\n\n@app.after_startup\nasync def send_messages():\n    await broker.publish(queue=\"test-q-1\", exchange=exch)  # handlers: 1\n    await broker.publish(queue=\"test-q-1\", exchange=exch)  # handlers: 2\n    await broker.publish(queue=\"test-q-1\", exchange=exch)  # handlers: 1\n    await broker.publish(queue=\"test-q-2\", exchange=exch)  # handlers: 3\n</code></pre>"},{"location":"rabbit/examples/direct/#consumer-announcement","title":"Consumer Announcement","text":"<p>First, we announce our Direct exchange and several queues that will listen to it:</p> <pre><code>exch = RabbitExchange(\"exchange\", auto_delete=True)\n\nqueue_1 = RabbitQueue(\"test-q-1\", auto_delete=True)\nqueue_2 = RabbitQueue(\"test-q-2\", auto_delete=True)\n</code></pre> <p>Then we sign up several consumers using the advertised queues to the <code>exchange</code> we created:</p> <pre><code>@broker.subscriber(queue_1, exch)\nasync def base_handler1(logger: Logger):\n    logger.info(\"base_handler1\")\n\n\n@broker.subscriber(queue_1, exch)\nasync def base_handler2(logger: Logger):\n    logger.info(\"base_handler2\")\n\n\n@broker.subscriber(queue_2, exch)\nasync def base_handler3(logger: Logger):\n    logger.info(\"base_handler3\")\n</code></pre> <p>Note</p> <p><code>handler1</code> and <code>handler2</code> are subscribed to the same <code>exchange</code> using the same queue: within a single service, this does not make sense, since messages will come to these handlers in turn. Here we emulate the work of several consumers and load balancing between them.</p>"},{"location":"rabbit/examples/direct/#message-distribution","title":"Message Distribution","text":"<p>Now, the distribution of messages between these consumers will look like this:</p> <pre><code>    await broker.publish(queue=\"test-q-1\", exchange=exch)  # handlers: 1\n</code></pre> <p>Message <code>1</code> will be sent to <code>handler1</code> because it listens to the <code>exchange</code> using a queue with the routing key <code>test-q-1</code>.</p> <pre><code>    await broker.publish(queue=\"test-q-1\", exchange=exch)  # handlers: 2\n</code></pre> <p>Message <code>2</code> will be sent to <code>handler2</code> because it listens to the <code>exchange</code> using the same queue, but <code>handler1</code> is busy.</p> <pre><code>    await broker.publish(queue=\"test-q-1\", exchange=exch)  # handlers: 1\n</code></pre> <p>Message <code>3</code> will be sent to <code>handler1</code> again because it is currently free.</p> <pre><code>    await broker.publish(queue=\"test-q-2\", exchange=exch)  # handlers: 3\n</code></pre> <p>Message <code>4</code> will be sent to <code>handler3</code> because it is the only one listening to the <code>exchange</code> using a queue with the routing key <code>test-q-2</code>.</p>"},{"location":"rabbit/examples/fanout/","title":"Fanout Exchange","text":"<p>The Fanout Exchange is an even simpler, but slightly less popular way of routing in RabbitMQ. This type of <code>exchange</code> sends messages to all queues subscribed to it, ignoring any arguments of the message.</p> <p>At the same time, if the queue listens to several consumers, messages will also be distributed among them.</p>"},{"location":"rabbit/examples/fanout/#example","title":"Example","text":"<pre><code>from faststream import FastStream, Logger\nfrom faststream.rabbit import ExchangeType, RabbitBroker, RabbitExchange, RabbitQueue\n\nbroker = RabbitBroker()\napp = FastStream(broker)\n\nexch = RabbitExchange(\"exchange\", auto_delete=True, type=ExchangeType.FANOUT)\n\nqueue_1 = RabbitQueue(\"test-q-1\", auto_delete=True)\nqueue_2 = RabbitQueue(\"test-q-2\", auto_delete=True)\n\n\n@broker.subscriber(queue_1, exch)\nasync def base_handler1(logger: Logger):\n    logger.info(\"base_handler1\")\n\n\n@broker.subscriber(queue_1, exch)\nasync def base_handler2(logger: Logger):\n    logger.info(\"base_handler2\")\n\n\n@broker.subscriber(queue_2, exch)\nasync def base_handler3(logger: Logger):\n    logger.info(\"base_handler3\")\n\n\n@app.after_startup\nasync def send_messages():\n    await broker.publish(exchange=exch)  # handlers: 1, 3\n    await broker.publish(exchange=exch)  # handlers: 2, 3\n    await broker.publish(exchange=exch)  # handlers: 1, 3\n    await broker.publish(exchange=exch)  # handlers: 2, 3\n</code></pre>"},{"location":"rabbit/examples/fanout/#consumer-announcement","title":"Consumer Announcement","text":"<p>To begin with, we announced our Fanout exchange and several queues that will listen to it:</p> <pre><code>exch = RabbitExchange(\"exchange\", auto_delete=True, type=ExchangeType.FANOUT)\n\nqueue_1 = RabbitQueue(\"test-q-1\", auto_delete=True)\nqueue_2 = RabbitQueue(\"test-q-2\", auto_delete=True)\n</code></pre> <p>Then we signed up several consumers using the advertised queues to the <code>exchange</code> we created:</p> <pre><code>@broker.subscriber(queue_1, exch)\nasync def base_handler1(logger: Logger):\n    logger.info(\"base_handler1\")\n\n\n@broker.subscriber(queue_1, exch)\nasync def base_handler2(logger: Logger):\n    logger.info(\"base_handler2\")\n\n\n@broker.subscriber(queue_2, exch)\nasync def base_handler3(logger: Logger):\n    logger.info(\"base_handler3\")\n</code></pre> <p>Note</p> <p><code>handler1</code> and <code>handler2</code> are subscribed to the same <code>exchange</code> using the same queue: within a single service, this does not make sense, since messages will come to these handlers in turn. Here we emulate the work of several consumers and load balancing between them.</p>"},{"location":"rabbit/examples/fanout/#message-distribution","title":"Message Distribution","text":"<p>Now the distribution of messages between these consumers will look like this:</p> <pre><code>    await broker.publish(exchange=exch)  # handlers: 1, 3\n</code></pre> <p>Message <code>1</code> will be sent to <code>handler1</code> and <code>handler3</code> because they listen to <code>exchange</code> using different queues.</p> <pre><code>    await broker.publish(exchange=exch)  # handlers: 2, 3\n</code></pre> <p>Message <code>2</code> will be sent to <code>handler2</code> and <code>handler3</code> because <code>handler2</code> listens to <code>exchange</code> using the same queue as <code>handler1</code>.</p> <pre><code>    await broker.publish(exchange=exch)  # handlers: 1, 3\n</code></pre> <p>Message <code>3</code> will be sent to <code>handler1</code> and <code>handler3</code>.</p> <pre><code>    await broker.publish(exchange=exch)  # handlers: 2, 3\n</code></pre> <p>Message <code>4</code> will be sent to <code>handler2</code> and <code>handler3</code>.</p> <p>Note</p> <p>When sending messages to Fanout exchange, it makes no sense to specify the arguments <code>queue</code> or <code>routing_key</code>, because they will be ignored.</p>"},{"location":"rabbit/examples/headers/","title":"Header Exchange","text":"<p>The Header Exchange is the most complex and flexible way to route messages in RabbitMQ. This <code>exchange</code> type sends messages to queues according by matching the queue binding arguments with message headers.</p> <p>At the same time, if several consumers are subscribed to the queue, messages will also be distributed among them.</p>"},{"location":"rabbit/examples/headers/#example","title":"Example","text":"<pre><code>from faststream import FastStream, Logger\nfrom faststream.rabbit import ExchangeType, RabbitBroker, RabbitExchange, RabbitQueue\n\nbroker = RabbitBroker()\napp = FastStream(broker)\n\nexch = RabbitExchange(\"exchange\", auto_delete=True, type=ExchangeType.HEADERS)\n\nqueue_1 = RabbitQueue(\n    \"test-queue-1\",\n    auto_delete=True,\n    bind_arguments={\"key\": 1},\n)\nqueue_2 = RabbitQueue(\n    \"test-queue-2\",\n    auto_delete=True,\n    bind_arguments={\"key\": 2, \"key2\": 2, \"x-match\": \"any\"},\n)\nqueue_3 = RabbitQueue(\n    \"test-queue-3\",\n    auto_delete=True,\n    bind_arguments={\"key\": 2, \"key2\": 2, \"x-match\": \"all\"},\n)\n\n\n@broker.subscriber(queue_1, exch)\nasync def base_handler1(logger: Logger):\n    logger.info(\"base_handler1\")\n\n\n@broker.subscriber(queue_1, exch)\nasync def base_handler2(logger: Logger):\n    logger.info(\"base_handler2\")\n\n\n@broker.subscriber(queue_2, exch)\nasync def base_handler3(logger: Logger):\n    logger.info(\"base_handler3\")\n\n\n@broker.subscriber(queue_3, exch)\nasync def base_handler4(logger: Logger):\n    logger.info(\"base_handler4\")\n\n\n@app.after_startup\nasync def send_messages():\n    await broker.publish(exchange=exch, headers={\"key\": 1})  # handlers: 1\n    await broker.publish(exchange=exch, headers={\"key\": 1})  # handlers: 2\n    await broker.publish(exchange=exch, headers={\"key\": 1})  # handlers: 1\n    await broker.publish(exchange=exch, headers={\"key\": 2})  # handlers: 3\n    await broker.publish(exchange=exch, headers={\"key2\": 2})  # handlers: 3\n    await broker.publish(\n        exchange=exch, headers={\"key\": 2, \"key2\": 2.0}\n    )  # handlers: 3, 4\n</code></pre>"},{"location":"rabbit/examples/headers/#consumer-announcement","title":"Consumer Announcement","text":"<p>First, we announce our Header exchange and several queues that will listen to it:</p> <pre><code>exch = RabbitExchange(\"exchange\", auto_delete=True, type=ExchangeType.HEADERS)\n\nqueue_1 = RabbitQueue(\n    \"test-queue-1\",\n    auto_delete=True,\n    bind_arguments={\"key\": 1},\n)\nqueue_2 = RabbitQueue(\n    \"test-queue-2\",\n    auto_delete=True,\n    bind_arguments={\"key\": 2, \"key2\": 2, \"x-match\": \"any\"},\n)\nqueue_3 = RabbitQueue(\n    \"test-queue-3\",\n    auto_delete=True,\n    bind_arguments={\"key\": 2, \"key2\": 2, \"x-match\": \"all\"},\n)\n</code></pre> <p>The <code>x-match</code> argument indicates whether the arguments should match the message headers in whole or in part.</p> <p>Then we signed up several consumers using the advertised queues to the <code>exchange</code> we created:</p> <pre><code>@broker.subscriber(queue_1, exch)\nasync def base_handler1(logger: Logger):\n    logger.info(\"base_handler1\")\n\n\n@broker.subscriber(queue_1, exch)\nasync def base_handler2(logger: Logger):\n    logger.info(\"base_handler2\")\n\n\n@broker.subscriber(queue_2, exch)\nasync def base_handler3(logger: Logger):\n    logger.info(\"base_handler3\")\n\n\n@broker.subscriber(queue_3, exch)\nasync def base_handler4(logger: Logger):\n    logger.info(\"base_handler4\")\n</code></pre> <p>Note</p> <p><code>handler1</code> and <code>handler2</code> are subscribed to the same <code>exchange</code> using the same queue: within a single service, this does not make sense, since messages will come to these handlers in turn. Here we emulate the work of several consumers and load balancing between them.</p>"},{"location":"rabbit/examples/headers/#message-distribution","title":"Message Distribution","text":"<p>Now the distribution of messages between these consumers will look like this:</p> <pre><code>    await broker.publish(exchange=exch, headers={\"key\": 1})  # handlers: 1\n</code></pre> <p>Message <code>1</code> will be sent to <code>handler1</code> because it listens to a queue whose <code>key</code> header matches the <code>key</code> header of the message.</p> <pre><code>    await broker.publish(exchange=exch, headers={\"key\": 1})  # handlers: 2\n</code></pre> <p>Message <code>2</code> will be sent to <code>handler2</code> because it listens to <code>exchange</code> using the same queue, but <code>handler1</code> is busy.</p> <pre><code>    await broker.publish(exchange=exch, headers={\"key\": 1})  # handlers: 1\n</code></pre> <p>Message <code>3</code> will be sent to <code>handler1</code> again because it is currently free.</p> <pre><code>    await broker.publish(exchange=exch, headers={\"key\": 2})  # handlers: 3\n</code></pre> <p>Message <code>4</code> will be sent to <code>handler3</code> because it listens to a queue whose <code>key</code> header coincided with the <code>key</code> header of the message.</p> <pre><code>    await broker.publish(exchange=exch, headers={\"key2\": 2})  # handlers: 3\n</code></pre> <p>Message <code>5</code> will be sent to <code>handler3</code> because it listens to a queue whose header <code>key2</code> coincided with the header <code>key2</code> of the message.</p> <pre><code>    await broker.publish(\n        exchange=exch, headers={\"key\": 2, \"key2\": 2.0}\n    )  # handlers: 3, 4\n</code></pre> <p>Message <code>6</code> will be sent to <code>handler3</code> and <code>handler4</code> because the message headers completely match the queue keys.</p> <p>Note</p> <p>When sending messages to Header exchange, it makes no sense to specify the arguments <code>queue</code> or <code>routing_key</code>, because they will be ignored</p> <p>Warning</p> <p>For incredibly complex routes, you can use the option to bind an <code>exchange</code> to another <code>exchange</code>. In this case, all the same rules apply as for queues subscribed to <code>exchange</code>. The only difference is that the signed <code>exchange</code> can further distribute messages according to its own rules.</p> <p>So, for example, you can combine Topic and Header exchange types.</p>"},{"location":"rabbit/examples/stream/","title":"RabbitMQ Streams","text":"<p>RabbitMQ has a Streams feature, which is closely related to Kafka topics.</p> <p>The main difference from regular RabbitMQ queues is that the messages are not deleted after consuming.</p> <p>And FastStream supports this feature as well!</p> <pre><code>from faststream import FastStream, Logger\nfrom faststream.rabbit import RabbitBroker, RabbitQueue\n\nbroker = RabbitBroker(max_consumers=10)\napp = FastStream(broker)\n\nqueue = RabbitQueue(\n    name=\"test\",\n    durable=True,\n    arguments={\n        \"x-queue-type\": \"stream\",\n    },\n)\n\n\n@broker.subscriber(\n    queue,\n    consume_args={\"x-stream-offset\": \"first\"},\n)\nasync def handle(msg, logger: Logger):\n    logger.info(msg)\n\n\n@app.after_startup\nasync def test():\n    await broker.publish(\"Hi!\", queue)\n</code></pre>"},{"location":"rabbit/examples/topic/","title":"Topic Exchange","text":"<p>The Topic Exchange is a powerful RabbitMQ routing tool. This type of <code>exchange</code> sends messages to the queue in accordance with the pattern specified when they are connected to <code>exchange</code> and the <code>routing_key</code> of the message itself.</p> <p>At the same time, if several consumers are subscribed to the queue, messages will be distributed among them.</p>"},{"location":"rabbit/examples/topic/#example","title":"Example","text":"<pre><code>from faststream import FastStream, Logger\nfrom faststream.rabbit import ExchangeType, RabbitBroker, RabbitExchange, RabbitQueue\n\nbroker = RabbitBroker()\napp = FastStream(broker)\n\nexch = RabbitExchange(\"exchange\", auto_delete=True, type=ExchangeType.TOPIC)\n\nqueue_1 = RabbitQueue(\"test-queue-1\", auto_delete=True, routing_key=\"*.info\")\nqueue_2 = RabbitQueue(\"test-queue-2\", auto_delete=True, routing_key=\"*.debug\")\n\n\n@broker.subscriber(queue_1, exch)\nasync def base_handler1(logger: Logger):\n    logger.info(\"base_handler1\")\n\n\n@broker.subscriber(queue_1, exch)\nasync def base_handler2(logger: Logger):\n    logger.info(\"base_handler2\")\n\n\n@broker.subscriber(queue_2, exch)\nasync def base_handler3(logger: Logger):\n    logger.info(\"base_handler3\")\n\n\n@app.after_startup\nasync def send_messages():\n    await broker.publish(routing_key=\"logs.info\", exchange=exch)  # handlers: 1\n    await broker.publish(routing_key=\"logs.info\", exchange=exch)  # handlers: 2\n    await broker.publish(routing_key=\"logs.info\", exchange=exch)  # handlers: 1\n    await broker.publish(routing_key=\"logs.debug\", exchange=exch)  # handlers: 3\n</code></pre>"},{"location":"rabbit/examples/topic/#consumer-announcement","title":"Consumer Announcement","text":"<p>First, we announce our Topic exchange and several queues that will listen to it:</p> <pre><code>exch = RabbitExchange(\"exchange\", auto_delete=True, type=ExchangeType.TOPIC)\n\nqueue_1 = RabbitQueue(\"test-queue-1\", auto_delete=True, routing_key=\"*.info\")\nqueue_2 = RabbitQueue(\"test-queue-2\", auto_delete=True, routing_key=\"*.debug\")\n</code></pre> <p>At the same time, in the <code>routing_key</code> of our queues, we specify the pattern of routing keys that will be processed by this queue.</p> <p>Then we sign up several consumers using the advertised queues to the <code>exchange</code> we created:</p> <pre><code>@broker.subscriber(queue_1, exch)\nasync def base_handler1(logger: Logger):\n    logger.info(\"base_handler1\")\n\n\n@broker.subscriber(queue_1, exch)\nasync def base_handler2(logger: Logger):\n    logger.info(\"base_handler2\")\n\n\n@broker.subscriber(queue_2, exch)\nasync def base_handler3(logger: Logger):\n    logger.info(\"base_handler3\")\n</code></pre> <p>Note</p> <p><code>handler1</code> and <code>handler2</code> are subscribed to the same <code>exchange</code> using the same queue: within a single service, this does not make sense, since messages will come to these handlers in turn. Here we emulate the work of several consumers and load balancing between them.</p>"},{"location":"rabbit/examples/topic/#message-distribution","title":"Message Distribution","text":"<p>Now the distribution of messages between these consumers will look like this:</p> <pre><code>    await broker.publish(routing_key=\"logs.info\", exchange=exch)  # handlers: 1\n</code></pre> <p>Message <code>1</code> will be sent to <code>handler1</code> because it listens to <code>exchange</code> using a queue with the routing key <code>*.info</code>.</p> <pre><code>    await broker.publish(routing_key=\"logs.info\", exchange=exch)  # handlers: 2\n</code></pre> <p>Message <code>2</code> will be sent to <code>handler2</code> because it listens to <code>exchange</code> using the same queue, but <code>handler1</code> is busy.</p> <pre><code>    await broker.publish(routing_key=\"logs.info\", exchange=exch)  # handlers: 1\n</code></pre> <p>Message <code>3</code> will be sent to <code>handler1</code> again because it is currently free.</p> <pre><code>    await broker.publish(routing_key=\"logs.debug\", exchange=exch)  # handlers: 3\n</code></pre> <p>Message <code>4</code> will be sent to <code>handler3</code> because it is the only one listening to <code>exchange</code> using a queue with the routing key <code>*.debug</code>.</p>"}]}