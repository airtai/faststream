# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/028_Plan_Generator.ipynb.

# %% auto 0
__all__ = ['logger', 'ENTITY_ERROR_MSG', 'APPS_ERROR_MSG', 'CONSUME_FUNCTIONS_ERROR_MSG', 'PRODUCE_FUNCTIONS_ERROR_MSG',
           'EXPECTED_FUNCTION_KEYS', 'EXPECTED_APP_KEYS', 'generate_plan']

# %% ../../nbs/028_Plan_Generator.ipynb 1
from typing import *
import time
import json

from yaspin import yaspin

from .._components.logger import get_logger
from .helper import CustomAIChat, ValidateAndFixResponse
from .prompts import PLAN_GENERATION_PROMPT

# %% ../../nbs/028_Plan_Generator.ipynb 3
logger = get_logger(__name__)

# %% ../../nbs/028_Plan_Generator.ipynb 5
ENTITY_ERROR_MSG = {
    "invalid_entity": "The entities should be a list and cannot be empty in the generated plan. Please read the ==== APP DESCRIPTION: ==== and generate valid entities",
    "invalid_name": "The name of the entity should be defined and cannot be empty. Please read the ==== APP DESCRIPTION: ==== and add a valid value to the 'name' key",
    "invalid_arguments": "The arguments of the entity should be a dictionary with key, value pairs and cannot be empty or any other datatype. Please read the ==== APP DESCRIPTION: ==== and generate valid arguments",
}

# %% ../../nbs/028_Plan_Generator.ipynb 6
def _validate_entities(plan: Dict[str, List[Dict[str, Any]]]) -> List[str]:
    """Validate the entities in the given plan and returns a list of any error messages encountered.

    Args:
        plan: The plan generated by OpenAI

    Returns:
        A list containing error messages for each validation failure. If there are no errors, an empty list is returned.
    """
    entities = plan.get("entities")
    if not isinstance(entities, list) or len(entities) == 0:
        return [ENTITY_ERROR_MSG["invalid_entity"]]

    errors = []
    for entity in entities:
        if not isinstance(entity.get("name"), str) or entity.get("name") == "":
            errors.append(ENTITY_ERROR_MSG["invalid_name"])
        if (
            not isinstance(entity.get("arguments"), dict)
            or entity.get("arguments") == {}
        ):
            errors.append(ENTITY_ERROR_MSG["invalid_arguments"])
    return errors

# %% ../../nbs/028_Plan_Generator.ipynb 12
APPS_ERROR_MSG = {
    "invalid_app": "The apps should be a list and cannot be empty in the generated plan. Please read the ==== APP DESCRIPTION: ==== and generate valid apps",
    "missing_app_keys": "The below keys are missing from the apps. Please read the ==== APP DESCRIPTION: ==== and add the missing keys",
    "invalid_app_name": "The app_name cannot have spaces. The app_name should be in lower letters and can have 'underscore'. Please read the ==== APP DESCRIPTION: ==== and generate valid arguments",
    "invalid_kafka_brokers": "The kafka_brokers can either be a dictionary or None. It cannot have anyother data types. The app_name should be in lower letters and can have 'underscore'. Please read the ==== APP DESCRIPTION: ==== and generate valid kafka_brokers",
}

CONSUME_FUNCTIONS_ERROR_MSG = {
    "invalid_functions": "The consumes_functions can either be a dictionary with key and value pairs or {}. It cannot have anyother data types. Please read the ==== APP DESCRIPTION: ==== and generate valid consumes_functions",
    "missing_functions_keys": "The below keys are missing from the '{}' consumes_functions. Please read the ==== APP DESCRIPTION: ==== and add the missing keys",
    "invalid_prefix": "The '{}' funtion name is having invalid prefix in the name. Please fix the function name using the following rule.\nConsume function names should follow the format: prefix + '_' + topic name. If the user doesn't explicitly define the prefix for the consumes function in the ==== APP DESCRIPTION: ====, the default prefix 'on' should be used.",
}

PRODUCE_FUNCTIONS_ERROR_MSG = {
    "invalid_functions": "The produces_functions can either be a dictionary with key and value paris or {}. It cannot have anyother data types. Please read the ==== APP DESCRIPTION: ==== and generate valid produces_functions",
    "missing_functions_keys": "The below keys are missing from the '{}' produces_functions. Please read the ==== APP DESCRIPTION: ==== and add the missing keys",
    "invalid_prefix": "The '{}' funtion name is having invalid prefix in the name. Please fix the function name using the following rule.\nProduce function names should follow the format: prefix + '_' + topic name. If the user doesn't explicitly define the prefix for the produces function, the default prefix 'to' should be used.",
    "missing_return": "The '{}' function has invalid return. The return key shoyuld have a value and it cannot be None. Please read the ==== APP DESCRIPTION: ==== and add a valid return type",
}

EXPECTED_FUNCTION_KEYS = [
    "topic",
    "prefix",
    "parameters",
]

# %% ../../nbs/028_Plan_Generator.ipynb 13
def _validate_for_missing_keys(
    key: str, missing_keys: List[str], errors: List[str], error_msgs: Dict[str, str]
) -> List[str]:
    """Validate for missing keys and append the error messages to the errors.

    Args:
        key: The key to be validated.
        missing_keys: List of missing keys to be appended.
        errors: List of existing errors to which new errors will be appended.
        error_msgs: Dictionary of common error messages.

    Returns:
        The updated list of errors after appending the missing keys error message.
    """
    missing_keys_error = error_msgs["missing_functions_keys"].format(key)
    missing_keys_list = "\n".join(sorted(missing_keys))
    errors.append(f"{missing_keys_error}\n\n{missing_keys_list}")

    return errors

# %% ../../nbs/028_Plan_Generator.ipynb 16
def _validate_prefix(
    key: str,
    params: Dict[str, Union[str, List[Dict[str, str]]]],
    errors: List[str],
    error_msgs: Dict[str, str],
) -> List[str]:
    """Validate the prefix key in consumers/producers function.

    Args:
        key: The key to be validated.
        params: A dictionary containing the response from OpenAI.
        errors: A list of error messages.
        error_msgs: A dictionary containing common error messages.

    Returns:
        The updated list of error messages.
    """
    if key.split("_")[0] != params["prefix"]:
        errors.append(error_msgs["invalid_prefix"].format(key))
    return errors

# %% ../../nbs/028_Plan_Generator.ipynb 20
def _get_error_msgs_and_expected_keys(
    is_producer_function: bool,
) -> Tuple[Dict[str, str], List[str]]:
    """Get appropriate error messages and expected keys to be checked for the given function.

    Args:
        is_producer_function: Flag indicating whether the function is a producer function or not.

    Returns:
        A tuple containing a dictionary of error messages and a list of expected keys.
    """
    if is_producer_function:
        return PRODUCE_FUNCTIONS_ERROR_MSG, EXPECTED_FUNCTION_KEYS + ["returns"]
    else:
        return CONSUME_FUNCTIONS_ERROR_MSG, EXPECTED_FUNCTION_KEYS

# %% ../../nbs/028_Plan_Generator.ipynb 23
def _validate_functions(
    functions: Dict[str, Dict[str, Union[str, List[Dict[str, str]]]]],
    errors: List[str],
    is_producer_function: bool = False,
) -> List[str]:
    """Validate the given functions dictionary

    Args:
        functions: A dictionary containing function names as keys and their properties as values.
        errors: A list of error messages.
        is_producer_function: A flag indicating whether the functions to be validated are producer functions. Defaults to False.

    Returns:
        A list of error messages. If no errors are found, an empty list is returned.
    """
    error_msgs, expected_keys = _get_error_msgs_and_expected_keys(is_producer_function)

    if not isinstance(functions, dict):
        errors.append(error_msgs["invalid_functions"])
        return errors

    if functions == {}:
        return errors

    for key, params in functions.items():
        missing_keys = list(set(expected_keys) - set(params.keys()))
        if len(missing_keys) > 0:
            errors = _validate_for_missing_keys(key, missing_keys, errors, error_msgs)
        else:
            errors = _validate_prefix(key, params, errors, error_msgs)
            if is_producer_function:
                if str(params["returns"]) == "None":
                    errors.append(error_msgs["missing_return"].format(key))
    return errors

# %% ../../nbs/028_Plan_Generator.ipynb 30
EXPECTED_APP_KEYS = [
    "app_name",
    "kafka_brokers",
    "title",
    "consumes_functions",
    "produces_functions",
]


def _validate_apps(plan: Dict[str, List[Dict[str, Any]]]) -> List[str]:
    """Validate the 'apps' part of the generated plan.

    Args:
        plan: The plan generated by OpenAI

    Returns:
        A list of error messages if there are any errors, otherwise an empty list.
    """
    apps = plan.get("apps")
    if not isinstance(apps, list) or len(apps) == 0:
        return [APPS_ERROR_MSG["invalid_app"]]

    errors = []
    for app in apps:
        missing_app_keys = list(set(EXPECTED_APP_KEYS) - set(app.keys()))
        if len(missing_app_keys) > 0:
            return [
                APPS_ERROR_MSG["missing_app_keys"]
                + "\n\n"
                + "\n".join(sorted(missing_app_keys))
            ]
        else:
            if len(app["app_name"].split(" ")) != 1:
                errors.append(APPS_ERROR_MSG["invalid_app_name"])
            if (
                not isinstance(app["kafka_brokers"], dict)
                and not str(app["kafka_brokers"]) == "None"
            ):
                errors.append(APPS_ERROR_MSG["invalid_kafka_brokers"])
            for func_details, flag in [
                (app["consumes_functions"], False),
                (app["produces_functions"], True),
            ]:
                errors = _validate_functions(func_details, errors, flag)
    return errors

# %% ../../nbs/028_Plan_Generator.ipynb 38
def _vaidate_plan(plan: Dict[str, List[Dict[str, Any]]]) -> List[str]:
    """Validates the generated plan

    Args:
        plan: The plan to be validated.

    Returns:
        A list of error messages generated during the validation process. If no errors are found, an empty list is returned.
    """
    entity_error = _validate_entities(plan)
    app_error = _validate_apps(plan)
    return entity_error + app_error

# %% ../../nbs/028_Plan_Generator.ipynb 41
def _validate_response(response: str) -> List[str]:
    """Validate the plan response generated by OpenAI

    Args:
        response: The JSON plan response generated by OpenAI in string format.

    Returns:
        Returns a list of errors if any found during the validation of the plan.

    Raises:
        json.JSONDecodeError: If the response is not a valid JSON.
    """
    try:
        response_dict = json.loads(response)
        errors_list = _vaidate_plan(response_dict)
        return errors_list
    except json.JSONDecodeError as e:
        return ["JSON decoding failed. Please send JSON response only."]

# %% ../../nbs/028_Plan_Generator.ipynb 44
def generate_plan(description: str) -> Tuple[str, str]:
    """Generate a plan from user's application description

    Args:
        description: Validated User application description

    Returns:
        The plan generated by OpenAI as a dictionary
    """
    with yaspin(
        text="Generating plan",  #  (slowest step, usually takes 30 to 90 seconds)...
        color="cyan",
        spinner="clock",
    ) as sp:
        plan_generator = CustomAIChat(user_prompt=PLAN_GENERATION_PROMPT)
        plan_validator = ValidateAndFixResponse(plan_generator, _validate_response)
        validated_plan, total_tokens = plan_validator.fix(description)

        sp.text = ""
        sp.ok(" âœ” Plan generated")
        return validated_plan, total_tokens
