{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>FastStream</li> <li>Tutorial<ul> <li>Getting Started</li> <li>Subscription and Serialization<ul> <li>Annotation Serialization</li> <li>Pydantic Serialization</li> <li>Filtering</li> <li>Testing</li> </ul> </li> <li>Publishing<ul> <li>Broker Publish</li> <li>Decorator</li> <li>Object Decorator</li> <li>Direct Publishing</li> <li>Testing</li> </ul> </li> <li>Routers</li> <li>Dependencies</li> <li>Context<ul> <li>Existing Fields</li> <li>Custom Context</li> <li>Fields Access</li> <li>Extra Options</li> </ul> </li> <li>Custom Serialization<ul> <li>Parser</li> <li>Decoder</li> <li>Examples</li> </ul> </li> <li>Lifespan<ul> <li>Lifespan Hooks</li> <li>Lifespan Testing</li> </ul> </li> <li>Middlewares</li> <li>AsyncAPI<ul> <li>Schema Export</li> <li>Schema Hosting</li> <li>Customize Information</li> </ul> </li> <li>Integrations</li> <li>FastAPI Plugin</li> <li>CLI commands</li> <li>Logging</li> <li>Config Management</li> </ul> </li> <li>Kafka<ul> <li>Subscribing<ul> <li>Batch Subscriber</li> </ul> </li> <li>Publishing<ul> <li>Batch Publishing</li> <li>Publish With Key</li> </ul> </li> <li>Message Information</li> </ul> </li> <li>RabbitMQ<ul> <li>Subsctiption<ul> <li>Direct</li> <li>Fanout</li> <li>Topic</li> <li>Headers</li> <li>Stream</li> </ul> </li> <li>Publishing</li> <li>RPC</li> <li>Acknowledgement</li> <li>Declare Queue/Exchange</li> <li>Message Information</li> </ul> </li> <li>Contributing<ul> <li>Development</li> <li>Documentation</li> </ul> </li> <li>Release Notes</li> </ul>"},{"location":"","title":"FastStream","text":"<p>Effortless event stream integration for your services</p> <p> </p>"},{"location":"#features","title":"Features","text":"<p>FastStream simplifies the process of writing producers and consumers for message queues, handling all the parsing, networking and documentation generation automatically.</p> <p>Making streaming microservices has never been easier. Designed with junior developers in mind, FastStream simplifies your work while keeping the door open for more advanced use-cases. Here's a look at the core features that make FastStream a go-to framework for modern, data-centric microservices.</p> <ul> <li> <p>Multiple Brokers: FastStream provides a unified API to work across multiple message brokers (Kafka, RabbitMQ support)</p> </li> <li> <p>Pydantic Validation: Leverage Pydantic's validation capabilities to serialize and validates incoming messages</p> </li> <li> <p>Automatic Docs: Stay ahead with automatic AsyncAPI documentation</p> </li> <li> <p>Intuitive: Full-typed editor support makes your development experience smooth, catching errors before they reach runtime</p> </li> <li> <p>Powerful Dependency Injection System: Manage your service dependencies efficiently with FastStream's built-in DI system</p> </li> <li> <p>Testable: Supports in-memory tests, making your CI/CD pipeline faster and more reliable</p> </li> <li> <p>Extendable: Use extensions for lifespans, custom serialization and middlewares</p> </li> <li> <p>Integrations: FastStream is fully compatible with any HTTP framework you want (FastAPI especially)</p> </li> <li> <p>Built for Automatic Code Generation: FastStream is optimized for automatic code generation using advanced models like GPT and Llama</p> </li> </ul> <p>That's FastStream in a nutshell\u2014easy, efficient, and powerful. Whether you're just starting with streaming microservices or looking to scale, FastStream has got you covered.</p>"},{"location":"#history","title":"History","text":"<p>FastStream is a new package based on the ideas and experiences gained from FastKafka and Propan. By joining our forces, we picked up the best from both packages and created a unified way to write services capable of processing streamed data regradless of the underliying protocol. We'll continue to maintain both packages, but new development will be in this project. If you are starting a new service, this package is the recommended way to do it.</p>"},{"location":"#install","title":"Install","text":"<p>FastStream works on Linux, macOS, Windows and most Unix-style operating systems. You can install it with <code>pip</code> as usual:</p> KafkaRabbitMQ <pre><code>pip install faststream[kafka]\n</code></pre> <pre><code>pip install faststream[rabbit]\n</code></pre> <p>By default FastStream uses PydanticV2 written in Rust, but you can downgrade it manually, if your platform has no Rust support - FastStream will work correctly with PydanticV1 as well.</p>"},{"location":"#writing-app-code","title":"Writing app code","text":"<p>FastStream brokers provide convenient function decorators <code>@broker.subscriber</code> and <code>@broker.publisher</code> to allow you to delegate the actual process of:</p> <ul> <li> <p>consuming and producing data to Event queues, and</p> </li> <li> <p>decoding and encoding JSON encoded messages</p> </li> </ul> <p>These decorators make it easy to specify the processing logic for your consumers and producers, allowing you to focus on the core business logic of your application without worrying about the underlying integration.</p> <p>Also, FastStream uses Pydantic to parse input JSON-encoded data into Python objects, making it easy to work with structured data in your applications, so you can serialize your input messages just using type annotations.</p> <p>Here is an example python app using FastStream that consumes data from an incoming data stream and outputs the data to another one:</p> KafkaRabbitMQ <pre><code>from faststream import FastStream\nfrom faststream.kafka import KafkaBroker\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\n@broker.subscriber(\"in-topic\")\n@broker.publisher(\"out-topic\")\nasync def handle_msg(user: str, user_id: int) -&gt; str:\nreturn f\"User: {user_id} - {user} registered\"\n</code></pre> <pre><code>from faststream import FastStream\nfrom faststream.rabbit import RabbitBroker\nbroker = RabbitBroker(\"amqp://guest:guest@localhost:5672/\")\napp = FastStream(broker)\n@broker.subscriber(\"in-queue\")\n@broker.publisher(\"out-queue\")\nasync def handle_msg(user: str, user_id: int) -&gt; str:\nreturn f\"User: {user_id} - {user} registered\"\n</code></pre> <p>Also, Pydantic\u2019s <code>BaseModel</code> class allows you to define messages using a declarative syntax, making it easy to specify the fields and types of your messages.</p> KafkaRabbitMQ <pre><code>from pydantic import BaseModel, Field, PositiveInt\nfrom faststream import FastStream\nfrom faststream.kafka import KafkaBroker\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\nclass User(BaseModel):\nuser: str = Field(..., examples=[\"John\"])\nuser_id: PositiveInt = Field(..., examples=[\"1\"])\n@broker.subscriber(\"in-topic\")\n@broker.publisher(\"out-topic\")\nasync def handle_msg(data: User) -&gt; str:\nreturn f\"User: {data.user} - {data.user_id} registered\"\n</code></pre> <pre><code>from pydantic import BaseModel, Field, PositiveInt\nfrom faststream import FastStream\nfrom faststream.rabbit import RabbitBroker\nbroker = RabbitBroker(\"amqp://guest:guest@localhost:5672/\")\napp = FastStream(broker)\nclass User(BaseModel):\nuser: str = Field(..., examples=[\"John\"])\nuser_id: PositiveInt = Field(..., examples=[\"1\"])\n@broker.subscriber(\"in-queue\")\n@broker.publisher(\"out-queue\")\nasync def handle_msg(data: User) -&gt; str:\nreturn f\"User: {data.user} - {data.user_id} registered\"\n</code></pre>"},{"location":"#testing-the-service","title":"Testing the service","text":"<p>The service can be tested using the <code>TestBroker</code> context managers, which, by default, puts the Broker into \"testing mode\".</p> <p>The Tester will redirect your <code>subscriber</code> and <code>publisher</code> decorated functions to the InMemory brokers, allowing you to quickly test your app without the need for a running broker and all its dependencies.</p> <p>Using pytest, the test for our service would look like this:</p> KafkaRabbitMQ <pre><code># Code above omitted \ud83d\udc46\nimport pytest\nimport pydantic\nfrom faststream.kafka import TestKafkaBroker\n@pytest.mark.asyncio\nasync def test_correct():\nasync with TestKafkaBroker(broker) as br:\nawait br.publish({\n\"user\": \"John\",\n\"user_id\": 1,\n}, \"in-topic\")\n@pytest.mark.asyncio\nasync def test_invalid():\nasync with TestKafkaBroker(broker) as br:\nwith pytest.raises(pydantic.ValidationError):\nawait br.publish(\"wrong message\", \"in-topic\")\n</code></pre> <pre><code># Code above omitted \ud83d\udc46\nimport pytest\nimport pydantic\nfrom faststream.rabbit import TestRabbitBroker\n@pytest.mark.asyncio\nasync def test_correct():\nasync with TestRabbitBroker(broker) as br:\nawait br.publish({\n\"user\": \"John\",\n\"user_id\": 1,\n}, \"in-queue\")\n@pytest.mark.asyncio\nasync def test_invalid():\nasync with TestRabbitBroker(broker) as br:\nwith pytest.raises(pydantic.ValidationError):\nawait br.publish(\"wrong message\", \"in-queue\")\n</code></pre>"},{"location":"#running-the-application","title":"Running the application","text":"<p>The application can be started using built-in FastStream CLI command.</p> <p>To run the service, use the FastStream CLI command and pass the module (in this case, the file where the app implementation is located) and the app symbol to the command.</p> <pre><code>faststream run basic:app\n</code></pre> <p>After running the command, you should see the following output:</p> <pre><code>INFO     - FastStream app starting...\nINFO     - input_data |            - `HandleMsg` waiting for messages\nINFO     - FastStream app started successfully! To exit press CTRL+C\n</code></pre> <p>Also, FastStream provides you a great hot reload feature to improve your Development Experience</p> <pre><code>faststream run basic:app --reload\n</code></pre> <p>And multiprocessing horizontal scaling feature as well:</p> <pre><code>faststream run basic:app --workers 3\n</code></pre> <p>You can know more about CLI features here</p>"},{"location":"#project-documentation","title":"Project Documentation","text":"<p>FastStream automatically generates documentation for your project according to the AsyncAPI specification. You can work with both generated artifacts and place a web view of your documentation on resources available to related teams.</p> <p>The availability of such documentation significantly simplifies the integration of services: you can immediately see what channels and message formats the application works with. And most importantly, it won't cost anything - FastStream has already created the docs for you!</p> <p></p>"},{"location":"#dependencies","title":"Dependencies","text":"<p>FastStream (thanks to FastDepend) has a dependency management system similar to <code>pytest fixtures</code> and <code>FastAPI Depends</code> at the same time. Function arguments declare which dependencies you want are needed, and a special decorator delivers them from the global Context object.</p> <pre><code>from faststream import Depends, Logger\nasync def base_dep(user_id: int) -&gt; bool:\nreturn True\n@broker.subscriber(\"in-test\")\nasync def base_handler(user: str,\nlogger: Logger,\ndep: bool = Depends(base_dep)):\nassert dep is True\nlogger.info(user)\n</code></pre>"},{"location":"#http-frameworks-integrations","title":"HTTP Frameworks integrations","text":""},{"location":"#any-framework","title":"Any Framework","text":"<p>You can use FastStream <code>MQBrokers</code> without a <code>FastStream</code> application. Just start and stop them according to your application's lifespan.</p> AiohttpBlacksheepFalconQuartSanic <pre><code>from aiohttp import web\nfrom faststream.kafka import KafkaBroker\nbroker = KafkaBroker(\"localhost:9092\")\n@broker.subscriber(\"test\")\nasync def base_handler(body):\nprint(body)\nasync def start_broker(app):\nawait broker.start()\nasync def stop_broker(app):\nawait broker.close()\nasync def hello(request):\nreturn web.Response(text=\"Hello, world\")\napp = web.Application()\napp.add_routes([web.get(\"/\", hello)])\napp.on_startup.append(start_broker)\napp.on_cleanup.append(stop_broker)\nif __name__ == \"__main__\":\nweb.run_app(app)\n</code></pre> <pre><code>from blacksheep import Application\nfrom faststream.kafka import KafkaBroker\nbroker = KafkaBroker(\"localhost:9092\")\napp = Application()\n@broker.subscriber(\"test\")\nasync def base_handler(body):\nprint(body)\n@app.on_start\nasync def start_broker(application: Application) -&gt; None:\nawait broker.start()\n@app.on_stop\nasync def stop_broker(application: Application) -&gt; None:\nawait broker.close()\n@app.route(\"/\")\nasync def home():\nreturn \"Hello, World!\"\n</code></pre> <pre><code>import falcon\nimport falcon.asgi\nfrom faststream.kafka import KafkaBroker\nbroker = KafkaBroker(\"localhost:9092\")\n@broker.subscriber(\"test\")\nasync def base_handler(body):\nprint(body)\nclass ThingsResource:\nasync def on_get(self, req, resp):\nresp.status = falcon.HTTP_200\nresp.content_type = falcon.MEDIA_TEXT\nresp.text = (\n\"\\nTwo things awe me most, the starry sky \"\n\"above me and the moral law within me.\\n\"\n\"\\n\"\n\"    ~ Immanuel Kant\\n\\n\"\n)\nclass PropanMiddleware:\nasync def process_startup(self, scope, event):\nawait broker.start()\nasync def process_shutdown(self, scope, event):\nawait broker.close()\napp = falcon.asgi.App()\napp.add_middleware(PropanMiddleware())\napp.add_route(\"/things\", ThingsResource())\n</code></pre> <pre><code>from quart import Quart\nfrom faststream.kafka import KafkaBroker\nbroker = KafkaBroker(\"localhost:9092\")\napp = Quart(__name__)\n@broker.subscriber(\"test\")\nasync def base_handler(body):\nprint(body)\n@app.before_serving\nasync def start_broker():\nawait broker.start()\n@app.after_serving\nasync def stop_broker():\nawait broker.close()\n@app.route(\"/\")\nasync def json():\nreturn {\"hello\": \"world\"}\n</code></pre> <pre><code>from sanic import Sanic\nfrom sanic.response import text\nfrom faststream.kafka import KafkaBroker\nbroker = KafkaBroker(\"localhost:9092\")\napp = Sanic(\"MyHelloWorldApp\")\n@broker.subscriber(\"test\")\nasync def base_handler(body):\nprint(body)\n@app.after_server_start\nasync def start_broker(app, loop):\nawait broker.start()\n@app.after_server_stop\nasync def stop_broker(app, loop):\nawait broker.close()\n@app.get(\"/\")\nasync def hello_world(request):\nreturn text(\"Hello, world.\")\n</code></pre>"},{"location":"#fastapi-plugin","title":"FastAPI Plugin","text":"<p>Also, FastStream can be used as part of FastAPI.</p> <p>Just import a StreamRouter you need and declare the message handler with the same <code>@router.subscriber(...)</code> and <code>@router.publisher(...)</code> decorators.</p> <p>Tip</p> <p>When used this way, FastStream does not utilize its own dependency and serialization system but integrates seamlessly into FastAPI. This means you can use <code>Depends</code>, <code>BackgroundTasks</code> and other FastAPI tools as if it were a regular HTTP endpoint.</p> KafkaRabbitMQ <pre><code>from fastapi import Depends, FastAPI\nfrom pydantic import BaseModel\nfrom faststream.kafka.fastapi import KafkaRouter\nrouter = KafkaRouter(\"localhost:9092\")\nclass Incoming(BaseModel):\nm: dict\ndef call():\nreturn True\n@router.subscriber(\"test\")\n@router.publisher(\"response\")\nasync def hello(m: Incoming, d=Depends(call)):\nreturn {\"response\": \"Hello, world!\"}\n@router.get(\"/\")\nasync def hello_http():\nreturn \"Hello, http!\"\napp = FastAPI(lifespan=router.lifespan_context)\napp.include_router(router)\n</code></pre> <pre><code>from fastapi import Depends, FastAPI\nfrom pydantic import BaseModel\nfrom faststream.rabbit.fastapi import RabbitRouter\nrouter = RabbitRouter(\"amqp://guest:guest@localhost:5672/\")\nclass Incoming(BaseModel):\nm: dict\ndef call():\nreturn True\n@router.subscriber(\"test\")\n@router.publisher(\"response\")\nasync def hello(m: Incoming, d=Depends(call)):\nreturn {\"response\": \"Hello, world!\"}\n@router.get(\"/\")\nasync def hello_http():\nreturn \"Hello, http!\"\napp = FastAPI(lifespan=router.lifespan_context)\napp.include_router(router)\n</code></pre> <p>Note</p> <p>More integration features can be found here</p>"},{"location":"#code-generator","title":"Code generator","text":"<p>As evident, FastStream is an incredibly user-friendly framework. However, we've taken it a step further and made it even more user-friendly! Introducing faststream-gen, a Python library that harnesses the power of generative AI to effortlessly generate FastStream applications. Simply describe your application requirements, and faststream-gen will generate a production-grade FastStream project that is ready to deploy in no time.</p> <p>Save application description inside <code>description.txt</code>: <pre><code>Create a FastStream application using localhost broker for testing and use the\ndefault port number.\n\nIt should consume messages from the 'input_data' topic, where each message is a\nJSON encoded object containing a single attribute: 'data'.\n\nWhile consuming from the topic, increment the value of the data attribute by 1.\n\nFinally, send message to the 'output_data' topic.\n</code></pre></p> <p>and run the following command to create a new FastStream project: <pre><code>faststream_gen -i description.txt\n</code></pre></p> <pre><code>\u2728  Generating a new FastStream application!\n \u2714 Application description validated.\n \u2714 FastStream app skeleton code generated. akes around 15 to 45 seconds)...\n \u2714 The app and the tests are generated.  around 30 to 90 seconds)...\n \u2714 New FastStream project created.\n \u2714 Integration tests were successfully completed.\n Tokens used: 10768\nTotal Cost (USD): $0.03284\n\u2728  All files were successfully generated!\n</code></pre>"},{"location":"#tutorial","title":"Tutorial","text":"<p>We also invite you to explore our tutorial, where we will guide you through the process of utilizing the faststream-gen Python library to effortlessly create FastStream applications:</p> <ul> <li>Cryptocurrency analysis with FastStream</li> </ul>"},{"location":"#stay-in-touch","title":"Stay in touch","text":"<p>Please show your support and stay in touch by:</p> <ul> <li> <p>giving our GitHub repository a star, and</p> </li> <li> <p>joining our Discord server</p> </li> </ul> <p>Your support helps us to stay in touch with you and encourages us to continue developing and improving the framework. Thank you for your support!</p>"},{"location":"#contributors","title":"Contributors","text":"<p>Thanks to all of these amazing people who made the project better!</p> <p> </p>"},{"location":"release/","title":"Release Notes","text":"<p>FastStream is a new package based on the ideas and experiences gained from FastKafka and Propan. By joining our forces, we picked up the best from both packages and created the unified way to write services capable of processing streamed data regradless of the underliying protocol. We'll continue to maintain both packages, but new development will be in this project. If you are starting a new service, this package is the recommended way to do it.</p>"},{"location":"release/#features","title":"Features","text":"<p>FastStream simplifies the process of writing producers and consumers for message queues, handling all the parsing, networking and documentation generation automatically.</p> <p>Making streaming microservices has never been easier. Designed with junior developers in mind, FastStream simplifies your work while keeping the door open for more advanced use-cases. Here's a look at the core features that make FastStream a go-to framework for modern, data-centric microservices.</p> <ul> <li> <p>Multiple Brokers: FastStream provides a unified API to work across multiple message brokers (Kafka, RabbitMQ support)</p> </li> <li> <p>Pydantic Validation: Leverage Pydantic's validation capabilities to serialize and validates incoming messages</p> </li> <li> <p>Automatic Docs: Stay ahead with automatic AsyncAPI documentation.</p> </li> <li> <p>Intuitive: full typed editor support makes your development experience smooth, catching errors before they reach runtime</p> </li> <li> <p>Powerful Dependency Injection System: Manage your service dependencies efficiently with FastStream's built-in DI system.</p> </li> <li> <p>Testable: supports in-memory tests, making your CI/CD pipeline faster and more reliable</p> </li> <li> <p>Extendable: use extensions for lifespans, custom serialization and middlewares</p> </li> <li> <p>Integrations: FastStream is fully compatible with any HTTP framework you want (FastAPI especially)</p> </li> <li> <p>Built for Automatic Code Generation: FastStream is optimized for automatic code generation using advanced models like GPT and Llama</p> </li> </ul> <p>That's FastStream in a nutshell\u2014easy, efficient, and powerful. Whether you're just starting with streaming microservices or looking to scale, FastStream has got you covered.</p>"},{"location":"api/faststream/app/ABCApp/","title":"ABCApp","text":""},{"location":"api/faststream/app/ABCApp/#faststream.app.ABCApp","title":"faststream.app.ABCApp","text":"<p>             Bases: <code>ABC</code></p> <p>A class representing an ABC App.</p> METHOD DESCRIPTION <code>set_broker </code> <p>Set the broker object</p> <code>on_startup </code> <p>Add a hook to be run before the broker is connected</p> <code>on_shutdown </code> <p>Add a hook to be run before the broker is disconnected</p> <code>after_startup </code> <p>Add a hook to be run after the broker is connected</p> <code>after_shutdown </code> <p>Add a hook to be run after the broker is disconnected</p> <code>_log </code> <p>Log a message at a specified</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/app.py</code> <pre><code>class ABCApp(ABC):\n\"\"\"A class representing an ABC App.\n    Attributes:\n        _on_startup_calling : List of callable functions to be called on startup\n        _after_startup_calling : List of callable functions to be called after startup\n        _on_shutdown_calling : List of callable functions to be called on shutdown\n        _after_shutdown_calling : List of callable functions to be called after shutdown\n        broker : Optional broker object\n        logger : Optional logger object\n        title : Title of the app\n        version : Version of the app\n        description : Description of the app\n        terms_of_service : Optional terms of service URL\n        license : Optional license information\n        contact : Optional contact information\n        identifier : Optional identifier\n        asyncapi_tags : Optional list of tags\n        external_docs : Optional external documentation\n    Methods:\n        set_broker : Set the broker object\n        on_startup : Add a hook to be run before the broker is connected\n        on_shutdown : Add a hook to be run before the broker is disconnected\n        after_startup : Add a hook to be run after the broker is connected\n        after_shutdown : Add a hook to be run after the broker is disconnected\n        _log : Log a message at a specified\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n_on_startup_calling: List[AnyCallable]\n_after_startup_calling: List[AnyCallable]\n_on_shutdown_calling: List[AnyCallable]\n_after_shutdown_calling: List[AnyCallable]\ndef __init__(\nself,\nbroker: Optional[BrokerAsyncUsecase[Any, Any]] = None,\nlogger: Optional[logging.Logger] = logger,\n# AsyncAPI information\ntitle: str = \"FastStream\",\nversion: str = \"0.1.0\",\ndescription: str = \"\",\nterms_of_service: Optional[AnyHttpUrl] = None,\nlicense: Optional[Union[License, LicenseDict, AnyDict]] = None,\ncontact: Optional[Union[Contact, ContactDict, AnyDict]] = None,\nidentifier: Optional[str] = None,\ntags: Optional[Sequence[Union[Tag, TagDict, AnyDict]]] = None,\nexternal_docs: Optional[Union[ExternalDocs, ExternalDocsDict, AnyDict]] = None,\n):\n\"\"\"Initialize an instance of the class.\n        Args:\n            broker: An optional instance of the BrokerAsyncUsecase class.\n            logger: An optional instance of the logging.Logger class.\n            title: A string representing the title of the AsyncAPI.\n            version: A string representing the version of the AsyncAPI.\n            description: A string representing the description of the AsyncAPI.\n            terms_of_service: An optional URL representing the terms of service of the AsyncAPI.\n            license: An optional instance of the License class.\n            contact: An optional instance of the Contact class.\n            identifier: An optional string representing the identifier of the AsyncAPI.\n            tags: An optional sequence of Tag instances.\n            external_docs: An optional instance of the ExternalDocs class.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nself.broker = broker\nself.logger = logger\nself.context = context\ncontext.set_global(\"app\", self)\nself._on_startup_calling = []\nself._after_startup_calling = []\nself._on_shutdown_calling = []\nself._after_shutdown_calling = []\n# AsyncAPI information\nself.title = title\nself.version = version\nself.description = description\nself.terms_of_service = terms_of_service\nself.license = license\nself.contact = contact\nself.identifier = identifier\nself.asyncapi_tags = tags\nself.external_docs = external_docs\ndef set_broker(self, broker: BrokerAsyncUsecase[Any, Any]) -&gt; None:\n\"\"\"Set already existed App object broker\n        Usefull then you create/init broker in `on_startup` hook\"\"\"\nself.broker = broker\ndef on_startup(\nself,\nfunc: Callable[P_HookParams, T_HookReturn],\n) -&gt; Callable[P_HookParams, T_HookReturn]:\n\"\"\"Add hook running BEFORE broker connected\n        This hook also takes an extra CLI options as a kwargs\"\"\"\nself._on_startup_calling.append(apply_types(func))\nreturn func\ndef on_shutdown(\nself,\nfunc: Callable[P_HookParams, T_HookReturn],\n) -&gt; Callable[P_HookParams, T_HookReturn]:\n\"\"\"Add hook running BEFORE broker disconnected\"\"\"\nself._on_shutdown_calling.append(apply_types(func))\nreturn func\ndef after_startup(\nself,\nfunc: Callable[P_HookParams, T_HookReturn],\n) -&gt; Callable[P_HookParams, T_HookReturn]:\n\"\"\"Add hook running AFTER broker connected\"\"\"\nself._after_startup_calling.append(apply_types(func))\nreturn func\ndef after_shutdown(\nself,\nfunc: Callable[P_HookParams, T_HookReturn],\n) -&gt; Callable[P_HookParams, T_HookReturn]:\n\"\"\"Add hook running AFTER broker disconnected\"\"\"\nself._after_shutdown_calling.append(apply_types(func))\nreturn func\ndef _log(self, level: int, message: str) -&gt; None:\n\"\"\"Logs a message with the specified log level.\n        Args:\n            level (int): The log level.\n            message (str): The message to be logged.\n        Returns:\n            None\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nif self.logger is not None:\nself.logger.log(level, message)\n</code></pre>"},{"location":"api/faststream/app/ABCApp/#faststream.app.ABCApp.asyncapi_tags","title":"asyncapi_tags  <code>instance-attribute</code>","text":"<pre><code>asyncapi_tags = tags\n</code></pre>"},{"location":"api/faststream/app/ABCApp/#faststream.app.ABCApp.broker","title":"broker  <code>instance-attribute</code>","text":"<pre><code>broker = broker\n</code></pre>"},{"location":"api/faststream/app/ABCApp/#faststream.app.ABCApp.contact","title":"contact  <code>instance-attribute</code>","text":"<pre><code>contact = contact\n</code></pre>"},{"location":"api/faststream/app/ABCApp/#faststream.app.ABCApp.context","title":"context  <code>instance-attribute</code>","text":"<pre><code>context = context\n</code></pre>"},{"location":"api/faststream/app/ABCApp/#faststream.app.ABCApp.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description = description\n</code></pre>"},{"location":"api/faststream/app/ABCApp/#faststream.app.ABCApp.external_docs","title":"external_docs  <code>instance-attribute</code>","text":"<pre><code>external_docs = external_docs\n</code></pre>"},{"location":"api/faststream/app/ABCApp/#faststream.app.ABCApp.identifier","title":"identifier  <code>instance-attribute</code>","text":"<pre><code>identifier = identifier\n</code></pre>"},{"location":"api/faststream/app/ABCApp/#faststream.app.ABCApp.license","title":"license  <code>instance-attribute</code>","text":"<pre><code>license = license\n</code></pre>"},{"location":"api/faststream/app/ABCApp/#faststream.app.ABCApp.logger","title":"logger  <code>instance-attribute</code>","text":"<pre><code>logger = logger\n</code></pre>"},{"location":"api/faststream/app/ABCApp/#faststream.app.ABCApp.terms_of_service","title":"terms_of_service  <code>instance-attribute</code>","text":"<pre><code>terms_of_service = terms_of_service\n</code></pre>"},{"location":"api/faststream/app/ABCApp/#faststream.app.ABCApp.title","title":"title  <code>instance-attribute</code>","text":"<pre><code>title = title\n</code></pre>"},{"location":"api/faststream/app/ABCApp/#faststream.app.ABCApp.version","title":"version  <code>instance-attribute</code>","text":"<pre><code>version = version\n</code></pre>"},{"location":"api/faststream/app/ABCApp/#faststream.app.ABCApp.after_shutdown","title":"after_shutdown","text":"<pre><code>after_shutdown(\nfunc: Callable[P_HookParams, T_HookReturn]\n) -&gt; Callable[P_HookParams, T_HookReturn]\n</code></pre> <p>Add hook running AFTER broker disconnected</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/app.py</code> <pre><code>def after_shutdown(\nself,\nfunc: Callable[P_HookParams, T_HookReturn],\n) -&gt; Callable[P_HookParams, T_HookReturn]:\n\"\"\"Add hook running AFTER broker disconnected\"\"\"\nself._after_shutdown_calling.append(apply_types(func))\nreturn func\n</code></pre>"},{"location":"api/faststream/app/ABCApp/#faststream.app.ABCApp.after_startup","title":"after_startup","text":"<pre><code>after_startup(\nfunc: Callable[P_HookParams, T_HookReturn]\n) -&gt; Callable[P_HookParams, T_HookReturn]\n</code></pre> <p>Add hook running AFTER broker connected</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/app.py</code> <pre><code>def after_startup(\nself,\nfunc: Callable[P_HookParams, T_HookReturn],\n) -&gt; Callable[P_HookParams, T_HookReturn]:\n\"\"\"Add hook running AFTER broker connected\"\"\"\nself._after_startup_calling.append(apply_types(func))\nreturn func\n</code></pre>"},{"location":"api/faststream/app/ABCApp/#faststream.app.ABCApp.on_shutdown","title":"on_shutdown","text":"<pre><code>on_shutdown(\nfunc: Callable[P_HookParams, T_HookReturn]\n) -&gt; Callable[P_HookParams, T_HookReturn]\n</code></pre> <p>Add hook running BEFORE broker disconnected</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/app.py</code> <pre><code>def on_shutdown(\nself,\nfunc: Callable[P_HookParams, T_HookReturn],\n) -&gt; Callable[P_HookParams, T_HookReturn]:\n\"\"\"Add hook running BEFORE broker disconnected\"\"\"\nself._on_shutdown_calling.append(apply_types(func))\nreturn func\n</code></pre>"},{"location":"api/faststream/app/ABCApp/#faststream.app.ABCApp.on_startup","title":"on_startup","text":"<pre><code>on_startup(\nfunc: Callable[P_HookParams, T_HookReturn]\n) -&gt; Callable[P_HookParams, T_HookReturn]\n</code></pre> <p>Add hook running BEFORE broker connected This hook also takes an extra CLI options as a kwargs</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/app.py</code> <pre><code>def on_startup(\nself,\nfunc: Callable[P_HookParams, T_HookReturn],\n) -&gt; Callable[P_HookParams, T_HookReturn]:\n\"\"\"Add hook running BEFORE broker connected\n    This hook also takes an extra CLI options as a kwargs\"\"\"\nself._on_startup_calling.append(apply_types(func))\nreturn func\n</code></pre>"},{"location":"api/faststream/app/ABCApp/#faststream.app.ABCApp.set_broker","title":"set_broker","text":"<pre><code>set_broker(broker: BrokerAsyncUsecase[Any, Any]) -&gt; None\n</code></pre> <p>Set already existed App object broker Usefull then you create/init broker in <code>on_startup</code> hook</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/app.py</code> <pre><code>def set_broker(self, broker: BrokerAsyncUsecase[Any, Any]) -&gt; None:\n\"\"\"Set already existed App object broker\n    Usefull then you create/init broker in `on_startup` hook\"\"\"\nself.broker = broker\n</code></pre>"},{"location":"api/faststream/app/FastStream/","title":"FastStream","text":""},{"location":"api/faststream/app/FastStream/#faststream.app.FastStream","title":"faststream.app.FastStream","text":"<p>             Bases: <code>ABCApp</code></p> <p>A class representing a FastStream application.</p> METHOD DESCRIPTION <code>__init__ </code> <p>initializes the FastStream application</p> <code>on_startup </code> <p>adds a hook to run before the broker is connected</p> <code>on_shutdown </code> <p>adds a hook to run before the broker is disconnected</p> <code>after_startup </code> <p>adds a hook to run after the broker is connected</p> <code>after_shutdown </code> <p>adds a hook to run after the broker is disconnected</p> <code>run </code> <p>runs the FastStream application</p> <code>_init_async_cycle </code> <p>initializes the async cycle</p> <code>_start </code> <p>starts the FastStream application</p> <code>_stop </code> <p>stops the FastStream application</p> <code>_startup </code> <p>runs the startup hooks</p> <code>_shutdown </code> <p>runs the shutdown hooks</p> <code>__exit </code> <p>exits the FastStream application</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/app.py</code> <pre><code>class FastStream(ABCApp):\n\"\"\"A class representing a FastStream application.\n    Attributes:\n        _on_startup_calling : list of async functions to be called on startup\n        _after_startup_calling : list of async functions to be called after startup\n        _on_shutdown_calling : list of async functions to be called on shutdown\n        _after_shutdown_calling : list of async functions to be called after shutdown\n        _stop_event : event to stop the application\n    Methods:\n        __init__ : initializes the FastStream application\n        on_startup : adds a hook to run before the broker is connected\n        on_shutdown : adds a hook to run before the broker is disconnected\n        after_startup : adds a hook to run after the broker is connected\n        after_shutdown : adds a hook to run after the broker is disconnected\n        run : runs the FastStream application\n        _init_async_cycle : initializes the async cycle\n        _start : starts the FastStream application\n        _stop : stops the FastStream application\n        _startup : runs the startup hooks\n        _shutdown : runs the shutdown hooks\n        __exit : exits the FastStream application\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n_on_startup_calling: List[AsyncFunc]\n_after_startup_calling: List[AsyncFunc]\n_on_shutdown_calling: List[AsyncFunc]\n_after_shutdown_calling: List[AsyncFunc]\n_stop_event: Optional[anyio.Event]\ndef __init__(\nself,\nbroker: Optional[BrokerAsyncUsecase[Any, Any]] = None,\nlogger: Optional[logging.Logger] = logger,\n# AsyncAPI args,\ntitle: str = \"FastStream\",\nversion: str = \"0.1.0\",\ndescription: str = \"\",\nterms_of_service: Optional[AnyHttpUrl] = None,\nlicense: Optional[Union[License, LicenseDict, AnyDict]] = None,\ncontact: Optional[Union[Contact, ContactDict, AnyDict]] = None,\nidentifier: Optional[str] = None,\ntags: Optional[Sequence[Union[Tag, TagDict, AnyDict]]] = None,\nexternal_docs: Optional[Union[ExternalDocs, ExternalDocsDict, AnyDict]] = None,\n):\n\"\"\"Asyncronous FastStream Application class\n        stores and run broker, control hooks\n        Args:\n            broker: async broker to run (may be `None`, then specify by `set_broker`)\n            logger: logger object to log startup/shutdown messages (`None` to disable)\n            title: application title - for AsyncAPI docs\n            version: application version - for AsyncAPI docs\n            description: application description - for AsyncAPI docs\n        \"\"\"\nsuper().__init__(\nbroker=broker,\nlogger=logger,\ntitle=title,\nversion=version,\ndescription=description,\nterms_of_service=terms_of_service,\nlicense=license,\ncontact=contact,\nidentifier=identifier,\ntags=tags,\nexternal_docs=external_docs,\n)\nself._stop_event = None\nset_exit(lambda *_: self.__exit())\ndef on_startup(\nself,\nfunc: Callable[P_HookParams, T_HookReturn],\n) -&gt; Callable[P_HookParams, T_HookReturn]:\n\"\"\"Add hook running BEFORE broker connected\n        This hook also takes an extra CLI options as a kwargs\n        Args:\n            func: async or sync func to call as a hook\n        Returns:\n            Async version of the func argument\n        \"\"\"\nsuper().on_startup(to_async(func))\nreturn func\ndef on_shutdown(\nself,\nfunc: Callable[P_HookParams, T_HookReturn],\n) -&gt; Callable[P_HookParams, T_HookReturn]:\n\"\"\"Add hook running BEFORE broker disconnected\n        Args:\n            func: async or sync func to call as a hook\n        Returns:\n            Async version of the func argument\n        \"\"\"\nsuper().on_shutdown(to_async(func))\nreturn func\ndef after_startup(\nself,\nfunc: Callable[P_HookParams, T_HookReturn],\n) -&gt; Callable[P_HookParams, T_HookReturn]:\n\"\"\"Add hook running AFTER broker connected\n        Args:\n            func: async or sync func to call as a hook\n        Returns:\n            Async version of the func argument\n        \"\"\"\nsuper().after_startup(to_async(func))\nreturn func\ndef after_shutdown(\nself,\nfunc: Callable[P_HookParams, T_HookReturn],\n) -&gt; Callable[P_HookParams, T_HookReturn]:\n\"\"\"Add hook running AFTER broker disconnected\n        Args:\n            func: async or sync func to call as a hook\n        Returns:\n            Async version of the func argument\n        \"\"\"\nsuper().after_shutdown(to_async(func))\nreturn func\nasync def run(\nself,\nlog_level: int = logging.INFO,\nrun_extra_options: Optional[Dict[str, SettingField]] = None,\n) -&gt; None:\n\"\"\"Run FastStream Application\n        Args:\n            log_level: force application log level\n        Returns:\n            Block an event loop until stopped\n        \"\"\"\nassert self.broker, \"You should setup a broker\"  # nosec B101\nself._init_async_cycle()\nasync with anyio.create_task_group() as tg:\ntg.start_soon(self._start, log_level, run_extra_options)\nawait self._stop(log_level)\ntg.cancel_scope.cancel()\ndef _init_async_cycle(self) -&gt; None:\nif self._stop_event is None:\nself._stop_event = anyio.Event()\nasync def _start(\nself,\nlog_level: int = logging.INFO,\nrun_extra_options: Optional[Dict[str, SettingField]] = None,\n) -&gt; None:\n\"\"\"Start the FastStream app.\n        Args:\n            log_level (int): log level (default: logging.INFO)\n            run_extra_options (Optional[Dict[str, SettingField]]): extra options for running the app (default: None)\n        Returns:\n            None\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nself._log(log_level, \"FastStream app starting...\")\nawait self._startup(**(run_extra_options or {}))\nself._log(\nlog_level, \"FastStream app started successfully! To exit, press CTRL+C\"\n)\nasync def _stop(self, log_level: int = logging.INFO) -&gt; None:\n\"\"\"Stop the application gracefully.\n        Args:\n            log_level (int): log level for logging messages (default: logging.INFO)\n        Raises:\n            AssertionError: If `_init_async_cycle` has not been called before calling `_stop`\n        Returns:\n            None\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nassert (  # nosec B101\nself._stop_event\n), \"You should call `_init_async_cycle` first\"\nawait self._stop_event.wait()\nself._stop_event = None\nself._log(log_level, \"FastStream app shutting down...\")\nawait self._shutdown()\nself._log(log_level, \"FastStream app shut down gracefully.\")\nasync def _startup(self, **run_extra_options: SettingField) -&gt; None:\n\"\"\"Executes startup tasks.\n        Args:\n            run_extra_options: Additional options to be passed to the startup tasks.\n        Returns:\n            None\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nfor func in self._on_startup_calling:\nawait func(**run_extra_options)\nif self.broker is not None:\nawait self.broker.start()\nfor func in self._after_startup_calling:\nawait func()\nasync def _shutdown(self) -&gt; None:\nfor func in self._on_shutdown_calling:\nawait func()\nif self.broker is not None:\nawait self.broker.close()\nfor func in self._after_shutdown_calling:\nawait func()\ndef __exit(self) -&gt; None:\nif self._stop_event is not None:  # pragma: no branch\nself._stop_event.set()\n</code></pre>"},{"location":"api/faststream/app/FastStream/#faststream.app.FastStream.after_shutdown","title":"after_shutdown","text":"<pre><code>after_shutdown(\nfunc: Callable[P_HookParams, T_HookReturn]\n) -&gt; Callable[P_HookParams, T_HookReturn]\n</code></pre> <p>Add hook running AFTER broker disconnected</p> PARAMETER  DESCRIPTION <code>func</code> <p>async or sync func to call as a hook</p> <p> TYPE: <code>Callable[P_HookParams, T_HookReturn]</code> </p> RETURNS DESCRIPTION <code>Callable[P_HookParams, T_HookReturn]</code> <p>Async version of the func argument</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/app.py</code> <pre><code>def after_shutdown(\nself,\nfunc: Callable[P_HookParams, T_HookReturn],\n) -&gt; Callable[P_HookParams, T_HookReturn]:\n\"\"\"Add hook running AFTER broker disconnected\n    Args:\n        func: async or sync func to call as a hook\n    Returns:\n        Async version of the func argument\n    \"\"\"\nsuper().after_shutdown(to_async(func))\nreturn func\n</code></pre>"},{"location":"api/faststream/app/FastStream/#faststream.app.FastStream.after_startup","title":"after_startup","text":"<pre><code>after_startup(\nfunc: Callable[P_HookParams, T_HookReturn]\n) -&gt; Callable[P_HookParams, T_HookReturn]\n</code></pre> <p>Add hook running AFTER broker connected</p> PARAMETER  DESCRIPTION <code>func</code> <p>async or sync func to call as a hook</p> <p> TYPE: <code>Callable[P_HookParams, T_HookReturn]</code> </p> RETURNS DESCRIPTION <code>Callable[P_HookParams, T_HookReturn]</code> <p>Async version of the func argument</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/app.py</code> <pre><code>def after_startup(\nself,\nfunc: Callable[P_HookParams, T_HookReturn],\n) -&gt; Callable[P_HookParams, T_HookReturn]:\n\"\"\"Add hook running AFTER broker connected\n    Args:\n        func: async or sync func to call as a hook\n    Returns:\n        Async version of the func argument\n    \"\"\"\nsuper().after_startup(to_async(func))\nreturn func\n</code></pre>"},{"location":"api/faststream/app/FastStream/#faststream.app.FastStream.on_shutdown","title":"on_shutdown","text":"<pre><code>on_shutdown(\nfunc: Callable[P_HookParams, T_HookReturn]\n) -&gt; Callable[P_HookParams, T_HookReturn]\n</code></pre> <p>Add hook running BEFORE broker disconnected</p> PARAMETER  DESCRIPTION <code>func</code> <p>async or sync func to call as a hook</p> <p> TYPE: <code>Callable[P_HookParams, T_HookReturn]</code> </p> RETURNS DESCRIPTION <code>Callable[P_HookParams, T_HookReturn]</code> <p>Async version of the func argument</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/app.py</code> <pre><code>def on_shutdown(\nself,\nfunc: Callable[P_HookParams, T_HookReturn],\n) -&gt; Callable[P_HookParams, T_HookReturn]:\n\"\"\"Add hook running BEFORE broker disconnected\n    Args:\n        func: async or sync func to call as a hook\n    Returns:\n        Async version of the func argument\n    \"\"\"\nsuper().on_shutdown(to_async(func))\nreturn func\n</code></pre>"},{"location":"api/faststream/app/FastStream/#faststream.app.FastStream.on_startup","title":"on_startup","text":"<pre><code>on_startup(\nfunc: Callable[P_HookParams, T_HookReturn]\n) -&gt; Callable[P_HookParams, T_HookReturn]\n</code></pre> <p>Add hook running BEFORE broker connected</p> <p>This hook also takes an extra CLI options as a kwargs</p> PARAMETER  DESCRIPTION <code>func</code> <p>async or sync func to call as a hook</p> <p> TYPE: <code>Callable[P_HookParams, T_HookReturn]</code> </p> RETURNS DESCRIPTION <code>Callable[P_HookParams, T_HookReturn]</code> <p>Async version of the func argument</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/app.py</code> <pre><code>def on_startup(\nself,\nfunc: Callable[P_HookParams, T_HookReturn],\n) -&gt; Callable[P_HookParams, T_HookReturn]:\n\"\"\"Add hook running BEFORE broker connected\n    This hook also takes an extra CLI options as a kwargs\n    Args:\n        func: async or sync func to call as a hook\n    Returns:\n        Async version of the func argument\n    \"\"\"\nsuper().on_startup(to_async(func))\nreturn func\n</code></pre>"},{"location":"api/faststream/app/FastStream/#faststream.app.FastStream.run","title":"run  <code>async</code>","text":"<pre><code>run(\nlog_level: int = logging.INFO,\nrun_extra_options: Optional[\nDict[str, SettingField]\n] = None,\n) -&gt; None\n</code></pre> <p>Run FastStream Application</p> PARAMETER  DESCRIPTION <code>log_level</code> <p>force application log level</p> <p> TYPE: <code>int</code> DEFAULT: <code>INFO</code> </p> RETURNS DESCRIPTION <code>None</code> <p>Block an event loop until stopped</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/app.py</code> <pre><code>async def run(\nself,\nlog_level: int = logging.INFO,\nrun_extra_options: Optional[Dict[str, SettingField]] = None,\n) -&gt; None:\n\"\"\"Run FastStream Application\n    Args:\n        log_level: force application log level\n    Returns:\n        Block an event loop until stopped\n    \"\"\"\nassert self.broker, \"You should setup a broker\"  # nosec B101\nself._init_async_cycle()\nasync with anyio.create_task_group() as tg:\ntg.start_soon(self._start, log_level, run_extra_options)\nawait self._stop(log_level)\ntg.cancel_scope.cancel()\n</code></pre>"},{"location":"api/faststream/asyncapi/base/AsyncAPIOperation/","title":"AsyncAPIOperation","text":""},{"location":"api/faststream/asyncapi/base/AsyncAPIOperation/#faststream.asyncapi.base.AsyncAPIOperation","title":"faststream.asyncapi.base.AsyncAPIOperation","text":"<p>A class representing an asynchronous API operation.</p> METHOD DESCRIPTION <code>schema</code> <p>returns the schema of the API operation as a dictionary of channel names and channel objects</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/base.py</code> <pre><code>class AsyncAPIOperation:\n\"\"\"A class representing an asynchronous API operation.\n    Attributes:\n        name : name of the API operation\n    Methods:\n        schema() : returns the schema of the API operation as a dictionary of channel names and channel objects\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n@abstractproperty\ndef name(self) -&gt; str:\nraise NotImplementedError()\ndef schema(self) -&gt; Dict[str, Channel]:  # pragma: no cover\nreturn {}\n</code></pre>"},{"location":"api/faststream/asyncapi/base/AsyncAPIOperation/#faststream.asyncapi.base.AsyncAPIOperation.name","title":"name","text":"<pre><code>name() -&gt; str\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/base.py</code> <pre><code>@abstractproperty\ndef name(self) -&gt; str:\nraise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/asyncapi/base/AsyncAPIOperation/#faststream.asyncapi.base.AsyncAPIOperation.schema","title":"schema","text":"<pre><code>schema() -&gt; Dict[str, Channel]\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/base.py</code> <pre><code>def schema(self) -&gt; Dict[str, Channel]:  # pragma: no cover\nreturn {}\n</code></pre>"},{"location":"api/faststream/asyncapi/generate/get_app_broker_channels/","title":"Get app broker channels","text":""},{"location":"api/faststream/asyncapi/generate/get_app_broker_channels/#faststream.asyncapi.generate.get_app_broker_channels","title":"faststream.asyncapi.generate.get_app_broker_channels","text":"<pre><code>get_app_broker_channels(\napp: Union[FastStream, StreamRouter[Any]]\n) -&gt; Dict[str, Channel]\n</code></pre> <p>Get the broker channels for an application.</p> PARAMETER  DESCRIPTION <code>app</code> <p>An instance of FastStream or StreamRouter.</p> <p> TYPE: <code>Union[FastStream, StreamRouter[Any]]</code> </p> RETURNS DESCRIPTION <code>Dict[str, Channel]</code> <p>A dictionary of channel names and their corresponding Channel objects.</p> RAISES DESCRIPTION <code>AssertionError</code> <p>If the app does not have a broker.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/generate.py</code> <pre><code>def get_app_broker_channels(\napp: Union[FastStream, \"StreamRouter[Any]\"]\n) -&gt; Dict[str, Channel]:\n\"\"\"Get the broker channels for an application.\n    Args:\n        app: An instance of FastStream or StreamRouter.\n    Returns:\n        A dictionary of channel names and their corresponding Channel objects.\n    Raises:\n        AssertionError: If the app does not have a broker.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nchannels = {}\nassert app.broker  # nosec B101\nfor h in app.broker.handlers.values():\nchannels.update(h.schema())\nfor p in app.broker._publishers.values():\nchannels.update(p.schema())\nreturn channels\n</code></pre>"},{"location":"api/faststream/asyncapi/generate/get_app_broker_server/","title":"Get app broker server","text":""},{"location":"api/faststream/asyncapi/generate/get_app_broker_server/#faststream.asyncapi.generate.get_app_broker_server","title":"faststream.asyncapi.generate.get_app_broker_server","text":"<pre><code>get_app_broker_server(\napp: Union[FastStream, StreamRouter[Any]]\n) -&gt; Dict[str, Server]\n</code></pre> <p>Get the broker server for an application.</p> PARAMETER  DESCRIPTION <code>app</code> <p>An instance of <code>FastStream</code> or <code>StreamRouter</code> representing the application.</p> <p> TYPE: <code>Union[FastStream, StreamRouter[Any]]</code> </p> RETURNS DESCRIPTION <code>Dict[str, Server]</code> <p>A dictionary containing the broker servers. The keys are the server names and the values are instances of <code>Server</code> class.</p> RAISES DESCRIPTION <code>AssertionError</code> <p>If the <code>broker</code> attribute of the app is not present.</p> Note <p>This function is currently incomplete and the following fields in the <code>broker_meta</code> dictionary are not populated: \"security\", \"variables\", \"bindings\".</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/generate.py</code> <pre><code>def get_app_broker_server(\napp: Union[FastStream, \"StreamRouter[Any]\"]\n) -&gt; Dict[str, Server]:\n\"\"\"Get the broker server for an application.\n    Args:\n        app: An instance of `FastStream` or `StreamRouter` representing the application.\n    Returns:\n        A dictionary containing the broker servers. The keys are the server names and the values are instances of `Server` class.\n    Raises:\n        AssertionError: If the `broker` attribute of the app is not present.\n    Note:\n        This function is currently incomplete and the following fields in the `broker_meta` dictionary are not populated: \"security\", \"variables\", \"bindings\".\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nservers = {}\nbroker = app.broker\nassert broker  # nosec B101\nbroker_meta: Dict[str, Any] = {\n\"protocol\": broker.protocol,\n\"protocolVersion\": broker.protocol_version,\n\"description\": broker.description,\n\"tags\": broker.tags,\n# TODO\n# \"variables\": \"\",\n# \"bindings\": \"\",\n}\nif broker.security is not None:\nbroker_meta[\"security\"] = broker.security.get_requirement()\nif isinstance(broker.url, str):\nservers[\"development\"] = Server(\nurl=broker.url,\n**broker_meta,\n)\nelse:\nfor i, url in enumerate(broker.url, 1):\nservers[f\"Server{i}\"] = Server(\nurl=url,\n**broker_meta,\n)\nreturn servers\n</code></pre>"},{"location":"api/faststream/asyncapi/generate/get_app_schema/","title":"Get app schema","text":""},{"location":"api/faststream/asyncapi/generate/get_app_schema/#faststream.asyncapi.generate.get_app_schema","title":"faststream.asyncapi.generate.get_app_schema","text":"<pre><code>get_app_schema(\napp: Union[FastStream, StreamRouter[Any]]\n) -&gt; Schema\n</code></pre> <p>Get the application schema.</p> PARAMETER  DESCRIPTION <code>app</code> <p>An instance of FastStream or StreamRouter.</p> <p> TYPE: <code>Union[FastStream, StreamRouter[Any]]</code> </p> RETURNS DESCRIPTION <code>Schema</code> <p>The schema object.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/generate.py</code> <pre><code>def get_app_schema(app: Union[FastStream, \"StreamRouter[Any]\"]) -&gt; Schema:\n\"\"\"Get the application schema.\n    Args:\n        app: An instance of FastStream or StreamRouter.\n    Returns:\n        The schema object.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nservers = get_app_broker_server(app)\nchannels = get_app_broker_channels(app)\nmessages: Dict[str, Message] = {}\npayloads: Dict[str, Dict[str, Any]] = {}\nfor channel_name, ch in channels.items():\nch.servers = list(servers.keys())\nif ch.subscribe is not None:\nm = ch.subscribe.message\nif isinstance(m, Message):\nch.subscribe.message = _resolve_msg_payloads(\nm,\nchannel_name,\npayloads,\nmessages,\n)\nif ch.publish is not None:\nm = ch.publish.message\nif isinstance(m, Message):\nch.publish.message = _resolve_msg_payloads(\nm,\nchannel_name,\npayloads,\nmessages,\n)\nbroker = app.broker\nif broker is None:\nraise RuntimeError()\nschema = Schema(\ninfo=Info(\ntitle=app.title,\nversion=app.version,\ndescription=app.description,\ntermsOfService=app.terms_of_service,\ncontact=app.contact,\nlicense=app.license,\n),\ndefaultContentType=ContentTypes.json.value,\nid=app.identifier,\ntags=list(app.asyncapi_tags) if app.asyncapi_tags else None,\nexternalDocs=app.external_docs,\nservers=servers,\nchannels=channels,\ncomponents=Components(\nmessages=messages,\nschemas=payloads,\nsecuritySchemes=None\nif broker.security is None\nelse broker.security.get_schema(),\n),\n)\nreturn schema\n</code></pre>"},{"location":"api/faststream/asyncapi/message/get_model_schema/","title":"Get model schema","text":""},{"location":"api/faststream/asyncapi/message/get_model_schema/#faststream.asyncapi.message.get_model_schema","title":"faststream.asyncapi.message.get_model_schema","text":"<pre><code>get_model_schema(\ncall: Optional[Type[BaseModel]],\nprefix: str = \"\",\nexclude: Sequence[str] = (),\n) -&gt; Optional[Dict[str, Any]]\n</code></pre> <p>Get the schema of a model.</p> PARAMETER  DESCRIPTION <code>call</code> <p>The model class to get the schema for.</p> <p> TYPE: <code>Optional[Type[BaseModel]]</code> </p> <code>prefix</code> <p>A prefix to add to the schema title.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>exclude</code> <p>A sequence of field names to exclude from the schema.</p> <p> TYPE: <code>Sequence[str]</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>Optional[Dict[str, Any]]</code> <p>The schema of the model as a dictionary, or None if the model has no fields.</p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>If the model is a silent animal.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/message.py</code> <pre><code>def get_model_schema(\ncall: Optional[Type[BaseModel]],\nprefix: str = \"\",\nexclude: Sequence[str] = (),\n) -&gt; Optional[Dict[str, Any]]:\n\"\"\"Get the schema of a model.\n    Args:\n        call: The model class to get the schema for.\n        prefix: A prefix to add to the schema title.\n        exclude: A sequence of field names to exclude from the schema.\n    Returns:\n        The schema of the model as a dictionary, or None if the model has no fields.\n    Raises:\n        NotImplementedError: If the model is a silent animal.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nif call is None:\nreturn None\nparams = {k: v for k, v in get_model_fields(call).items() if k not in exclude}\nparams_number = len(params)\nif params_number == 0:\nreturn None\nmodel = None\nuse_original_model = False\nif params_number == 1:\nname, param = tuple(params.items())[0]\nif (\nparam.annotation\nand isclass(param.annotation)\nand issubclass(param.annotation, BaseModel)  # NOTE: 3.7-3.10 compatibility\n):\nmodel = param.annotation\nuse_original_model = True\nif model is None:\nmodel = call\nbody = model_schema(model)\nif params_number == 1 and not use_original_model:\nparam_body = body.get(\"properties\", {})\nparam_body = param_body[name]\nif PYDANTIC_V2:\noriginal_title = param.title\nelse:\noriginal_title = param.field_info.title  # type: ignore[attr-defined]\nif original_title:\nuse_original_model = True\nparam_body[\"title\"] = original_title\nelse:\nparam_body[\"title\"] = name\nbody = param_body\ncamel_body = to_camelcase(body[\"title\"])\nif not use_original_model:\nif prefix.lower() != camel_body.lower():\nbody[\"title\"] = f\"{prefix}{camel_body}Payload\"\nelse:\nbody[\"title\"] = f\"{camel_body}Payload\"\nreturn body\n</code></pre>"},{"location":"api/faststream/asyncapi/message/get_response_schema/","title":"Get response schema","text":""},{"location":"api/faststream/asyncapi/message/get_response_schema/#faststream.asyncapi.message.get_response_schema","title":"faststream.asyncapi.message.get_response_schema","text":"<pre><code>get_response_schema(\ncall: Optional[CallModel[Any, Any]], prefix: str = \"\"\n) -&gt; Optional[Dict[str, Any]]\n</code></pre> <p>Get the response schema for a given call.</p> PARAMETER  DESCRIPTION <code>call</code> <p>The call model.</p> <p> TYPE: <code>Optional[CallModel[Any, Any]]</code> </p> <code>prefix</code> <p>A prefix to add to the schema keys.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> RETURNS DESCRIPTION <code>Optional[Dict[str, Any]]</code> <p>The response schema as a dictionary.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/message.py</code> <pre><code>def get_response_schema(\ncall: Optional[CallModel[Any, Any]],\nprefix: str = \"\",\n) -&gt; Optional[Dict[str, Any]]:\n\"\"\"Get the response schema for a given call.\n    Args:\n        call: The call model.\n        prefix: A prefix to add to the schema keys.\n    Returns:\n        The response schema as a dictionary.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nreturn get_model_schema(\ngetattr(\ncall, \"response_model\", None\n),  # NOTE: FastAPI Dependant object compatibility\nprefix=prefix,\n)\n</code></pre>"},{"location":"api/faststream/asyncapi/message/parse_handler_params/","title":"Parse handler params","text":""},{"location":"api/faststream/asyncapi/message/parse_handler_params/#faststream.asyncapi.message.parse_handler_params","title":"faststream.asyncapi.message.parse_handler_params","text":"<pre><code>parse_handler_params(\ncall: CallModel[Any, Any], prefix: str = \"\"\n) -&gt; Dict[str, Any]\n</code></pre> <p>Parses the handler parameters.</p> PARAMETER  DESCRIPTION <code>call</code> <p>The call model.</p> <p> TYPE: <code>CallModel[Any, Any]</code> </p> <code>prefix</code> <p>The prefix for the model schema.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> RETURNS DESCRIPTION <code>Dict[str, Any]</code> <p>A dictionary containing the parsed parameters.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/message.py</code> <pre><code>def parse_handler_params(call: CallModel[Any, Any], prefix: str = \"\") -&gt; Dict[str, Any]:\n\"\"\"Parses the handler parameters.\n    Args:\n        call: The call model.\n        prefix: The prefix for the model schema.\n    Returns:\n        A dictionary containing the parsed parameters.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nbody = get_model_schema(\ncall.model, prefix=prefix, exclude=tuple(call.custom_fields.keys())\n)\nif body is None:\nreturn {\"title\": \"EmptyPayload\", \"type\": \"null\"}\nreturn body\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/amqp/ChannelBinding/","title":"ChannelBinding","text":""},{"location":"api/faststream/asyncapi/schema/bindings/amqp/ChannelBinding/#faststream.asyncapi.schema.bindings.amqp.ChannelBinding","title":"faststream.asyncapi.schema.bindings.amqp.ChannelBinding","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent channel binding.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/bindings/amqp.py</code> <pre><code>class ChannelBinding(BaseModel):\n\"\"\"A class to represent channel binding.\n    Attributes:\n        is_ : Type of binding, can be \"queue\" or \"routingKey\"\n        bindingVersion : Version of the binding\n        queue : Optional queue object\n        exchange : Optional exchange object\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nis_: Literal[\"queue\", \"routingKey\"] = Field(..., alias=\"is\")\nbindingVersion: str = \"0.2.0\"\nqueue: Optional[Queue] = None\nexchange: Optional[Exchange] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/amqp/ChannelBinding/#faststream.asyncapi.schema.bindings.amqp.ChannelBinding.bindingVersion","title":"bindingVersion  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bindingVersion: str = '0.2.0'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/amqp/ChannelBinding/#faststream.asyncapi.schema.bindings.amqp.ChannelBinding.exchange","title":"exchange  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>exchange: Optional[Exchange] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/amqp/ChannelBinding/#faststream.asyncapi.schema.bindings.amqp.ChannelBinding.is_","title":"is_  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>is_: Literal[\"queue\", \"routingKey\"] = Field(..., alias=\"is\")\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/amqp/ChannelBinding/#faststream.asyncapi.schema.bindings.amqp.ChannelBinding.queue","title":"queue  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>queue: Optional[Queue] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/amqp/Exchange/","title":"Exchange","text":""},{"location":"api/faststream/asyncapi/schema/bindings/amqp/Exchange/#faststream.asyncapi.schema.bindings.amqp.Exchange","title":"faststream.asyncapi.schema.bindings.amqp.Exchange","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent an exchange.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/bindings/amqp.py</code> <pre><code>class Exchange(BaseModel):\n\"\"\"A class to represent an exchange.\n    Attributes:\n        name : name of the exchange (optional)\n        type : type of the exchange, can be one of \"default\", \"direct\", \"topic\", \"fanout\", \"headers\"\n        durable : whether the exchange is durable (optional)\n        autoDelete : whether the exchange is automatically deleted (optional)\n        vhost : virtual host of the exchange, default is \"/\"\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nname: Optional[str] = None\ntype: Literal[\"default\", \"direct\", \"topic\", \"fanout\", \"headers\"]\ndurable: Optional[bool] = None\nautoDelete: Optional[bool] = None\nvhost: str = \"/\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/amqp/Exchange/#faststream.asyncapi.schema.bindings.amqp.Exchange.autoDelete","title":"autoDelete  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>autoDelete: Optional[bool] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/amqp/Exchange/#faststream.asyncapi.schema.bindings.amqp.Exchange.durable","title":"durable  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>durable: Optional[bool] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/amqp/Exchange/#faststream.asyncapi.schema.bindings.amqp.Exchange.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/amqp/Exchange/#faststream.asyncapi.schema.bindings.amqp.Exchange.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: Literal[\n\"default\", \"direct\", \"topic\", \"fanout\", \"headers\"\n]\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/amqp/Exchange/#faststream.asyncapi.schema.bindings.amqp.Exchange.vhost","title":"vhost  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>vhost: str = '/'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/amqp/OperationBinding/","title":"OperationBinding","text":""},{"location":"api/faststream/asyncapi/schema/bindings/amqp/OperationBinding/#faststream.asyncapi.schema.bindings.amqp.OperationBinding","title":"faststream.asyncapi.schema.bindings.amqp.OperationBinding","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent an operation binding.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/bindings/amqp.py</code> <pre><code>class OperationBinding(BaseModel):\n\"\"\"A class to represent an operation binding.\n    Attributes:\n        cc : optional string representing the cc\n        ack : boolean indicating if the operation is acknowledged\n        replyTo : optional dictionary representing the replyTo\n        bindingVersion : string representing the binding version\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\ncc: Optional[str] = None\nack: bool = True\nreplyTo: Optional[Dict[str, Any]] = None\nbindingVersion: str = \"0.2.0\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/amqp/OperationBinding/#faststream.asyncapi.schema.bindings.amqp.OperationBinding.ack","title":"ack  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ack: bool = True\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/amqp/OperationBinding/#faststream.asyncapi.schema.bindings.amqp.OperationBinding.bindingVersion","title":"bindingVersion  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bindingVersion: str = '0.2.0'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/amqp/OperationBinding/#faststream.asyncapi.schema.bindings.amqp.OperationBinding.cc","title":"cc  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cc: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/amqp/OperationBinding/#faststream.asyncapi.schema.bindings.amqp.OperationBinding.replyTo","title":"replyTo  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>replyTo: Optional[Dict[str, Any]] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/amqp/Queue/","title":"Queue","text":""},{"location":"api/faststream/asyncapi/schema/bindings/amqp/Queue/#faststream.asyncapi.schema.bindings.amqp.Queue","title":"faststream.asyncapi.schema.bindings.amqp.Queue","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent a queue.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/bindings/amqp.py</code> <pre><code>class Queue(BaseModel):\n\"\"\"A class to represent a queue.\n    Attributes:\n        name : name of the queue\n        durable : indicates if the queue is durable\n        exclusive : indicates if the queue is exclusive\n        autoDelete : indicates if the queue should be automatically deleted\n        vhost : virtual host of the queue (default is \"/\")\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nname: str\ndurable: bool\nexclusive: bool\nautoDelete: bool\nvhost: str = \"/\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/amqp/Queue/#faststream.asyncapi.schema.bindings.amqp.Queue.autoDelete","title":"autoDelete  <code>instance-attribute</code>","text":"<pre><code>autoDelete: bool\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/amqp/Queue/#faststream.asyncapi.schema.bindings.amqp.Queue.durable","title":"durable  <code>instance-attribute</code>","text":"<pre><code>durable: bool\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/amqp/Queue/#faststream.asyncapi.schema.bindings.amqp.Queue.exclusive","title":"exclusive  <code>instance-attribute</code>","text":"<pre><code>exclusive: bool\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/amqp/Queue/#faststream.asyncapi.schema.bindings.amqp.Queue.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/amqp/Queue/#faststream.asyncapi.schema.bindings.amqp.Queue.vhost","title":"vhost  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>vhost: str = '/'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/amqp/ServerBinding/","title":"ServerBinding","text":""},{"location":"api/faststream/asyncapi/schema/bindings/amqp/ServerBinding/#faststream.asyncapi.schema.bindings.amqp.ServerBinding","title":"faststream.asyncapi.schema.bindings.amqp.ServerBinding","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent a server binding.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/bindings/amqp.py</code> <pre><code>class ServerBinding(BaseModel):\n\"\"\"A class to represent a server binding.\n    Attributes:\n        bindingVersion : version of the binding (default: \"0.2.0\")\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nbindingVersion: str = \"0.2.0\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/amqp/ServerBinding/#faststream.asyncapi.schema.bindings.amqp.ServerBinding.bindingVersion","title":"bindingVersion  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bindingVersion: str = '0.2.0'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/kafka/ChannelBinding/","title":"ChannelBinding","text":""},{"location":"api/faststream/asyncapi/schema/bindings/kafka/ChannelBinding/#faststream.asyncapi.schema.bindings.kafka.ChannelBinding","title":"faststream.asyncapi.schema.bindings.kafka.ChannelBinding","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent a channel binding.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/bindings/kafka.py</code> <pre><code>class ChannelBinding(BaseModel):\n\"\"\"A class to represent a channel binding.\n    Attributes:\n        topic : optional string representing the topic\n        partitions : optional positive integer representing the number of partitions\n        replicas : optional positive integer representing the number of replicas\n        bindingVersion : string representing the binding version\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\ntopic: Optional[str] = None\npartitions: Optional[PositiveInt] = None\nreplicas: Optional[PositiveInt] = None\n# TODO:\n# topicConfiguration\nbindingVersion: str = \"0.4.0\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/kafka/ChannelBinding/#faststream.asyncapi.schema.bindings.kafka.ChannelBinding.bindingVersion","title":"bindingVersion  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bindingVersion: str = '0.4.0'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/kafka/ChannelBinding/#faststream.asyncapi.schema.bindings.kafka.ChannelBinding.partitions","title":"partitions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>partitions: Optional[PositiveInt] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/kafka/ChannelBinding/#faststream.asyncapi.schema.bindings.kafka.ChannelBinding.replicas","title":"replicas  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>replicas: Optional[PositiveInt] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/kafka/ChannelBinding/#faststream.asyncapi.schema.bindings.kafka.ChannelBinding.topic","title":"topic  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>topic: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/kafka/OperationBinding/","title":"OperationBinding","text":""},{"location":"api/faststream/asyncapi/schema/bindings/kafka/OperationBinding/#faststream.asyncapi.schema.bindings.kafka.OperationBinding","title":"faststream.asyncapi.schema.bindings.kafka.OperationBinding","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent an operation binding.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/bindings/kafka.py</code> <pre><code>class OperationBinding(BaseModel):\n\"\"\"A class to represent an operation binding.\n    Attributes:\n        groupId : optional dictionary representing the group ID\n        clientId : optional dictionary representing the client ID\n        replyTo : optional dictionary representing the reply-to\n        bindingVersion : version of the binding (default: \"0.4.0\")\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\ngroupId: Optional[Dict[str, Any]] = None\nclientId: Optional[Dict[str, Any]] = None\nreplyTo: Optional[Dict[str, Any]] = None\nbindingVersion: str = \"0.4.0\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/kafka/OperationBinding/#faststream.asyncapi.schema.bindings.kafka.OperationBinding.bindingVersion","title":"bindingVersion  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bindingVersion: str = '0.4.0'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/kafka/OperationBinding/#faststream.asyncapi.schema.bindings.kafka.OperationBinding.clientId","title":"clientId  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>clientId: Optional[Dict[str, Any]] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/kafka/OperationBinding/#faststream.asyncapi.schema.bindings.kafka.OperationBinding.groupId","title":"groupId  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>groupId: Optional[Dict[str, Any]] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/kafka/OperationBinding/#faststream.asyncapi.schema.bindings.kafka.OperationBinding.replyTo","title":"replyTo  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>replyTo: Optional[Dict[str, Any]] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/kafka/ServerBinding/","title":"ServerBinding","text":""},{"location":"api/faststream/asyncapi/schema/bindings/kafka/ServerBinding/#faststream.asyncapi.schema.bindings.kafka.ServerBinding","title":"faststream.asyncapi.schema.bindings.kafka.ServerBinding","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent a server binding.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/bindings/kafka.py</code> <pre><code>class ServerBinding(BaseModel):\n\"\"\"A class to represent a server binding.\n    Attributes:\n        bindingVersion : version of the binding (default: \"0.4.0\")\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nbindingVersion: str = \"0.4.0\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/kafka/ServerBinding/#faststream.asyncapi.schema.bindings.kafka.ServerBinding.bindingVersion","title":"bindingVersion  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bindingVersion: str = '0.4.0'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/ChannelBinding/","title":"ChannelBinding","text":""},{"location":"api/faststream/asyncapi/schema/bindings/main/ChannelBinding/#faststream.asyncapi.schema.bindings.main.ChannelBinding","title":"faststream.asyncapi.schema.bindings.main.ChannelBinding","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent channel bindings.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/bindings/main.py</code> <pre><code>class ChannelBinding(BaseModel):\n\"\"\"A class to represent channel bindings.\n    Attributes:\n        amqp : AMQP channel binding (optional)\n        kafka : Kafka channel binding (optional)\n        sqs : SQS channel binding (optional)\n        nats : NATS channel binding (optional)\n        redis : Redis channel binding (optional)\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\namqp: Optional[amqp_bindings.ChannelBinding] = None\nkafka: Optional[kafka_bindings.ChannelBinding] = None\nsqs: Optional[sqs_bindings.ChannelBinding] = None\nnats: Optional[nats_bindings.ChannelBinding] = None\nredis: Optional[redis_bindings.ChannelBinding] = None\nif PYDANTIC_V2:\nmodel_config = {\"extra\": \"allow\"}\nelse:\nclass Config:\nextra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/ChannelBinding/#faststream.asyncapi.schema.bindings.main.ChannelBinding.amqp","title":"amqp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>amqp: Optional[amqp_bindings.ChannelBinding] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/ChannelBinding/#faststream.asyncapi.schema.bindings.main.ChannelBinding.kafka","title":"kafka  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>kafka: Optional[kafka_bindings.ChannelBinding] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/ChannelBinding/#faststream.asyncapi.schema.bindings.main.ChannelBinding.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = {'extra': 'allow'}\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/ChannelBinding/#faststream.asyncapi.schema.bindings.main.ChannelBinding.nats","title":"nats  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>nats: Optional[nats_bindings.ChannelBinding] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/ChannelBinding/#faststream.asyncapi.schema.bindings.main.ChannelBinding.redis","title":"redis  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>redis: Optional[redis_bindings.ChannelBinding] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/ChannelBinding/#faststream.asyncapi.schema.bindings.main.ChannelBinding.sqs","title":"sqs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sqs: Optional[sqs_bindings.ChannelBinding] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/ChannelBinding/#faststream.asyncapi.schema.bindings.main.ChannelBinding.Config","title":"Config","text":"Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/bindings/main.py</code> <pre><code>class Config:\nextra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/ChannelBinding/#faststream.asyncapi.schema.bindings.main.ChannelBinding.Config.extra","title":"extra  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extra = 'allow'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/OperationBinding/","title":"OperationBinding","text":""},{"location":"api/faststream/asyncapi/schema/bindings/main/OperationBinding/#faststream.asyncapi.schema.bindings.main.OperationBinding","title":"faststream.asyncapi.schema.bindings.main.OperationBinding","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent an operation binding.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/bindings/main.py</code> <pre><code>class OperationBinding(BaseModel):\n\"\"\"A class to represent an operation binding.\n    Attributes:\n        amqp : AMQP operation binding (optional)\n        kafka : Kafka operation binding (optional)\n        sqs : SQS operation binding (optional)\n        nats : NATS operation binding (optional)\n        redis : Redis operation binding (optional)\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\namqp: Optional[amqp_bindings.OperationBinding] = None\nkafka: Optional[kafka_bindings.OperationBinding] = None\nsqs: Optional[sqs_bindings.OperationBinding] = None\nnats: Optional[nats_bindings.OperationBinding] = None\nredis: Optional[redis_bindings.OperationBinding] = None\nif PYDANTIC_V2:\nmodel_config = {\"extra\": \"allow\"}\nelse:\nclass Config:\nextra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/OperationBinding/#faststream.asyncapi.schema.bindings.main.OperationBinding.amqp","title":"amqp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>amqp: Optional[amqp_bindings.OperationBinding] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/OperationBinding/#faststream.asyncapi.schema.bindings.main.OperationBinding.kafka","title":"kafka  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>kafka: Optional[kafka_bindings.OperationBinding] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/OperationBinding/#faststream.asyncapi.schema.bindings.main.OperationBinding.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = {'extra': 'allow'}\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/OperationBinding/#faststream.asyncapi.schema.bindings.main.OperationBinding.nats","title":"nats  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>nats: Optional[nats_bindings.OperationBinding] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/OperationBinding/#faststream.asyncapi.schema.bindings.main.OperationBinding.redis","title":"redis  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>redis: Optional[redis_bindings.OperationBinding] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/OperationBinding/#faststream.asyncapi.schema.bindings.main.OperationBinding.sqs","title":"sqs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sqs: Optional[sqs_bindings.OperationBinding] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/OperationBinding/#faststream.asyncapi.schema.bindings.main.OperationBinding.Config","title":"Config","text":"Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/bindings/main.py</code> <pre><code>class Config:\nextra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/OperationBinding/#faststream.asyncapi.schema.bindings.main.OperationBinding.Config.extra","title":"extra  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extra = 'allow'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/ServerBinding/","title":"ServerBinding","text":""},{"location":"api/faststream/asyncapi/schema/bindings/main/ServerBinding/#faststream.asyncapi.schema.bindings.main.ServerBinding","title":"faststream.asyncapi.schema.bindings.main.ServerBinding","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent server bindings.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/bindings/main.py</code> <pre><code>class ServerBinding(BaseModel):\n\"\"\"A class to represent server bindings.\n    Attributes:\n        amqp : AMQP server binding (optional)\n        kafka : Kafka server binding (optional)\n        sqs : SQS server binding (optional)\n        nats : NATS server binding (optional)\n        redis : Redis server binding (optional)\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\namqp: Optional[amqp_bindings.ServerBinding] = None\nkafka: Optional[kafka_bindings.ServerBinding] = None\nsqs: Optional[sqs_bindings.ServerBinding] = None\nnats: Optional[nats_bindings.ServerBinding] = None\nredis: Optional[redis_bindings.ServerBinding] = None\nif PYDANTIC_V2:\nmodel_config = {\"extra\": \"allow\"}\nelse:\nclass Config:\nextra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/ServerBinding/#faststream.asyncapi.schema.bindings.main.ServerBinding.amqp","title":"amqp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>amqp: Optional[amqp_bindings.ServerBinding] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/ServerBinding/#faststream.asyncapi.schema.bindings.main.ServerBinding.kafka","title":"kafka  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>kafka: Optional[kafka_bindings.ServerBinding] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/ServerBinding/#faststream.asyncapi.schema.bindings.main.ServerBinding.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = {'extra': 'allow'}\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/ServerBinding/#faststream.asyncapi.schema.bindings.main.ServerBinding.nats","title":"nats  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>nats: Optional[nats_bindings.ServerBinding] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/ServerBinding/#faststream.asyncapi.schema.bindings.main.ServerBinding.redis","title":"redis  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>redis: Optional[redis_bindings.ServerBinding] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/ServerBinding/#faststream.asyncapi.schema.bindings.main.ServerBinding.sqs","title":"sqs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sqs: Optional[sqs_bindings.ServerBinding] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/ServerBinding/#faststream.asyncapi.schema.bindings.main.ServerBinding.Config","title":"Config","text":"Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/bindings/main.py</code> <pre><code>class Config:\nextra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/main/ServerBinding/#faststream.asyncapi.schema.bindings.main.ServerBinding.Config.extra","title":"extra  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extra = 'allow'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/nats/ChannelBinding/","title":"ChannelBinding","text":""},{"location":"api/faststream/asyncapi/schema/bindings/nats/ChannelBinding/#faststream.asyncapi.schema.bindings.nats.ChannelBinding","title":"faststream.asyncapi.schema.bindings.nats.ChannelBinding","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent channel binding.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/bindings/nats.py</code> <pre><code>class ChannelBinding(BaseModel):\n\"\"\"A class to represent channel binding.\n    Attributes:\n        subject : subject of the channel binding\n        queue : optional queue for the channel binding\n        bindingVersion : version of the channel binding, default is \"custom\"\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nsubject: str\nqueue: Optional[str] = None\nbindingVersion: str = \"custom\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/nats/ChannelBinding/#faststream.asyncapi.schema.bindings.nats.ChannelBinding.bindingVersion","title":"bindingVersion  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bindingVersion: str = 'custom'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/nats/ChannelBinding/#faststream.asyncapi.schema.bindings.nats.ChannelBinding.queue","title":"queue  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>queue: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/nats/ChannelBinding/#faststream.asyncapi.schema.bindings.nats.ChannelBinding.subject","title":"subject  <code>instance-attribute</code>","text":"<pre><code>subject: str\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/nats/OperationBinding/","title":"OperationBinding","text":""},{"location":"api/faststream/asyncapi/schema/bindings/nats/OperationBinding/#faststream.asyncapi.schema.bindings.nats.OperationBinding","title":"faststream.asyncapi.schema.bindings.nats.OperationBinding","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent an operation binding.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/bindings/nats.py</code> <pre><code>class OperationBinding(BaseModel):\n\"\"\"A class to represent an operation binding.\n    Attributes:\n        replyTo : optional dictionary containing reply information\n        bindingVersion : version of the binding (default is \"custom\")\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nreplyTo: Optional[Dict[str, Any]] = None\nbindingVersion: str = \"custom\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/nats/OperationBinding/#faststream.asyncapi.schema.bindings.nats.OperationBinding.bindingVersion","title":"bindingVersion  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bindingVersion: str = 'custom'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/nats/OperationBinding/#faststream.asyncapi.schema.bindings.nats.OperationBinding.replyTo","title":"replyTo  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>replyTo: Optional[Dict[str, Any]] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/nats/ServerBinding/","title":"ServerBinding","text":""},{"location":"api/faststream/asyncapi/schema/bindings/nats/ServerBinding/#faststream.asyncapi.schema.bindings.nats.ServerBinding","title":"faststream.asyncapi.schema.bindings.nats.ServerBinding","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent a server binding.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/bindings/nats.py</code> <pre><code>class ServerBinding(BaseModel):\n\"\"\"A class to represent a server binding.\n    Attributes:\n        bindingVersion : version of the binding (default: \"custom\")\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nbindingVersion: str = \"custom\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/nats/ServerBinding/#faststream.asyncapi.schema.bindings.nats.ServerBinding.bindingVersion","title":"bindingVersion  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bindingVersion: str = 'custom'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/redis/ChannelBinding/","title":"ChannelBinding","text":""},{"location":"api/faststream/asyncapi/schema/bindings/redis/ChannelBinding/#faststream.asyncapi.schema.bindings.redis.ChannelBinding","title":"faststream.asyncapi.schema.bindings.redis.ChannelBinding","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent channel binding.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/bindings/redis.py</code> <pre><code>class ChannelBinding(BaseModel):\n\"\"\"A class to represent channel binding.\n    Attributes:\n        channel : the channel name\n        method : the method used for binding (ssubscribe, psubscribe, subscribe)\n        bindingVersion : the version of the binding\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nchannel: str\nmethod: Literal[\"ssubscribe\", \"psubscribe\", \"subscribe\"] = \"subscribe\"\nbindingVersion: str = \"custom\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/redis/ChannelBinding/#faststream.asyncapi.schema.bindings.redis.ChannelBinding.bindingVersion","title":"bindingVersion  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bindingVersion: str = 'custom'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/redis/ChannelBinding/#faststream.asyncapi.schema.bindings.redis.ChannelBinding.channel","title":"channel  <code>instance-attribute</code>","text":"<pre><code>channel: str\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/redis/ChannelBinding/#faststream.asyncapi.schema.bindings.redis.ChannelBinding.method","title":"method  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>method: Literal[\n\"ssubscribe\", \"psubscribe\", \"subscribe\"\n] = \"subscribe\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/redis/OperationBinding/","title":"OperationBinding","text":""},{"location":"api/faststream/asyncapi/schema/bindings/redis/OperationBinding/#faststream.asyncapi.schema.bindings.redis.OperationBinding","title":"faststream.asyncapi.schema.bindings.redis.OperationBinding","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent an operation binding.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/bindings/redis.py</code> <pre><code>class OperationBinding(BaseModel):\n\"\"\"A class to represent an operation binding.\n    Attributes:\n        replyTo : optional dictionary containing reply information\n        bindingVersion : version of the binding (default is \"custom\")\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nreplyTo: Optional[Dict[str, Any]] = None\nbindingVersion: str = \"custom\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/redis/OperationBinding/#faststream.asyncapi.schema.bindings.redis.OperationBinding.bindingVersion","title":"bindingVersion  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bindingVersion: str = 'custom'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/redis/OperationBinding/#faststream.asyncapi.schema.bindings.redis.OperationBinding.replyTo","title":"replyTo  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>replyTo: Optional[Dict[str, Any]] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/redis/ServerBinding/","title":"ServerBinding","text":""},{"location":"api/faststream/asyncapi/schema/bindings/redis/ServerBinding/#faststream.asyncapi.schema.bindings.redis.ServerBinding","title":"faststream.asyncapi.schema.bindings.redis.ServerBinding","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent a server binding.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/bindings/redis.py</code> <pre><code>class ServerBinding(BaseModel):\n\"\"\"A class to represent a server binding.\n    Attributes:\n        bindingVersion : version of the binding (default: \"custom\")\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nbindingVersion: str = \"custom\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/redis/ServerBinding/#faststream.asyncapi.schema.bindings.redis.ServerBinding.bindingVersion","title":"bindingVersion  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bindingVersion: str = 'custom'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/sqs/ChannelBinding/","title":"ChannelBinding","text":""},{"location":"api/faststream/asyncapi/schema/bindings/sqs/ChannelBinding/#faststream.asyncapi.schema.bindings.sqs.ChannelBinding","title":"faststream.asyncapi.schema.bindings.sqs.ChannelBinding","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent channel binding.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/bindings/sqs.py</code> <pre><code>class ChannelBinding(BaseModel):\n\"\"\"A class to represent channel binding.\n    Attributes:\n        queue : a dictionary representing the queue\n        bindingVersion : a string representing the binding version (default: \"custom\")\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nqueue: Dict[str, Any]\nbindingVersion: str = \"custom\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/sqs/ChannelBinding/#faststream.asyncapi.schema.bindings.sqs.ChannelBinding.bindingVersion","title":"bindingVersion  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bindingVersion: str = 'custom'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/sqs/ChannelBinding/#faststream.asyncapi.schema.bindings.sqs.ChannelBinding.queue","title":"queue  <code>instance-attribute</code>","text":"<pre><code>queue: Dict[str, Any]\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/sqs/OperationBinding/","title":"OperationBinding","text":""},{"location":"api/faststream/asyncapi/schema/bindings/sqs/OperationBinding/#faststream.asyncapi.schema.bindings.sqs.OperationBinding","title":"faststream.asyncapi.schema.bindings.sqs.OperationBinding","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent an operation binding.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/bindings/sqs.py</code> <pre><code>class OperationBinding(BaseModel):\n\"\"\"A class to represent an operation binding.\n    Attributes:\n        replyTo : optional dictionary containing reply information\n        bindingVersion : version of the binding, default is \"custom\"\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nreplyTo: Optional[Dict[str, Any]] = None\nbindingVersion: str = \"custom\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/sqs/OperationBinding/#faststream.asyncapi.schema.bindings.sqs.OperationBinding.bindingVersion","title":"bindingVersion  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bindingVersion: str = 'custom'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/sqs/OperationBinding/#faststream.asyncapi.schema.bindings.sqs.OperationBinding.replyTo","title":"replyTo  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>replyTo: Optional[Dict[str, Any]] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/sqs/ServerBinding/","title":"ServerBinding","text":""},{"location":"api/faststream/asyncapi/schema/bindings/sqs/ServerBinding/#faststream.asyncapi.schema.bindings.sqs.ServerBinding","title":"faststream.asyncapi.schema.bindings.sqs.ServerBinding","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent a server binding.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/bindings/sqs.py</code> <pre><code>class ServerBinding(BaseModel):\n\"\"\"A class to represent a server binding.\n    Attributes:\n        bindingVersion : version of the binding (default: \"custom\")\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nbindingVersion: str = \"custom\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/bindings/sqs/ServerBinding/#faststream.asyncapi.schema.bindings.sqs.ServerBinding.bindingVersion","title":"bindingVersion  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bindingVersion: str = 'custom'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/channels/Channel/","title":"Channel","text":""},{"location":"api/faststream/asyncapi/schema/channels/Channel/#faststream.asyncapi.schema.channels.Channel","title":"faststream.asyncapi.schema.channels.Channel","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent a channel.</p> Configurations <p>model_config : configuration for the model (only applicable for Pydantic version 2) Config : configuration for the class (only applicable for Pydantic version 1)</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/channels.py</code> <pre><code>class Channel(BaseModel):\n\"\"\"A class to represent a channel.\n    Attributes:\n        description : optional description of the channel\n        servers : optional list of servers associated with the channel\n        bindings : optional channel binding\n        subscribe : optional operation for subscribing to the channel\n        publish : optional operation for publishing to the channel\n        parameters : optional parameters associated with the channel\n    Configurations:\n        model_config : configuration for the model (only applicable for Pydantic version 2)\n        Config : configuration for the class (only applicable for Pydantic version 1)\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\ndescription: Optional[str] = None\nservers: Optional[List[str]] = None\nbindings: Optional[ChannelBinding] = None\nsubscribe: Optional[Operation] = None\npublish: Optional[Operation] = None\nparameters: Optional[Parameter] = None\nif PYDANTIC_V2:\nmodel_config = {\"extra\": \"allow\"}\nelse:\nclass Config:\nextra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/channels/Channel/#faststream.asyncapi.schema.channels.Channel.bindings","title":"bindings  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bindings: Optional[ChannelBinding] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/channels/Channel/#faststream.asyncapi.schema.channels.Channel.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/channels/Channel/#faststream.asyncapi.schema.channels.Channel.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = {'extra': 'allow'}\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/channels/Channel/#faststream.asyncapi.schema.channels.Channel.parameters","title":"parameters  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>parameters: Optional[Parameter] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/channels/Channel/#faststream.asyncapi.schema.channels.Channel.publish","title":"publish  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>publish: Optional[Operation] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/channels/Channel/#faststream.asyncapi.schema.channels.Channel.servers","title":"servers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>servers: Optional[List[str]] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/channels/Channel/#faststream.asyncapi.schema.channels.Channel.subscribe","title":"subscribe  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>subscribe: Optional[Operation] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/channels/Channel/#faststream.asyncapi.schema.channels.Channel.Config","title":"Config","text":"Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/channels.py</code> <pre><code>class Config:\nextra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/channels/Channel/#faststream.asyncapi.schema.channels.Channel.Config.extra","title":"extra  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extra = 'allow'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/Contact/","title":"Contact","text":""},{"location":"api/faststream/asyncapi/schema/info/Contact/#faststream.asyncapi.schema.info.Contact","title":"faststream.asyncapi.schema.info.Contact","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent a contact.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/info.py</code> <pre><code>class Contact(BaseModel):\n\"\"\"A class to represent a contact.\n    Attributes:\n        name : name of the contact (str)\n        url : URL of the contact (Optional[AnyHttpUrl])\n        email : email of the contact (Optional[EmailStr])\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nname: str\nurl: Optional[AnyHttpUrl] = None\nemail: Optional[EmailStr] = None\nif PYDANTIC_V2:\nmodel_config = {\"extra\": \"allow\"}\nelse:\nclass Config:\nextra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/Contact/#faststream.asyncapi.schema.info.Contact.email","title":"email  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>email: Optional[EmailStr] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/Contact/#faststream.asyncapi.schema.info.Contact.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = {'extra': 'allow'}\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/Contact/#faststream.asyncapi.schema.info.Contact.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/Contact/#faststream.asyncapi.schema.info.Contact.url","title":"url  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>url: Optional[AnyHttpUrl] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/Contact/#faststream.asyncapi.schema.info.Contact.Config","title":"Config","text":"Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/info.py</code> <pre><code>class Config:\nextra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/Contact/#faststream.asyncapi.schema.info.Contact.Config.extra","title":"extra  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extra = 'allow'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/ContactDict/","title":"ContactDict","text":""},{"location":"api/faststream/asyncapi/schema/info/ContactDict/#faststream.asyncapi.schema.info.ContactDict","title":"faststream.asyncapi.schema.info.ContactDict","text":"<p>             Bases: <code>TypedDict</code></p> <p>A class to represent a dictionary of contact information.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/info.py</code> <pre><code>class ContactDict(TypedDict, total=False):\n\"\"\"A class to represent a dictionary of contact information.\n    Attributes:\n        name : required name of the contact (type: str)\n        url : URL of the contact (type: AnyHttpUrl)\n        email : email address of the contact (type: EmailStr)\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nname: Required[str]\nurl: AnyHttpUrl\nemail: EmailStr\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/ContactDict/#faststream.asyncapi.schema.info.ContactDict.email","title":"email  <code>instance-attribute</code>","text":"<pre><code>email: EmailStr\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/ContactDict/#faststream.asyncapi.schema.info.ContactDict.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: Required[str]\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/ContactDict/#faststream.asyncapi.schema.info.ContactDict.url","title":"url  <code>instance-attribute</code>","text":"<pre><code>url: AnyHttpUrl\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/EmailStr/","title":"EmailStr","text":""},{"location":"api/faststream/asyncapi/schema/info/EmailStr/#faststream.asyncapi.schema.info.EmailStr","title":"faststream.asyncapi.schema.info.EmailStr","text":"<p>             Bases: <code>str</code></p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/info.py</code> <pre><code>class EmailStr(str):  # type: ignore\n@classmethod\ndef __get_validators__(cls) -&gt; Iterable[Callable[..., Any]]:\nyield cls.validate\n@classmethod\ndef validate(cls, v: Any) -&gt; str:\nlogger.warning(\n\"email-validator bot installed, email fields will be treated as str.\\n\"\n\"To install, run: pip install email-validator\"\n)\nreturn str(v)\n@classmethod\ndef _validate(cls, __input_value: Any, _: Any) -&gt; str:\nlogger.warning(\n\"email-validator bot installed, email fields will be treated as str.\\n\"\n\"To install, run: pip install email-validator\"\n)\nreturn str(__input_value)\n@classmethod\ndef __get_pydantic_json_schema__(\ncls,\ncore_schema: CoreSchema,\nhandler: GetJsonSchemaHandler,\n) -&gt; JsonSchemaValue:\nreturn {\"type\": \"string\", \"format\": \"email\"}\n@classmethod\ndef __get_pydantic_core_schema__(\ncls,\nsource: Type[Any],\nhandler: Callable[[Any], CoreSchema],\n) -&gt; JsonSchemaValue:\nreturn with_info_plain_validator_function(cls._validate)  # type: ignore[no-any-return]\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/EmailStr/#faststream.asyncapi.schema.info.EmailStr.validate","title":"validate  <code>classmethod</code>","text":"<pre><code>validate(v: Any) -&gt; str\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/info.py</code> <pre><code>@classmethod\ndef validate(cls, v: Any) -&gt; str:\nlogger.warning(\n\"email-validator bot installed, email fields will be treated as str.\\n\"\n\"To install, run: pip install email-validator\"\n)\nreturn str(v)\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/Info/","title":"Info","text":""},{"location":"api/faststream/asyncapi/schema/info/Info/#faststream.asyncapi.schema.info.Info","title":"faststream.asyncapi.schema.info.Info","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent information.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/info.py</code> <pre><code>class Info(BaseModel):\n\"\"\"A class to represent information.\n    Attributes:\n        title : title of the information\n        version : version of the information (default: \"1.0.0\")\n        description : description of the information (default: \"\")\n        termsOfService : terms of service for the information (default: None)\n        contact : contact information for the information (default: None)\n        license : license information for the information (default: None)\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\ntitle: str\nversion: str = \"1.0.0\"\ndescription: str = \"\"\ntermsOfService: Optional[AnyHttpUrl] = None\ncontact: Optional[Union[Contact, ContactDict, Dict[str, Any]]] = None\nlicense: Optional[Union[License, LicenseDict, Dict[str, Any]]] = None\nif PYDANTIC_V2:\nmodel_config = {\"extra\": \"allow\"}\nelse:\nclass Config:\nextra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/Info/#faststream.asyncapi.schema.info.Info.contact","title":"contact  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>contact: Optional[\nUnion[Contact, ContactDict, Dict[str, Any]]\n] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/Info/#faststream.asyncapi.schema.info.Info.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: str = ''\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/Info/#faststream.asyncapi.schema.info.Info.license","title":"license  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>license: Optional[\nUnion[License, LicenseDict, Dict[str, Any]]\n] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/Info/#faststream.asyncapi.schema.info.Info.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = {'extra': 'allow'}\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/Info/#faststream.asyncapi.schema.info.Info.termsOfService","title":"termsOfService  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>termsOfService: Optional[AnyHttpUrl] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/Info/#faststream.asyncapi.schema.info.Info.title","title":"title  <code>instance-attribute</code>","text":"<pre><code>title: str\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/Info/#faststream.asyncapi.schema.info.Info.version","title":"version  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>version: str = '1.0.0'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/Info/#faststream.asyncapi.schema.info.Info.Config","title":"Config","text":"Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/info.py</code> <pre><code>class Config:\nextra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/Info/#faststream.asyncapi.schema.info.Info.Config.extra","title":"extra  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extra = 'allow'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/License/","title":"License","text":""},{"location":"api/faststream/asyncapi/schema/info/License/#faststream.asyncapi.schema.info.License","title":"faststream.asyncapi.schema.info.License","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent a license.</p> Config <p>extra : allow additional attributes in the model (PYDANTIC_V2)</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/info.py</code> <pre><code>class License(BaseModel):\n\"\"\"A class to represent a license.\n    Attributes:\n        name : name of the license\n        url : URL of the license (optional)\n    Config:\n        extra : allow additional attributes in the model (PYDANTIC_V2)\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nname: str\nurl: Optional[AnyHttpUrl] = None\nif PYDANTIC_V2:\nmodel_config = {\"extra\": \"allow\"}\nelse:\nclass Config:\nextra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/License/#faststream.asyncapi.schema.info.License.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = {'extra': 'allow'}\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/License/#faststream.asyncapi.schema.info.License.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/License/#faststream.asyncapi.schema.info.License.url","title":"url  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>url: Optional[AnyHttpUrl] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/License/#faststream.asyncapi.schema.info.License.Config","title":"Config","text":"Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/info.py</code> <pre><code>class Config:\nextra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/License/#faststream.asyncapi.schema.info.License.Config.extra","title":"extra  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extra = 'allow'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/LicenseDict/","title":"LicenseDict","text":""},{"location":"api/faststream/asyncapi/schema/info/LicenseDict/#faststream.asyncapi.schema.info.LicenseDict","title":"faststream.asyncapi.schema.info.LicenseDict","text":"<p>             Bases: <code>TypedDict</code></p> <p>A dictionary-like class to represent a license.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/info.py</code> <pre><code>class LicenseDict(TypedDict, total=False):\n\"\"\"A dictionary-like class to represent a license.\n    Attributes:\n        name : required name of the license (type: str)\n        url : URL of the license (type: AnyHttpUrl)\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nname: Required[str]\nurl: AnyHttpUrl\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/LicenseDict/#faststream.asyncapi.schema.info.LicenseDict.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: Required[str]\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/info/LicenseDict/#faststream.asyncapi.schema.info.LicenseDict.url","title":"url  <code>instance-attribute</code>","text":"<pre><code>url: AnyHttpUrl\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/main/Components/","title":"Components","text":""},{"location":"api/faststream/asyncapi/schema/main/Components/#faststream.asyncapi.schema.main.Components","title":"faststream.asyncapi.schema.main.Components","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent components in a system.</p> Note <p>The following attributes are not implemented yet: - servers - serverVariables - channels - securitySchemes - parameters - correlationIds - operationTraits - messageTraits - serverBindings - channelBindings - operationBindings - messageBindings</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/main.py</code> <pre><code>class Components(BaseModel):\n# TODO\n# servers\n# serverVariables\n# channels\n\"\"\"A class to represent components in a system.\n    Attributes:\n        messages : Optional dictionary of messages\n        schemas : Optional dictionary of schemas\n    Note:\n        The following attributes are not implemented yet:\n        - servers\n        - serverVariables\n        - channels\n        - securitySchemes\n        - parameters\n        - correlationIds\n        - operationTraits\n        - messageTraits\n        - serverBindings\n        - channelBindings\n        - operationBindings\n        - messageBindings\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nmessages: Optional[Dict[str, Message]] = None\nschemas: Optional[Dict[str, Dict[str, Any]]] = None\nsecuritySchemes: Optional[Dict[str, Dict[str, Any]]] = None\n# parameters\n# correlationIds\n# operationTraits\n# messageTraits\n# serverBindings\n# channelBindings\n# operationBindings\n# messageBindings\nif PYDANTIC_V2:\nmodel_config = {\"extra\": \"allow\"}\nelse:\nclass Config:\nextra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/main/Components/#faststream.asyncapi.schema.main.Components.messages","title":"messages  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>messages: Optional[Dict[str, Message]] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/main/Components/#faststream.asyncapi.schema.main.Components.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = {'extra': 'allow'}\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/main/Components/#faststream.asyncapi.schema.main.Components.schemas","title":"schemas  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>schemas: Optional[Dict[str, Dict[str, Any]]] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/main/Components/#faststream.asyncapi.schema.main.Components.securitySchemes","title":"securitySchemes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>securitySchemes: Optional[Dict[str, Dict[str, Any]]] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/main/Components/#faststream.asyncapi.schema.main.Components.Config","title":"Config","text":"Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/main.py</code> <pre><code>class Config:\nextra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/main/Components/#faststream.asyncapi.schema.main.Components.Config.extra","title":"extra  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extra = 'allow'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/main/Schema/","title":"Schema","text":""},{"location":"api/faststream/asyncapi/schema/main/Schema/#faststream.asyncapi.schema.main.Schema","title":"faststream.asyncapi.schema.main.Schema","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent a schema.</p> METHOD DESCRIPTION <code>to_jsonable</code> <p>Convert the schema to a JSON-serializable object.</p> <code>to_json</code> <p>Convert the schema to a JSON string.</p> <code>to_yaml</code> <p>Convert the schema to a YAML string.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/main.py</code> <pre><code>class Schema(BaseModel):\n\"\"\"A class to represent a schema.\n    Attributes:\n        asyncapi : version of the async API\n        id : optional ID\n        defaultContentType : optional default content type\n        info : information about the schema\n        servers : optional dictionary of servers\n        channels : dictionary of channels\n        components : optional components of the schema\n        tags : optional list of tags\n        externalDocs : optional external documentation\n    Methods:\n        to_jsonable() -&gt; Any: Convert the schema to a JSON-serializable object.\n        to_json() -&gt; str: Convert the schema to a JSON string.\n        to_yaml() -&gt; str: Convert the schema to a YAML string.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nasyncapi: str = ASYNC_API_VERSION\nid: Optional[str] = None\ndefaultContentType: Optional[str] = None\ninfo: Info\nservers: Optional[Dict[str, Server]] = None\nchannels: Dict[str, Channel]\ncomponents: Optional[Components] = None\ntags: Optional[List[Union[Tag, TagDict, Dict[str, Any]]]] = None\nexternalDocs: Optional[Union[ExternalDocs, ExternalDocsDict, Dict[str, Any]]] = None\ndef to_jsonable(self) -&gt; Any:\nreturn model_to_jsonable(\nself,\nby_alias=True,\nexclude_none=True,\n)\ndef to_json(self) -&gt; str:\nreturn model_to_json(\nself,\nby_alias=True,\nexclude_none=True,\n)\ndef to_yaml(self) -&gt; str:\nfrom io import StringIO\nimport yaml\nio = StringIO(initial_value=\"\", newline=\"\\n\")\nyaml.dump(self.to_jsonable(), io, sort_keys=False)\nreturn io.getvalue()\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/main/Schema/#faststream.asyncapi.schema.main.Schema.asyncapi","title":"asyncapi  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>asyncapi: str = ASYNC_API_VERSION\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/main/Schema/#faststream.asyncapi.schema.main.Schema.channels","title":"channels  <code>instance-attribute</code>","text":"<pre><code>channels: Dict[str, Channel]\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/main/Schema/#faststream.asyncapi.schema.main.Schema.components","title":"components  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>components: Optional[Components] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/main/Schema/#faststream.asyncapi.schema.main.Schema.defaultContentType","title":"defaultContentType  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>defaultContentType: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/main/Schema/#faststream.asyncapi.schema.main.Schema.externalDocs","title":"externalDocs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>externalDocs: Optional[\nUnion[ExternalDocs, ExternalDocsDict, Dict[str, Any]]\n] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/main/Schema/#faststream.asyncapi.schema.main.Schema.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/main/Schema/#faststream.asyncapi.schema.main.Schema.info","title":"info  <code>instance-attribute</code>","text":"<pre><code>info: Info\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/main/Schema/#faststream.asyncapi.schema.main.Schema.servers","title":"servers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>servers: Optional[Dict[str, Server]] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/main/Schema/#faststream.asyncapi.schema.main.Schema.tags","title":"tags  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tags: Optional[\nList[Union[Tag, TagDict, Dict[str, Any]]]\n] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/main/Schema/#faststream.asyncapi.schema.main.Schema.to_json","title":"to_json","text":"<pre><code>to_json() -&gt; str\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/main.py</code> <pre><code>def to_json(self) -&gt; str:\nreturn model_to_json(\nself,\nby_alias=True,\nexclude_none=True,\n)\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/main/Schema/#faststream.asyncapi.schema.main.Schema.to_jsonable","title":"to_jsonable","text":"<pre><code>to_jsonable() -&gt; Any\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/main.py</code> <pre><code>def to_jsonable(self) -&gt; Any:\nreturn model_to_jsonable(\nself,\nby_alias=True,\nexclude_none=True,\n)\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/main/Schema/#faststream.asyncapi.schema.main.Schema.to_yaml","title":"to_yaml","text":"<pre><code>to_yaml() -&gt; str\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/main.py</code> <pre><code>def to_yaml(self) -&gt; str:\nfrom io import StringIO\nimport yaml\nio = StringIO(initial_value=\"\", newline=\"\\n\")\nyaml.dump(self.to_jsonable(), io, sort_keys=False)\nreturn io.getvalue()\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/message/CorrelationId/","title":"CorrelationId","text":""},{"location":"api/faststream/asyncapi/schema/message/CorrelationId/#faststream.asyncapi.schema.message.CorrelationId","title":"faststream.asyncapi.schema.message.CorrelationId","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent a correlation ID.</p> Configurations <p>extra : allows extra fields in the correlation ID model</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/message.py</code> <pre><code>class CorrelationId(BaseModel):\n\"\"\"A class to represent a correlation ID.\n    Attributes:\n        description : optional description of the correlation ID\n        location : location of the correlation ID\n    Configurations:\n        extra : allows extra fields in the correlation ID model\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\ndescription: Optional[str] = None\nlocation: str\nif PYDANTIC_V2:\nmodel_config = {\"extra\": \"allow\"}\nelse:\nclass Config:\nextra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/message/CorrelationId/#faststream.asyncapi.schema.message.CorrelationId.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/message/CorrelationId/#faststream.asyncapi.schema.message.CorrelationId.location","title":"location  <code>instance-attribute</code>","text":"<pre><code>location: str\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/message/CorrelationId/#faststream.asyncapi.schema.message.CorrelationId.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = {'extra': 'allow'}\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/message/CorrelationId/#faststream.asyncapi.schema.message.CorrelationId.Config","title":"Config","text":"Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/message.py</code> <pre><code>class Config:\nextra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/message/CorrelationId/#faststream.asyncapi.schema.message.CorrelationId.Config.extra","title":"extra  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extra = 'allow'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/message/Message/","title":"Message","text":""},{"location":"api/faststream/asyncapi/schema/message/Message/#faststream.asyncapi.schema.message.Message","title":"faststream.asyncapi.schema.message.Message","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent a message.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/message.py</code> <pre><code>class Message(BaseModel):\n\"\"\"A class to represent a message.\n    Attributes:\n        title : title of the message\n        name : name of the message\n        summary : summary of the message\n        description : description of the message\n        messageId : ID of the message\n        correlationId : correlation ID of the message\n        contentType : content type of the message\n        payload : dictionary representing the payload of the message\n        tags : list of tags associated with the message\n        externalDocs : external documentation associated with the message\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\ntitle: Optional[str] = None\nname: Optional[str] = None\nsummary: Optional[str] = None\ndescription: Optional[str] = None\nmessageId: Optional[str] = None\ncorrelationId: Optional[CorrelationId] = None\ncontentType: Optional[str] = None\npayload: Dict[str, Any]\n# TODO:\n# headers\n# schemaFormat\n# bindings\n# examples\n# traits\ntags: Optional[\nList[Union[Tag, Dict[str, Any]]]\n] = None  # TODO: weird TagDict behavior\nexternalDocs: Optional[\nUnion[ExternalDocs, Dict[str, Any]]\n] = None  # TODO: weird ExternalDocsDict behavior\nif PYDANTIC_V2:\nmodel_config = {\"extra\": \"allow\"}\nelse:\nclass Config:\nextra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/message/Message/#faststream.asyncapi.schema.message.Message.contentType","title":"contentType  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>contentType: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/message/Message/#faststream.asyncapi.schema.message.Message.correlationId","title":"correlationId  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>correlationId: Optional[CorrelationId] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/message/Message/#faststream.asyncapi.schema.message.Message.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/message/Message/#faststream.asyncapi.schema.message.Message.externalDocs","title":"externalDocs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>externalDocs: Optional[\nUnion[ExternalDocs, Dict[str, Any]]\n] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/message/Message/#faststream.asyncapi.schema.message.Message.messageId","title":"messageId  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>messageId: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/message/Message/#faststream.asyncapi.schema.message.Message.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = {'extra': 'allow'}\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/message/Message/#faststream.asyncapi.schema.message.Message.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/message/Message/#faststream.asyncapi.schema.message.Message.payload","title":"payload  <code>instance-attribute</code>","text":"<pre><code>payload: Dict[str, Any]\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/message/Message/#faststream.asyncapi.schema.message.Message.summary","title":"summary  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>summary: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/message/Message/#faststream.asyncapi.schema.message.Message.tags","title":"tags  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tags: Optional[List[Union[Tag, Dict[str, Any]]]] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/message/Message/#faststream.asyncapi.schema.message.Message.title","title":"title  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>title: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/message/Message/#faststream.asyncapi.schema.message.Message.Config","title":"Config","text":"Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/message.py</code> <pre><code>class Config:\nextra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/message/Message/#faststream.asyncapi.schema.message.Message.Config.extra","title":"extra  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extra = 'allow'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/operations/Operation/","title":"Operation","text":""},{"location":"api/faststream/asyncapi/schema/operations/Operation/#faststream.asyncapi.schema.operations.Operation","title":"faststream.asyncapi.schema.operations.Operation","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent an operation.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/operations.py</code> <pre><code>class Operation(BaseModel):\n\"\"\"A class to represent an operation.\n    Attributes:\n        operationId : ID of the operation\n        summary : summary of the operation\n        description : description of the operation\n        bindings : bindings of the operation\n        message : message of the operation\n        security : security details of the operation\n        tags : tags associated with the operation\n        externalDocs : external documentation for the operation\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\noperationId: Optional[str] = None\nsummary: Optional[str] = None\ndescription: Optional[str] = None\nbindings: Optional[OperationBinding] = None\nmessage: Union[Message, Reference]\nsecurity: Optional[Dict[str, List[str]]] = None\n# TODO\n# traits\ntags: Optional[List[Union[Tag, TagDict, Dict[str, Any]]]] = None\nexternalDocs: Optional[Union[ExternalDocs, ExternalDocsDict, Dict[str, Any]]] = None\nif PYDANTIC_V2:\nmodel_config = {\"extra\": \"allow\"}\nelse:\nclass Config:\nextra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/operations/Operation/#faststream.asyncapi.schema.operations.Operation.bindings","title":"bindings  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bindings: Optional[OperationBinding] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/operations/Operation/#faststream.asyncapi.schema.operations.Operation.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/operations/Operation/#faststream.asyncapi.schema.operations.Operation.externalDocs","title":"externalDocs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>externalDocs: Optional[\nUnion[ExternalDocs, ExternalDocsDict, Dict[str, Any]]\n] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/operations/Operation/#faststream.asyncapi.schema.operations.Operation.message","title":"message  <code>instance-attribute</code>","text":"<pre><code>message: Union[Message, Reference]\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/operations/Operation/#faststream.asyncapi.schema.operations.Operation.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = {'extra': 'allow'}\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/operations/Operation/#faststream.asyncapi.schema.operations.Operation.operationId","title":"operationId  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>operationId: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/operations/Operation/#faststream.asyncapi.schema.operations.Operation.security","title":"security  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>security: Optional[Dict[str, List[str]]] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/operations/Operation/#faststream.asyncapi.schema.operations.Operation.summary","title":"summary  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>summary: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/operations/Operation/#faststream.asyncapi.schema.operations.Operation.tags","title":"tags  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tags: Optional[\nList[Union[Tag, TagDict, Dict[str, Any]]]\n] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/operations/Operation/#faststream.asyncapi.schema.operations.Operation.Config","title":"Config","text":"Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/operations.py</code> <pre><code>class Config:\nextra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/operations/Operation/#faststream.asyncapi.schema.operations.Operation.Config.extra","title":"extra  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extra = 'allow'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/OauthFlowObj/","title":"OauthFlowObj","text":""},{"location":"api/faststream/asyncapi/schema/security/OauthFlowObj/#faststream.asyncapi.schema.security.OauthFlowObj","title":"faststream.asyncapi.schema.security.OauthFlowObj","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent an OAuth flow object.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/security.py</code> <pre><code>class OauthFlowObj(BaseModel):\n\"\"\"A class to represent an OAuth flow object.\n    Attributes:\n        authorizationUrl : Optional[AnyHttpUrl] : The URL for authorization\n        tokenUrl : Optional[AnyHttpUrl] : The URL for token\n        refreshUrl : Optional[AnyHttpUrl] : The URL for refresh\n        scopes : Dict[str, str] : The scopes for the OAuth flow\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nauthorizationUrl: Optional[AnyHttpUrl] = None\ntokenUrl: Optional[AnyHttpUrl] = None\nrefreshUrl: Optional[AnyHttpUrl] = None\nscopes: Dict[str, str]\nif PYDANTIC_V2:\nmodel_config = {\"extra\": \"allow\"}\nelse:\nclass Config:\nextra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/OauthFlowObj/#faststream.asyncapi.schema.security.OauthFlowObj.authorizationUrl","title":"authorizationUrl  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>authorizationUrl: Optional[AnyHttpUrl] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/OauthFlowObj/#faststream.asyncapi.schema.security.OauthFlowObj.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = {'extra': 'allow'}\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/OauthFlowObj/#faststream.asyncapi.schema.security.OauthFlowObj.refreshUrl","title":"refreshUrl  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>refreshUrl: Optional[AnyHttpUrl] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/OauthFlowObj/#faststream.asyncapi.schema.security.OauthFlowObj.scopes","title":"scopes  <code>instance-attribute</code>","text":"<pre><code>scopes: Dict[str, str]\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/OauthFlowObj/#faststream.asyncapi.schema.security.OauthFlowObj.tokenUrl","title":"tokenUrl  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tokenUrl: Optional[AnyHttpUrl] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/OauthFlowObj/#faststream.asyncapi.schema.security.OauthFlowObj.Config","title":"Config","text":"Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/security.py</code> <pre><code>class Config:\nextra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/OauthFlowObj/#faststream.asyncapi.schema.security.OauthFlowObj.Config.extra","title":"extra  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extra = 'allow'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/OauthFlows/","title":"OauthFlows","text":""},{"location":"api/faststream/asyncapi/schema/security/OauthFlows/#faststream.asyncapi.schema.security.OauthFlows","title":"faststream.asyncapi.schema.security.OauthFlows","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent OAuth flows.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/security.py</code> <pre><code>class OauthFlows(BaseModel):\n\"\"\"A class to represent OAuth flows.\n    Attributes:\n        implicit : Optional[OauthFlowObj] : Implicit OAuth flow object\n        password : Optional[OauthFlowObj] : Password OAuth flow object\n        clientCredentials : Optional[OauthFlowObj] : Client credentials OAuth flow object\n        authorizationCode : Optional[OauthFlowObj] : Authorization code OAuth flow object\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nimplicit: Optional[OauthFlowObj] = None\npassword: Optional[OauthFlowObj] = None\nclientCredentials: Optional[OauthFlowObj] = None\nauthorizationCode: Optional[OauthFlowObj] = None\nif PYDANTIC_V2:\nmodel_config = {\"extra\": \"allow\"}\nelse:\nclass Config:\nextra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/OauthFlows/#faststream.asyncapi.schema.security.OauthFlows.authorizationCode","title":"authorizationCode  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>authorizationCode: Optional[OauthFlowObj] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/OauthFlows/#faststream.asyncapi.schema.security.OauthFlows.clientCredentials","title":"clientCredentials  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>clientCredentials: Optional[OauthFlowObj] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/OauthFlows/#faststream.asyncapi.schema.security.OauthFlows.implicit","title":"implicit  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>implicit: Optional[OauthFlowObj] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/OauthFlows/#faststream.asyncapi.schema.security.OauthFlows.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = {'extra': 'allow'}\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/OauthFlows/#faststream.asyncapi.schema.security.OauthFlows.password","title":"password  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>password: Optional[OauthFlowObj] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/OauthFlows/#faststream.asyncapi.schema.security.OauthFlows.Config","title":"Config","text":"Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/security.py</code> <pre><code>class Config:\nextra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/OauthFlows/#faststream.asyncapi.schema.security.OauthFlows.Config.extra","title":"extra  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extra = 'allow'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/SecuritySchemaComponent/","title":"SecuritySchemaComponent","text":""},{"location":"api/faststream/asyncapi/schema/security/SecuritySchemaComponent/#faststream.asyncapi.schema.security.SecuritySchemaComponent","title":"faststream.asyncapi.schema.security.SecuritySchemaComponent","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent a security schema component.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/security.py</code> <pre><code>class SecuritySchemaComponent(BaseModel):\n\"\"\"A class to represent a security schema component.\n    Attributes:\n        type : Literal, the type of the security schema component\n        name : optional name of the security schema component\n        description : optional description of the security schema component\n        in_ : optional location of the security schema component\n        schema_ : optional schema of the security schema component\n        bearerFormat : optional bearer format of the security schema component\n        openIdConnectUrl : optional OpenID Connect URL of the security schema component\n        flows : optional OAuth flows of the security schema component\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\ntype: Literal[\n\"userPassword\",\n\"apikey\",\n\"X509\",\n\"symmetricEncryption\",\n\"asymmetricEncryption\",\n\"httpApiKey\",\n\"http\",\n\"oauth2\",\n\"openIdConnect\",\n\"plain\",\n\"scramSha256\",\n\"scramSha512\",\n\"gssapi\",\n]\nname: Optional[str] = None\ndescription: Optional[str] = None\nin_: Optional[str] = Field(\ndefault=None,\nalias=\"in\",\n)\nschema_: Optional[str] = Field(\ndefault=None,\nalias=\"schema\",\n)\nbearerFormat: Optional[str] = None\nopenIdConnectUrl: Optional[str] = None\nflows: Optional[OauthFlows] = None\nif PYDANTIC_V2:\nmodel_config = {\"extra\": \"allow\"}\nelse:\nclass Config:\nextra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/SecuritySchemaComponent/#faststream.asyncapi.schema.security.SecuritySchemaComponent.bearerFormat","title":"bearerFormat  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bearerFormat: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/SecuritySchemaComponent/#faststream.asyncapi.schema.security.SecuritySchemaComponent.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/SecuritySchemaComponent/#faststream.asyncapi.schema.security.SecuritySchemaComponent.flows","title":"flows  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>flows: Optional[OauthFlows] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/SecuritySchemaComponent/#faststream.asyncapi.schema.security.SecuritySchemaComponent.in_","title":"in_  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>in_: Optional[str] = Field(default=None, alias='in')\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/SecuritySchemaComponent/#faststream.asyncapi.schema.security.SecuritySchemaComponent.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = {'extra': 'allow'}\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/SecuritySchemaComponent/#faststream.asyncapi.schema.security.SecuritySchemaComponent.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/SecuritySchemaComponent/#faststream.asyncapi.schema.security.SecuritySchemaComponent.openIdConnectUrl","title":"openIdConnectUrl  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>openIdConnectUrl: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/SecuritySchemaComponent/#faststream.asyncapi.schema.security.SecuritySchemaComponent.schema_","title":"schema_  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>schema_: Optional[str] = Field(default=None, alias=\"schema\")\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/SecuritySchemaComponent/#faststream.asyncapi.schema.security.SecuritySchemaComponent.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: Literal[\n\"userPassword\",\n\"apikey\",\n\"X509\",\n\"symmetricEncryption\",\n\"asymmetricEncryption\",\n\"httpApiKey\",\n\"http\",\n\"oauth2\",\n\"openIdConnect\",\n\"plain\",\n\"scramSha256\",\n\"scramSha512\",\n\"gssapi\",\n]\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/SecuritySchemaComponent/#faststream.asyncapi.schema.security.SecuritySchemaComponent.Config","title":"Config","text":"Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/security.py</code> <pre><code>class Config:\nextra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/security/SecuritySchemaComponent/#faststream.asyncapi.schema.security.SecuritySchemaComponent.Config.extra","title":"extra  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extra = 'allow'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/servers/Server/","title":"Server","text":""},{"location":"api/faststream/asyncapi/schema/servers/Server/#faststream.asyncapi.schema.servers.Server","title":"faststream.asyncapi.schema.servers.Server","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent a server.</p> Note <p>The attributes <code>description</code>, <code>protocolVersion</code>, <code>tags</code>, <code>security</code>, <code>variables</code>, and <code>bindings</code> are all optional.</p> Configurations <p>If <code>PYDANTIC_V2</code> is True, the model configuration is set to allow extra attributes. Otherwise, the <code>Config</code> class is defined with the <code>extra</code> attribute set to \"allow\".</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/servers.py</code> <pre><code>class Server(BaseModel):\n\"\"\"A class to represent a server.\n    Attributes:\n        url : URL of the server\n        protocol : protocol used by the server\n        description : optional description of the server\n        protocolVersion : optional version of the protocol used by the server\n        tags : optional list of tags associated with the server\n        security : optional security requirement for the server\n        variables : optional dictionary of server variables\n        bindings : optional server binding\n    Note:\n        The attributes `description`, `protocolVersion`, `tags`, `security`, `variables`, and `bindings` are all optional.\n    Configurations:\n        If `PYDANTIC_V2` is True, the model configuration is set to allow extra attributes.\n        Otherwise, the `Config` class is defined with the `extra` attribute set to \"allow\".\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nurl: str\nprotocol: str\ndescription: Optional[str] = None\nprotocolVersion: Optional[str] = None\ntags: Optional[List[Union[Tag, TagDict, Dict[str, Any]]]] = None\nsecurity: Optional[SecurityRequirement] = None\nvariables: Optional[Dict[str, Union[ServerVariable, Reference]]] = None\nbindings: Optional[Union[ServerBinding, Reference]] = None\nif PYDANTIC_V2:\nmodel_config = {\"extra\": \"allow\"}\nelse:\nclass Config:\nextra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/servers/Server/#faststream.asyncapi.schema.servers.Server.bindings","title":"bindings  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bindings: Optional[Union[ServerBinding, Reference]] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/servers/Server/#faststream.asyncapi.schema.servers.Server.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/servers/Server/#faststream.asyncapi.schema.servers.Server.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = {'extra': 'allow'}\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/servers/Server/#faststream.asyncapi.schema.servers.Server.protocol","title":"protocol  <code>instance-attribute</code>","text":"<pre><code>protocol: str\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/servers/Server/#faststream.asyncapi.schema.servers.Server.protocolVersion","title":"protocolVersion  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>protocolVersion: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/servers/Server/#faststream.asyncapi.schema.servers.Server.security","title":"security  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>security: Optional[SecurityRequirement] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/servers/Server/#faststream.asyncapi.schema.servers.Server.tags","title":"tags  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tags: Optional[\nList[Union[Tag, TagDict, Dict[str, Any]]]\n] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/servers/Server/#faststream.asyncapi.schema.servers.Server.url","title":"url  <code>instance-attribute</code>","text":"<pre><code>url: str\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/servers/Server/#faststream.asyncapi.schema.servers.Server.variables","title":"variables  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>variables: Optional[\nDict[str, Union[ServerVariable, Reference]]\n] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/servers/Server/#faststream.asyncapi.schema.servers.Server.Config","title":"Config","text":"Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/servers.py</code> <pre><code>class Config:\nextra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/servers/Server/#faststream.asyncapi.schema.servers.Server.Config.extra","title":"extra  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extra = 'allow'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/servers/ServerVariable/","title":"ServerVariable","text":""},{"location":"api/faststream/asyncapi/schema/servers/ServerVariable/#faststream.asyncapi.schema.servers.ServerVariable","title":"faststream.asyncapi.schema.servers.ServerVariable","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent a server variable.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/servers.py</code> <pre><code>class ServerVariable(BaseModel):\n\"\"\"A class to represent a server variable.\n    Attributes:\n        enum : list of possible values for the server variable (optional)\n        default : default value for the server variable (optional)\n        description : description of the server variable (optional)\n        examples : list of example values for the server variable (optional)\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nenum: Optional[List[str]] = None\ndefault: Optional[str] = None\ndescription: Optional[str] = None\nexamples: Optional[List[str]] = None\nif PYDANTIC_V2:\nmodel_config = {\"extra\": \"allow\"}\nelse:\nclass Config:\nextra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/servers/ServerVariable/#faststream.asyncapi.schema.servers.ServerVariable.default","title":"default  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>default: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/servers/ServerVariable/#faststream.asyncapi.schema.servers.ServerVariable.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/servers/ServerVariable/#faststream.asyncapi.schema.servers.ServerVariable.enum","title":"enum  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>enum: Optional[List[str]] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/servers/ServerVariable/#faststream.asyncapi.schema.servers.ServerVariable.examples","title":"examples  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>examples: Optional[List[str]] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/servers/ServerVariable/#faststream.asyncapi.schema.servers.ServerVariable.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = {'extra': 'allow'}\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/servers/ServerVariable/#faststream.asyncapi.schema.servers.ServerVariable.Config","title":"Config","text":"Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/servers.py</code> <pre><code>class Config:\nextra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/servers/ServerVariable/#faststream.asyncapi.schema.servers.ServerVariable.Config.extra","title":"extra  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extra = 'allow'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/utils/ExternalDocs/","title":"ExternalDocs","text":""},{"location":"api/faststream/asyncapi/schema/utils/ExternalDocs/#faststream.asyncapi.schema.utils.ExternalDocs","title":"faststream.asyncapi.schema.utils.ExternalDocs","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent external documentation.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/utils.py</code> <pre><code>class ExternalDocs(BaseModel):\n\"\"\"A class to represent external documentation.\n    Attributes:\n        url : URL of the external documentation\n        description : optional description of the external documentation\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nurl: AnyHttpUrl\ndescription: Optional[str] = None\nif PYDANTIC_V2:\nmodel_config = {\"extra\": \"allow\"}\nelse:\nclass Config:\nextra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/utils/ExternalDocs/#faststream.asyncapi.schema.utils.ExternalDocs.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/utils/ExternalDocs/#faststream.asyncapi.schema.utils.ExternalDocs.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = {'extra': 'allow'}\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/utils/ExternalDocs/#faststream.asyncapi.schema.utils.ExternalDocs.url","title":"url  <code>instance-attribute</code>","text":"<pre><code>url: AnyHttpUrl\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/utils/ExternalDocs/#faststream.asyncapi.schema.utils.ExternalDocs.Config","title":"Config","text":"Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/utils.py</code> <pre><code>class Config:\nextra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/utils/ExternalDocs/#faststream.asyncapi.schema.utils.ExternalDocs.Config.extra","title":"extra  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extra = 'allow'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/utils/ExternalDocsDict/","title":"ExternalDocsDict","text":""},{"location":"api/faststream/asyncapi/schema/utils/ExternalDocsDict/#faststream.asyncapi.schema.utils.ExternalDocsDict","title":"faststream.asyncapi.schema.utils.ExternalDocsDict","text":"<p>             Bases: <code>TypedDict</code></p> <p>A dictionary type for representing external documentation.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/utils.py</code> <pre><code>class ExternalDocsDict(TypedDict, total=False):\n\"\"\"A dictionary type for representing external documentation.\n    Attributes:\n        url : Required URL for the external documentation\n        description : Description of the external documentation\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nurl: Required[AnyHttpUrl]\ndescription: str\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/utils/ExternalDocsDict/#faststream.asyncapi.schema.utils.ExternalDocsDict.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description: str\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/utils/ExternalDocsDict/#faststream.asyncapi.schema.utils.ExternalDocsDict.url","title":"url  <code>instance-attribute</code>","text":"<pre><code>url: Required[AnyHttpUrl]\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/utils/Parameter/","title":"Parameter","text":""},{"location":"api/faststream/asyncapi/schema/utils/Parameter/#faststream.asyncapi.schema.utils.Parameter","title":"faststream.asyncapi.schema.utils.Parameter","text":"<p>             Bases: <code>BaseModel</code></p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/utils.py</code> <pre><code>class Parameter(BaseModel):\n# TODO\n...\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/utils/Reference/","title":"Reference","text":""},{"location":"api/faststream/asyncapi/schema/utils/Reference/#faststream.asyncapi.schema.utils.Reference","title":"faststream.asyncapi.schema.utils.Reference","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent a reference.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/utils.py</code> <pre><code>class Reference(BaseModel):\n\"\"\"A class to represent a reference.\n    Attributes:\n        ref : the reference string\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nref: str = Field(..., alias=\"$ref\")\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/utils/Reference/#faststream.asyncapi.schema.utils.Reference.ref","title":"ref  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ref: str = Field(..., alias='$ref')\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/utils/Tag/","title":"Tag","text":""},{"location":"api/faststream/asyncapi/schema/utils/Tag/#faststream.asyncapi.schema.utils.Tag","title":"faststream.asyncapi.schema.utils.Tag","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent a tag.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/utils.py</code> <pre><code>class Tag(BaseModel):\n\"\"\"A class to represent a tag.\n    Attributes:\n        name : name of the tag\n        description : description of the tag (optional)\n        externalDocs : external documentation for the tag (optional)\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nname: str\ndescription: Optional[str] = None\nexternalDocs: Optional[Union[ExternalDocs, ExternalDocsDict]] = None\nif PYDANTIC_V2:\nmodel_config = {\"extra\": \"allow\"}\nelse:\nclass Config:\nextra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/utils/Tag/#faststream.asyncapi.schema.utils.Tag.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/utils/Tag/#faststream.asyncapi.schema.utils.Tag.externalDocs","title":"externalDocs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>externalDocs: Optional[\nUnion[ExternalDocs, ExternalDocsDict]\n] = None\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/utils/Tag/#faststream.asyncapi.schema.utils.Tag.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = {'extra': 'allow'}\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/utils/Tag/#faststream.asyncapi.schema.utils.Tag.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/utils/Tag/#faststream.asyncapi.schema.utils.Tag.Config","title":"Config","text":"Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/utils.py</code> <pre><code>class Config:\nextra = \"allow\"\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/utils/Tag/#faststream.asyncapi.schema.utils.Tag.Config.extra","title":"extra  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extra = 'allow'\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/utils/TagDict/","title":"TagDict","text":""},{"location":"api/faststream/asyncapi/schema/utils/TagDict/#faststream.asyncapi.schema.utils.TagDict","title":"faststream.asyncapi.schema.utils.TagDict","text":"<p>             Bases: <code>TypedDict</code></p> <p>A dictionary-like class for storing tags.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/schema/utils.py</code> <pre><code>class TagDict(TypedDict, total=False):\n\"\"\"A dictionary-like class for storing tags.\n    Attributes:\n        name : required name of the tag\n        description : description of the tag\n        externalDocs : external documentation for the tag\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nname: Required[str]\ndescription: str\nexternalDocs: Union[ExternalDocs, ExternalDocsDict]\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/utils/TagDict/#faststream.asyncapi.schema.utils.TagDict.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description: str\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/utils/TagDict/#faststream.asyncapi.schema.utils.TagDict.externalDocs","title":"externalDocs  <code>instance-attribute</code>","text":"<pre><code>externalDocs: Union[ExternalDocs, ExternalDocsDict]\n</code></pre>"},{"location":"api/faststream/asyncapi/schema/utils/TagDict/#faststream.asyncapi.schema.utils.TagDict.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: Required[str]\n</code></pre>"},{"location":"api/faststream/asyncapi/site/get_asyncapi_html/","title":"Get asyncapi html","text":""},{"location":"api/faststream/asyncapi/site/get_asyncapi_html/#faststream.asyncapi.site.get_asyncapi_html","title":"faststream.asyncapi.site.get_asyncapi_html","text":"<pre><code>get_asyncapi_html(\nschema: Schema,\nsidebar: bool = True,\ninfo: bool = True,\nservers: bool = True,\noperations: bool = True,\nmessages: bool = True,\nschemas: bool = True,\nerrors: bool = True,\nexpand_message_examples: bool = True,\ntitle: str = \"FastStream\",\n) -&gt; str\n</code></pre> <p>Generate HTML for displaying an AsyncAPI document.</p> PARAMETER  DESCRIPTION <code>schema</code> <p>The AsyncAPI schema object.</p> <p> TYPE: <code>Schema</code> </p> <code>sidebar</code> <p>Whether to show the sidebar. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>info</code> <p>Whether to show the info section. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>servers</code> <p>Whether to show the servers section. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>operations</code> <p>Whether to show the operations section. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>messages</code> <p>Whether to show the messages section. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>schemas</code> <p>Whether to show the schemas section. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>errors</code> <p>Whether to show the errors section. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>expand_message_examples</code> <p>Whether to expand message examples. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>title</code> <p>The title of the HTML document. Defaults to \"FastStream\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'FastStream'</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The generated HTML document.</p> <p> TYPE: <code>str</code> </p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>If silent animals are not supported.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/site.py</code> <pre><code>def get_asyncapi_html(\nschema: \"Schema\",\nsidebar: bool = True,\ninfo: bool = True,\nservers: bool = True,\noperations: bool = True,\nmessages: bool = True,\nschemas: bool = True,\nerrors: bool = True,\nexpand_message_examples: bool = True,\ntitle: str = \"FastStream\",\n) -&gt; str:\n\"\"\"Generate HTML for displaying an AsyncAPI document.\n    Args:\n        schema (Schema): The AsyncAPI schema object.\n        sidebar (bool, optional): Whether to show the sidebar. Defaults to True.\n        info (bool, optional): Whether to show the info section. Defaults to True.\n        servers (bool, optional): Whether to show the servers section. Defaults to True.\n        operations (bool, optional): Whether to show the operations section. Defaults to True.\n        messages (bool, optional): Whether to show the messages section. Defaults to True.\n        schemas (bool, optional): Whether to show the schemas section. Defaults to True.\n        errors (bool, optional): Whether to show the errors section. Defaults to True.\n        expand_message_examples (bool, optional): Whether to expand message examples. Defaults to True.\n        title (str, optional): The title of the HTML document. Defaults to \"FastStream\".\n    Returns:\n        str: The generated HTML document.\n    Raises:\n        NotImplementedError: If silent animals are not supported.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nschema_json = schema.to_json()\nconfig = {\n\"schema\": schema_json,\n\"config\": {\n\"show\": {\n\"sidebar\": sidebar,\n\"info\": info,\n\"servers\": servers,\n\"operations\": operations,\n\"messages\": messages,\n\"schemas\": schemas,\n\"errors\": errors,\n},\n\"expand\": {\n\"messageExamples\": expand_message_examples,\n},\n\"sidebar\": {\n\"showServers\": \"byDefault\",\n\"showOperations\": \"byDefault\",\n},\n},\n}\nreturn (\n\"\"\"\n    &lt;!DOCTYPE html&gt;\n    &lt;html&gt;\n        &lt;head&gt;\n    \"\"\"\nf\"\"\"\n        &lt;title&gt;{title} AsyncAPI&lt;/title&gt;\n    \"\"\"\n\"\"\"\n        &lt;link rel=\"icon\" href=\"https://www.asyncapi.com/favicon.ico\"&gt;\n        &lt;link rel=\"icon\" type=\"image/png\" sizes=\"16x16\" href=\"https://www.asyncapi.com/favicon-16x16.png\"&gt;\n        &lt;link rel=\"icon\" type=\"image/png\" sizes=\"32x32\" href=\"https://www.asyncapi.com/favicon-32x32.png\"&gt;\n        &lt;link rel=\"icon\" type=\"image/png\" sizes=\"194x194\" href=\"https://www.asyncapi.com/favicon-194x194.png\"&gt;\n        &lt;link rel=\"stylesheet\" href=\"https://unpkg.com/@asyncapi/react-component@1.0.0-next.46/styles/default.min.css\"&gt;\n        &lt;/head&gt;\n        &lt;style&gt;\n        html {\n            font-family: ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;\n            line-height: 1.5;\n        }\n        &lt;/style&gt;\n        &lt;body&gt;\n        &lt;div id=\"asyncapi\"&gt;&lt;/div&gt;\n        &lt;script src=\"https://unpkg.com/@asyncapi/react-component@1.0.0-next.47/browser/standalone/index.js\"&gt;&lt;/script&gt;\n        &lt;script&gt;\n    \"\"\"\nf\"\"\"\n            AsyncApiStandalone.render({json.dumps(config)}, document.getElementById('asyncapi'));\n    \"\"\"\n\"\"\"\n        &lt;/script&gt;\n        &lt;/body&gt;\n    &lt;/html&gt;\n    \"\"\"\n)\n</code></pre>"},{"location":"api/faststream/asyncapi/site/serve_app/","title":"Serve app","text":""},{"location":"api/faststream/asyncapi/site/serve_app/#faststream.asyncapi.site.serve_app","title":"faststream.asyncapi.site.serve_app","text":"<pre><code>serve_app(schema: Schema, host: str, port: int) -&gt; None\n</code></pre> <p>Serve the FastAPI application.</p> PARAMETER  DESCRIPTION <code>schema</code> <p>The schema object representing the API specification.</p> <p> TYPE: <code>Schema</code> </p> <code>host</code> <p>The host address to run the application on.</p> <p> TYPE: <code>str</code> </p> <code>port</code> <p>The port number to run the application on.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/site.py</code> <pre><code>def serve_app(\nschema: \"Schema\",\nhost: str,\nport: int,\n) -&gt; None:\n\"\"\"Serve the FastAPI application.\n    Args:\n        schema: The schema object representing the API specification.\n        host: The host address to run the application on.\n        port: The port number to run the application on.\n    Returns:\n        None\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nimport uvicorn\nfrom fastapi import FastAPI\nfrom fastapi.responses import HTMLResponse\napp = FastAPI()\n@app.get(\"/\")\ndef asyncapi(\nsidebar: bool = True,\ninfo: bool = True,\nservers: bool = True,\noperations: bool = True,\nmessages: bool = True,\nschemas: bool = True,\nerrors: bool = True,\nexpandMessageExamples: bool = True,\n) -&gt; HTMLResponse:\n\"\"\"Generate an AsyncAPI HTML response.\n        Args:\n            sidebar (bool): Whether to include the sidebar. Default is True.\n            info (bool): Whether to include the info section. Default is True.\n            servers (bool): Whether to include the servers section. Default is True.\n            operations (bool): Whether to include the operations section. Default is True.\n            messages (bool): Whether to include the messages section. Default is True.\n            schemas (bool): Whether to include the schemas section. Default is True.\n            errors (bool): Whether to include the errors section. Default is True.\n            expandMessageExamples (bool): Whether to expand message examples. Default is True.\n        Returns:\n            HTMLResponse: The generated HTML response.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nreturn HTMLResponse(\ncontent=get_asyncapi_html(\nschema,\nsidebar=sidebar,\ninfo=info,\nservers=servers,\noperations=operations,\nmessages=messages,\nschemas=schemas,\nerrors=errors,\nexpand_message_examples=expandMessageExamples,\ntitle=schema.info.title,\n)\n)\nuvicorn.run(app, host=host, port=port)\n</code></pre>"},{"location":"api/faststream/asyncapi/utils/resolve_payloads/","title":"Resolve payloads","text":""},{"location":"api/faststream/asyncapi/utils/resolve_payloads/#faststream.asyncapi.utils.resolve_payloads","title":"faststream.asyncapi.utils.resolve_payloads","text":"<pre><code>resolve_payloads(payloads: List[AnyDict]) -&gt; AnyDict\n</code></pre> <p>Resolve payloads.</p> PARAMETER  DESCRIPTION <code>payloads</code> <p>A list of dictionaries representing payloads.</p> <p> TYPE: <code>List[AnyDict]</code> </p> RETURNS DESCRIPTION <code>AnyDict</code> <p>A dictionary representing the resolved payload.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/utils.py</code> <pre><code>def resolve_payloads(payloads: List[AnyDict]) -&gt; AnyDict:\n\"\"\"Resolve payloads.\n    Args:\n        payloads: A list of dictionaries representing payloads.\n    Returns:\n        A dictionary representing the resolved payload.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nln = len(payloads)\npayload: AnyDict\nif ln &gt; 1:\npayload = {\"oneOf\": {body[\"title\"]: body for body in payloads}}\nelif ln == 1:\npayload = payloads[0]\nelse:\npayload = {}\nreturn payload\n</code></pre>"},{"location":"api/faststream/asyncapi/utils/to_camelcase/","title":"To camelcase","text":""},{"location":"api/faststream/asyncapi/utils/to_camelcase/#faststream.asyncapi.utils.to_camelcase","title":"faststream.asyncapi.utils.to_camelcase","text":"<pre><code>to_camelcase(*names: str) -&gt; str\n</code></pre> <p>Converts a list of names to camel case.</p> PARAMETER  DESCRIPTION <code>*names</code> <p>Variable length list of names to be converted to camel case.</p> <p> TYPE: <code>str</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The camel case representation of the names.</p> Example <p>to_camelcase(\"hello_world\") \"HelloWorld\"</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/asyncapi/utils.py</code> <pre><code>def to_camelcase(*names: str) -&gt; str:\n\"\"\"Converts a list of names to camel case.\n    Args:\n        *names: Variable length list of names to be converted to camel case.\n    Returns:\n        The camel case representation of the names.\n    Example:\n        &gt;&gt;&gt; to_camelcase(\"hello_world\")\n        \"HelloWorld\"\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nreturn \" \".join(names).replace(\"_\", \" \").title().replace(\" \", \"\")\n</code></pre>"},{"location":"api/faststream/broker/core/abc/BrokerUsecase/","title":"BrokerUsecase","text":""},{"location":"api/faststream/broker/core/abc/BrokerUsecase/#faststream.broker.core.abc.BrokerUsecase","title":"faststream.broker.core.abc.BrokerUsecase","text":"<p>             Bases: <code>ABC</code>, <code>Generic[MsgType, ConnectionType]</code>, <code>LoggingMixin</code></p> <p>A class representing a broker use case.</p> METHOD DESCRIPTION <code>__init__ </code> <p>constructor method</p> <code>include_router </code> <p>include a router in the broker</p> <code>include_routers </code> <p>include multiple routers in the broker</p> <code>_resolve_connection_kwargs </code> <p>resolve connection kwargs</p> <code>_wrap_handler </code> <p>wrap a handler function</p> <code>_abc_start </code> <p>start the broker</p> <code>_abc_close </code> <p>close the broker</p> <code>_abc__close </code> <p>close the broker connection</p> <code>_process_message </code> <p>process a message</p> <code>subscriber </code> <p>decorator to register a subscriber</p> <code>publisher </code> <p>register a publisher</p> <code>_wrap_decode_message </code> <p>wrap a message decoding function</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/core/abc.py</code> <pre><code>class BrokerUsecase(\nABC,\nGeneric[MsgType, ConnectionType],\nLoggingMixin,\n):\n\"\"\"A class representing a broker use case.\n    Attributes:\n        logger : optional logger object\n        log_level : log level\n        handlers : dictionary of handlers\n        _publishers : dictionary of publishers\n        dependencies : sequence of dependencies\n        started : boolean indicating if the broker has started\n        middlewares : sequence of middleware functions\n        _global_parser : optional custom parser object\n        _global_decoder : optional custom decoder object\n        _connection : optional connection object\n        _fmt : optional string format\n    Methods:\n        __init__ : constructor method\n        include_router : include a router in the broker\n        include_routers : include multiple routers in the broker\n        _resolve_connection_kwargs : resolve connection kwargs\n        _wrap_handler : wrap a handler function\n        _abc_start : start the broker\n        _abc_close : close the broker\n        _abc__close : close the broker connection\n        _process_message : process a message\n        subscriber : decorator to register a subscriber\n        publisher : register a publisher\n        _wrap_decode_message : wrap a message decoding function\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nlogger: Optional[logging.Logger]\nlog_level: int\nhandlers: Dict[Any, BaseHandler[MsgType]]\n_publishers: Dict[Any, BasePublisher[MsgType]]\ndependencies: Sequence[Depends]\nstarted: bool\nmiddlewares: Sequence[Callable[[Any], BaseMiddleware]]\n_global_parser: Optional[CustomParser[MsgType]]\n_global_decoder: Optional[CustomDecoder[MsgType]]\n_connection: Optional[ConnectionType]\n_fmt: Optional[str]\ndef __init__(\nself,\nurl: Union[str, List[str]],\n*args: Any,\n# AsyncAPI kwargs\nprotocol: str,\nprotocol_version: Optional[str] = None,\ndescription: Optional[str] = None,\ntags: Optional[Sequence[Union[asyncapi.Tag, asyncapi.TagDict]]] = None,\n# broker kwargs\napply_types: bool = True,\nlogger: Optional[logging.Logger] = access_logger,\nlog_level: int = logging.INFO,\nlog_fmt: Optional[str] = \"%(asctime)s %(levelname)s - %(message)s\",\ndependencies: Sequence[Depends] = (),\nmiddlewares: Optional[Sequence[Callable[[MsgType], BaseMiddleware]]] = None,\ndecoder: Optional[CustomDecoder[MsgType]] = None,\nparser: Optional[CustomParser[MsgType]] = None,\nsecurity: Optional[BaseSecurity] = None,\n**kwargs: Any,\n) -&gt; None:\n\"\"\"Initialize a broker.\n        Args:\n            url: The URL or list of URLs to connect to.\n            *args: Additional arguments.\n            protocol: The protocol to use for the connection.\n            protocol_version: The version of the protocol.\n            description: A description of the broker.\n            tags: Tags associated with the broker.\n            apply_types: Whether to apply types to messages.\n            logger: The logger to use.\n            log_level: The log level to use.\n            log_fmt: The log format to use.\n            dependencies: Dependencies of the broker.\n            middlewares: Middlewares to use.\n            decoder: Custom decoder for messages.\n            parser: Custom parser for messages.\n            **kwargs: Additional keyword arguments.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nsuper().__init__(\nlogger=logger,\nlog_level=log_level,\nlog_fmt=log_fmt,\n)\nself._connection = None\nself._is_apply_types = apply_types\nself.handlers = {}\nself._publishers = {}\nempty_middleware: Sequence[Callable[[MsgType], BaseMiddleware]] = ()\nmidd_args: Sequence[Callable[[MsgType], BaseMiddleware]] = (\nmiddlewares or empty_middleware\n)\nself.middlewares = [CriticalLogMiddleware(logger, log_level), *midd_args]\nself.dependencies = dependencies\nself._connection_args = (url, *args)\nself._connection_kwargs = kwargs\nself._global_parser = parser\nself._global_decoder = decoder\ncontext.set_global(\"logger\", logger)\ncontext.set_global(\"broker\", self)\nself.started = False\n# AsyncAPI information\nself.url = url\nself.protocol = protocol\nself.protocol_version = protocol_version\nself.description = description\nself.tags = tags\nself.security = security\ndef include_router(self, router: BrokerRouter[Any, MsgType]) -&gt; None:\n\"\"\"Includes a router in the current object.\n        Args:\n            router: The router to be included.\n        Returns:\n            None\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nfor r in router._handlers:\nself.subscriber(*r.args, **r.kwargs)(r.call)\nself._publishers.update(router._publishers)\ndef include_routers(self, *routers: BrokerRouter[Any, MsgType]) -&gt; None:\n\"\"\"Includes routers in the current object.\n        Args:\n            *routers: Variable length argument list of routers to include.\n        Returns:\n            None\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nfor r in routers:\nself.include_router(r)\ndef _resolve_connection_kwargs(self, *args: Any, **kwargs: Any) -&gt; AnyDict:\n\"\"\"Resolve connection keyword arguments.\n        Args:\n            *args: Positional arguments passed to the function.\n            **kwargs: Keyword arguments passed to the function.\n        Returns:\n            A dictionary containing the resolved connection keyword arguments.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\narguments = get_function_positional_arguments(self.__init__)  # type: ignore\ninit_kwargs = {\n**self._connection_kwargs,\n**dict(zip(arguments, self._connection_args)),\n}\nconnect_kwargs = {\n**kwargs,\n**dict(zip(arguments, args)),\n}\nreturn {**init_kwargs, **connect_kwargs}\ndef _wrap_handler(\nself,\nfunc: Union[\nHandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn],\nCallable[P_HandlerParams, T_HandlerReturn],\n],\n*,\nretry: Union[bool, int] = False,\nextra_dependencies: Sequence[Depends] = (),\n_raw: bool = False,\n_get_dependant: Optional[Any] = None,\n) -&gt; Tuple[\nHandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn],\nUnion[\nCallModel[P_HandlerParams, T_HandlerReturn],\nCallModel[P_HandlerParams, Awaitable[T_HandlerReturn]],\n],\n]:\n\"\"\"Wrap a handler function.\n        Args:\n            func: The handler function to wrap.\n            retry: Whether to retry the handler function if it fails. Can be a boolean or an integer specifying the number of retries.\n            extra_dependencies: Additional dependencies for the handler function.\n            _raw: Whether to use the raw handler function.\n            _get_dependant: The dependant function to use.\n            **broker_log_context_kwargs: Additional keyword arguments for the broker log context.\n        Returns:\n            A tuple containing the wrapped handler function and the call model.\n        Raises:\n            NotImplementedError: If silent animals are not supported.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nbuild_dep = cast(\nCallable[[Callable[F_Spec, F_Return]], CallModel[F_Spec, F_Return]],\n_get_dependant or build_call_model,\n)\nif isinstance(func, HandlerCallWrapper):\nhandler_call, func = func, func._original_call\nif handler_call._wrapped_call is not None:\nreturn handler_call, build_dep(func)\nelse:\nhandler_call = HandlerCallWrapper(func)\nf = to_async(func)\ndependant = build_dep(f)\nextra = [\nbuild_dep(d.dependency)\nfor d in chain(extra_dependencies, self.dependencies)\n]\nextend_dependencies(extra, dependant)\nif getattr(dependant, \"flat_params\", None) is None:  # handle FastAPI Dependant\ndependant = _patch_fastapi_dependant(dependant)\nif self._is_apply_types is True:\napply_wrapper: _InjectWrapper[\nP_HandlerParams, Awaitable[T_HandlerReturn]\n] = apply_types(None)\nf = apply_wrapper(f, dependant)\ndecode_f = self._wrap_decode_message(\nfunc=f,\n_raw=_raw,\nparams=set(\nchain(\ndependant.flat_params.keys(), *(d.flat_params.keys() for d in extra)\n)\n),\n)\nprocess_f = self._process_message(\nfunc=decode_f,\nwatcher=get_watcher(self.logger, retry),\n)\nprocess_f = set_message_context(process_f)\nhandler_call.set_wrapped(process_f)\nreturn handler_call, dependant\ndef _abc_start(self) -&gt; None:\nself.started = True\nfor h in self.handlers.values():\nh.global_middlewares = (*self.middlewares, *h.global_middlewares)\nif self.logger is not None:\nchange_logger_handlers(self.logger, self.fmt)\ndef _abc_close(\nself,\nexc_type: Optional[Type[BaseException]] = None,\nexc_val: Optional[BaseException] = None,\nexec_tb: Optional[TracebackType] = None,\n) -&gt; None:\n\"\"\"Closes the ABC.\n        Args:\n            exc_type: The exception type\n            exc_val: The exception value\n            exec_tb: The traceback\n        Returns:\n            None\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nself.started = False\ndef _abc__close(\nself,\nexc_type: Optional[Type[BaseException]] = None,\nexc_val: Optional[BaseException] = None,\nexec_tb: Optional[TracebackType] = None,\n) -&gt; None:\n\"\"\"Closes the connection.\n        Args:\n            exc_type: The type of the exception being handled (optional)\n            exc_val: The exception instance being handled (optional)\n            exec_tb: The traceback for the exception being handled (optional)\n        Returns:\n            None\n        Note:\n            This is an abstract method and must be implemented by subclasses.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nself._connection = None\n@abstractmethod\ndef _process_message(\nself,\nfunc: Callable[[StreamMessage[MsgType]], Awaitable[T_HandlerReturn]],\nwatcher: BaseWatcher,\n) -&gt; Callable[[StreamMessage[MsgType]], Awaitable[WrappedReturn[T_HandlerReturn]],]:\n\"\"\"Processes a message using a given function and watcher.\n        Args:\n            func: A callable that takes a StreamMessage of type MsgType and returns an Awaitable of type T_HandlerReturn.\n            watcher: An instance of BaseWatcher.\n        Returns:\n            A callable that takes a StreamMessage of type MsgType and returns an Awaitable of type WrappedReturn[T_HandlerReturn].\n        Raises:\n            NotImplementedError: If the method is not implemented.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nraise NotImplementedError()\n@abstractmethod\ndef subscriber(  # type: ignore[return]\nself,\n*broker_args: Any,\nretry: Union[bool, int] = False,\ndependencies: Sequence[Depends] = (),\ndecoder: Optional[CustomDecoder[MsgType]] = None,\nparser: Optional[CustomParser[MsgType]] = None,\nmiddlewares: Optional[\nSequence[\nCallable[\n[StreamMessage[MsgType]],\nBaseMiddleware,\n]\n]\n] = None,\nfilter: Filter[StreamMessage[MsgType]] = lambda m: not m.processed,\n_raw: bool = False,\n_get_dependant: Optional[Any] = None,\n**broker_kwargs: Any,\n) -&gt; Callable[\n[\nUnion[\nCallable[P_HandlerParams, T_HandlerReturn],\nHandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn],\n]\n],\nHandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn],\n]:\n\"\"\"This is a function decorator for subscribing to a message broker.\n        Args:\n            *broker_args: Positional arguments to be passed to the broker.\n            retry: Whether to retry the subscription if it fails. Can be a boolean or an integer specifying the number of retries.\n            dependencies: Sequence of dependencies to be injected into the handler function.\n            decoder: Custom decoder function to decode the message.\n            parser: Custom parser function to parse the decoded message.\n            middlewares: Sequence of middleware functions to be applied to the message.\n            filter: Filter function to filter the messages to be processed.\n            _raw: Whether to return the raw message instead of the processed message.\n            _get_dependant: Optional parameter to get the dependant object.\n            **broker_kwargs: Keyword arguments to be passed to the broker.\n        Returns:\n            A callable object that can be used as a decorator for a handler function.\n        Raises:\n            RuntimeWarning: If the broker is already running.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nif self.started:\nwarnings.warn(\n\"You are trying to register `handler` with already running broker\\n\"  # noqa: E501\n\"It has no effect until broker restarting.\",  # noqa: E501\ncategory=RuntimeWarning,\nstacklevel=1,\n)\n@abstractmethod\ndef publisher(\nself,\nkey: Any,\npublisher: BasePublisher[MsgType],\n) -&gt; BasePublisher[MsgType]:\n\"\"\"Publishes a publisher.\n        Args:\n            key: The key associated with the publisher.\n            publisher: The publisher to be published.\n        Returns:\n            The published publisher.\n        Raises:\n            NotImplementedError: If the method is not implemented.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nself._publishers[key] = publisher\nreturn publisher\n@abstractmethod\ndef _wrap_decode_message(\nself,\nfunc: Callable[..., Awaitable[T_HandlerReturn]],\nparams: Sized = (),\n_raw: bool = False,\n) -&gt; Callable[[StreamMessage[MsgType]], Awaitable[T_HandlerReturn]]:\n\"\"\"Wrap a decoding message function.\n        Args:\n            func: The function to wrap.\n            params: The parameters to pass to the function.\n            _raw: Whether to return the raw message or not.\n        Returns:\n            The wrapped function.\n        Raises:\n            NotImplementedError: If the method is not implemented.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nraise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/broker/core/abc/BrokerUsecase/#faststream.broker.core.abc.BrokerUsecase.dependencies","title":"dependencies  <code>instance-attribute</code>","text":"<pre><code>dependencies: Sequence[Depends] = dependencies\n</code></pre>"},{"location":"api/faststream/broker/core/abc/BrokerUsecase/#faststream.broker.core.abc.BrokerUsecase.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description = description\n</code></pre>"},{"location":"api/faststream/broker/core/abc/BrokerUsecase/#faststream.broker.core.abc.BrokerUsecase.handlers","title":"handlers  <code>instance-attribute</code>","text":"<pre><code>handlers: Dict[Any, BaseHandler[MsgType]] = {}\n</code></pre>"},{"location":"api/faststream/broker/core/abc/BrokerUsecase/#faststream.broker.core.abc.BrokerUsecase.log_level","title":"log_level  <code>instance-attribute</code>","text":"<pre><code>log_level: int\n</code></pre>"},{"location":"api/faststream/broker/core/abc/BrokerUsecase/#faststream.broker.core.abc.BrokerUsecase.logger","title":"logger  <code>instance-attribute</code>","text":"<pre><code>logger: Optional[logging.Logger]\n</code></pre>"},{"location":"api/faststream/broker/core/abc/BrokerUsecase/#faststream.broker.core.abc.BrokerUsecase.middlewares","title":"middlewares  <code>instance-attribute</code>","text":"<pre><code>middlewares: Sequence[Callable[[Any], BaseMiddleware]] = [\nCriticalLogMiddleware(logger, log_level),\n*midd_args,\n]\n</code></pre>"},{"location":"api/faststream/broker/core/abc/BrokerUsecase/#faststream.broker.core.abc.BrokerUsecase.protocol","title":"protocol  <code>instance-attribute</code>","text":"<pre><code>protocol = protocol\n</code></pre>"},{"location":"api/faststream/broker/core/abc/BrokerUsecase/#faststream.broker.core.abc.BrokerUsecase.protocol_version","title":"protocol_version  <code>instance-attribute</code>","text":"<pre><code>protocol_version = protocol_version\n</code></pre>"},{"location":"api/faststream/broker/core/abc/BrokerUsecase/#faststream.broker.core.abc.BrokerUsecase.security","title":"security  <code>instance-attribute</code>","text":"<pre><code>security = security\n</code></pre>"},{"location":"api/faststream/broker/core/abc/BrokerUsecase/#faststream.broker.core.abc.BrokerUsecase.started","title":"started  <code>instance-attribute</code>","text":"<pre><code>started: bool = False\n</code></pre>"},{"location":"api/faststream/broker/core/abc/BrokerUsecase/#faststream.broker.core.abc.BrokerUsecase.tags","title":"tags  <code>instance-attribute</code>","text":"<pre><code>tags = tags\n</code></pre>"},{"location":"api/faststream/broker/core/abc/BrokerUsecase/#faststream.broker.core.abc.BrokerUsecase.url","title":"url  <code>instance-attribute</code>","text":"<pre><code>url = url\n</code></pre>"},{"location":"api/faststream/broker/core/abc/BrokerUsecase/#faststream.broker.core.abc.BrokerUsecase.include_router","title":"include_router","text":"<pre><code>include_router(router: BrokerRouter[Any, MsgType]) -&gt; None\n</code></pre> <p>Includes a router in the current object.</p> PARAMETER  DESCRIPTION <code>router</code> <p>The router to be included.</p> <p> TYPE: <code>BrokerRouter[Any, MsgType]</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/core/abc.py</code> <pre><code>def include_router(self, router: BrokerRouter[Any, MsgType]) -&gt; None:\n\"\"\"Includes a router in the current object.\n    Args:\n        router: The router to be included.\n    Returns:\n        None\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nfor r in router._handlers:\nself.subscriber(*r.args, **r.kwargs)(r.call)\nself._publishers.update(router._publishers)\n</code></pre>"},{"location":"api/faststream/broker/core/abc/BrokerUsecase/#faststream.broker.core.abc.BrokerUsecase.include_routers","title":"include_routers","text":"<pre><code>include_routers(\n*routers: BrokerRouter[Any, MsgType]\n) -&gt; None\n</code></pre> <p>Includes routers in the current object.</p> PARAMETER  DESCRIPTION <code>*routers</code> <p>Variable length argument list of routers to include.</p> <p> TYPE: <code>BrokerRouter[Any, MsgType]</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/core/abc.py</code> <pre><code>def include_routers(self, *routers: BrokerRouter[Any, MsgType]) -&gt; None:\n\"\"\"Includes routers in the current object.\n    Args:\n        *routers: Variable length argument list of routers to include.\n    Returns:\n        None\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nfor r in routers:\nself.include_router(r)\n</code></pre>"},{"location":"api/faststream/broker/core/abc/BrokerUsecase/#faststream.broker.core.abc.BrokerUsecase.publisher","title":"publisher  <code>abstractmethod</code>","text":"<pre><code>publisher(\nkey: Any, publisher: BasePublisher[MsgType]\n) -&gt; BasePublisher[MsgType]\n</code></pre> <p>Publishes a publisher.</p> PARAMETER  DESCRIPTION <code>key</code> <p>The key associated with the publisher.</p> <p> TYPE: <code>Any</code> </p> <code>publisher</code> <p>The publisher to be published.</p> <p> TYPE: <code>BasePublisher[MsgType]</code> </p> RETURNS DESCRIPTION <code>BasePublisher[MsgType]</code> <p>The published publisher.</p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>If the method is not implemented.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/core/abc.py</code> <pre><code>@abstractmethod\ndef publisher(\nself,\nkey: Any,\npublisher: BasePublisher[MsgType],\n) -&gt; BasePublisher[MsgType]:\n\"\"\"Publishes a publisher.\n    Args:\n        key: The key associated with the publisher.\n        publisher: The publisher to be published.\n    Returns:\n        The published publisher.\n    Raises:\n        NotImplementedError: If the method is not implemented.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nself._publishers[key] = publisher\nreturn publisher\n</code></pre>"},{"location":"api/faststream/broker/core/abc/BrokerUsecase/#faststream.broker.core.abc.BrokerUsecase.subscriber","title":"subscriber  <code>abstractmethod</code>","text":"<pre><code>subscriber(\n*broker_args: Any,\nretry: Union[bool, int] = False,\ndependencies: Sequence[Depends] = (),\ndecoder: Optional[CustomDecoder[MsgType]] = None,\nparser: Optional[CustomParser[MsgType]] = None,\nmiddlewares: Optional[\nSequence[\nCallable[\n[StreamMessage[MsgType]], BaseMiddleware\n]\n]\n] = None,\nfilter: Filter[\nStreamMessage[MsgType]\n] = lambda: not m.processed,\n_raw: bool = False,\n_get_dependant: Optional[Any] = None,\n**broker_kwargs: Any\n) -&gt; Callable[\n[\nUnion[\nCallable[P_HandlerParams, T_HandlerReturn],\nHandlerCallWrapper[\nMsgType, P_HandlerParams, T_HandlerReturn\n],\n]\n],\nHandlerCallWrapper[\nMsgType, P_HandlerParams, T_HandlerReturn\n],\n]\n</code></pre> <p>This is a function decorator for subscribing to a message broker.</p> PARAMETER  DESCRIPTION <code>*broker_args</code> <p>Positional arguments to be passed to the broker.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>()</code> </p> <code>retry</code> <p>Whether to retry the subscription if it fails. Can be a boolean or an integer specifying the number of retries.</p> <p> TYPE: <code>Union[bool, int]</code> DEFAULT: <code>False</code> </p> <code>dependencies</code> <p>Sequence of dependencies to be injected into the handler function.</p> <p> TYPE: <code>Sequence[Depends]</code> DEFAULT: <code>()</code> </p> <code>decoder</code> <p>Custom decoder function to decode the message.</p> <p> TYPE: <code>Optional[CustomDecoder[MsgType]]</code> DEFAULT: <code>None</code> </p> <code>parser</code> <p>Custom parser function to parse the decoded message.</p> <p> TYPE: <code>Optional[CustomParser[MsgType]]</code> DEFAULT: <code>None</code> </p> <code>middlewares</code> <p>Sequence of middleware functions to be applied to the message.</p> <p> TYPE: <code>Optional[Sequence[Callable[[StreamMessage[MsgType]], BaseMiddleware]]]</code> DEFAULT: <code>None</code> </p> <code>filter</code> <p>Filter function to filter the messages to be processed.</p> <p> TYPE: <code>Filter[StreamMessage[MsgType]]</code> DEFAULT: <code>lambda : not processed</code> </p> <code>_raw</code> <p>Whether to return the raw message instead of the processed message.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>_get_dependant</code> <p>Optional parameter to get the dependant object.</p> <p> TYPE: <code>Optional[Any]</code> DEFAULT: <code>None</code> </p> <code>**broker_kwargs</code> <p>Keyword arguments to be passed to the broker.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Callable[[Union[Callable[P_HandlerParams, T_HandlerReturn], HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn]]], HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn]]</code> <p>A callable object that can be used as a decorator for a handler function.</p> RAISES DESCRIPTION <code>RuntimeWarning</code> <p>If the broker is already running.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/core/abc.py</code> <pre><code>@abstractmethod\ndef subscriber(  # type: ignore[return]\nself,\n*broker_args: Any,\nretry: Union[bool, int] = False,\ndependencies: Sequence[Depends] = (),\ndecoder: Optional[CustomDecoder[MsgType]] = None,\nparser: Optional[CustomParser[MsgType]] = None,\nmiddlewares: Optional[\nSequence[\nCallable[\n[StreamMessage[MsgType]],\nBaseMiddleware,\n]\n]\n] = None,\nfilter: Filter[StreamMessage[MsgType]] = lambda m: not m.processed,\n_raw: bool = False,\n_get_dependant: Optional[Any] = None,\n**broker_kwargs: Any,\n) -&gt; Callable[\n[\nUnion[\nCallable[P_HandlerParams, T_HandlerReturn],\nHandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn],\n]\n],\nHandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn],\n]:\n\"\"\"This is a function decorator for subscribing to a message broker.\n    Args:\n        *broker_args: Positional arguments to be passed to the broker.\n        retry: Whether to retry the subscription if it fails. Can be a boolean or an integer specifying the number of retries.\n        dependencies: Sequence of dependencies to be injected into the handler function.\n        decoder: Custom decoder function to decode the message.\n        parser: Custom parser function to parse the decoded message.\n        middlewares: Sequence of middleware functions to be applied to the message.\n        filter: Filter function to filter the messages to be processed.\n        _raw: Whether to return the raw message instead of the processed message.\n        _get_dependant: Optional parameter to get the dependant object.\n        **broker_kwargs: Keyword arguments to be passed to the broker.\n    Returns:\n        A callable object that can be used as a decorator for a handler function.\n    Raises:\n        RuntimeWarning: If the broker is already running.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nif self.started:\nwarnings.warn(\n\"You are trying to register `handler` with already running broker\\n\"  # noqa: E501\n\"It has no effect until broker restarting.\",  # noqa: E501\ncategory=RuntimeWarning,\nstacklevel=1,\n)\n</code></pre>"},{"location":"api/faststream/broker/core/abc/extend_dependencies/","title":"Extend dependencies","text":""},{"location":"api/faststream/broker/core/abc/extend_dependencies/#faststream.broker.core.abc.extend_dependencies","title":"faststream.broker.core.abc.extend_dependencies","text":"<pre><code>extend_dependencies(\nextra: Sequence[CallModel[Any, Any]],\ndependant: CallModel[Any, Any],\n) -&gt; CallModel[Any, Any]\n</code></pre> <p>Extends the dependencies of a function or FastAPI dependency.</p> PARAMETER  DESCRIPTION <code>extra</code> <p>Additional dependencies to be added.</p> <p> TYPE: <code>Sequence[CallModel[Any, Any]]</code> </p> <code>dependant</code> <p>The function or FastAPI dependency whose dependencies will be extended.</p> <p> TYPE: <code>CallModel[Any, Any]</code> </p> RETURNS DESCRIPTION <code>CallModel[Any, Any]</code> <p>The updated function or FastAPI dependency.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/core/abc.py</code> <pre><code>def extend_dependencies(\nextra: Sequence[CallModel[Any, Any]], dependant: CallModel[Any, Any]\n) -&gt; CallModel[Any, Any]:\n\"\"\"Extends the dependencies of a function or FastAPI dependency.\n    Args:\n        extra: Additional dependencies to be added.\n        dependant: The function or FastAPI dependency whose dependencies will be extended.\n    Returns:\n        The updated function or FastAPI dependency.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nif isinstance(dependant, CallModel):\ndependant.extra_dependencies = (*dependant.extra_dependencies, *extra)\nelse:  # FastAPI dependencies\ndependant.dependencies.extend(extra)\nreturn dependant\n</code></pre>"},{"location":"api/faststream/broker/core/asyncronous/BrokerAsyncUsecase/","title":"BrokerAsyncUsecase","text":""},{"location":"api/faststream/broker/core/asyncronous/BrokerAsyncUsecase/#faststream.broker.core.asyncronous.BrokerAsyncUsecase","title":"faststream.broker.core.asyncronous.BrokerAsyncUsecase","text":"<p>             Bases: <code>BrokerUsecase[MsgType, ConnectionType]</code></p> <p>A class representing a broker async usecase.</p> METHOD DESCRIPTION <code>start</code> <p>Abstract method to start the broker async usecase.</p> <code>_connect</code> <p>Any) : Abstract method to connect to the broker.</p> <code>_close</code> <p>Optional[Type[BaseException]] = None, exc_val: Optional[BaseException] = None, exec_tb: Optional[TracebackType] = None) : Abstract method to close the connection to the broker.</p> <code>close</code> <p>Optional[Type[BaseException]] = None, exc_val: Optional[BaseException] = None, exec_tb: Optional[TracebackType] = None) : Close the connection to the broker.</p> <code>_process_message</code> <p>Callable[[StreamMessage[MsgType]], Awaitable[T_HandlerReturn]], watcher: BaseWatcher) : Abstract method to process a message.</p> <code>publish</code> <p>SendableMessage, *args: Any, reply_to: str = \"\", rpc: bool = False, rpc_timeout: Optional[float]</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/core/asyncronous.py</code> <pre><code>class BrokerAsyncUsecase(BrokerUsecase[MsgType, ConnectionType]):\n\"\"\"A class representing a broker async usecase.\n    Attributes:\n        handlers : A dictionary of handlers for different message types.\n        middlewares : A sequence of middleware functions.\n        _global_parser : An optional global parser for messages.\n        _global_decoder : An optional global decoder for messages.\n    Methods:\n        start() : Abstract method to start the broker async usecase.\n        _connect(**kwargs: Any) : Abstract method to connect to the broker.\n        _close(exc_type: Optional[Type[BaseException]] = None, exc_val: Optional[BaseException] = None, exec_tb: Optional[TracebackType] = None) : Abstract method to close the connection to the broker.\n        close(exc_type: Optional[Type[BaseException]] = None, exc_val: Optional[BaseException] = None, exec_tb: Optional[TracebackType] = None) : Close the connection to the broker.\n        _process_message(func: Callable[[StreamMessage[MsgType]], Awaitable[T_HandlerReturn]], watcher: BaseWatcher) : Abstract method to process a message.\n        publish(message: SendableMessage, *args: Any, reply_to: str = \"\", rpc: bool = False, rpc_timeout: Optional[float]\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nhandlers: Dict[Any, AsyncHandler[MsgType]]  # type: ignore[assignment]\nmiddlewares: Sequence[Callable[[MsgType], BaseMiddleware]]\n_global_parser: Optional[AsyncCustomParser[MsgType]]\n_global_decoder: Optional[AsyncCustomDecoder[MsgType]]\n@abstractmethod\nasync def start(self) -&gt; None:\nsuper()._abc_start()\nfor h in self.handlers.values():\nfor f, _, _, _, _, _ in h.calls:\nf.refresh(with_mock=False)\nawait self.connect()\n@abstractmethod\nasync def _connect(self, **kwargs: Any) -&gt; ConnectionType:\n\"\"\"Connect to a resource.\n        Args:\n            **kwargs: Additional keyword arguments for the connection.\n        Returns:\n            The connection object.\n        Raises:\n            NotImplementedError: If the method is not implemented.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nraise NotImplementedError()\n@abstractmethod\nasync def _close(\nself,\nexc_type: Optional[Type[BaseException]] = None,\nexc_val: Optional[BaseException] = None,\nexec_tb: Optional[TracebackType] = None,\n) -&gt; None:\n\"\"\"Close the object.\n        Args:\n            exc_type: Optional. The type of the exception.\n            exc_val: Optional. The exception value.\n            exec_tb: Optional. The traceback of the exception.\n        Returns:\n            None\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nsuper()._abc__close(exc_type, exc_val, exec_tb)\nasync def close(\nself,\nexc_type: Optional[Type[BaseException]] = None,\nexc_val: Optional[BaseException] = None,\nexec_tb: Optional[TracebackType] = None,\n) -&gt; None:\n\"\"\"Closes the object.\n        Args:\n            exc_type: The type of the exception being handled, if any.\n            exc_val: The exception instance being handled, if any.\n            exec_tb: The traceback of the exception being handled, if any.\n        Returns:\n            None\n        Raises:\n            NotImplementedError: If the method is not implemented.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nsuper()._abc_close(exc_type, exc_val, exec_tb)\nfor h in self.handlers.values():\nawait h.close()\nif self._connection is not None:\nawait self._close(exc_type, exc_val, exec_tb)\n@override\n@abstractmethod\ndef _process_message(\nself,\nfunc: Callable[[StreamMessage[MsgType]], Awaitable[T_HandlerReturn]],\nwatcher: BaseWatcher,\n) -&gt; Callable[[StreamMessage[MsgType]], Awaitable[WrappedReturn[T_HandlerReturn]],]:\n\"\"\"Process a message.\n        Args:\n            func: A callable function that takes a StreamMessage and returns an Awaitable\n            watcher: An instance of BaseWatcher\n        Returns:\n            A callable function that takes a StreamMessage and returns an Awaitable\n        Raises:\n            NotImplementedError: If the method is not implemented\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nraise NotImplementedError()\n@abstractmethod\nasync def publish(\nself,\nmessage: SendableMessage,\n*args: Any,\nreply_to: str = \"\",\nrpc: bool = False,\nrpc_timeout: Optional[float] = None,\nraise_timeout: bool = False,\n**kwargs: Any,\n) -&gt; Optional[SendableMessage]:\n\"\"\"Publish a message.\n        Args:\n            message: The message to be published.\n            *args: Additional arguments.\n            reply_to: The reply-to address for the message.\n            rpc: Whether the message is for RPC.\n            rpc_timeout: The timeout for RPC.\n            raise_timeout: Whether to raise an exception on timeout.\n            **kwargs: Additional keyword arguments.\n        Returns:\n            The published message.\n        Raises:\n            NotImplementedError: If the method is not implemented.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nraise NotImplementedError()\n@override\n@abstractmethod\ndef subscriber(  # type: ignore[override,return]\nself,\n*broker_args: Any,\nretry: Union[bool, int] = False,\ndependencies: Sequence[Depends] = (),\ndecoder: Optional[CustomDecoder[MsgType]] = None,\nparser: Optional[CustomParser[MsgType]] = None,\nmiddlewares: Optional[Sequence[Callable[[MsgType], BaseMiddleware]]] = None,\nfilter: Filter[StreamMessage[MsgType]] = default_filter,\n_raw: bool = False,\n_get_dependant: Optional[Any] = None,\n**broker_kwargs: Any,\n) -&gt; Callable[\n[\nUnion[\nCallable[P_HandlerParams, T_HandlerReturn],\nHandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn],\n]\n],\nHandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn],\n]:\n\"\"\"A function decorator for subscribing to a message broker.\n        Args:\n            *broker_args: Positional arguments to be passed to the message broker.\n            retry: Whether to retry the subscription if it fails. Can be a boolean or an integer specifying the number of retries.\n            dependencies: Sequence of dependencies to be injected into the decorated function.\n            decoder: Custom decoder function for decoding the message.\n            parser: Custom parser function for parsing the decoded message.\n            middlewares: Sequence of middleware functions to be applied to the message.\n            filter: Filter function for filtering the messages to be processed.\n            _raw: Whether to return the raw message instead of the processed result.\n            _get_dependant: Optional argument to get the dependant object.\n        Returns:\n            A callable decorator that wraps the decorated function and handles the subscription.\n        Raises:\n            NotImplementedError: If silent animals are not supported.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nsuper().subscriber()\ndef __init__(\nself,\n*args: Any,\napply_types: bool = True,\nlogger: Optional[logging.Logger] = access_logger,\nlog_level: int = logging.INFO,\nlog_fmt: Optional[str] = \"%(asctime)s %(levelname)s - %(message)s\",\ndependencies: Sequence[Depends] = (),\ndecoder: Optional[CustomDecoder[MsgType]] = None,\nparser: Optional[CustomParser[MsgType]] = None,\nmiddlewares: Optional[Sequence[Callable[[MsgType], BaseMiddleware]]] = None,\n**kwargs: Any,\n) -&gt; None:\n\"\"\"Initialize the class.\n        Args:\n            *args: Variable length arguments\n            apply_types: Whether to apply types or not\n            logger: Logger object for logging\n            log_level: Log level for logging\n            log_fmt: Log format for logging\n            dependencies: Sequence of dependencies\n            decoder: Custom decoder object\n            parser: Custom parser object\n            middlewares: Sequence of middlewares\n            **kwargs: Keyword arguments\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nsuper().__init__(\n*args,\napply_types=apply_types,\nlogger=logger,\nlog_level=log_level,\nlog_fmt=log_fmt,\ndependencies=dependencies,\ndecoder=cast(\nOptional[AsyncCustomDecoder[MsgType]],\nto_async(decoder) if decoder else None,\n),\nparser=cast(\nOptional[AsyncCustomParser[MsgType]],\nto_async(parser) if parser else None,\n),\nmiddlewares=middlewares,\n**kwargs,\n)\nasync def connect(self, *args: Any, **kwargs: Any) -&gt; ConnectionType:\n\"\"\"Connect to a remote server.\n        Args:\n            *args: Variable length argument list.\n            **kwargs: Arbitrary keyword arguments.\n        Returns:\n            The connection object.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nif self._connection is None:\n_kwargs = self._resolve_connection_kwargs(*args, **kwargs)\nself._connection = await self._connect(**_kwargs)\nreturn self._connection\nasync def __aenter__(self) -&gt; Self:\nawait self.connect()\nreturn self\nasync def __aexit__(\nself,\nexc_type: Optional[Type[BaseException]],\nexc_val: Optional[BaseException],\nexec_tb: Optional[TracebackType],\n) -&gt; None:\n\"\"\"Exit the context manager.\n        Args:\n            exc_type: The type of the exception raised, if any.\n            exc_val: The exception raised, if any.\n            exec_tb: The traceback of the exception raised, if any.\n        Returns:\n            None\n        Overrides:\n            This method overrides the __aexit__ method of the base class.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nawait self.close(exc_type, exc_val, exec_tb)\n@override\ndef _wrap_decode_message(\nself,\nfunc: Callable[..., Awaitable[T_HandlerReturn]],\nparams: Sized = (),\n_raw: bool = False,\n) -&gt; Callable[[StreamMessage[MsgType]], Awaitable[T_HandlerReturn]]:\n\"\"\"Wraps a function to decode a message and pass it as an argument to the wrapped function.\n        Args:\n            func: The function to be wrapped.\n            params: The parameters to be passed to the wrapped function.\n            _raw: Whether to return the raw message or not.\n        Returns:\n            The wrapped function.\n        Raises:\n            AssertionError: If the code reaches an unreachable state.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nparams_ln = len(params)\n@wraps(func)\nasync def decode_wrapper(message: StreamMessage[MsgType]) -&gt; T_HandlerReturn:\n\"\"\"A wrapper function to decode and handle a message.\n            Args:\n                message : The message to be decoded and handled\n            Returns:\n                The return value of the handler function\n            Raises:\n                AssertionError: If the code reaches an unreachable state\n            !!! note\n                The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n            \"\"\"\nif _raw is True:\nreturn await func(message)\nmsg = message.decoded_body\nif params_ln &gt; 1:\nif isinstance(msg, Mapping):\nreturn await func(**msg)\nelif isinstance(msg, Sequence):\nreturn await func(*msg)\nelse:\nreturn await func(msg)\nraise AssertionError(\"unreachable\")\nreturn decode_wrapper\n@override\ndef _wrap_handler(\nself,\nfunc: Callable[P_HandlerParams, T_HandlerReturn],\n*,\nretry: Union[bool, int] = False,\nextra_dependencies: Sequence[Depends] = (),\n_raw: bool = False,\n_get_dependant: Optional[Any] = None,\n) -&gt; Tuple[\nHandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn],\nCallModel[P_HandlerParams, T_HandlerReturn],\n]:\n\"\"\"Wrap a handler function.\n        Args:\n            func: The handler function to wrap.\n            retry: Whether to retry the handler function if it fails. Can be a boolean or an integer specifying the number of retries.\n            extra_dependencies: Additional dependencies to inject into the handler function.\n            _raw: Whether to return the raw response from the handler function.\n            _get_dependant: An optional object to use as the dependant for the handler function.\n            **broker_log_context_kwargs: Additional keyword arguments to pass to the broker log context.\n        Returns:\n            A tuple containing the wrapped handler function and the call model.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nreturn super()._wrap_handler(  # type: ignore[return-value]\nfunc,\nretry=retry,\nextra_dependencies=extra_dependencies,\n_raw=_raw,\n_get_dependant=_get_dependant,\n)\nasync def _execute_handler(\nself,\nfunc: Callable[[StreamMessage[MsgType]], Awaitable[T_HandlerReturn]],\nmessage: StreamMessage[MsgType],\n) -&gt; T_HandlerReturn:\n\"\"\"Executes a handler function asynchronously.\n        Args:\n            func: The handler function to be executed.\n            message: The message to be passed to the handler function.\n        Returns:\n            The return value of the handler function.\n        Raises:\n            AckMessage: If the handler function raises an AckMessage exception.\n            NackMessage: If the handler function raises a NackMessage exception.\n            RejectMessage: If the handler function raises a RejectMessage exception.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\ntry:\nreturn await func(message)\nexcept AckMessage as e:\nawait message.ack()\nraise e\nexcept NackMessage as e:\nawait message.nack()\nraise e\nexcept RejectMessage as e:\nawait message.reject()\nraise e\n</code></pre>"},{"location":"api/faststream/broker/core/asyncronous/BrokerAsyncUsecase/#faststream.broker.core.asyncronous.BrokerAsyncUsecase.handlers","title":"handlers  <code>instance-attribute</code>","text":"<pre><code>handlers: Dict[Any, AsyncHandler[MsgType]]\n</code></pre>"},{"location":"api/faststream/broker/core/asyncronous/BrokerAsyncUsecase/#faststream.broker.core.asyncronous.BrokerAsyncUsecase.middlewares","title":"middlewares  <code>instance-attribute</code>","text":"<pre><code>middlewares: Sequence[Callable[[MsgType], BaseMiddleware]]\n</code></pre>"},{"location":"api/faststream/broker/core/asyncronous/BrokerAsyncUsecase/#faststream.broker.core.asyncronous.BrokerAsyncUsecase.close","title":"close  <code>async</code>","text":"<pre><code>close(\nexc_type: Optional[Type[BaseException]] = None,\nexc_val: Optional[BaseException] = None,\nexec_tb: Optional[TracebackType] = None,\n) -&gt; None\n</code></pre> <p>Closes the object.</p> PARAMETER  DESCRIPTION <code>exc_type</code> <p>The type of the exception being handled, if any.</p> <p> TYPE: <code>Optional[Type[BaseException]]</code> DEFAULT: <code>None</code> </p> <code>exc_val</code> <p>The exception instance being handled, if any.</p> <p> TYPE: <code>Optional[BaseException]</code> DEFAULT: <code>None</code> </p> <code>exec_tb</code> <p>The traceback of the exception being handled, if any.</p> <p> TYPE: <code>Optional[TracebackType]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>If the method is not implemented.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/core/asyncronous.py</code> <pre><code>async def close(\nself,\nexc_type: Optional[Type[BaseException]] = None,\nexc_val: Optional[BaseException] = None,\nexec_tb: Optional[TracebackType] = None,\n) -&gt; None:\n\"\"\"Closes the object.\n    Args:\n        exc_type: The type of the exception being handled, if any.\n        exc_val: The exception instance being handled, if any.\n        exec_tb: The traceback of the exception being handled, if any.\n    Returns:\n        None\n    Raises:\n        NotImplementedError: If the method is not implemented.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nsuper()._abc_close(exc_type, exc_val, exec_tb)\nfor h in self.handlers.values():\nawait h.close()\nif self._connection is not None:\nawait self._close(exc_type, exc_val, exec_tb)\n</code></pre>"},{"location":"api/faststream/broker/core/asyncronous/BrokerAsyncUsecase/#faststream.broker.core.asyncronous.BrokerAsyncUsecase.connect","title":"connect  <code>async</code>","text":"<pre><code>connect(*args: Any, **kwargs: Any) -&gt; ConnectionType\n</code></pre> <p>Connect to a remote server.</p> PARAMETER  DESCRIPTION <code>*args</code> <p>Variable length argument list.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>()</code> </p> <code>**kwargs</code> <p>Arbitrary keyword arguments.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>ConnectionType</code> <p>The connection object.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/core/asyncronous.py</code> <pre><code>async def connect(self, *args: Any, **kwargs: Any) -&gt; ConnectionType:\n\"\"\"Connect to a remote server.\n    Args:\n        *args: Variable length argument list.\n        **kwargs: Arbitrary keyword arguments.\n    Returns:\n        The connection object.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nif self._connection is None:\n_kwargs = self._resolve_connection_kwargs(*args, **kwargs)\nself._connection = await self._connect(**_kwargs)\nreturn self._connection\n</code></pre>"},{"location":"api/faststream/broker/core/asyncronous/BrokerAsyncUsecase/#faststream.broker.core.asyncronous.BrokerAsyncUsecase.publish","title":"publish  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>publish(\nmessage: SendableMessage,\n*args: Any,\nreply_to: str = \"\",\nrpc: bool = False,\nrpc_timeout: Optional[float] = None,\nraise_timeout: bool = False,\n**kwargs: Any\n) -&gt; Optional[SendableMessage]\n</code></pre> <p>Publish a message.</p> PARAMETER  DESCRIPTION <code>message</code> <p>The message to be published.</p> <p> TYPE: <code>SendableMessage</code> </p> <code>*args</code> <p>Additional arguments.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>()</code> </p> <code>reply_to</code> <p>The reply-to address for the message.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>rpc</code> <p>Whether the message is for RPC.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>rpc_timeout</code> <p>The timeout for RPC.</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>raise_timeout</code> <p>Whether to raise an exception on timeout.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>**kwargs</code> <p>Additional keyword arguments.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Optional[SendableMessage]</code> <p>The published message.</p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>If the method is not implemented.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/core/asyncronous.py</code> <pre><code>@abstractmethod\nasync def publish(\nself,\nmessage: SendableMessage,\n*args: Any,\nreply_to: str = \"\",\nrpc: bool = False,\nrpc_timeout: Optional[float] = None,\nraise_timeout: bool = False,\n**kwargs: Any,\n) -&gt; Optional[SendableMessage]:\n\"\"\"Publish a message.\n    Args:\n        message: The message to be published.\n        *args: Additional arguments.\n        reply_to: The reply-to address for the message.\n        rpc: Whether the message is for RPC.\n        rpc_timeout: The timeout for RPC.\n        raise_timeout: Whether to raise an exception on timeout.\n        **kwargs: Additional keyword arguments.\n    Returns:\n        The published message.\n    Raises:\n        NotImplementedError: If the method is not implemented.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nraise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/broker/core/asyncronous/BrokerAsyncUsecase/#faststream.broker.core.asyncronous.BrokerAsyncUsecase.start","title":"start  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>start() -&gt; None\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/core/asyncronous.py</code> <pre><code>@abstractmethod\nasync def start(self) -&gt; None:\nsuper()._abc_start()\nfor h in self.handlers.values():\nfor f, _, _, _, _, _ in h.calls:\nf.refresh(with_mock=False)\nawait self.connect()\n</code></pre>"},{"location":"api/faststream/broker/core/asyncronous/BrokerAsyncUsecase/#faststream.broker.core.asyncronous.BrokerAsyncUsecase.subscriber","title":"subscriber  <code>abstractmethod</code>","text":"<pre><code>subscriber(\n*broker_args: Any,\nretry: Union[bool, int] = False,\ndependencies: Sequence[Depends] = (),\ndecoder: Optional[CustomDecoder[MsgType]] = None,\nparser: Optional[CustomParser[MsgType]] = None,\nmiddlewares: Optional[\nSequence[Callable[[MsgType], BaseMiddleware]]\n] = None,\nfilter: Filter[StreamMessage[MsgType]] = default_filter,\n_raw: bool = False,\n_get_dependant: Optional[Any] = None,\n**broker_kwargs: Any\n) -&gt; Callable[\n[\nUnion[\nCallable[P_HandlerParams, T_HandlerReturn],\nHandlerCallWrapper[\nMsgType, P_HandlerParams, T_HandlerReturn\n],\n]\n],\nHandlerCallWrapper[\nMsgType, P_HandlerParams, T_HandlerReturn\n],\n]\n</code></pre> <p>A function decorator for subscribing to a message broker.</p> PARAMETER  DESCRIPTION <code>*broker_args</code> <p>Positional arguments to be passed to the message broker.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>()</code> </p> <code>retry</code> <p>Whether to retry the subscription if it fails. Can be a boolean or an integer specifying the number of retries.</p> <p> TYPE: <code>Union[bool, int]</code> DEFAULT: <code>False</code> </p> <code>dependencies</code> <p>Sequence of dependencies to be injected into the decorated function.</p> <p> TYPE: <code>Sequence[Depends]</code> DEFAULT: <code>()</code> </p> <code>decoder</code> <p>Custom decoder function for decoding the message.</p> <p> TYPE: <code>Optional[CustomDecoder[MsgType]]</code> DEFAULT: <code>None</code> </p> <code>parser</code> <p>Custom parser function for parsing the decoded message.</p> <p> TYPE: <code>Optional[CustomParser[MsgType]]</code> DEFAULT: <code>None</code> </p> <code>middlewares</code> <p>Sequence of middleware functions to be applied to the message.</p> <p> TYPE: <code>Optional[Sequence[Callable[[MsgType], BaseMiddleware]]]</code> DEFAULT: <code>None</code> </p> <code>filter</code> <p>Filter function for filtering the messages to be processed.</p> <p> TYPE: <code>Filter[StreamMessage[MsgType]]</code> DEFAULT: <code>default_filter</code> </p> <code>_raw</code> <p>Whether to return the raw message instead of the processed result.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>_get_dependant</code> <p>Optional argument to get the dependant object.</p> <p> TYPE: <code>Optional[Any]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Callable[[Union[Callable[P_HandlerParams, T_HandlerReturn], HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn]]], HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn]]</code> <p>A callable decorator that wraps the decorated function and handles the subscription.</p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>If silent animals are not supported.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/core/asyncronous.py</code> <pre><code>@override\n@abstractmethod\ndef subscriber(  # type: ignore[override,return]\nself,\n*broker_args: Any,\nretry: Union[bool, int] = False,\ndependencies: Sequence[Depends] = (),\ndecoder: Optional[CustomDecoder[MsgType]] = None,\nparser: Optional[CustomParser[MsgType]] = None,\nmiddlewares: Optional[Sequence[Callable[[MsgType], BaseMiddleware]]] = None,\nfilter: Filter[StreamMessage[MsgType]] = default_filter,\n_raw: bool = False,\n_get_dependant: Optional[Any] = None,\n**broker_kwargs: Any,\n) -&gt; Callable[\n[\nUnion[\nCallable[P_HandlerParams, T_HandlerReturn],\nHandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn],\n]\n],\nHandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn],\n]:\n\"\"\"A function decorator for subscribing to a message broker.\n    Args:\n        *broker_args: Positional arguments to be passed to the message broker.\n        retry: Whether to retry the subscription if it fails. Can be a boolean or an integer specifying the number of retries.\n        dependencies: Sequence of dependencies to be injected into the decorated function.\n        decoder: Custom decoder function for decoding the message.\n        parser: Custom parser function for parsing the decoded message.\n        middlewares: Sequence of middleware functions to be applied to the message.\n        filter: Filter function for filtering the messages to be processed.\n        _raw: Whether to return the raw message instead of the processed result.\n        _get_dependant: Optional argument to get the dependant object.\n    Returns:\n        A callable decorator that wraps the decorated function and handles the subscription.\n    Raises:\n        NotImplementedError: If silent animals are not supported.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nsuper().subscriber()\n</code></pre>"},{"location":"api/faststream/broker/core/asyncronous/default_filter/","title":"Default filter","text":""},{"location":"api/faststream/broker/core/asyncronous/default_filter/#faststream.broker.core.asyncronous.default_filter","title":"faststream.broker.core.asyncronous.default_filter  <code>async</code>","text":"<pre><code>default_filter(msg: StreamMessage[Any]) -&gt; bool\n</code></pre> <p>A function to filter stream messages.</p> PARAMETER  DESCRIPTION <code>msg</code> <p>A stream message object</p> <p> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the message has not been processed, False otherwise</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/core/asyncronous.py</code> <pre><code>async def default_filter(msg: StreamMessage[Any]) -&gt; bool:\n\"\"\"A function to filter stream messages.\n    Args:\n        msg : A stream message object\n    Returns:\n        True if the message has not been processed, False otherwise\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nreturn not msg.processed\n</code></pre>"},{"location":"api/faststream/broker/core/mixins/LoggingMixin/","title":"LoggingMixin","text":""},{"location":"api/faststream/broker/core/mixins/LoggingMixin/#faststream.broker.core.mixins.LoggingMixin","title":"faststream.broker.core.mixins.LoggingMixin","text":"<p>A mixin class for logging.</p> METHOD DESCRIPTION <code>fmt </code> <p>getter method for _fmt attribute</p> <code>_get_log_context </code> <p>returns a dictionary with log context information</p> <code>_log </code> <p>logs a message with optional log level, extra data, and exception info</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/core/mixins.py</code> <pre><code>class LoggingMixin:\n\"\"\"A mixin class for logging.\n    Attributes:\n        logger : logger object used for logging\n        log_level : log level for logging\n        _fmt : format string for log messages\n    Methods:\n        fmt : getter method for _fmt attribute\n        _get_log_context : returns a dictionary with log context information\n        _log : logs a message with optional log level, extra data, and exception info\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\ndef __init__(\nself,\n*args: Any,\nlogger: Optional[logging.Logger] = access_logger,\nlog_level: int = logging.INFO,\nlog_fmt: Optional[str] = \"%(asctime)s %(levelname)s - %(message)s\",\n**kwargs: Any,\n) -&gt; None:\n\"\"\"Initialize the class.\n        Args:\n            *args: Variable length argument list\n            logger: Optional logger object\n            log_level: Log level (default: logging.INFO)\n            log_fmt: Log format (default: \"%(asctime)s %(levelname)s - %(message)s\")\n            **kwargs: Arbitrary keyword arguments\n        Returns:\n            None\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nself.logger = logger\nself.log_level = log_level\nself._fmt = log_fmt\n@property\ndef fmt(self) -&gt; str:  # pragma: no cover\nreturn self._fmt or \"\"\ndef _get_log_context(\nself,\nmessage: Optional[StreamMessage[MsgType]],\n**kwargs: str,\n) -&gt; AnyDict:\n\"\"\"Get the log context.\n        Args:\n            message: Optional stream message\n            **kwargs: Additional keyword arguments\n        Returns:\n            A dictionary containing the log context with the following keys:\n                - message_id: The first 10 characters of the message_id if message is not None, otherwise an empty string\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nreturn {\n\"message_id\": message.message_id[:10] if message else \"\",\n}\ndef _log(\nself,\nmessage: str,\nlog_level: Optional[int] = None,\nextra: Optional[AnyDict] = None,\nexc_info: Optional[Exception] = None,\n) -&gt; None:\n\"\"\"Logs a message.\n        Args:\n            message: The message to be logged.\n            log_level: The log level of the message. If not provided, the default log level of the logger will be used.\n            extra: Additional information to be logged along with the message. This should be a dictionary.\n            exc_info: An exception to be logged along with the message.\n        Returns:\n            None\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nif self.logger is not None:\nself.logger.log(\nlevel=(log_level or self.log_level),\nmsg=message,\nextra=extra,\nexc_info=exc_info,\n)\n</code></pre>"},{"location":"api/faststream/broker/core/mixins/LoggingMixin/#faststream.broker.core.mixins.LoggingMixin.fmt","title":"fmt  <code>property</code>","text":"<pre><code>fmt: str\n</code></pre>"},{"location":"api/faststream/broker/core/mixins/LoggingMixin/#faststream.broker.core.mixins.LoggingMixin.log_level","title":"log_level  <code>instance-attribute</code>","text":"<pre><code>log_level = log_level\n</code></pre>"},{"location":"api/faststream/broker/core/mixins/LoggingMixin/#faststream.broker.core.mixins.LoggingMixin.logger","title":"logger  <code>instance-attribute</code>","text":"<pre><code>logger = logger\n</code></pre>"},{"location":"api/faststream/broker/fastapi/route/StreamMessage/","title":"StreamMessage","text":""},{"location":"api/faststream/broker/fastapi/route/StreamMessage/#faststream.broker.fastapi.route.StreamMessage","title":"faststream.broker.fastapi.route.StreamMessage","text":"<p>             Bases: <code>Request</code></p> <p>A class to represent a stream message.</p> METHOD DESCRIPTION <code>__init__ </code> <p>initializes the StreamMessage object</p> <code>get_session </code> <p>returns a callable function that handles the session of the message</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/fastapi/route.py</code> <pre><code>class StreamMessage(Request):\n\"\"\"A class to represent a stream message.\n    Attributes:\n        scope : dictionary representing the scope of the message\n        _cookies : dictionary representing the cookies of the message\n        _headers : dictionary representing the headers of the message\n        _body : dictionary representing the body of the message\n        _query_params : dictionary representing the query parameters of the message\n    Methods:\n        __init__ : initializes the StreamMessage object\n        get_session : returns a callable function that handles the session of the message\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nscope: AnyDict\n_cookies: AnyDict\n_headers: AnyDict  # type: ignore\n_body: AnyDict  # type: ignore\n_query_params: AnyDict  # type: ignore\ndef __init__(\nself,\nbody: Optional[AnyDict] = None,\nheaders: Optional[AnyDict] = None,\n):\n\"\"\"Initialize a class instance.\n        Args:\n            body: The body of the request as a dictionary. Default is None.\n            headers: The headers of the request as a dictionary. Default is None.\n        Attributes:\n            scope: A dictionary to store the scope of the request.\n            _cookies: A dictionary to store the cookies of the request.\n            _headers: A dictionary to store the headers of the request.\n            _body: A dictionary to store the body of the request.\n            _query_params: A dictionary to store the query parameters of the request.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nself.scope = {}\nself._cookies = {}\nself._headers = headers or {}\nself._body = body or {}\nself._query_params = self._body\n@classmethod\ndef get_session(\ncls,\ndependant: Dependant,\ndependency_overrides_provider: Optional[Any] = None,\n) -&gt; Callable[[NativeMessage[Any]], Awaitable[SendableMessage]]:\n\"\"\"Creates a session for handling requests.\n        Args:\n            dependant: The dependant object representing the session.\n            dependency_overrides_provider: Optional provider for dependency overrides.\n        Returns:\n            A callable that takes a native message and returns an awaitable sendable message.\n        Raises:\n            AssertionError: If the dependant call is not defined.\n        Note:\n            This function is used to create a session for handling requests. It takes a dependant object, which represents the session, and a dependency overrides provider, which allows for overriding dependencies. It returns a callable that takes a native message and returns an awaitable sendable message. The session is created based on the dependant object and the message passed to the callable. The session is then used to call the function obtained from the dependant object, and the result is returned.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nassert dependant.call  # nosec B101\nfunc = get_app(dependant, dependency_overrides_provider)\ndependencies_names = tuple(i.name for i in dependant.dependencies)\nfirst_arg = next(\ndropwhile(\nlambda i: i in dependencies_names,\ninspect.signature(dependant.call).parameters,\n),\nNone,\n)\nasync def app(message: NativeMessage[Any]) -&gt; SendableMessage:\n\"\"\"An asynchronous function that processes an incoming message and returns a sendable message.\n            Args:\n                message : The incoming message to be processed\n            Returns:\n                The sendable message\n            Raises:\n                TypeError: If the body of the message is not a dictionary\n            !!! note\n                The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n            \"\"\"\nbody = message.decoded_body\nif first_arg is not None:\nif not isinstance(body, dict) and not isinstance(body, list):\nfastapi_body: Any = {first_arg: body}\nelse:\nfastapi_body = body\nsession = cls(fastapi_body, message.headers)\nelse:\nsession = cls()\nreturn await func(session)\nreturn app\n</code></pre>"},{"location":"api/faststream/broker/fastapi/route/StreamMessage/#faststream.broker.fastapi.route.StreamMessage.scope","title":"scope  <code>instance-attribute</code>","text":"<pre><code>scope: AnyDict = {}\n</code></pre>"},{"location":"api/faststream/broker/fastapi/route/StreamMessage/#faststream.broker.fastapi.route.StreamMessage.get_session","title":"get_session  <code>classmethod</code>","text":"<pre><code>get_session(\ndependant: Dependant,\ndependency_overrides_provider: Optional[Any] = None,\n) -&gt; Callable[\n[NativeMessage[Any]], Awaitable[SendableMessage]\n]\n</code></pre> <p>Creates a session for handling requests.</p> PARAMETER  DESCRIPTION <code>dependant</code> <p>The dependant object representing the session.</p> <p> TYPE: <code>Dependant</code> </p> <code>dependency_overrides_provider</code> <p>Optional provider for dependency overrides.</p> <p> TYPE: <code>Optional[Any]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Callable[[StreamMessage[Any]], Awaitable[SendableMessage]]</code> <p>A callable that takes a native message and returns an awaitable sendable message.</p> RAISES DESCRIPTION <code>AssertionError</code> <p>If the dependant call is not defined.</p> Note <p>This function is used to create a session for handling requests. It takes a dependant object, which represents the session, and a dependency overrides provider, which allows for overriding dependencies. It returns a callable that takes a native message and returns an awaitable sendable message. The session is created based on the dependant object and the message passed to the callable. The session is then used to call the function obtained from the dependant object, and the result is returned.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/fastapi/route.py</code> <pre><code>@classmethod\ndef get_session(\ncls,\ndependant: Dependant,\ndependency_overrides_provider: Optional[Any] = None,\n) -&gt; Callable[[NativeMessage[Any]], Awaitable[SendableMessage]]:\n\"\"\"Creates a session for handling requests.\n    Args:\n        dependant: The dependant object representing the session.\n        dependency_overrides_provider: Optional provider for dependency overrides.\n    Returns:\n        A callable that takes a native message and returns an awaitable sendable message.\n    Raises:\n        AssertionError: If the dependant call is not defined.\n    Note:\n        This function is used to create a session for handling requests. It takes a dependant object, which represents the session, and a dependency overrides provider, which allows for overriding dependencies. It returns a callable that takes a native message and returns an awaitable sendable message. The session is created based on the dependant object and the message passed to the callable. The session is then used to call the function obtained from the dependant object, and the result is returned.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nassert dependant.call  # nosec B101\nfunc = get_app(dependant, dependency_overrides_provider)\ndependencies_names = tuple(i.name for i in dependant.dependencies)\nfirst_arg = next(\ndropwhile(\nlambda i: i in dependencies_names,\ninspect.signature(dependant.call).parameters,\n),\nNone,\n)\nasync def app(message: NativeMessage[Any]) -&gt; SendableMessage:\n\"\"\"An asynchronous function that processes an incoming message and returns a sendable message.\n        Args:\n            message : The incoming message to be processed\n        Returns:\n            The sendable message\n        Raises:\n            TypeError: If the body of the message is not a dictionary\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nbody = message.decoded_body\nif first_arg is not None:\nif not isinstance(body, dict) and not isinstance(body, list):\nfastapi_body: Any = {first_arg: body}\nelse:\nfastapi_body = body\nsession = cls(fastapi_body, message.headers)\nelse:\nsession = cls()\nreturn await func(session)\nreturn app\n</code></pre>"},{"location":"api/faststream/broker/fastapi/route/StreamRoute/","title":"StreamRoute","text":""},{"location":"api/faststream/broker/fastapi/route/StreamRoute/#faststream.broker.fastapi.route.StreamRoute","title":"faststream.broker.fastapi.route.StreamRoute","text":"<p>             Bases: <code>BaseRoute</code>, <code>Generic[MsgType, P_HandlerParams, T_HandlerReturn]</code></p> <p>A class representing a stream route.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/fastapi/route.py</code> <pre><code>class StreamRoute(BaseRoute, Generic[MsgType, P_HandlerParams, T_HandlerReturn]):\n\"\"\"A class representing a stream route.\n    Attributes:\n        handler : HandlerCallWrapper object representing the handler for the route\n        path : path of the route\n        broker : BrokerAsyncUsecase object representing the broker for the route\n        dependant : Dependable object representing the dependencies for the route\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nhandler: HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn]\ndef __init__(\nself,\npath: Union[NameRequired, str],\n*extra: Union[NameRequired, str],\nendpoint: Union[\nCallable[P_HandlerParams, T_HandlerReturn],\nHandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn],\n],\nbroker: BrokerAsyncUsecase[MsgType, Any],\ndependencies: Sequence[params.Depends] = (),\ndependency_overrides_provider: Optional[Any] = None,\n**handle_kwargs: Any,\n) -&gt; None:\n\"\"\"Initialize a class instance.\n        Args:\n            path: The path of the instance.\n            *extra: Additional arguments.\n            endpoint: The endpoint of the instance.\n            broker: The broker of the instance.\n            dependencies: The dependencies of the instance.\n            dependency_overrides_provider: The provider for dependency overrides.\n            **handle_kwargs: Additional keyword arguments.\n        Returns:\n            None.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nself.path = path\nself.broker = broker\npath_name = (path if isinstance(path, str) else path.name) or \"\"\nif isinstance(endpoint, HandlerCallWrapper):\norig_call = endpoint._original_call\nelse:\norig_call = endpoint\ndependant = get_dependant(\npath=path_name,\ncall=orig_call,\n)\nfor depends in dependencies[::-1]:\ndependant.dependencies.insert(\n0,\nget_parameterless_sub_dependant(depends=depends, path=path_name),\n)\nself.dependant = dependant\ncall = wraps(orig_call)(\nStreamMessage.get_session(\ndependant,\ndependency_overrides_provider,\n)\n)\nif isinstance(endpoint, HandlerCallWrapper):\nendpoint._original_call = call\nhandler = endpoint\nelse:\nhandler = call\nself.handler = broker.subscriber(\npath,\n*extra,\n_raw=True,\n_get_dependant=lambda call: dependant,\n**handle_kwargs,\n)(\nhandler  # type: ignore[arg-type]\n)\n</code></pre>"},{"location":"api/faststream/broker/fastapi/route/StreamRoute/#faststream.broker.fastapi.route.StreamRoute.broker","title":"broker  <code>instance-attribute</code>","text":"<pre><code>broker = broker\n</code></pre>"},{"location":"api/faststream/broker/fastapi/route/StreamRoute/#faststream.broker.fastapi.route.StreamRoute.dependant","title":"dependant  <code>instance-attribute</code>","text":"<pre><code>dependant = dependant\n</code></pre>"},{"location":"api/faststream/broker/fastapi/route/StreamRoute/#faststream.broker.fastapi.route.StreamRoute.handler","title":"handler  <code>instance-attribute</code>","text":"<pre><code>handler: HandlerCallWrapper[\nMsgType, P_HandlerParams, T_HandlerReturn\n] = broker.subscriber(\npath,\n*extra,\n_raw=True,\n_get_dependant=lambda: dependant,\n**handle_kwargs\n)(\nhandler\n)\n</code></pre>"},{"location":"api/faststream/broker/fastapi/route/StreamRoute/#faststream.broker.fastapi.route.StreamRoute.path","title":"path  <code>instance-attribute</code>","text":"<pre><code>path = path\n</code></pre>"},{"location":"api/faststream/broker/fastapi/route/get_app/","title":"Get app","text":""},{"location":"api/faststream/broker/fastapi/route/get_app/#faststream.broker.fastapi.route.get_app","title":"faststream.broker.fastapi.route.get_app","text":"<pre><code>get_app(\ndependant: Dependant,\ndependency_overrides_provider: Optional[Any] = None,\n) -&gt; Callable[\n[StreamMessage], Coroutine[Any, Any, SendableMessage]\n]\n</code></pre> <p>Creates a FastAPI application.</p> PARAMETER  DESCRIPTION <code>dependant</code> <p>The dependant object that defines the endpoint function and its dependencies.</p> <p> TYPE: <code>Dependant</code> </p> <code>dependency_overrides_provider</code> <p>Optional provider for dependency overrides.</p> <p> TYPE: <code>Optional[Any]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Callable[[StreamMessage], Coroutine[Any, Any, SendableMessage]]</code> <p>The FastAPI application as a callable that takes a StreamMessage object as input and returns a SendableMessage coroutine.</p> RAISES DESCRIPTION <code>AssertionError</code> <p>If the code reaches an unreachable state.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/fastapi/route.py</code> <pre><code>def get_app(\ndependant: Dependant,\ndependency_overrides_provider: Optional[Any] = None,\n) -&gt; Callable[[StreamMessage], Coroutine[Any, Any, SendableMessage]]:\n\"\"\"Creates a FastAPI application.\n    Args:\n        dependant: The dependant object that defines the endpoint function and its dependencies.\n        dependency_overrides_provider: Optional provider for dependency overrides.\n    Returns:\n        The FastAPI application as a callable that takes a StreamMessage object as input and returns a SendableMessage coroutine.\n    Raises:\n        AssertionError: If the code reaches an unreachable state.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nasync def app(request: StreamMessage) -&gt; SendableMessage:\n\"\"\"Handle an HTTP request and return a response.\n        Args:\n            request: The incoming HTTP request.\n        Returns:\n            The response to be sent back to the client.\n        Raises:\n            AssertionError: If the code reaches an unreachable point.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nasync with AsyncExitStack() as stack:\nrequest.scope[\"fastapi_astack\"] = stack\nsolved_result = await solve_dependencies(\nrequest=request,\nbody=request._body,\ndependant=dependant,\ndependency_overrides_provider=dependency_overrides_provider,\n)\nvalues, errors, _, _2, _3 = solved_result\nif errors:\nraise_fastapi_validation_error(errors, request._body)\nreturn cast(\nSendableMessage,\nawait run_endpoint_function(\ndependant=dependant,\nvalues=values,\nis_coroutine=asyncio.iscoroutinefunction(dependant.call),\n),\n)\nraise AssertionError(\"unreachable\")\nreturn app\n</code></pre>"},{"location":"api/faststream/broker/fastapi/router/StreamRouter/","title":"StreamRouter","text":""},{"location":"api/faststream/broker/fastapi/router/StreamRouter/#faststream.broker.fastapi.router.StreamRouter","title":"faststream.broker.fastapi.router.StreamRouter","text":"<p>             Bases: <code>APIRouter</code>, <code>Generic[MsgType]</code></p> <p>A class to route streams.</p> METHOD DESCRIPTION <code>__init__ </code> <p>initialize the StreamRouter</p> <code>add_api_mq_route </code> <p>add a route for API and message queue</p> <code>subscriber </code> <p>decorator to define a subscriber</p> <code>wrap_lifespan </code> <p>wrap the lifespan of the router</p> <code>after_startup </code> <p>decorator to define a function to be executed after startup</p> <code>publisher </code> <p>create a publisher for the broker</p> <code>asyncapi_router </code> <p>create an APIRouter for AsyncAPI documentation</p> <code>include_router </code> <p>include another router in the StreamRouter</p> <code>_setup_log_context </code> <p>setup log context for the broker</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/fastapi/router.py</code> <pre><code>class StreamRouter(APIRouter, Generic[MsgType]):\n\"\"\"A class to route streams.\n    Attributes:\n        broker_class : type of the broker\n        broker : instance of the broker\n        docs_router : optional APIRouter for documentation\n        _after_startup_hooks : list of functions to be executed after startup\n        schema : optional schema\n        title : title of the router\n        description : description of the router\n        version : version of the router\n        license : optional license information\n        contact : optional contact information\n    Methods:\n        __init__ : initialize the StreamRouter\n        add_api_mq_route : add a route for API and message queue\n        subscriber : decorator to define a subscriber\n        wrap_lifespan : wrap the lifespan of the router\n        after_startup : decorator to define a function to be executed after startup\n        publisher : create a publisher for the broker\n        asyncapi_router : create an APIRouter for AsyncAPI documentation\n        include_router : include another router in the StreamRouter\n        _setup_log_context : setup log context for the broker\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nbroker_class: Type[BrokerAsyncUsecase[MsgType, Any]]\nbroker: BrokerAsyncUsecase[MsgType, Any]\ndocs_router: Optional[APIRouter]\n_after_startup_hooks: List[\nCallable[[AppType], Awaitable[Optional[Mapping[str, Any]]]]\n]\nschema: Optional[Schema]\ntitle: str\ndescription: str\nversion: str\nlicense: Optional[AnyDict]\ncontact: Optional[AnyDict]\ndef __init__(\nself,\n*connection_args: Tuple[Any, ...],\nprefix: str = \"\",\ntags: Optional[List[Union[str, Enum]]] = None,\ndependencies: Optional[Sequence[params.Depends]] = None,\ndefault_response_class: Type[Response] = Default(JSONResponse),\nresponses: Optional[Dict[Union[int, str], AnyDict]] = None,\ncallbacks: Optional[List[routing.BaseRoute]] = None,\nroutes: Optional[List[routing.BaseRoute]] = None,\nredirect_slashes: bool = True,\ndefault: Optional[ASGIApp] = None,\ndependency_overrides_provider: Optional[Any] = None,\nroute_class: Type[APIRoute] = APIRoute,\non_startup: Optional[Sequence[Callable[[], Any]]] = None,\non_shutdown: Optional[Sequence[Callable[[], Any]]] = None,\ndeprecated: Optional[bool] = None,\ninclude_in_schema: bool = True,\nsetup_state: bool = True,\nlifespan: Optional[Lifespan[Any]] = None,\ngenerate_unique_id_function: Callable[[APIRoute], str] = Default(\ngenerate_unique_id\n),\n# AsyncAPI information\nasyncapi_tags: Optional[Sequence[Union[asyncapi.Tag, asyncapi.TagDict]]] = None,\nschema_url: Optional[str] = \"/asyncapi\",\n**connection_kwars: Any,\n) -&gt; None:\n\"\"\"Initialize an instance of a class.\n        Args:\n            *connection_args: Variable length arguments for the connection\n            prefix: Prefix for the class\n            tags: Optional list of tags for the class\n            dependencies: Optional sequence of dependencies for the class\n            default_response_class: Default response class for the class\n            responses: Optional dictionary of responses for the class\n            callbacks: Optional list of callbacks for the class\n            routes: Optional list of routes for the class\n            redirect_slashes: Boolean value indicating whether to redirect slashes\n            default: Optional default value for the class\n            dependency_overrides_provider: Optional provider for dependency overrides\n            route_class: Route class for the class\n            on_startup: Optional sequence of functions to run on startup\n            on_shutdown: Optional sequence of functions to run on shutdown\n            deprecated: Optional boolean value indicating whether the class is deprecated\n            include_in_schema: Boolean value indicating whether to include the class in the schema\n            setup_state: Boolean value indicating whether to setup state\n            lifespan: Optional lifespan for the class\n            generate_unique_id_function: Function to generate unique ID for the class\n            asyncapi_tags: Optional sequence of asyncapi tags for the class schema\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nassert (  # nosec B101\nself.broker_class\n), \"You should specify `broker_class` at your implementation\"\nself.broker = self.broker_class(\n*connection_args,\napply_types=False,\ntags=asyncapi_tags,\n**connection_kwars,\n)\nself.setup_state = setup_state\n# AsyncAPI information\n# Empty\nself.terms_of_service = None\nself.identifier = None\nself.asyncapi_tags = None\nself.external_docs = None\n# parse from FastAPI app on startup\nself.title = \"\"\nself.version = \"\"\nself.description = \"\"\nself.license = None\nself.contact = None\nself.schema = None\nsuper().__init__(\nprefix=prefix,\ntags=tags,\ndependencies=dependencies,\ndefault_response_class=default_response_class,\nresponses=responses,\ncallbacks=callbacks,\nroutes=routes,\nredirect_slashes=redirect_slashes,\ndefault=default,\ndependency_overrides_provider=dependency_overrides_provider,\nroute_class=route_class,\ndeprecated=deprecated,\ninclude_in_schema=include_in_schema,\ngenerate_unique_id_function=generate_unique_id_function,\nlifespan=self.wrap_lifespan(lifespan),\non_startup=on_startup,\non_shutdown=on_shutdown,\n)\nself.docs_router = self.asyncapi_router(schema_url)\nself._after_startup_hooks = []\ndef add_api_mq_route(\nself,\npath: Union[NameRequired, str],\n*extra: Union[NameRequired, str],\nendpoint: Callable[P_HandlerParams, T_HandlerReturn],\ndependencies: Sequence[params.Depends],\n**broker_kwargs: Any,\n) -&gt; HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn]:\n\"\"\"Add an API message queue route.\n        Args:\n            path: The path of the route.\n            *extra: Additional path segments.\n            endpoint: The endpoint function to be called for this route.\n            dependencies: The dependencies required by the endpoint function.\n            **broker_kwargs: Additional keyword arguments to be passed to the broker.\n        Returns:\n            The handler call wrapper for the route.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nroute: StreamRoute[MsgType, P_HandlerParams, T_HandlerReturn] = StreamRoute(\npath,\n*extra,\nendpoint=endpoint,\ndependencies=dependencies,\ndependency_overrides_provider=self.dependency_overrides_provider,\nbroker=self.broker,\n**broker_kwargs,\n)\nself.routes.append(route)\nreturn route.handler\ndef subscriber(\nself,\npath: Union[str, NameRequired],\n*extra: Union[NameRequired, str],\ndependencies: Optional[Sequence[params.Depends]] = None,\n**broker_kwargs: Any,\n) -&gt; Callable[\n[Callable[P_HandlerParams, T_HandlerReturn]],\nHandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn],\n]:\n\"\"\"A function decorator for subscribing to a message queue.\n        Args:\n            path : The path to subscribe to. Can be a string or a `NameRequired` object.\n            *extra : Additional path segments. Can be a `NameRequired` object or a string.\n            dependencies : Optional sequence of dependencies.\n            **broker_kwargs : Additional keyword arguments for the broker.\n        Returns:\n            A callable decorator that adds the decorated function as an endpoint for the specified path.\n        Raises:\n            NotImplementedError: If silent animals are not supported.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\ncurrent_dependencies = self.dependencies.copy()\nif dependencies:\ncurrent_dependencies.extend(dependencies)\ndef decorator(\nfunc: Callable[P_HandlerParams, T_HandlerReturn],\n) -&gt; HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn]:\n\"\"\"A decorator function.\n            Args:\n                func: The function to be decorated.\n            Returns:\n                The decorated function.\n            !!! note\n                The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n            \"\"\"\nreturn self.add_api_mq_route(\npath,\n*extra,\nendpoint=func,\ndependencies=current_dependencies,\n**broker_kwargs,\n)\nreturn decorator\ndef wrap_lifespan(self, lifespan: Optional[Lifespan[Any]] = None) -&gt; Lifespan[Any]:\n\"\"\"Wrap the lifespan of the application.\n        Args:\n            lifespan: Optional lifespan object.\n        Returns:\n            The wrapped lifespan object.\n        Raises:\n            NotImplementedError: If silent animals are not supported.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nif lifespan is not None:\nlifespan_context = lifespan\nelse:\nlifespan_context = _DefaultLifespan(self)\n@asynccontextmanager\nasync def start_broker_lifespan(\napp: FastAPI,\n) -&gt; AsyncIterator[Mapping[str, Any]]:\n\"\"\"Starts the lifespan of a broker.\n            Args:\n                app (FastAPI): The FastAPI application.\n            Yields:\n                AsyncIterator[Mapping[str, Any]]: A mapping of context information during the lifespan of the broker.\n            Raises:\n                NotImplementedError: If silent animals are not supported.\n            !!! note\n                The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n            \"\"\"\nfrom faststream.asyncapi.generate import get_app_schema\nself.title = app.title\nself.description = app.description\nself.version = app.version\nself.contact = app.contact\nself.license = app.license_info\nself.schema = get_app_schema(self)\nif self.docs_router:\napp.include_router(self.docs_router)\nasync with lifespan_context(app) as maybe_context:\nif maybe_context is None:\ncontext: AnyDict = {}\nelse:\ncontext = dict(maybe_context)\ncontext.update({\"broker\": self.broker})\nawait self.broker.start()\nfor h in self._after_startup_hooks:\nh_context = await h(app)\nif h_context:  # pragma: no branch\ncontext.update(h_context)\ntry:\nif self.setup_state:\nyield context\nelse:\n# NOTE: old asgi compatibility\nyield  # type: ignore\nfinally:\nawait self.broker.close()\nreturn start_broker_lifespan\n@overload\ndef after_startup(\nself,\nfunc: Callable[[AppType], Mapping[str, Any]],\n) -&gt; Callable[[AppType], Mapping[str, Any]]:\n\"\"\"A function decorator to be used for executing a function after startup.\n        Args:\n            func: A function that takes an `AppType` argument and returns a mapping of strings to any type.\n        Returns:\n            A decorated function that takes an `AppType` argument and returns a mapping of strings to any type.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n...\n@overload\ndef after_startup(\nself,\nfunc: Callable[[AppType], Awaitable[Mapping[str, Any]]],\n) -&gt; Callable[[AppType], Awaitable[Mapping[str, Any]]]:\n\"\"\"A function decorator to be used for running a function after the startup of an application.\n        Args:\n            func: The function to be decorated. It should take an argument of type AppType and return an awaitable mapping of strings to any type.\n        Returns:\n            The decorated function.\n        Note:\n            This function can be used as a decorator for other functions.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n...\n@overload\ndef after_startup(\nself,\nfunc: Callable[[AppType], None],\n) -&gt; Callable[[AppType], None]:\n\"\"\"A function decorator to be used for running a function after the startup of an application.\n        Args:\n            func: The function to be executed after startup.\n        Returns:\n            A decorated function that will be executed after startup.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n...\n@overload\ndef after_startup(\nself,\nfunc: Callable[[AppType], Awaitable[None]],\n) -&gt; Callable[[AppType], Awaitable[None]]:\n\"\"\"Decorator to register a function to be executed after the application startup.\n        Args:\n            func: A callable that takes an `AppType` argument and returns an awaitable `None`.\n        Returns:\n            A decorated function that takes an `AppType` argument and returns an awaitable `None`.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n...\ndef after_startup(\nself,\nfunc: Union[\nCallable[[AppType], Mapping[str, Any]],\nCallable[[AppType], Awaitable[Mapping[str, Any]]],\nCallable[[AppType], None],\nCallable[[AppType], Awaitable[None]],\n],\n) -&gt; Union[\nCallable[[AppType], Mapping[str, Any]],\nCallable[[AppType], Awaitable[Mapping[str, Any]]],\nCallable[[AppType], None],\nCallable[[AppType], Awaitable[None]],\n]:\n\"\"\"Register a function to be executed after startup.\n        Args:\n            func: A function to be executed after startup. It can take an `AppType` argument and return a mapping of strings to any values, or it can take an `AppType` argument and return an awaitable that resolves to a mapping of strings to any values, or it can take an `AppType` argument and return nothing, or it can take an `AppType` argument and return an awaitable that resolves to nothing.\n        Returns:\n            The registered function.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nself._after_startup_hooks.append(to_async(func))  # type: ignore\nreturn func\ndef publisher(\nself,\nqueue: Union[NameRequired, str],\n*publisher_args: Any,\n**publisher_kwargs: Any,\n) -&gt; BasePublisher[MsgType]:\n\"\"\"Publishes messages to a queue.\n        Args:\n            queue: The queue to publish the messages to. Can be either a `NameRequired` object or a string.\n            *publisher_args: Additional arguments to be passed to the publisher.\n            **publisher_kwargs: Additional keyword arguments to be passed to the publisher.\n        Returns:\n            An instance of `BasePublisher` that can be used to publish messages to the specified queue.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nreturn self.broker.publisher(\nqueue,\n*publisher_args,\n**publisher_kwargs,\n)\ndef asyncapi_router(self, schema_url: Optional[str]) -&gt; Optional[APIRouter]:\n\"\"\"Creates an API router for serving AsyncAPI documentation.\n        Args:\n            schema_url: The URL where the AsyncAPI schema will be served.\n        Returns:\n            An instance of APIRouter if include_in_schema and schema_url are both True, otherwise returns None.\n        Raises:\n            AssertionError: If self.schema is not set.\n        Notes:\n            This function defines three nested functions: download_app_json_schema, download_app_yaml_schema, and serve_asyncapi_schema. These functions are used to handle different routes for serving the AsyncAPI schema and documentation.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nif not self.include_in_schema or not schema_url:\nreturn None\ndef download_app_json_schema() -&gt; Response:\nassert (  # nosec B101\nself.schema\n), \"You need to run application lifespan at first\"\nreturn Response(\ncontent=json.dumps(self.schema.to_jsonable(), indent=4),\nheaders={\"Content-Type\": \"application/octet-stream\"},\n)\ndef download_app_yaml_schema() -&gt; Response:\nassert (  # nosec B101\nself.schema\n), \"You need to run application lifespan at first\"\nreturn Response(\ncontent=self.schema.to_yaml(),\nheaders={\n\"Content-Type\": \"application/octet-stream\",\n},\n)\ndef serve_asyncapi_schema(\nsidebar: bool = True,\ninfo: bool = True,\nservers: bool = True,\noperations: bool = True,\nmessages: bool = True,\nschemas: bool = True,\nerrors: bool = True,\nexpandMessageExamples: bool = True,\n) -&gt; HTMLResponse:\n\"\"\"Serve the AsyncAPI schema as an HTML response.\n            Args:\n                sidebar (bool, optional): Whether to include the sidebar in the HTML. Defaults to True.\n                info (bool, optional): Whether to include the info section in the HTML. Defaults to True.\n                servers (bool, optional): Whether to include the servers section in the HTML. Defaults to True.\n                operations (bool, optional): Whether to include the operations section in the HTML. Defaults to True.\n                messages (bool, optional): Whether to include the messages section in the HTML. Defaults to True.\n                schemas (bool, optional): Whether to include the schemas section in the HTML. Defaults to True.\n                errors (bool, optional): Whether to include the errors section in the HTML. Defaults to True.\n                expandMessageExamples (bool, optional): Whether to expand message examples in the HTML. Defaults to True.\n            Returns:\n                HTMLResponse: The HTML response containing the AsyncAPI schema.\n            Raises:\n                AssertionError: If the schema is not available.\n            !!! note\n                The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n            \"\"\"\nassert (  # nosec B101\nself.schema\n), \"You need to run application lifespan at first\"\nreturn HTMLResponse(\ncontent=get_asyncapi_html(\nself.schema,\nsidebar=sidebar,\ninfo=info,\nservers=servers,\noperations=operations,\nmessages=messages,\nschemas=schemas,\nerrors=errors,\nexpand_message_examples=expandMessageExamples,\ntitle=self.schema.info.title,\n)\n)\ndocs_router = APIRouter(\nprefix=self.prefix,\ntags=[\"asyncapi\"],\nredirect_slashes=self.redirect_slashes,\ndefault=self.default,\ndeprecated=self.deprecated,\n)\ndocs_router.get(schema_url)(serve_asyncapi_schema)\ndocs_router.get(f\"{schema_url}.json\")(download_app_json_schema)\ndocs_router.get(f\"{schema_url}.yaml\")(download_app_yaml_schema)\nreturn docs_router\ndef include_router(\nself,\nrouter: \"APIRouter\",\n*,\nprefix: str = \"\",\ntags: Optional[List[Union[str, Enum]]] = None,\ndependencies: Optional[Sequence[params.Depends]] = None,\ndefault_response_class: Type[Response] = Default(JSONResponse),\nresponses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\ncallbacks: Optional[List[BaseRoute]] = None,\ndeprecated: Optional[bool] = None,\ninclude_in_schema: bool = True,\ngenerate_unique_id_function: Callable[[APIRoute], str] = Default(\ngenerate_unique_id\n),\n) -&gt; None:\n\"\"\"Includes a router in the API.\n        Args:\n            router (APIRouter): The router to include.\n            prefix (str, optional): The prefix to prepend to all paths defined in the router. Defaults to \"\".\n            tags (List[Union[str, Enum]], optional): The tags to assign to all paths defined in the router. Defaults to None.\n            dependencies (Sequence[params.Depends], optional): The dependencies to apply to all paths defined in the router. Defaults to None.\n            default_response_class (Type[Response], optional): The default response class to use for all paths defined in the router. Defaults to Default(JSONResponse).\n            responses (Dict[Union[int, str], Dict[str, Any]], optional): The responses to define for all paths defined in the router. Defaults to None.\n            callbacks (List[BaseRoute], optional): The callbacks to apply to all paths defined in the router. Defaults to None.\n            deprecated (bool, optional): Whether the router is deprecated. Defaults to None.\n            include_in_schema (bool, optional): Whether to include the router in the API schema. Defaults to True.\n            generate_unique_id_function (Callable[[APIRoute], str], optional): The function to generate unique IDs for\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nif isinstance(router, StreamRouter):\nself._setup_log_context(self.broker, router.broker)\nself.broker.handlers.update(router.broker.handlers)\nself.broker._publishers.update(router.broker._publishers)\nsuper().include_router(\nrouter=router,\nprefix=prefix,\ntags=tags,\ndependencies=dependencies,\ndefault_response_class=default_response_class,\nresponses=responses,\ncallbacks=callbacks,\ndeprecated=deprecated,\ninclude_in_schema=include_in_schema,\ngenerate_unique_id_function=generate_unique_id_function,\n)\n@staticmethod\n@abstractmethod\ndef _setup_log_context(\nmain_broker: BrokerAsyncUsecase[MsgType, Any],\nincluding_broker: BrokerAsyncUsecase[MsgType, Any],\n) -&gt; None:\n\"\"\"Set up log context.\n        Args:\n            main_broker: The main broker.\n            including_broker: The including broker.\n        Returns:\n            None\n        Raises:\n            NotImplementedError: If the function is not implemented.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nraise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/broker/fastapi/router/StreamRouter/#faststream.broker.fastapi.router.StreamRouter.asyncapi_tags","title":"asyncapi_tags  <code>instance-attribute</code>","text":"<pre><code>asyncapi_tags = None\n</code></pre>"},{"location":"api/faststream/broker/fastapi/router/StreamRouter/#faststream.broker.fastapi.router.StreamRouter.broker","title":"broker  <code>instance-attribute</code>","text":"<pre><code>broker: BrokerAsyncUsecase[\nMsgType, Any\n] = self.broker_class(\n*connection_args,\napply_types=False,\ntags=asyncapi_tags,\n**connection_kwars\n)\n</code></pre>"},{"location":"api/faststream/broker/fastapi/router/StreamRouter/#faststream.broker.fastapi.router.StreamRouter.broker_class","title":"broker_class  <code>instance-attribute</code>","text":"<pre><code>broker_class: Type[BrokerAsyncUsecase[MsgType, Any]]\n</code></pre>"},{"location":"api/faststream/broker/fastapi/router/StreamRouter/#faststream.broker.fastapi.router.StreamRouter.contact","title":"contact  <code>instance-attribute</code>","text":"<pre><code>contact: Optional[AnyDict] = None\n</code></pre>"},{"location":"api/faststream/broker/fastapi/router/StreamRouter/#faststream.broker.fastapi.router.StreamRouter.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description: str = ''\n</code></pre>"},{"location":"api/faststream/broker/fastapi/router/StreamRouter/#faststream.broker.fastapi.router.StreamRouter.docs_router","title":"docs_router  <code>instance-attribute</code>","text":"<pre><code>docs_router: Optional[APIRouter] = self.asyncapi_router(\nschema_url\n)\n</code></pre>"},{"location":"api/faststream/broker/fastapi/router/StreamRouter/#faststream.broker.fastapi.router.StreamRouter.external_docs","title":"external_docs  <code>instance-attribute</code>","text":"<pre><code>external_docs = None\n</code></pre>"},{"location":"api/faststream/broker/fastapi/router/StreamRouter/#faststream.broker.fastapi.router.StreamRouter.identifier","title":"identifier  <code>instance-attribute</code>","text":"<pre><code>identifier = None\n</code></pre>"},{"location":"api/faststream/broker/fastapi/router/StreamRouter/#faststream.broker.fastapi.router.StreamRouter.license","title":"license  <code>instance-attribute</code>","text":"<pre><code>license: Optional[AnyDict] = None\n</code></pre>"},{"location":"api/faststream/broker/fastapi/router/StreamRouter/#faststream.broker.fastapi.router.StreamRouter.schema","title":"schema  <code>instance-attribute</code>","text":"<pre><code>schema: Optional[Schema] = None\n</code></pre>"},{"location":"api/faststream/broker/fastapi/router/StreamRouter/#faststream.broker.fastapi.router.StreamRouter.setup_state","title":"setup_state  <code>instance-attribute</code>","text":"<pre><code>setup_state = setup_state\n</code></pre>"},{"location":"api/faststream/broker/fastapi/router/StreamRouter/#faststream.broker.fastapi.router.StreamRouter.terms_of_service","title":"terms_of_service  <code>instance-attribute</code>","text":"<pre><code>terms_of_service = None\n</code></pre>"},{"location":"api/faststream/broker/fastapi/router/StreamRouter/#faststream.broker.fastapi.router.StreamRouter.title","title":"title  <code>instance-attribute</code>","text":"<pre><code>title: str = ''\n</code></pre>"},{"location":"api/faststream/broker/fastapi/router/StreamRouter/#faststream.broker.fastapi.router.StreamRouter.version","title":"version  <code>instance-attribute</code>","text":"<pre><code>version: str = ''\n</code></pre>"},{"location":"api/faststream/broker/fastapi/router/StreamRouter/#faststream.broker.fastapi.router.StreamRouter.add_api_mq_route","title":"add_api_mq_route","text":"<pre><code>add_api_mq_route(\npath: Union[NameRequired, str],\n*extra: Union[NameRequired, str],\nendpoint: Callable[P_HandlerParams, T_HandlerReturn],\ndependencies: Sequence[params.Depends],\n**broker_kwargs: Any\n) -&gt; HandlerCallWrapper[\nMsgType, P_HandlerParams, T_HandlerReturn\n]\n</code></pre> <p>Add an API message queue route.</p> PARAMETER  DESCRIPTION <code>path</code> <p>The path of the route.</p> <p> TYPE: <code>Union[NameRequired, str]</code> </p> <code>*extra</code> <p>Additional path segments.</p> <p> TYPE: <code>Union[NameRequired, str]</code> DEFAULT: <code>()</code> </p> <code>endpoint</code> <p>The endpoint function to be called for this route.</p> <p> TYPE: <code>Callable[P_HandlerParams, T_HandlerReturn]</code> </p> <code>dependencies</code> <p>The dependencies required by the endpoint function.</p> <p> TYPE: <code>Sequence[Depends]</code> </p> <code>**broker_kwargs</code> <p>Additional keyword arguments to be passed to the broker.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn]</code> <p>The handler call wrapper for the route.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/fastapi/router.py</code> <pre><code>def add_api_mq_route(\nself,\npath: Union[NameRequired, str],\n*extra: Union[NameRequired, str],\nendpoint: Callable[P_HandlerParams, T_HandlerReturn],\ndependencies: Sequence[params.Depends],\n**broker_kwargs: Any,\n) -&gt; HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn]:\n\"\"\"Add an API message queue route.\n    Args:\n        path: The path of the route.\n        *extra: Additional path segments.\n        endpoint: The endpoint function to be called for this route.\n        dependencies: The dependencies required by the endpoint function.\n        **broker_kwargs: Additional keyword arguments to be passed to the broker.\n    Returns:\n        The handler call wrapper for the route.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nroute: StreamRoute[MsgType, P_HandlerParams, T_HandlerReturn] = StreamRoute(\npath,\n*extra,\nendpoint=endpoint,\ndependencies=dependencies,\ndependency_overrides_provider=self.dependency_overrides_provider,\nbroker=self.broker,\n**broker_kwargs,\n)\nself.routes.append(route)\nreturn route.handler\n</code></pre>"},{"location":"api/faststream/broker/fastapi/router/StreamRouter/#faststream.broker.fastapi.router.StreamRouter.after_startup","title":"after_startup","text":"<pre><code>after_startup(\nfunc: Union[\nCallable[[AppType], Mapping[str, Any]],\nCallable[[AppType], Awaitable[Mapping[str, Any]]],\nCallable[[AppType], None],\nCallable[[AppType], Awaitable[None]],\n]\n) -&gt; Union[\nCallable[[AppType], Mapping[str, Any]],\nCallable[[AppType], Awaitable[Mapping[str, Any]]],\nCallable[[AppType], None],\nCallable[[AppType], Awaitable[None]],\n]\n</code></pre> <p>Register a function to be executed after startup.</p> PARAMETER  DESCRIPTION <code>func</code> <p>A function to be executed after startup. It can take an <code>AppType</code> argument and return a mapping of strings to any values, or it can take an <code>AppType</code> argument and return an awaitable that resolves to a mapping of strings to any values, or it can take an <code>AppType</code> argument and return nothing, or it can take an <code>AppType</code> argument and return an awaitable that resolves to nothing.</p> <p> TYPE: <code>Union[Callable[[AppType], Mapping[str, Any]], Callable[[AppType], Awaitable[Mapping[str, Any]]], Callable[[AppType], None], Callable[[AppType], Awaitable[None]]]</code> </p> RETURNS DESCRIPTION <code>Union[Callable[[AppType], Mapping[str, Any]], Callable[[AppType], Awaitable[Mapping[str, Any]]], Callable[[AppType], None], Callable[[AppType], Awaitable[None]]]</code> <p>The registered function.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/fastapi/router.py</code> <pre><code>def after_startup(\nself,\nfunc: Union[\nCallable[[AppType], Mapping[str, Any]],\nCallable[[AppType], Awaitable[Mapping[str, Any]]],\nCallable[[AppType], None],\nCallable[[AppType], Awaitable[None]],\n],\n) -&gt; Union[\nCallable[[AppType], Mapping[str, Any]],\nCallable[[AppType], Awaitable[Mapping[str, Any]]],\nCallable[[AppType], None],\nCallable[[AppType], Awaitable[None]],\n]:\n\"\"\"Register a function to be executed after startup.\n    Args:\n        func: A function to be executed after startup. It can take an `AppType` argument and return a mapping of strings to any values, or it can take an `AppType` argument and return an awaitable that resolves to a mapping of strings to any values, or it can take an `AppType` argument and return nothing, or it can take an `AppType` argument and return an awaitable that resolves to nothing.\n    Returns:\n        The registered function.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nself._after_startup_hooks.append(to_async(func))  # type: ignore\nreturn func\n</code></pre>"},{"location":"api/faststream/broker/fastapi/router/StreamRouter/#faststream.broker.fastapi.router.StreamRouter.asyncapi_router","title":"asyncapi_router","text":"<pre><code>asyncapi_router(\nschema_url: Optional[str],\n) -&gt; Optional[APIRouter]\n</code></pre> <p>Creates an API router for serving AsyncAPI documentation.</p> PARAMETER  DESCRIPTION <code>schema_url</code> <p>The URL where the AsyncAPI schema will be served.</p> <p> TYPE: <code>Optional[str]</code> </p> RETURNS DESCRIPTION <code>Optional[APIRouter]</code> <p>An instance of APIRouter if include_in_schema and schema_url are both True, otherwise returns None.</p> RAISES DESCRIPTION <code>AssertionError</code> <p>If self.schema is not set.</p> Notes <p>This function defines three nested functions: download_app_json_schema, download_app_yaml_schema, and serve_asyncapi_schema. These functions are used to handle different routes for serving the AsyncAPI schema and documentation.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/fastapi/router.py</code> <pre><code>def asyncapi_router(self, schema_url: Optional[str]) -&gt; Optional[APIRouter]:\n\"\"\"Creates an API router for serving AsyncAPI documentation.\n    Args:\n        schema_url: The URL where the AsyncAPI schema will be served.\n    Returns:\n        An instance of APIRouter if include_in_schema and schema_url are both True, otherwise returns None.\n    Raises:\n        AssertionError: If self.schema is not set.\n    Notes:\n        This function defines three nested functions: download_app_json_schema, download_app_yaml_schema, and serve_asyncapi_schema. These functions are used to handle different routes for serving the AsyncAPI schema and documentation.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nif not self.include_in_schema or not schema_url:\nreturn None\ndef download_app_json_schema() -&gt; Response:\nassert (  # nosec B101\nself.schema\n), \"You need to run application lifespan at first\"\nreturn Response(\ncontent=json.dumps(self.schema.to_jsonable(), indent=4),\nheaders={\"Content-Type\": \"application/octet-stream\"},\n)\ndef download_app_yaml_schema() -&gt; Response:\nassert (  # nosec B101\nself.schema\n), \"You need to run application lifespan at first\"\nreturn Response(\ncontent=self.schema.to_yaml(),\nheaders={\n\"Content-Type\": \"application/octet-stream\",\n},\n)\ndef serve_asyncapi_schema(\nsidebar: bool = True,\ninfo: bool = True,\nservers: bool = True,\noperations: bool = True,\nmessages: bool = True,\nschemas: bool = True,\nerrors: bool = True,\nexpandMessageExamples: bool = True,\n) -&gt; HTMLResponse:\n\"\"\"Serve the AsyncAPI schema as an HTML response.\n        Args:\n            sidebar (bool, optional): Whether to include the sidebar in the HTML. Defaults to True.\n            info (bool, optional): Whether to include the info section in the HTML. Defaults to True.\n            servers (bool, optional): Whether to include the servers section in the HTML. Defaults to True.\n            operations (bool, optional): Whether to include the operations section in the HTML. Defaults to True.\n            messages (bool, optional): Whether to include the messages section in the HTML. Defaults to True.\n            schemas (bool, optional): Whether to include the schemas section in the HTML. Defaults to True.\n            errors (bool, optional): Whether to include the errors section in the HTML. Defaults to True.\n            expandMessageExamples (bool, optional): Whether to expand message examples in the HTML. Defaults to True.\n        Returns:\n            HTMLResponse: The HTML response containing the AsyncAPI schema.\n        Raises:\n            AssertionError: If the schema is not available.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nassert (  # nosec B101\nself.schema\n), \"You need to run application lifespan at first\"\nreturn HTMLResponse(\ncontent=get_asyncapi_html(\nself.schema,\nsidebar=sidebar,\ninfo=info,\nservers=servers,\noperations=operations,\nmessages=messages,\nschemas=schemas,\nerrors=errors,\nexpand_message_examples=expandMessageExamples,\ntitle=self.schema.info.title,\n)\n)\ndocs_router = APIRouter(\nprefix=self.prefix,\ntags=[\"asyncapi\"],\nredirect_slashes=self.redirect_slashes,\ndefault=self.default,\ndeprecated=self.deprecated,\n)\ndocs_router.get(schema_url)(serve_asyncapi_schema)\ndocs_router.get(f\"{schema_url}.json\")(download_app_json_schema)\ndocs_router.get(f\"{schema_url}.yaml\")(download_app_yaml_schema)\nreturn docs_router\n</code></pre>"},{"location":"api/faststream/broker/fastapi/router/StreamRouter/#faststream.broker.fastapi.router.StreamRouter.include_router","title":"include_router","text":"<pre><code>include_router(\nrouter: APIRouter,\n*,\nprefix: str = \"\",\ntags: Optional[List[Union[str, Enum]]] = None,\ndependencies: Optional[Sequence[params.Depends]] = None,\ndefault_response_class: Type[Response] = Default(\nJSONResponse\n),\nresponses: Optional[\nDict[Union[int, str], Dict[str, Any]]\n] = None,\ncallbacks: Optional[List[BaseRoute]] = None,\ndeprecated: Optional[bool] = None,\ninclude_in_schema: bool = True,\ngenerate_unique_id_function: Callable[\n[APIRoute], str\n] = Default(generate_unique_id)\n) -&gt; None\n</code></pre> <p>Includes a router in the API.</p> PARAMETER  DESCRIPTION <code>router</code> <p>The router to include.</p> <p> TYPE: <code>APIRouter</code> </p> <code>prefix</code> <p>The prefix to prepend to all paths defined in the router. Defaults to \"\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>tags</code> <p>The tags to assign to all paths defined in the router. Defaults to None.</p> <p> TYPE: <code>List[Union[str, Enum]]</code> DEFAULT: <code>None</code> </p> <code>dependencies</code> <p>The dependencies to apply to all paths defined in the router. Defaults to None.</p> <p> TYPE: <code>Sequence[Depends]</code> DEFAULT: <code>None</code> </p> <code>default_response_class</code> <p>The default response class to use for all paths defined in the router. Defaults to Default(JSONResponse).</p> <p> TYPE: <code>Type[Response]</code> DEFAULT: <code>Default(JSONResponse)</code> </p> <code>responses</code> <p>The responses to define for all paths defined in the router. Defaults to None.</p> <p> TYPE: <code>Dict[Union[int, str], Dict[str, Any]]</code> DEFAULT: <code>None</code> </p> <code>callbacks</code> <p>The callbacks to apply to all paths defined in the router. Defaults to None.</p> <p> TYPE: <code>List[BaseRoute]</code> DEFAULT: <code>None</code> </p> <code>deprecated</code> <p>Whether the router is deprecated. Defaults to None.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>None</code> </p> <code>include_in_schema</code> <p>Whether to include the router in the API schema. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>generate_unique_id_function</code> <p>The function to generate unique IDs for</p> <p> TYPE: <code>Callable[[APIRoute], str]</code> DEFAULT: <code>Default(generate_unique_id)</code> </p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/fastapi/router.py</code> <pre><code>def include_router(\nself,\nrouter: \"APIRouter\",\n*,\nprefix: str = \"\",\ntags: Optional[List[Union[str, Enum]]] = None,\ndependencies: Optional[Sequence[params.Depends]] = None,\ndefault_response_class: Type[Response] = Default(JSONResponse),\nresponses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\ncallbacks: Optional[List[BaseRoute]] = None,\ndeprecated: Optional[bool] = None,\ninclude_in_schema: bool = True,\ngenerate_unique_id_function: Callable[[APIRoute], str] = Default(\ngenerate_unique_id\n),\n) -&gt; None:\n\"\"\"Includes a router in the API.\n    Args:\n        router (APIRouter): The router to include.\n        prefix (str, optional): The prefix to prepend to all paths defined in the router. Defaults to \"\".\n        tags (List[Union[str, Enum]], optional): The tags to assign to all paths defined in the router. Defaults to None.\n        dependencies (Sequence[params.Depends], optional): The dependencies to apply to all paths defined in the router. Defaults to None.\n        default_response_class (Type[Response], optional): The default response class to use for all paths defined in the router. Defaults to Default(JSONResponse).\n        responses (Dict[Union[int, str], Dict[str, Any]], optional): The responses to define for all paths defined in the router. Defaults to None.\n        callbacks (List[BaseRoute], optional): The callbacks to apply to all paths defined in the router. Defaults to None.\n        deprecated (bool, optional): Whether the router is deprecated. Defaults to None.\n        include_in_schema (bool, optional): Whether to include the router in the API schema. Defaults to True.\n        generate_unique_id_function (Callable[[APIRoute], str], optional): The function to generate unique IDs for\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nif isinstance(router, StreamRouter):\nself._setup_log_context(self.broker, router.broker)\nself.broker.handlers.update(router.broker.handlers)\nself.broker._publishers.update(router.broker._publishers)\nsuper().include_router(\nrouter=router,\nprefix=prefix,\ntags=tags,\ndependencies=dependencies,\ndefault_response_class=default_response_class,\nresponses=responses,\ncallbacks=callbacks,\ndeprecated=deprecated,\ninclude_in_schema=include_in_schema,\ngenerate_unique_id_function=generate_unique_id_function,\n)\n</code></pre>"},{"location":"api/faststream/broker/fastapi/router/StreamRouter/#faststream.broker.fastapi.router.StreamRouter.publisher","title":"publisher","text":"<pre><code>publisher(\nqueue: Union[NameRequired, str],\n*publisher_args: Any,\n**publisher_kwargs: Any\n) -&gt; BasePublisher[MsgType]\n</code></pre> <p>Publishes messages to a queue.</p> PARAMETER  DESCRIPTION <code>queue</code> <p>The queue to publish the messages to. Can be either a <code>NameRequired</code> object or a string.</p> <p> TYPE: <code>Union[NameRequired, str]</code> </p> <code>*publisher_args</code> <p>Additional arguments to be passed to the publisher.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>()</code> </p> <code>**publisher_kwargs</code> <p>Additional keyword arguments to be passed to the publisher.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>BasePublisher[MsgType]</code> <p>An instance of <code>BasePublisher</code> that can be used to publish messages to the specified queue.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/fastapi/router.py</code> <pre><code>def publisher(\nself,\nqueue: Union[NameRequired, str],\n*publisher_args: Any,\n**publisher_kwargs: Any,\n) -&gt; BasePublisher[MsgType]:\n\"\"\"Publishes messages to a queue.\n    Args:\n        queue: The queue to publish the messages to. Can be either a `NameRequired` object or a string.\n        *publisher_args: Additional arguments to be passed to the publisher.\n        **publisher_kwargs: Additional keyword arguments to be passed to the publisher.\n    Returns:\n        An instance of `BasePublisher` that can be used to publish messages to the specified queue.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nreturn self.broker.publisher(\nqueue,\n*publisher_args,\n**publisher_kwargs,\n)\n</code></pre>"},{"location":"api/faststream/broker/fastapi/router/StreamRouter/#faststream.broker.fastapi.router.StreamRouter.subscriber","title":"subscriber","text":"<pre><code>subscriber(\npath: Union[str, NameRequired],\n*extra: Union[NameRequired, str],\ndependencies: Optional[Sequence[params.Depends]] = None,\n**broker_kwargs: Any\n) -&gt; Callable[\n[Callable[P_HandlerParams, T_HandlerReturn]],\nHandlerCallWrapper[\nMsgType, P_HandlerParams, T_HandlerReturn\n],\n]\n</code></pre> <p>A function decorator for subscribing to a message queue.</p> PARAMETER  DESCRIPTION <code>path</code> <p>The path to subscribe to. Can be a string or a <code>NameRequired</code> object.</p> <p> </p> <code>*extra</code> <p>Additional path segments. Can be a <code>NameRequired</code> object or a string.</p> <p> DEFAULT: <code>()</code> </p> <code>dependencies</code> <p>Optional sequence of dependencies.</p> <p> DEFAULT: <code>None</code> </p> <code>**broker_kwargs</code> <p>Additional keyword arguments for the broker.</p> <p> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Callable[[Callable[P_HandlerParams, T_HandlerReturn]], HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn]]</code> <p>A callable decorator that adds the decorated function as an endpoint for the specified path.</p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>If silent animals are not supported.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/fastapi/router.py</code> <pre><code>def subscriber(\nself,\npath: Union[str, NameRequired],\n*extra: Union[NameRequired, str],\ndependencies: Optional[Sequence[params.Depends]] = None,\n**broker_kwargs: Any,\n) -&gt; Callable[\n[Callable[P_HandlerParams, T_HandlerReturn]],\nHandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn],\n]:\n\"\"\"A function decorator for subscribing to a message queue.\n    Args:\n        path : The path to subscribe to. Can be a string or a `NameRequired` object.\n        *extra : Additional path segments. Can be a `NameRequired` object or a string.\n        dependencies : Optional sequence of dependencies.\n        **broker_kwargs : Additional keyword arguments for the broker.\n    Returns:\n        A callable decorator that adds the decorated function as an endpoint for the specified path.\n    Raises:\n        NotImplementedError: If silent animals are not supported.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\ncurrent_dependencies = self.dependencies.copy()\nif dependencies:\ncurrent_dependencies.extend(dependencies)\ndef decorator(\nfunc: Callable[P_HandlerParams, T_HandlerReturn],\n) -&gt; HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn]:\n\"\"\"A decorator function.\n        Args:\n            func: The function to be decorated.\n        Returns:\n            The decorated function.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nreturn self.add_api_mq_route(\npath,\n*extra,\nendpoint=func,\ndependencies=current_dependencies,\n**broker_kwargs,\n)\nreturn decorator\n</code></pre>"},{"location":"api/faststream/broker/fastapi/router/StreamRouter/#faststream.broker.fastapi.router.StreamRouter.wrap_lifespan","title":"wrap_lifespan","text":"<pre><code>wrap_lifespan(\nlifespan: Optional[Lifespan[Any]] = None,\n) -&gt; Lifespan[Any]\n</code></pre> <p>Wrap the lifespan of the application.</p> PARAMETER  DESCRIPTION <code>lifespan</code> <p>Optional lifespan object.</p> <p> TYPE: <code>Optional[Lifespan[Any]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Lifespan[Any]</code> <p>The wrapped lifespan object.</p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>If silent animals are not supported.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/fastapi/router.py</code> <pre><code>def wrap_lifespan(self, lifespan: Optional[Lifespan[Any]] = None) -&gt; Lifespan[Any]:\n\"\"\"Wrap the lifespan of the application.\n    Args:\n        lifespan: Optional lifespan object.\n    Returns:\n        The wrapped lifespan object.\n    Raises:\n        NotImplementedError: If silent animals are not supported.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nif lifespan is not None:\nlifespan_context = lifespan\nelse:\nlifespan_context = _DefaultLifespan(self)\n@asynccontextmanager\nasync def start_broker_lifespan(\napp: FastAPI,\n) -&gt; AsyncIterator[Mapping[str, Any]]:\n\"\"\"Starts the lifespan of a broker.\n        Args:\n            app (FastAPI): The FastAPI application.\n        Yields:\n            AsyncIterator[Mapping[str, Any]]: A mapping of context information during the lifespan of the broker.\n        Raises:\n            NotImplementedError: If silent animals are not supported.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nfrom faststream.asyncapi.generate import get_app_schema\nself.title = app.title\nself.description = app.description\nself.version = app.version\nself.contact = app.contact\nself.license = app.license_info\nself.schema = get_app_schema(self)\nif self.docs_router:\napp.include_router(self.docs_router)\nasync with lifespan_context(app) as maybe_context:\nif maybe_context is None:\ncontext: AnyDict = {}\nelse:\ncontext = dict(maybe_context)\ncontext.update({\"broker\": self.broker})\nawait self.broker.start()\nfor h in self._after_startup_hooks:\nh_context = await h(app)\nif h_context:  # pragma: no branch\ncontext.update(h_context)\ntry:\nif self.setup_state:\nyield context\nelse:\n# NOTE: old asgi compatibility\nyield  # type: ignore\nfinally:\nawait self.broker.close()\nreturn start_broker_lifespan\n</code></pre>"},{"location":"api/faststream/broker/handler/AsyncHandler/","title":"AsyncHandler","text":""},{"location":"api/faststream/broker/handler/AsyncHandler/#faststream.broker.handler.AsyncHandler","title":"faststream.broker.handler.AsyncHandler","text":"<p>             Bases: <code>BaseHandler[MsgType]</code></p> <p>A class representing an asynchronous handler.</p> METHOD DESCRIPTION <code>add_call </code> <p>adds a new call to the list of calls</p> <code>consume </code> <p>consumes a message and returns a sendable message</p> <code>start </code> <p>starts the handler</p> <code>close </code> <p>closes the handler</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/handler.py</code> <pre><code>class AsyncHandler(BaseHandler[MsgType]):\n\"\"\"A class representing an asynchronous handler.\n    Attributes:\n        calls : a list of tuples containing the following information:\n            - handler : the handler function\n            - filter : a callable that filters the stream message\n            - parser : an async parser for the message\n            - decoder : an async decoder for the message\n            - middlewares : a sequence of middlewares\n            - dependant : a call model for the handler\n    Methods:\n        add_call : adds a new call to the list of calls\n        consume : consumes a message and returns a sendable message\n        start : starts the handler\n        close : closes the handler\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\ncalls: List[\nTuple[\nHandlerCallWrapper[MsgType, Any, SendableMessage],  # handler\nCallable[[StreamMessage[MsgType]], Awaitable[bool]],  # filter\nAsyncParser[MsgType],  # parser\nAsyncDecoder[MsgType],  # decoder\nSequence[Callable[[Any], BaseMiddleware]],  # middlewares\nCallModel[Any, SendableMessage],  # dependant\n]\n]\ndef add_call(\nself,\n*,\nhandler: HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn],\nparser: CustomParser[MsgType],\ndecoder: CustomDecoder[MsgType],\ndependant: CallModel[P_HandlerParams, T_HandlerReturn],\nfilter: Filter[StreamMessage[MsgType]],\nmiddlewares: Optional[Sequence[Callable[[Any], BaseMiddleware]]],\n) -&gt; None:\n\"\"\"Adds a call to the handler.\n        Args:\n            handler: The handler call wrapper.\n            parser: The custom parser.\n            decoder: The custom decoder.\n            dependant: The call model.\n            filter: The filter for stream messages.\n            middlewares: Optional sequence of middlewares.\n        Returns:\n            None\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nself.calls.append(\n(  # type: ignore[arg-type]\nhandler,\nto_async(filter),\nto_async(parser) if parser else None,\nto_async(decoder) if decoder else None,\nmiddlewares or (),\ndependant,\n)\n)\n@override\nasync def consume(self, msg: MsgType) -&gt; SendableMessage:  # type: ignore[override]\n\"\"\"Consume a message asynchronously.\n        Args:\n            msg: The message to be consumed.\n        Returns:\n            The sendable message.\n        Raises:\n            StopConsume: If the consumption needs to be stopped.\n        Raises:\n            Exception: If an error occurs during consumption.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nresult: Optional[WrappedReturn[SendableMessage]] = None\nresult_msg: SendableMessage = None\nlogged = False\nasync with AsyncExitStack() as stack:\ngl_middlewares: List[BaseMiddleware] = []\nfor m in self.global_middlewares:\ngl_middlewares.append(await stack.enter_async_context(m(msg)))\nprocessed = False\nfor handler, filter_, parser, decoder, middlewares, _ in self.calls:\nlocal_middlewares: List[BaseMiddleware] = []\nfor local_m in middlewares:\nlocal_middlewares.append(\nawait stack.enter_async_context(local_m(msg))\n)\nall_middlewares = gl_middlewares + local_middlewares\n# TODO: add parser &amp; decoder cashes\nmessage = await parser(msg)\nif not logged:\nlog_context_tag = context.set_local(\n\"log_context\", self.log_context_builder(message)\n)\nmessage.decoded_body = await decoder(message)\nmessage.processed = processed\nif await filter_(message):\nassert (  # nosec B101\nnot processed\n), \"You can't proccess a message with multiple consumers\"\ntry:\nasync with AsyncExitStack() as consume_stack:\nfor m_consume in all_middlewares:\nmessage.decoded_body = (\nawait consume_stack.enter_async_context(\nm_consume.consume_scope(message.decoded_body)\n)\n)\nresult = await cast(\nAwaitable[Optional[WrappedReturn[SendableMessage]]],\nhandler.call_wrapped(message),\n)\nif result is not None:\nresult_msg, pub_response = result\n# TODO: suppress all publishing errors and raise them after all publishers will be tried\nfor publisher in (pub_response, *handler._publishers):\nif publisher is not None:\nasync with AsyncExitStack() as pub_stack:\nresult_to_send = result_msg\nfor m_pub in all_middlewares:\nresult_to_send = (\nawait pub_stack.enter_async_context(\nm_pub.publish_scope(result_msg)\n)\n)\nawait publisher.publish(\nmessage=result_to_send,\ncorrelation_id=message.correlation_id,\n)\nexcept StopConsume:\nawait self.close()\nhandler.trigger()\nexcept HandlerException as e:\nhandler.trigger()\nraise e\nexcept Exception as e:\nhandler.trigger(error=e)\nraise e\nelse:\nhandler.trigger(result=result[0] if result else None)\nmessage.processed = processed = True\nif IS_OPTIMIZED:  # pragma: no cover\nbreak\nassert processed, \"You have to consume message\"  # nosec B101\ncontext.reset_local(\"log_context\", log_context_tag)\nreturn result_msg\n@abstractmethod\nasync def start(self) -&gt; None:\nraise NotImplementedError()\n@abstractmethod\nasync def close(self) -&gt; None:\nraise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/broker/handler/AsyncHandler/#faststream.broker.handler.AsyncHandler.calls","title":"calls  <code>instance-attribute</code>","text":"<pre><code>calls: List[\nTuple[\nHandlerCallWrapper[MsgType, Any, SendableMessage],\nCallable[[StreamMessage[MsgType]], Awaitable[bool]],\nAsyncParser[MsgType],\nAsyncDecoder[MsgType],\nSequence[Callable[[Any], BaseMiddleware]],\nCallModel[Any, SendableMessage],\n]\n]\n</code></pre>"},{"location":"api/faststream/broker/handler/AsyncHandler/#faststream.broker.handler.AsyncHandler.add_call","title":"add_call","text":"<pre><code>add_call(\n*,\nhandler: HandlerCallWrapper[\nMsgType, P_HandlerParams, T_HandlerReturn\n],\nparser: CustomParser[MsgType],\ndecoder: CustomDecoder[MsgType],\ndependant: CallModel[P_HandlerParams, T_HandlerReturn],\nfilter: Filter[StreamMessage[MsgType]],\nmiddlewares: Optional[\nSequence[Callable[[Any], BaseMiddleware]]\n]\n) -&gt; None\n</code></pre> <p>Adds a call to the handler.</p> PARAMETER  DESCRIPTION <code>handler</code> <p>The handler call wrapper.</p> <p> TYPE: <code>HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn]</code> </p> <code>parser</code> <p>The custom parser.</p> <p> TYPE: <code>CustomParser[MsgType]</code> </p> <code>decoder</code> <p>The custom decoder.</p> <p> TYPE: <code>CustomDecoder[MsgType]</code> </p> <code>dependant</code> <p>The call model.</p> <p> TYPE: <code>CallModel[P_HandlerParams, T_HandlerReturn]</code> </p> <code>filter</code> <p>The filter for stream messages.</p> <p> TYPE: <code>Filter[StreamMessage[MsgType]]</code> </p> <code>middlewares</code> <p>Optional sequence of middlewares.</p> <p> TYPE: <code>Optional[Sequence[Callable[[Any], BaseMiddleware]]]</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/handler.py</code> <pre><code>def add_call(\nself,\n*,\nhandler: HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn],\nparser: CustomParser[MsgType],\ndecoder: CustomDecoder[MsgType],\ndependant: CallModel[P_HandlerParams, T_HandlerReturn],\nfilter: Filter[StreamMessage[MsgType]],\nmiddlewares: Optional[Sequence[Callable[[Any], BaseMiddleware]]],\n) -&gt; None:\n\"\"\"Adds a call to the handler.\n    Args:\n        handler: The handler call wrapper.\n        parser: The custom parser.\n        decoder: The custom decoder.\n        dependant: The call model.\n        filter: The filter for stream messages.\n        middlewares: Optional sequence of middlewares.\n    Returns:\n        None\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nself.calls.append(\n(  # type: ignore[arg-type]\nhandler,\nto_async(filter),\nto_async(parser) if parser else None,\nto_async(decoder) if decoder else None,\nmiddlewares or (),\ndependant,\n)\n)\n</code></pre>"},{"location":"api/faststream/broker/handler/AsyncHandler/#faststream.broker.handler.AsyncHandler.close","title":"close  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>close() -&gt; None\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/handler.py</code> <pre><code>@abstractmethod\nasync def close(self) -&gt; None:\nraise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/broker/handler/AsyncHandler/#faststream.broker.handler.AsyncHandler.consume","title":"consume  <code>async</code>","text":"<pre><code>consume(msg: MsgType) -&gt; SendableMessage\n</code></pre> <p>Consume a message asynchronously.</p> PARAMETER  DESCRIPTION <code>msg</code> <p>The message to be consumed.</p> <p> TYPE: <code>MsgType</code> </p> RETURNS DESCRIPTION <code>SendableMessage</code> <p>The sendable message.</p> RAISES DESCRIPTION <code>StopConsume</code> <p>If the consumption needs to be stopped.</p> RAISES DESCRIPTION <code>Exception</code> <p>If an error occurs during consumption.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/handler.py</code> <pre><code>@override\nasync def consume(self, msg: MsgType) -&gt; SendableMessage:  # type: ignore[override]\n\"\"\"Consume a message asynchronously.\n    Args:\n        msg: The message to be consumed.\n    Returns:\n        The sendable message.\n    Raises:\n        StopConsume: If the consumption needs to be stopped.\n    Raises:\n        Exception: If an error occurs during consumption.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nresult: Optional[WrappedReturn[SendableMessage]] = None\nresult_msg: SendableMessage = None\nlogged = False\nasync with AsyncExitStack() as stack:\ngl_middlewares: List[BaseMiddleware] = []\nfor m in self.global_middlewares:\ngl_middlewares.append(await stack.enter_async_context(m(msg)))\nprocessed = False\nfor handler, filter_, parser, decoder, middlewares, _ in self.calls:\nlocal_middlewares: List[BaseMiddleware] = []\nfor local_m in middlewares:\nlocal_middlewares.append(\nawait stack.enter_async_context(local_m(msg))\n)\nall_middlewares = gl_middlewares + local_middlewares\n# TODO: add parser &amp; decoder cashes\nmessage = await parser(msg)\nif not logged:\nlog_context_tag = context.set_local(\n\"log_context\", self.log_context_builder(message)\n)\nmessage.decoded_body = await decoder(message)\nmessage.processed = processed\nif await filter_(message):\nassert (  # nosec B101\nnot processed\n), \"You can't proccess a message with multiple consumers\"\ntry:\nasync with AsyncExitStack() as consume_stack:\nfor m_consume in all_middlewares:\nmessage.decoded_body = (\nawait consume_stack.enter_async_context(\nm_consume.consume_scope(message.decoded_body)\n)\n)\nresult = await cast(\nAwaitable[Optional[WrappedReturn[SendableMessage]]],\nhandler.call_wrapped(message),\n)\nif result is not None:\nresult_msg, pub_response = result\n# TODO: suppress all publishing errors and raise them after all publishers will be tried\nfor publisher in (pub_response, *handler._publishers):\nif publisher is not None:\nasync with AsyncExitStack() as pub_stack:\nresult_to_send = result_msg\nfor m_pub in all_middlewares:\nresult_to_send = (\nawait pub_stack.enter_async_context(\nm_pub.publish_scope(result_msg)\n)\n)\nawait publisher.publish(\nmessage=result_to_send,\ncorrelation_id=message.correlation_id,\n)\nexcept StopConsume:\nawait self.close()\nhandler.trigger()\nexcept HandlerException as e:\nhandler.trigger()\nraise e\nexcept Exception as e:\nhandler.trigger(error=e)\nraise e\nelse:\nhandler.trigger(result=result[0] if result else None)\nmessage.processed = processed = True\nif IS_OPTIMIZED:  # pragma: no cover\nbreak\nassert processed, \"You have to consume message\"  # nosec B101\ncontext.reset_local(\"log_context\", log_context_tag)\nreturn result_msg\n</code></pre>"},{"location":"api/faststream/broker/handler/AsyncHandler/#faststream.broker.handler.AsyncHandler.start","title":"start  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>start() -&gt; None\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/handler.py</code> <pre><code>@abstractmethod\nasync def start(self) -&gt; None:\nraise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/broker/handler/BaseHandler/","title":"BaseHandler","text":""},{"location":"api/faststream/broker/handler/BaseHandler/#faststream.broker.handler.BaseHandler","title":"faststream.broker.handler.BaseHandler","text":"<p>             Bases: <code>AsyncAPIOperation</code>, <code>Generic[MsgType]</code></p> <p>A base handler class for asynchronous API operations.</p> METHOD DESCRIPTION <code>__init__ </code> <p>Initializes the BaseHandler object.</p> <code>name </code> <p>Returns the name of the handler.</p> <code>call_name </code> <p>Returns the name of the handler call.</p> <code>description </code> <p>Returns the description of the handler.</p> <code>consume </code> <p>Abstract method to consume a message.</p> <p>Note: This class inherits from AsyncAPIOperation and is a generic class with type parameter MsgType.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/handler.py</code> <pre><code>class BaseHandler(AsyncAPIOperation, Generic[MsgType]):\n\"\"\"A base handler class for asynchronous API operations.\n    Attributes:\n        calls : List of tuples representing handler calls, filters, parsers, decoders, middlewares, and dependants.\n        global_middlewares : Sequence of global middlewares.\n    Methods:\n        __init__ : Initializes the BaseHandler object.\n        name : Returns the name of the handler.\n        call_name : Returns the name of the handler call.\n        description : Returns the description of the handler.\n        consume : Abstract method to consume a message.\n    Note: This class inherits from AsyncAPIOperation and is a generic class with type parameter MsgType.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\ncalls: Union[\nList[\nTuple[\nHandlerCallWrapper[MsgType, Any, SendableMessage],  # handler\nCallable[[StreamMessage[MsgType]], bool],  # filter\nSyncParser[MsgType],  # parser\nSyncDecoder[MsgType],  # decoder\nSequence[Callable[[Any], BaseMiddleware]],  # middlewares\nCallModel[Any, SendableMessage],  # dependant\n]\n],\nList[\nTuple[\nHandlerCallWrapper[MsgType, Any, SendableMessage],  # handler\nCallable[[StreamMessage[MsgType]], Awaitable[bool]],  # filter\nAsyncParser[MsgType],  # parser\nAsyncDecoder[MsgType],  # decoder\nSequence[Callable[[Any], BaseMiddleware]],  # middlewares\nCallModel[Any, SendableMessage],  # dependant\n]\n],\n]\nglobal_middlewares: Sequence[Callable[[Any], BaseMiddleware]]\ndef __init__(\nself,\n*,\nlog_context_builder: Callable[[StreamMessage[Any]], Dict[str, str]],\ndescription: Optional[str] = None,\ntitle: Optional[str] = None,\n):\n\"\"\"Initialize a new instance of the class.\n        Args:\n            description: Optional description of the instance.\n            title: Optional title of the instance.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nself.calls = []  # type: ignore[assignment]\nself.global_middlewares = []\n# AsyncAPI information\nself._description = description\nself._title = title\nself.log_context_builder = log_context_builder\n@override\n@property\ndef name(self) -&gt; Union[str, bool]:  # type: ignore[override]\nif self._title:\nreturn self._title\nif not self.calls:  # pragma: no cover\nreturn False\nelse:\nreturn True\n@property\ndef call_name(self) -&gt; str:\ncaller = self.calls[0][0]._original_call\nname = getattr(caller, \"__name__\", str(caller))\nreturn to_camelcase(name)\n@property\ndef description(self) -&gt; Optional[str]:\nif not self.calls:  # pragma: no cover\ndescription = None\nelse:\ncaller = self.calls[0][0]._original_call\ndescription = getattr(caller, \"__doc__\", None)\nreturn self._description or description\n@abstractmethod\ndef consume(self, msg: MsgType) -&gt; SendableMessage:\n\"\"\"Consume a message.\n        Args:\n            msg: The message to be consumed.\n        Returns:\n            The sendable message.\n        Raises:\n            NotImplementedError: If the method is not implemented.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nraise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/broker/handler/BaseHandler/#faststream.broker.handler.BaseHandler.call_name","title":"call_name  <code>property</code>","text":"<pre><code>call_name: str\n</code></pre>"},{"location":"api/faststream/broker/handler/BaseHandler/#faststream.broker.handler.BaseHandler.calls","title":"calls  <code>instance-attribute</code>","text":"<pre><code>calls: Union[\nList[\nTuple[\nHandlerCallWrapper[\nMsgType, Any, SendableMessage\n],\nCallable[[StreamMessage[MsgType]], bool],\nSyncParser[MsgType],\nSyncDecoder[MsgType],\nSequence[Callable[[Any], BaseMiddleware]],\nCallModel[Any, SendableMessage],\n]\n],\nList[\nTuple[\nHandlerCallWrapper[\nMsgType, Any, SendableMessage\n],\nCallable[\n[StreamMessage[MsgType]], Awaitable[bool]\n],\nAsyncParser[MsgType],\nAsyncDecoder[MsgType],\nSequence[Callable[[Any], BaseMiddleware]],\nCallModel[Any, SendableMessage],\n]\n],\n] = []\n</code></pre>"},{"location":"api/faststream/broker/handler/BaseHandler/#faststream.broker.handler.BaseHandler.description","title":"description  <code>property</code>","text":"<pre><code>description: Optional[str]\n</code></pre>"},{"location":"api/faststream/broker/handler/BaseHandler/#faststream.broker.handler.BaseHandler.global_middlewares","title":"global_middlewares  <code>instance-attribute</code>","text":"<pre><code>global_middlewares: Sequence[\nCallable[[Any], BaseMiddleware]\n] = []\n</code></pre>"},{"location":"api/faststream/broker/handler/BaseHandler/#faststream.broker.handler.BaseHandler.log_context_builder","title":"log_context_builder  <code>instance-attribute</code>","text":"<pre><code>log_context_builder = log_context_builder\n</code></pre>"},{"location":"api/faststream/broker/handler/BaseHandler/#faststream.broker.handler.BaseHandler.name","title":"name  <code>property</code>","text":"<pre><code>name: Union[str, bool]\n</code></pre>"},{"location":"api/faststream/broker/handler/BaseHandler/#faststream.broker.handler.BaseHandler.consume","title":"consume  <code>abstractmethod</code>","text":"<pre><code>consume(msg: MsgType) -&gt; SendableMessage\n</code></pre> <p>Consume a message.</p> PARAMETER  DESCRIPTION <code>msg</code> <p>The message to be consumed.</p> <p> TYPE: <code>MsgType</code> </p> RETURNS DESCRIPTION <code>SendableMessage</code> <p>The sendable message.</p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>If the method is not implemented.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/handler.py</code> <pre><code>@abstractmethod\ndef consume(self, msg: MsgType) -&gt; SendableMessage:\n\"\"\"Consume a message.\n    Args:\n        msg: The message to be consumed.\n    Returns:\n        The sendable message.\n    Raises:\n        NotImplementedError: If the method is not implemented.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nraise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/broker/message/ABCStreamMessage/","title":"ABCStreamMessage","text":""},{"location":"api/faststream/broker/message/ABCStreamMessage/#faststream.broker.message.ABCStreamMessage","title":"faststream.broker.message.ABCStreamMessage  <code>dataclass</code>","text":"<p>             Bases: <code>Generic[Msg]</code></p> <p>A generic class to represent a stream message.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/message.py</code> <pre><code>@dataclass\nclass ABCStreamMessage(Generic[Msg]):\n\"\"\"A generic class to represent a stream message.\n    Attributes:\n        raw_message : the raw message\n        body : the body of the message, can be bytes or any other type\n        decoded_body : the decoded message body, if applicable\n        content_type : the content type of the message\n        reply_to : the reply-to address of the message\n        headers : additional headers of the message\n        message_id : the unique identifier of the message\n        correlation_id : the correlation identifier of the message\n        processed : a flag indicating whether the message has been processed or not\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nraw_message: Msg\nbody: Union[bytes, Any]\ndecoded_body: Optional[DecodedMessage] = None\ncontent_type: Optional[str] = None\nreply_to: str = \"\"\nheaders: AnyDict = field(default_factory=dict)\nmessage_id: str = field(default_factory=lambda: str(uuid4()))  # pragma: no cover\ncorrelation_id: str = field(\ndefault_factory=lambda: str(uuid4())\n)  # pragma: no cover\nprocessed: bool = False\n</code></pre>"},{"location":"api/faststream/broker/message/ABCStreamMessage/#faststream.broker.message.ABCStreamMessage.body","title":"body  <code>instance-attribute</code>","text":"<pre><code>body: Union[bytes, Any]\n</code></pre>"},{"location":"api/faststream/broker/message/ABCStreamMessage/#faststream.broker.message.ABCStreamMessage.content_type","title":"content_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>content_type: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/broker/message/ABCStreamMessage/#faststream.broker.message.ABCStreamMessage.correlation_id","title":"correlation_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>correlation_id: str = field(\ndefault_factory=lambda: str(uuid4())\n)\n</code></pre>"},{"location":"api/faststream/broker/message/ABCStreamMessage/#faststream.broker.message.ABCStreamMessage.decoded_body","title":"decoded_body  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>decoded_body: Optional[DecodedMessage] = None\n</code></pre>"},{"location":"api/faststream/broker/message/ABCStreamMessage/#faststream.broker.message.ABCStreamMessage.headers","title":"headers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>headers: AnyDict = field(default_factory=dict)\n</code></pre>"},{"location":"api/faststream/broker/message/ABCStreamMessage/#faststream.broker.message.ABCStreamMessage.message_id","title":"message_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>message_id: str = field(\ndefault_factory=lambda: str(uuid4())\n)\n</code></pre>"},{"location":"api/faststream/broker/message/ABCStreamMessage/#faststream.broker.message.ABCStreamMessage.processed","title":"processed  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>processed: bool = False\n</code></pre>"},{"location":"api/faststream/broker/message/ABCStreamMessage/#faststream.broker.message.ABCStreamMessage.raw_message","title":"raw_message  <code>instance-attribute</code>","text":"<pre><code>raw_message: Msg\n</code></pre>"},{"location":"api/faststream/broker/message/ABCStreamMessage/#faststream.broker.message.ABCStreamMessage.reply_to","title":"reply_to  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>reply_to: str = ''\n</code></pre>"},{"location":"api/faststream/broker/message/StreamMessage/","title":"StreamMessage","text":""},{"location":"api/faststream/broker/message/StreamMessage/#faststream.broker.message.StreamMessage","title":"faststream.broker.message.StreamMessage","text":"<p>             Bases: <code>ABCStreamMessage[Msg]</code></p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/message.py</code> <pre><code>class StreamMessage(ABCStreamMessage[Msg]):\n@abstractmethod\nasync def ack(self, **kwargs: Any) -&gt; None:\n\"\"\"Acknowledge method.\n        Args:\n            **kwargs: Additional keyword arguments\n        Raises:\n            NotImplementedError: If the method is not implemented.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nraise NotImplementedError()\n@abstractmethod\nasync def nack(self, **kwargs: Any) -&gt; None:\n\"\"\"A function to handle a nack.\n        Args:\n            **kwargs: Additional arguments\n        Returns:\n            None\n        Raises:\n            NotImplementedError: If the function is not implemented.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nraise NotImplementedError()\n@abstractmethod\nasync def reject(self, **kwargs: Any) -&gt; None:\n\"\"\"Rejects the operation.\n        Args:\n            **kwargs: Additional keyword arguments\n        Returns:\n            None\n        Raises:\n            NotImplementedError: Always raises NotImplementedError\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nraise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/broker/message/StreamMessage/#faststream.broker.message.StreamMessage.ack","title":"ack  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>ack(**kwargs: Any) -&gt; None\n</code></pre> <p>Acknowledge method.</p> PARAMETER  DESCRIPTION <code>**kwargs</code> <p>Additional keyword arguments</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>If the method is not implemented.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/message.py</code> <pre><code>@abstractmethod\nasync def ack(self, **kwargs: Any) -&gt; None:\n\"\"\"Acknowledge method.\n    Args:\n        **kwargs: Additional keyword arguments\n    Raises:\n        NotImplementedError: If the method is not implemented.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nraise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/broker/message/StreamMessage/#faststream.broker.message.StreamMessage.nack","title":"nack  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>nack(**kwargs: Any) -&gt; None\n</code></pre> <p>A function to handle a nack.</p> PARAMETER  DESCRIPTION <code>**kwargs</code> <p>Additional arguments</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>If the function is not implemented.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/message.py</code> <pre><code>@abstractmethod\nasync def nack(self, **kwargs: Any) -&gt; None:\n\"\"\"A function to handle a nack.\n    Args:\n        **kwargs: Additional arguments\n    Returns:\n        None\n    Raises:\n        NotImplementedError: If the function is not implemented.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nraise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/broker/message/StreamMessage/#faststream.broker.message.StreamMessage.reject","title":"reject  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>reject(**kwargs: Any) -&gt; None\n</code></pre> <p>Rejects the operation.</p> PARAMETER  DESCRIPTION <code>**kwargs</code> <p>Additional keyword arguments</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>Always raises NotImplementedError</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/message.py</code> <pre><code>@abstractmethod\nasync def reject(self, **kwargs: Any) -&gt; None:\n\"\"\"Rejects the operation.\n    Args:\n        **kwargs: Additional keyword arguments\n    Returns:\n        None\n    Raises:\n        NotImplementedError: Always raises NotImplementedError\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nraise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/broker/message/SyncStreamMessage/","title":"SyncStreamMessage","text":""},{"location":"api/faststream/broker/message/SyncStreamMessage/#faststream.broker.message.SyncStreamMessage","title":"faststream.broker.message.SyncStreamMessage","text":"<p>             Bases: <code>ABCStreamMessage[Msg]</code></p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/message.py</code> <pre><code>class SyncStreamMessage(ABCStreamMessage[Msg]):\n@abstractmethod\ndef ack(self, **kwargs: Any) -&gt; None:\nraise NotImplementedError()\n@abstractmethod\ndef nack(self, **kwargs: Any) -&gt; None:\n\"\"\"A function to raise a NotImplementedError.\n        Args:\n            kwargs: Additional keyword arguments\n        Returns:\n            None\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nraise NotImplementedError()\n@abstractmethod\ndef reject(self, **kwargs: Any) -&gt; None:\n\"\"\"Reject function.\n        Args:\n            **kwargs: Arbitrary keyword arguments\n        Returns:\n            None\n        Raises:\n            NotImplementedError: Always raises NotImplementedError\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nraise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/broker/message/SyncStreamMessage/#faststream.broker.message.SyncStreamMessage.ack","title":"ack  <code>abstractmethod</code>","text":"<pre><code>ack(**kwargs: Any) -&gt; None\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/message.py</code> <pre><code>@abstractmethod\ndef ack(self, **kwargs: Any) -&gt; None:\nraise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/broker/message/SyncStreamMessage/#faststream.broker.message.SyncStreamMessage.nack","title":"nack  <code>abstractmethod</code>","text":"<pre><code>nack(**kwargs: Any) -&gt; None\n</code></pre> <p>A function to raise a NotImplementedError.</p> PARAMETER  DESCRIPTION <code>kwargs</code> <p>Additional keyword arguments</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/message.py</code> <pre><code>@abstractmethod\ndef nack(self, **kwargs: Any) -&gt; None:\n\"\"\"A function to raise a NotImplementedError.\n    Args:\n        kwargs: Additional keyword arguments\n    Returns:\n        None\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nraise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/broker/message/SyncStreamMessage/#faststream.broker.message.SyncStreamMessage.reject","title":"reject  <code>abstractmethod</code>","text":"<pre><code>reject(**kwargs: Any) -&gt; None\n</code></pre> <p>Reject function.</p> PARAMETER  DESCRIPTION <code>**kwargs</code> <p>Arbitrary keyword arguments</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>Always raises NotImplementedError</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/message.py</code> <pre><code>@abstractmethod\ndef reject(self, **kwargs: Any) -&gt; None:\n\"\"\"Reject function.\n    Args:\n        **kwargs: Arbitrary keyword arguments\n    Returns:\n        None\n    Raises:\n        NotImplementedError: Always raises NotImplementedError\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nraise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/broker/middlewares/BaseMiddleware/","title":"BaseMiddleware","text":""},{"location":"api/faststream/broker/middlewares/BaseMiddleware/#faststream.broker.middlewares.BaseMiddleware","title":"faststream.broker.middlewares.BaseMiddleware","text":"<p>A base middleware class.</p> METHOD DESCRIPTION <code>on_receive</code> <p>Called when a message is received.</p> <code>after_processed</code> <p>Optional[Type[BaseException]] = None, exc_val: Optional[BaseException] = None, exec_tb: Optional[TracebackType] = None) -&gt; Optional[bool]: Called after processing a message.</p> <code>__aenter__</code> <p>Called when entering a context.</p> <code>__aexit__</code> <p>Optional[Type[BaseException]] = None, exc_val: Optional[BaseException] = None, exec_tb: Optional[TracebackType] = None) -&gt; Optional[bool]: Called when exiting a context.</p> <code>on_consume</code> <p>DecodedMessage) -&gt; DecodedMessage: Called before consuming a message.</p> <code>after_consume</code> <p>Optional[Exception]) -&gt; None: Called after consuming a message.</p> <code>consume_scope</code> <p>DecodedMessage) -&gt; AsyncIterator[DecodedMessage]: Context manager for consuming a message.</p> <code>on_publish</code> <p>SendableMessage) -&gt; SendableMessage: Called before publishing a message.</p> <code>after_publish</code> <p>Optional[Exception]) -&gt; None: Asynchronous function to handle the after publish event.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/middlewares.py</code> <pre><code>class BaseMiddleware:\n\"\"\"A base middleware class.\n    Attributes:\n        msg: Any - a message\n    Methods:\n        on_receive() -&gt; None:\n            Called when a message is received.\n        after_processed(exc_type: Optional[Type[BaseException]] = None, exc_val: Optional[BaseException] = None, exec_tb: Optional[TracebackType] = None) -&gt; Optional[bool]:\n            Called after processing a message.\n        __aenter__() -&gt; Self:\n            Called when entering a context.\n        __aexit__(exc_type: Optional[Type[BaseException]] = None, exc_val: Optional[BaseException] = None, exec_tb: Optional[TracebackType] = None) -&gt; Optional[bool]:\n            Called when exiting a context.\n        on_consume(msg: DecodedMessage) -&gt; DecodedMessage:\n            Called before consuming a message.\n        after_consume(err: Optional[Exception]) -&gt; None:\n            Called after consuming a message.\n        consume_scope(msg: DecodedMessage) -&gt; AsyncIterator[DecodedMessage]:\n            Context manager for consuming a message.\n        on_publish(msg: SendableMessage) -&gt; SendableMessage:\n            Called before publishing a message.\n        after_publish(err: Optional[Exception]) -&gt; None:\n            Asynchronous function to handle the after publish event.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\ndef __init__(self, msg: Any) -&gt; None:\n\"\"\"Initialize the class.\n        Args:\n            msg: Any message to be stored.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nself.msg = msg\nasync def on_receive(self) -&gt; None:\npass\nasync def after_processed(\nself,\nexc_type: Optional[Type[BaseException]] = None,\nexc_val: Optional[BaseException] = None,\nexec_tb: Optional[TracebackType] = None,\n) -&gt; Optional[bool]:\n\"\"\"Asynchronously called after processing.\n        Args:\n            exc_type: Optional exception type\n            exc_val: Optional exception value\n            exec_tb: Optional traceback\n        Returns:\n            Optional boolean value indicating whether the processing was successful or not.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nreturn False\nasync def __aenter__(self) -&gt; Self:\nawait self.on_receive()\nreturn self\nasync def __aexit__(\nself,\nexc_type: Optional[Type[BaseException]] = None,\nexc_val: Optional[BaseException] = None,\nexec_tb: Optional[TracebackType] = None,\n) -&gt; Optional[bool]:\n\"\"\"Exit the asynchronous context manager.\n        Args:\n            exc_type: The type of the exception raised, if any.\n            exc_val: The exception instance raised, if any.\n            exec_tb: The traceback for the exception raised, if any.\n        Returns:\n            A boolean indicating whether the exception was handled or not.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nreturn await self.after_processed(exc_type, exc_val, exec_tb)\nasync def on_consume(self, msg: DecodedMessage) -&gt; DecodedMessage:\n\"\"\"Asynchronously consumes a message.\n        Args:\n            msg: The message to be consumed.\n        Returns:\n            The consumed message.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nreturn msg\nasync def after_consume(self, err: Optional[Exception]) -&gt; None:\n\"\"\"A function to handle the result of consuming a resource asynchronously.\n        Args:\n            err : Optional exception that occurred during consumption\n        Raises:\n            err : If an exception occurred during consumption\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nif err is not None:\nraise err\n@asynccontextmanager\nasync def consume_scope(self, msg: DecodedMessage) -&gt; AsyncIterator[DecodedMessage]:\n\"\"\"Asynchronously consumes a message and returns an asynchronous iterator of decoded messages.\n        Args:\n            msg: The decoded message to consume.\n        Yields:\n            An asynchronous iterator of decoded messages.\n        Returns:\n            An asynchronous iterator of decoded messages.\n        Raises:\n            Exception: If an error occurs while consuming the message.\n        AsyncIterator:\n            An asynchronous iterator that yields decoded messages.\n        Note:\n            This function is an async function.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nerr: Optional[Exception]\ntry:\nyield await self.on_consume(msg)\nexcept Exception as e:\nerr = e\nelse:\nerr = None\nawait self.after_consume(err)\nasync def on_publish(self, msg: SendableMessage) -&gt; SendableMessage:\n\"\"\"Asynchronously handle a publish event.\n        Args:\n            msg: The message to be published.\n        Returns:\n            The published message.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nreturn msg\nasync def after_publish(self, err: Optional[Exception]) -&gt; None:\n\"\"\"Asynchronous function to handle the after publish event.\n        Args:\n            err: Optional exception that occurred during the publish\n        Returns:\n            None\n        Raises:\n            Exception: If an error occurred during the publish\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nif err is not None:\nraise err\n@asynccontextmanager\nasync def publish_scope(\nself, msg: SendableMessage\n) -&gt; AsyncIterator[SendableMessage]:\n\"\"\"Publish a message and return an async iterator.\n        Args:\n            msg: The message to be published.\n        Yields:\n            A sendable message.\n        Returns:\n            An async iterator of sendable messages.\n        Raises:\n            Exception: If an error occurs during publishing.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nerr: Optional[Exception]\ntry:\nyield await self.on_publish(msg)\nexcept Exception as e:\nerr = e\nelse:\nerr = None\nawait self.after_publish(err)\n</code></pre>"},{"location":"api/faststream/broker/middlewares/BaseMiddleware/#faststream.broker.middlewares.BaseMiddleware.msg","title":"msg  <code>instance-attribute</code>","text":"<pre><code>msg = msg\n</code></pre>"},{"location":"api/faststream/broker/middlewares/BaseMiddleware/#faststream.broker.middlewares.BaseMiddleware.after_consume","title":"after_consume  <code>async</code>","text":"<pre><code>after_consume(err: Optional[Exception]) -&gt; None\n</code></pre> <p>A function to handle the result of consuming a resource asynchronously.</p> PARAMETER  DESCRIPTION <code>err</code> <p>Optional exception that occurred during consumption</p> <p> </p> RAISES DESCRIPTION <code>err</code> <p>If an exception occurred during consumption</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/middlewares.py</code> <pre><code>async def after_consume(self, err: Optional[Exception]) -&gt; None:\n\"\"\"A function to handle the result of consuming a resource asynchronously.\n    Args:\n        err : Optional exception that occurred during consumption\n    Raises:\n        err : If an exception occurred during consumption\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nif err is not None:\nraise err\n</code></pre>"},{"location":"api/faststream/broker/middlewares/BaseMiddleware/#faststream.broker.middlewares.BaseMiddleware.after_processed","title":"after_processed  <code>async</code>","text":"<pre><code>after_processed(\nexc_type: Optional[Type[BaseException]] = None,\nexc_val: Optional[BaseException] = None,\nexec_tb: Optional[TracebackType] = None,\n) -&gt; Optional[bool]\n</code></pre> <p>Asynchronously called after processing.</p> PARAMETER  DESCRIPTION <code>exc_type</code> <p>Optional exception type</p> <p> TYPE: <code>Optional[Type[BaseException]]</code> DEFAULT: <code>None</code> </p> <code>exc_val</code> <p>Optional exception value</p> <p> TYPE: <code>Optional[BaseException]</code> DEFAULT: <code>None</code> </p> <code>exec_tb</code> <p>Optional traceback</p> <p> TYPE: <code>Optional[TracebackType]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Optional[bool]</code> <p>Optional boolean value indicating whether the processing was successful or not.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/middlewares.py</code> <pre><code>async def after_processed(\nself,\nexc_type: Optional[Type[BaseException]] = None,\nexc_val: Optional[BaseException] = None,\nexec_tb: Optional[TracebackType] = None,\n) -&gt; Optional[bool]:\n\"\"\"Asynchronously called after processing.\n    Args:\n        exc_type: Optional exception type\n        exc_val: Optional exception value\n        exec_tb: Optional traceback\n    Returns:\n        Optional boolean value indicating whether the processing was successful or not.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nreturn False\n</code></pre>"},{"location":"api/faststream/broker/middlewares/BaseMiddleware/#faststream.broker.middlewares.BaseMiddleware.after_publish","title":"after_publish  <code>async</code>","text":"<pre><code>after_publish(err: Optional[Exception]) -&gt; None\n</code></pre> <p>Asynchronous function to handle the after publish event.</p> PARAMETER  DESCRIPTION <code>err</code> <p>Optional exception that occurred during the publish</p> <p> TYPE: <code>Optional[Exception]</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> RAISES DESCRIPTION <code>Exception</code> <p>If an error occurred during the publish</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/middlewares.py</code> <pre><code>async def after_publish(self, err: Optional[Exception]) -&gt; None:\n\"\"\"Asynchronous function to handle the after publish event.\n    Args:\n        err: Optional exception that occurred during the publish\n    Returns:\n        None\n    Raises:\n        Exception: If an error occurred during the publish\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nif err is not None:\nraise err\n</code></pre>"},{"location":"api/faststream/broker/middlewares/BaseMiddleware/#faststream.broker.middlewares.BaseMiddleware.consume_scope","title":"consume_scope  <code>async</code>","text":"<pre><code>consume_scope(\nmsg: DecodedMessage,\n) -&gt; AsyncIterator[DecodedMessage]\n</code></pre> <p>Asynchronously consumes a message and returns an asynchronous iterator of decoded messages.</p> PARAMETER  DESCRIPTION <code>msg</code> <p>The decoded message to consume.</p> <p> TYPE: <code>DecodedMessage</code> </p> YIELDS DESCRIPTION <code>AsyncIterator[DecodedMessage]</code> <p>An asynchronous iterator of decoded messages.</p> RETURNS DESCRIPTION <code>AsyncIterator[DecodedMessage]</code> <p>An asynchronous iterator of decoded messages.</p> RAISES DESCRIPTION <code>Exception</code> <p>If an error occurs while consuming the message.</p> AsyncIterator <p>An asynchronous iterator that yields decoded messages.</p> Note <p>This function is an async function.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/middlewares.py</code> <pre><code>@asynccontextmanager\nasync def consume_scope(self, msg: DecodedMessage) -&gt; AsyncIterator[DecodedMessage]:\n\"\"\"Asynchronously consumes a message and returns an asynchronous iterator of decoded messages.\n    Args:\n        msg: The decoded message to consume.\n    Yields:\n        An asynchronous iterator of decoded messages.\n    Returns:\n        An asynchronous iterator of decoded messages.\n    Raises:\n        Exception: If an error occurs while consuming the message.\n    AsyncIterator:\n        An asynchronous iterator that yields decoded messages.\n    Note:\n        This function is an async function.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nerr: Optional[Exception]\ntry:\nyield await self.on_consume(msg)\nexcept Exception as e:\nerr = e\nelse:\nerr = None\nawait self.after_consume(err)\n</code></pre>"},{"location":"api/faststream/broker/middlewares/BaseMiddleware/#faststream.broker.middlewares.BaseMiddleware.on_consume","title":"on_consume  <code>async</code>","text":"<pre><code>on_consume(msg: DecodedMessage) -&gt; DecodedMessage\n</code></pre> <p>Asynchronously consumes a message.</p> PARAMETER  DESCRIPTION <code>msg</code> <p>The message to be consumed.</p> <p> TYPE: <code>DecodedMessage</code> </p> RETURNS DESCRIPTION <code>DecodedMessage</code> <p>The consumed message.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/middlewares.py</code> <pre><code>async def on_consume(self, msg: DecodedMessage) -&gt; DecodedMessage:\n\"\"\"Asynchronously consumes a message.\n    Args:\n        msg: The message to be consumed.\n    Returns:\n        The consumed message.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nreturn msg\n</code></pre>"},{"location":"api/faststream/broker/middlewares/BaseMiddleware/#faststream.broker.middlewares.BaseMiddleware.on_publish","title":"on_publish  <code>async</code>","text":"<pre><code>on_publish(msg: SendableMessage) -&gt; SendableMessage\n</code></pre> <p>Asynchronously handle a publish event.</p> PARAMETER  DESCRIPTION <code>msg</code> <p>The message to be published.</p> <p> TYPE: <code>SendableMessage</code> </p> RETURNS DESCRIPTION <code>SendableMessage</code> <p>The published message.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/middlewares.py</code> <pre><code>async def on_publish(self, msg: SendableMessage) -&gt; SendableMessage:\n\"\"\"Asynchronously handle a publish event.\n    Args:\n        msg: The message to be published.\n    Returns:\n        The published message.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nreturn msg\n</code></pre>"},{"location":"api/faststream/broker/middlewares/BaseMiddleware/#faststream.broker.middlewares.BaseMiddleware.on_receive","title":"on_receive  <code>async</code>","text":"<pre><code>on_receive() -&gt; None\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/middlewares.py</code> <pre><code>async def on_receive(self) -&gt; None:\npass\n</code></pre>"},{"location":"api/faststream/broker/middlewares/BaseMiddleware/#faststream.broker.middlewares.BaseMiddleware.publish_scope","title":"publish_scope  <code>async</code>","text":"<pre><code>publish_scope(\nmsg: SendableMessage,\n) -&gt; AsyncIterator[SendableMessage]\n</code></pre> <p>Publish a message and return an async iterator.</p> PARAMETER  DESCRIPTION <code>msg</code> <p>The message to be published.</p> <p> TYPE: <code>SendableMessage</code> </p> YIELDS DESCRIPTION <code>AsyncIterator[SendableMessage]</code> <p>A sendable message.</p> RETURNS DESCRIPTION <code>AsyncIterator[SendableMessage]</code> <p>An async iterator of sendable messages.</p> RAISES DESCRIPTION <code>Exception</code> <p>If an error occurs during publishing.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/middlewares.py</code> <pre><code>@asynccontextmanager\nasync def publish_scope(\nself, msg: SendableMessage\n) -&gt; AsyncIterator[SendableMessage]:\n\"\"\"Publish a message and return an async iterator.\n    Args:\n        msg: The message to be published.\n    Yields:\n        A sendable message.\n    Returns:\n        An async iterator of sendable messages.\n    Raises:\n        Exception: If an error occurs during publishing.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nerr: Optional[Exception]\ntry:\nyield await self.on_publish(msg)\nexcept Exception as e:\nerr = e\nelse:\nerr = None\nawait self.after_publish(err)\n</code></pre>"},{"location":"api/faststream/broker/middlewares/CriticalLogMiddleware/","title":"CriticalLogMiddleware","text":""},{"location":"api/faststream/broker/middlewares/CriticalLogMiddleware/#faststream.broker.middlewares.CriticalLogMiddleware","title":"faststream.broker.middlewares.CriticalLogMiddleware","text":"<p>             Bases: <code>BaseMiddleware</code></p> <p>A middleware class for logging critical errors.</p> PARAMETER  DESCRIPTION <code>logger</code> <p>The logger object to use for logging</p> <p> TYPE: <code>Optional[Logger]</code> </p> METHOD DESCRIPTION <code>__call__</code> <p>Any) -&gt; Self: Returns the middleware instance</p> <code>after_processed</code> <p>Optional[Type[BaseException]] = None, exc_val: Optional[BaseException] = None, exec_tb: Optional[TracebackType] = None) -&gt; bool: Logs critical errors if they occur and returns True</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/middlewares.py</code> <pre><code>class CriticalLogMiddleware(BaseMiddleware):\n\"\"\"A middleware class for logging critical errors.\n    Args:\n        logger: The logger object to use for logging\n    Methods:\n        __call__(msg: Any) -&gt; Self: Returns the middleware instance\n        after_processed(exc_type: Optional[Type[BaseException]] = None, exc_val: Optional[BaseException] = None, exec_tb: Optional[TracebackType] = None) -&gt; bool: Logs critical errors if they occur and returns True\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\ndef __init__(self, logger: Optional[logging.Logger], log_level: int) -&gt; None:\n\"\"\"Initialize the class.\n        Args:\n            logger: an instance of the logging.Logger class\n        Returns:\n            None\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nself.logger = logger\nself.log_level = log_level\nself.is_log_enabled = bool(logger and logger.isEnabledFor(self.log_level))\ndef __call__(self, msg: Any) -&gt; Self:\n\"\"\"Call the object with a message.\n        Args:\n            msg: Any message to be passed to the object.\n        Returns:\n            The object itself.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nreturn self\nasync def on_consume(self, msg: DecodedMessage) -&gt; DecodedMessage:\nif self.is_log_enabled and self.logger is not None:\nc = context.get(\"log_context\")\nself.logger._log(self.log_level, msg=\"Received\", args=(), extra=c)\nreturn await super().on_consume(msg)\nasync def after_processed(\nself,\nexc_type: Optional[Type[BaseException]] = None,\nexc_val: Optional[BaseException] = None,\nexec_tb: Optional[TracebackType] = None,\n) -&gt; bool:\n\"\"\"Asynchronously called after processing.\n        Args:\n            exc_type (Optional[Type[BaseException]]): Type of the exception raised during processing.\n            exc_val (Optional[BaseException]): Value of the exception raised during processing.\n            exec_tb (Optional[TracebackType]): Traceback of the exception raised during processing.\n        Returns:\n            bool: True if the method is successfully executed.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nif self.logger is not None:\nc = context.get(\"log_context\")\nif exc_type and exc_val:\nself.logger.error(\nf\"{exc_type.__name__}: {exc_val}\",\nexc_info=exc_val,\nextra=c,\n)\nif self.is_log_enabled:\nself.logger._log(self.log_level, msg=\"Processed\", args=(), extra=c)\nreturn True\n</code></pre>"},{"location":"api/faststream/broker/middlewares/CriticalLogMiddleware/#faststream.broker.middlewares.CriticalLogMiddleware.is_log_enabled","title":"is_log_enabled  <code>instance-attribute</code>","text":"<pre><code>is_log_enabled = bool(\nlogger and logger.isEnabledFor(self.log_level)\n)\n</code></pre>"},{"location":"api/faststream/broker/middlewares/CriticalLogMiddleware/#faststream.broker.middlewares.CriticalLogMiddleware.log_level","title":"log_level  <code>instance-attribute</code>","text":"<pre><code>log_level = log_level\n</code></pre>"},{"location":"api/faststream/broker/middlewares/CriticalLogMiddleware/#faststream.broker.middlewares.CriticalLogMiddleware.logger","title":"logger  <code>instance-attribute</code>","text":"<pre><code>logger = logger\n</code></pre>"},{"location":"api/faststream/broker/middlewares/CriticalLogMiddleware/#faststream.broker.middlewares.CriticalLogMiddleware.after_processed","title":"after_processed  <code>async</code>","text":"<pre><code>after_processed(\nexc_type: Optional[Type[BaseException]] = None,\nexc_val: Optional[BaseException] = None,\nexec_tb: Optional[TracebackType] = None,\n) -&gt; bool\n</code></pre> <p>Asynchronously called after processing.</p> PARAMETER  DESCRIPTION <code>exc_type</code> <p>Type of the exception raised during processing.</p> <p> TYPE: <code>Optional[Type[BaseException]]</code> DEFAULT: <code>None</code> </p> <code>exc_val</code> <p>Value of the exception raised during processing.</p> <p> TYPE: <code>Optional[BaseException]</code> DEFAULT: <code>None</code> </p> <code>exec_tb</code> <p>Traceback of the exception raised during processing.</p> <p> TYPE: <code>Optional[TracebackType]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the method is successfully executed.</p> <p> TYPE: <code>bool</code> </p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/middlewares.py</code> <pre><code>async def after_processed(\nself,\nexc_type: Optional[Type[BaseException]] = None,\nexc_val: Optional[BaseException] = None,\nexec_tb: Optional[TracebackType] = None,\n) -&gt; bool:\n\"\"\"Asynchronously called after processing.\n    Args:\n        exc_type (Optional[Type[BaseException]]): Type of the exception raised during processing.\n        exc_val (Optional[BaseException]): Value of the exception raised during processing.\n        exec_tb (Optional[TracebackType]): Traceback of the exception raised during processing.\n    Returns:\n        bool: True if the method is successfully executed.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nif self.logger is not None:\nc = context.get(\"log_context\")\nif exc_type and exc_val:\nself.logger.error(\nf\"{exc_type.__name__}: {exc_val}\",\nexc_info=exc_val,\nextra=c,\n)\nif self.is_log_enabled:\nself.logger._log(self.log_level, msg=\"Processed\", args=(), extra=c)\nreturn True\n</code></pre>"},{"location":"api/faststream/broker/middlewares/CriticalLogMiddleware/#faststream.broker.middlewares.CriticalLogMiddleware.on_consume","title":"on_consume  <code>async</code>","text":"<pre><code>on_consume(msg: DecodedMessage) -&gt; DecodedMessage\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/middlewares.py</code> <pre><code>async def on_consume(self, msg: DecodedMessage) -&gt; DecodedMessage:\nif self.is_log_enabled and self.logger is not None:\nc = context.get(\"log_context\")\nself.logger._log(self.log_level, msg=\"Received\", args=(), extra=c)\nreturn await super().on_consume(msg)\n</code></pre>"},{"location":"api/faststream/broker/parsers/decode_message/","title":"Decode message","text":""},{"location":"api/faststream/broker/parsers/decode_message/#faststream.broker.parsers.decode_message","title":"faststream.broker.parsers.decode_message","text":"<pre><code>decode_message(\nmessage: StreamMessage[Any],\n) -&gt; DecodedMessage\n</code></pre> <p>Decodes a message.</p> PARAMETER  DESCRIPTION <code>message</code> <p>The message to decode.</p> <p> TYPE: <code>StreamMessage[Any]</code> </p> RETURNS DESCRIPTION <code>DecodedMessage</code> <p>The decoded message.</p> RAISES DESCRIPTION <code>JSONDecodeError</code> <p>If the message body cannot be decoded as JSON.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/parsers.py</code> <pre><code>def decode_message(message: StreamMessage[Any]) -&gt; DecodedMessage:\n\"\"\"Decodes a message.\n    Args:\n        message: The message to decode.\n    Returns:\n        The decoded message.\n    Raises:\n        JSONDecodeError: If the message body cannot be decoded as JSON.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nbody = message.body\nm: DecodedMessage = body\nif message.content_type:\nif ContentTypes.text.value in message.content_type:\nm = body.decode()\nelif ContentTypes.json.value in message.content_type:  # pragma: no branch\nm = json.loads(body)\nelse:\nwith suppress(json.JSONDecodeError):\nm = json.loads(body)\nreturn m\n</code></pre>"},{"location":"api/faststream/broker/parsers/encode_message/","title":"Encode message","text":""},{"location":"api/faststream/broker/parsers/encode_message/#faststream.broker.parsers.encode_message","title":"faststream.broker.parsers.encode_message","text":"<pre><code>encode_message(\nmsg: SendableMessage,\n) -&gt; Tuple[bytes, Optional[ContentType]]\n</code></pre> <p>Encodes a message.</p> PARAMETER  DESCRIPTION <code>msg</code> <p>The message to be encoded.</p> <p> TYPE: <code>SendableMessage</code> </p> RETURNS DESCRIPTION <code>Tuple[bytes, Optional[ContentType]]</code> <p>A tuple containing the encoded message as bytes and the content type of the message.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/parsers.py</code> <pre><code>def encode_message(msg: SendableMessage) -&gt; Tuple[bytes, Optional[ContentType]]:\n\"\"\"Encodes a message.\n    Args:\n        msg: The message to be encoded.\n    Returns:\n        A tuple containing the encoded message as bytes and the content type of the message.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nif msg is None:\nreturn b\"\", None\nif isinstance(msg, bytes):\nreturn msg, None\nif isinstance(msg, str):\nreturn msg.encode(), ContentTypes.text.value\nreturn (\ndump_json(msg).encode(),\nContentTypes.json.value,\n)\n</code></pre>"},{"location":"api/faststream/broker/parsers/resolve_custom_func/","title":"Resolve custom func","text":""},{"location":"api/faststream/broker/parsers/resolve_custom_func/#faststream.broker.parsers.resolve_custom_func","title":"faststream.broker.parsers.resolve_custom_func","text":"<pre><code>resolve_custom_func(\ncustom_func: Optional[\nUnion[CustomDecoder[MsgType], CustomParser[MsgType]]\n],\ndefault_func: Union[Decoder[MsgType], Parser[MsgType]],\n) -&gt; Union[Decoder[MsgType], Parser[MsgType]]\n</code></pre> <p>Resolve a custom function.</p> PARAMETER  DESCRIPTION <code>custom_func</code> <p>Optional custom function of type CustomDecoder or CustomParser.</p> <p> TYPE: <code>Optional[Union[CustomDecoder[MsgType], CustomParser[MsgType]]]</code> </p> <code>default_func</code> <p>Default function of type Decoder or Parser.</p> <p> TYPE: <code>Union[Decoder[MsgType], Parser[MsgType]]</code> </p> RETURNS DESCRIPTION <code>Union[Decoder[MsgType], Parser[MsgType]]</code> <p>The resolved function of type Decoder or Parser.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/parsers.py</code> <pre><code>def resolve_custom_func(\ncustom_func: Optional[Union[CustomDecoder[MsgType], CustomParser[MsgType]]],\ndefault_func: Union[Decoder[MsgType], Parser[MsgType]],\n) -&gt; Union[Decoder[MsgType], Parser[MsgType]]:\n\"\"\"Resolve a custom function.\n    Args:\n        custom_func: Optional custom function of type CustomDecoder or CustomParser.\n        default_func: Default function of type Decoder or Parser.\n    Returns:\n        The resolved function of type Decoder or Parser.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nif custom_func is None:\nreturn default_func\noriginal_params = inspect.signature(custom_func).parameters\nif len(original_params) == 1:\nreturn cast(Union[Decoder[MsgType], Parser[MsgType]], custom_func)\nelse:\nname = tuple(original_params.items())[1][0]\nreturn partial(custom_func, **{name: default_func})  # type: ignore\n</code></pre>"},{"location":"api/faststream/broker/publisher/BasePublisher/","title":"BasePublisher","text":""},{"location":"api/faststream/broker/publisher/BasePublisher/#faststream.broker.publisher.BasePublisher","title":"faststream.broker.publisher.BasePublisher  <code>dataclass</code>","text":"<p>             Bases: <code>AsyncAPIOperation</code>, <code>Generic[MsgType]</code></p> <p>A base class for publishers in an asynchronous API.</p> METHOD DESCRIPTION <code>description</code> <p>returns the description of the publisher</p> <code>__call__</code> <p>decorator to register a function as a handler for the publisher</p> <code>publish</code> <p>publishes a message with optional correlation ID</p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>if the publish method is not implemented.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/publisher.py</code> <pre><code>@dataclass\nclass BasePublisher(AsyncAPIOperation, Generic[MsgType]):\n\"\"\"A base class for publishers in an asynchronous API.\n    Attributes:\n        title : optional title of the publisher\n        _description : optional description of the publisher\n        _fake_handler : boolean indicating if a fake handler is used\n        calls : list of callable objects\n        mock : MagicMock object for mocking purposes\n    Methods:\n        description() : returns the description of the publisher\n        __call__(func) : decorator to register a function as a handler for the publisher\n        publish(message, correlation_id, **kwargs) : publishes a message with optional correlation ID\n    Raises:\n        NotImplementedError: if the publish method is not implemented.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\ntitle: Optional[str] = field(default=None)\n_description: Optional[str] = field(default=None)\n_fake_handler: bool = field(default=False)\ncalls: List[Callable[..., Any]] = field(\ninit=False, default_factory=list, repr=False\n)\nmock: MagicMock = field(init=False, default_factory=MagicMock, repr=False)\n@property\ndef description(self) -&gt; Optional[str]:\nreturn self._description\ndef __call__(\nself,\nfunc: Callable[P_HandlerParams, T_HandlerReturn],\n) -&gt; HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn]:\n\"\"\"This is a Python function.\n        Args:\n            func: A callable object that takes `P_HandlerParams` as input and returns `T_HandlerReturn`.\n        Returns:\n            An instance of `HandlerCallWrapper` class.\n        Raises:\n            TypeError: If `func` is not callable.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nhandler_call: HandlerCallWrapper[\nMsgType, P_HandlerParams, T_HandlerReturn\n] = HandlerCallWrapper(func)\nhandler_call._publishers.append(self)\nself.calls.append(handler_call._original_call)\nreturn handler_call\n@abstractmethod\nasync def publish(\nself,\nmessage: SendableMessage,\ncorrelation_id: Optional[str] = None,\n**kwargs: Any,\n) -&gt; Optional[SendableMessage]:\n\"\"\"Publish a message.\n        Args:\n            message: The message to be published.\n            correlation_id: Optional correlation ID for the message.\n            **kwargs: Additional keyword arguments.\n        Returns:\n            The published message.\n        Raises:\n            NotImplementedError: If the method is not implemented.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nraise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/broker/publisher/BasePublisher/#faststream.broker.publisher.BasePublisher.calls","title":"calls  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>calls: List[Callable[..., Any]] = field(\ninit=False, default_factory=list, repr=False\n)\n</code></pre>"},{"location":"api/faststream/broker/publisher/BasePublisher/#faststream.broker.publisher.BasePublisher.description","title":"description  <code>property</code>","text":"<pre><code>description: Optional[str]\n</code></pre>"},{"location":"api/faststream/broker/publisher/BasePublisher/#faststream.broker.publisher.BasePublisher.mock","title":"mock  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mock: MagicMock = field(\ninit=False, default_factory=MagicMock, repr=False\n)\n</code></pre>"},{"location":"api/faststream/broker/publisher/BasePublisher/#faststream.broker.publisher.BasePublisher.title","title":"title  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>title: Optional[str] = field(default=None)\n</code></pre>"},{"location":"api/faststream/broker/publisher/BasePublisher/#faststream.broker.publisher.BasePublisher.publish","title":"publish  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>publish(\nmessage: SendableMessage,\ncorrelation_id: Optional[str] = None,\n**kwargs: Any\n) -&gt; Optional[SendableMessage]\n</code></pre> <p>Publish a message.</p> PARAMETER  DESCRIPTION <code>message</code> <p>The message to be published.</p> <p> TYPE: <code>SendableMessage</code> </p> <code>correlation_id</code> <p>Optional correlation ID for the message.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>**kwargs</code> <p>Additional keyword arguments.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Optional[SendableMessage]</code> <p>The published message.</p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>If the method is not implemented.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/publisher.py</code> <pre><code>@abstractmethod\nasync def publish(\nself,\nmessage: SendableMessage,\ncorrelation_id: Optional[str] = None,\n**kwargs: Any,\n) -&gt; Optional[SendableMessage]:\n\"\"\"Publish a message.\n    Args:\n        message: The message to be published.\n        correlation_id: Optional correlation ID for the message.\n        **kwargs: Additional keyword arguments.\n    Returns:\n        The published message.\n    Raises:\n        NotImplementedError: If the method is not implemented.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nraise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/broker/push_back_watcher/BaseWatcher/","title":"BaseWatcher","text":""},{"location":"api/faststream/broker/push_back_watcher/BaseWatcher/#faststream.broker.push_back_watcher.BaseWatcher","title":"faststream.broker.push_back_watcher.BaseWatcher","text":"<p>             Bases: <code>ABC</code></p> <p>A base class for a watcher.</p> PARAMETER  DESCRIPTION <code>max_tries</code> <p>maximum number of tries allowed (default=0)</p> <p> DEFAULT: <code>0</code> </p> <code>logger</code> <p>logger object (optional)</p> <p> DEFAULT: <code>None</code> </p> METHOD DESCRIPTION <code>add </code> <p>add a message to the watcher</p> <code>is_max </code> <p>check if the maximum number of tries has been reached for a message</p> <code>remove </code> <p>remove a message from the watcher</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/push_back_watcher.py</code> <pre><code>class BaseWatcher(ABC):\n\"\"\"A base class for a watcher.\n    Attributes:\n        max_tries : maximum number of tries allowed\n    Args:\n        max_tries : maximum number of tries allowed (default=0)\n        logger : logger object (optional)\n    Methods:\n        add : add a message to the watcher\n        is_max : check if the maximum number of tries has been reached for a message\n        remove : remove a message from the watcher\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nmax_tries: int\ndef __init__(\nself,\nmax_tries: int = 0,\nlogger: Optional[Logger] = None,\n):\n\"\"\"Initialize the class.\n        Args:\n            max_tries: Maximum number of tries allowed\n            logger: Optional logger object\n        Raises:\n            NotImplementedError: If the method is not implemented in the subclass.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nself.logger = logger\nself.max_tries = max_tries\n@abstractmethod\ndef add(self, message_id: str) -&gt; None:\n\"\"\"Add a message.\n        Args:\n            message_id: ID of the message to be added\n        Returns:\n            None\n        Raises:\n            NotImplementedError: If the method is not implemented\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nraise NotImplementedError()\n@abstractmethod\ndef is_max(self, message_id: str) -&gt; bool:\n\"\"\"Check if the given message ID is the maximum.\n        Args:\n            message_id: The ID of the message to check.\n        Returns:\n            True if the given message ID is the maximum, False otherwise.\n        Raises:\n            NotImplementedError: This method is meant to be overridden by subclasses.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nraise NotImplementedError()\n@abstractmethod\ndef remove(self, message_id: str) -&gt; None:\n\"\"\"Remove a message.\n        Args:\n            message_id: ID of the message to be removed\n        Returns:\n            None\n        Raises:\n            NotImplementedError: If the method is not implemented\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nraise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/broker/push_back_watcher/BaseWatcher/#faststream.broker.push_back_watcher.BaseWatcher.logger","title":"logger  <code>instance-attribute</code>","text":"<pre><code>logger = logger\n</code></pre>"},{"location":"api/faststream/broker/push_back_watcher/BaseWatcher/#faststream.broker.push_back_watcher.BaseWatcher.max_tries","title":"max_tries  <code>instance-attribute</code>","text":"<pre><code>max_tries: int = max_tries\n</code></pre>"},{"location":"api/faststream/broker/push_back_watcher/BaseWatcher/#faststream.broker.push_back_watcher.BaseWatcher.add","title":"add  <code>abstractmethod</code>","text":"<pre><code>add(message_id: str) -&gt; None\n</code></pre> <p>Add a message.</p> PARAMETER  DESCRIPTION <code>message_id</code> <p>ID of the message to be added</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>If the method is not implemented</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/push_back_watcher.py</code> <pre><code>@abstractmethod\ndef add(self, message_id: str) -&gt; None:\n\"\"\"Add a message.\n    Args:\n        message_id: ID of the message to be added\n    Returns:\n        None\n    Raises:\n        NotImplementedError: If the method is not implemented\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nraise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/broker/push_back_watcher/BaseWatcher/#faststream.broker.push_back_watcher.BaseWatcher.is_max","title":"is_max  <code>abstractmethod</code>","text":"<pre><code>is_max(message_id: str) -&gt; bool\n</code></pre> <p>Check if the given message ID is the maximum.</p> PARAMETER  DESCRIPTION <code>message_id</code> <p>The ID of the message to check.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the given message ID is the maximum, False otherwise.</p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>This method is meant to be overridden by subclasses.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/push_back_watcher.py</code> <pre><code>@abstractmethod\ndef is_max(self, message_id: str) -&gt; bool:\n\"\"\"Check if the given message ID is the maximum.\n    Args:\n        message_id: The ID of the message to check.\n    Returns:\n        True if the given message ID is the maximum, False otherwise.\n    Raises:\n        NotImplementedError: This method is meant to be overridden by subclasses.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nraise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/broker/push_back_watcher/BaseWatcher/#faststream.broker.push_back_watcher.BaseWatcher.remove","title":"remove  <code>abstractmethod</code>","text":"<pre><code>remove(message_id: str) -&gt; None\n</code></pre> <p>Remove a message.</p> PARAMETER  DESCRIPTION <code>message_id</code> <p>ID of the message to be removed</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>If the method is not implemented</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/push_back_watcher.py</code> <pre><code>@abstractmethod\ndef remove(self, message_id: str) -&gt; None:\n\"\"\"Remove a message.\n    Args:\n        message_id: ID of the message to be removed\n    Returns:\n        None\n    Raises:\n        NotImplementedError: If the method is not implemented\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nraise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/broker/push_back_watcher/CounterWatcher/","title":"CounterWatcher","text":""},{"location":"api/faststream/broker/push_back_watcher/CounterWatcher/#faststream.broker.push_back_watcher.CounterWatcher","title":"faststream.broker.push_back_watcher.CounterWatcher","text":"<p>             Bases: <code>BaseWatcher</code></p> <p>A class to watch and track the count of messages.</p> PARAMETER  DESCRIPTION <code>max_tries</code> <p>int - maximum number of tries allowed</p> <p> DEFAULT: <code>3</code> </p> <code>logger</code> <p>Optional[Logger] - logger object for logging messages</p> <p> DEFAULT: <code>None</code> </p> METHOD DESCRIPTION <code>__init__</code> <p>int = 3, logger: Optional[Logger] = None) - initializes the CounterWatcher object</p> <code>add</code> <p>str) -&gt; None - adds a message to the counter</p> <code>is_max</code> <p>str) -&gt; bool - checks if the count of a message has reached the maximum tries</p> <code>remove</code> <p>str) -&gt; None - removes a message from the counter</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/push_back_watcher.py</code> <pre><code>class CounterWatcher(BaseWatcher):\n\"\"\"A class to watch and track the count of messages.\n    Attributes:\n        memory : CounterType[str] - a counter to store the count of each message\n    Args:\n        max_tries : int - maximum number of tries allowed\n        logger : Optional[Logger] - logger object for logging messages\n    Methods:\n        __init__(self, max_tries: int = 3, logger: Optional[Logger] = None) - initializes the CounterWatcher object\n        add(self, message_id: str) -&gt; None - adds a message to the counter\n        is_max(self, message_id: str) -&gt; bool - checks if the count of a message has reached the maximum tries\n        remove(self, message: str) -&gt; None - removes a message from the counter\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nmemory: CounterType[str]\ndef __init__(\nself,\nmax_tries: int = 3,\nlogger: Optional[Logger] = None,\n):\n\"\"\"Initialize the class.\n        Args:\n            max_tries (int): maximum number of tries\n            logger (Optional[Logger]): logger object (default: None)\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nsuper().__init__(logger=logger, max_tries=max_tries)\nself.memory = Counter()\ndef add(self, message_id: str) -&gt; None:\n\"\"\"Increments the count of a message in the memory.\n        Args:\n            message_id: The ID of the message to be incremented.\n        Returns:\n            None\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nself.memory[message_id] += 1\ndef is_max(self, message_id: str) -&gt; bool:\n\"\"\"Check if the number of tries for a message has exceeded the maximum allowed tries.\n        Args:\n            message_id: The ID of the message\n        Returns:\n            True if the number of tries has exceeded the maximum allowed tries, False otherwise\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nis_max = self.memory[message_id] &gt; self.max_tries\nif self.logger is not None:\nif is_max:\nself.logger.error(f\"Already retried {self.max_tries} times. Skipped.\")\nelse:\nself.logger.error(\"Error is occured. Pushing back to queue.\")\nreturn is_max\ndef remove(self, message: str) -&gt; None:\n\"\"\"Remove a message from memory.\n        Args:\n            message: The message to be removed.\n        Returns:\n            None\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nself.memory[message] = 0\nself.memory += Counter()\n</code></pre>"},{"location":"api/faststream/broker/push_back_watcher/CounterWatcher/#faststream.broker.push_back_watcher.CounterWatcher.memory","title":"memory  <code>instance-attribute</code>","text":"<pre><code>memory: CounterType[str] = Counter()\n</code></pre>"},{"location":"api/faststream/broker/push_back_watcher/CounterWatcher/#faststream.broker.push_back_watcher.CounterWatcher.add","title":"add","text":"<pre><code>add(message_id: str) -&gt; None\n</code></pre> <p>Increments the count of a message in the memory.</p> PARAMETER  DESCRIPTION <code>message_id</code> <p>The ID of the message to be incremented.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/push_back_watcher.py</code> <pre><code>def add(self, message_id: str) -&gt; None:\n\"\"\"Increments the count of a message in the memory.\n    Args:\n        message_id: The ID of the message to be incremented.\n    Returns:\n        None\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nself.memory[message_id] += 1\n</code></pre>"},{"location":"api/faststream/broker/push_back_watcher/CounterWatcher/#faststream.broker.push_back_watcher.CounterWatcher.is_max","title":"is_max","text":"<pre><code>is_max(message_id: str) -&gt; bool\n</code></pre> <p>Check if the number of tries for a message has exceeded the maximum allowed tries.</p> PARAMETER  DESCRIPTION <code>message_id</code> <p>The ID of the message</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the number of tries has exceeded the maximum allowed tries, False otherwise</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/push_back_watcher.py</code> <pre><code>def is_max(self, message_id: str) -&gt; bool:\n\"\"\"Check if the number of tries for a message has exceeded the maximum allowed tries.\n    Args:\n        message_id: The ID of the message\n    Returns:\n        True if the number of tries has exceeded the maximum allowed tries, False otherwise\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nis_max = self.memory[message_id] &gt; self.max_tries\nif self.logger is not None:\nif is_max:\nself.logger.error(f\"Already retried {self.max_tries} times. Skipped.\")\nelse:\nself.logger.error(\"Error is occured. Pushing back to queue.\")\nreturn is_max\n</code></pre>"},{"location":"api/faststream/broker/push_back_watcher/CounterWatcher/#faststream.broker.push_back_watcher.CounterWatcher.remove","title":"remove","text":"<pre><code>remove(message: str) -&gt; None\n</code></pre> <p>Remove a message from memory.</p> PARAMETER  DESCRIPTION <code>message</code> <p>The message to be removed.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/push_back_watcher.py</code> <pre><code>def remove(self, message: str) -&gt; None:\n\"\"\"Remove a message from memory.\n    Args:\n        message: The message to be removed.\n    Returns:\n        None\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nself.memory[message] = 0\nself.memory += Counter()\n</code></pre>"},{"location":"api/faststream/broker/push_back_watcher/EndlessWatcher/","title":"EndlessWatcher","text":""},{"location":"api/faststream/broker/push_back_watcher/EndlessWatcher/#faststream.broker.push_back_watcher.EndlessWatcher","title":"faststream.broker.push_back_watcher.EndlessWatcher","text":"<p>             Bases: <code>BaseWatcher</code></p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/push_back_watcher.py</code> <pre><code>class EndlessWatcher(BaseWatcher):\ndef add(self, message_id: str) -&gt; None:\n\"\"\"Add a message to the list.\n        Args:\n            message_id: ID of the message to be added\n        Returns:\n            None\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\npass\ndef is_max(self, message_id: str) -&gt; bool:\n\"\"\"Check if a message is the maximum.\n        Args:\n            message_id: ID of the message to check\n        Returns:\n            True if the message is the maximum, False otherwise\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nreturn False\ndef remove(self, message_id: str) -&gt; None:\n\"\"\"Remove a message.\n        Args:\n            message_id: The ID of the message to be removed.\n        Returns:\n            None\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\npass\n</code></pre>"},{"location":"api/faststream/broker/push_back_watcher/EndlessWatcher/#faststream.broker.push_back_watcher.EndlessWatcher.add","title":"add","text":"<pre><code>add(message_id: str) -&gt; None\n</code></pre> <p>Add a message to the list.</p> PARAMETER  DESCRIPTION <code>message_id</code> <p>ID of the message to be added</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/push_back_watcher.py</code> <pre><code>def add(self, message_id: str) -&gt; None:\n\"\"\"Add a message to the list.\n    Args:\n        message_id: ID of the message to be added\n    Returns:\n        None\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\npass\n</code></pre>"},{"location":"api/faststream/broker/push_back_watcher/EndlessWatcher/#faststream.broker.push_back_watcher.EndlessWatcher.is_max","title":"is_max","text":"<pre><code>is_max(message_id: str) -&gt; bool\n</code></pre> <p>Check if a message is the maximum.</p> PARAMETER  DESCRIPTION <code>message_id</code> <p>ID of the message to check</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the message is the maximum, False otherwise</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/push_back_watcher.py</code> <pre><code>def is_max(self, message_id: str) -&gt; bool:\n\"\"\"Check if a message is the maximum.\n    Args:\n        message_id: ID of the message to check\n    Returns:\n        True if the message is the maximum, False otherwise\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nreturn False\n</code></pre>"},{"location":"api/faststream/broker/push_back_watcher/EndlessWatcher/#faststream.broker.push_back_watcher.EndlessWatcher.remove","title":"remove","text":"<pre><code>remove(message_id: str) -&gt; None\n</code></pre> <p>Remove a message.</p> PARAMETER  DESCRIPTION <code>message_id</code> <p>The ID of the message to be removed.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/push_back_watcher.py</code> <pre><code>def remove(self, message_id: str) -&gt; None:\n\"\"\"Remove a message.\n    Args:\n        message_id: The ID of the message to be removed.\n    Returns:\n        None\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\npass\n</code></pre>"},{"location":"api/faststream/broker/push_back_watcher/OneTryWatcher/","title":"OneTryWatcher","text":""},{"location":"api/faststream/broker/push_back_watcher/OneTryWatcher/#faststream.broker.push_back_watcher.OneTryWatcher","title":"faststream.broker.push_back_watcher.OneTryWatcher","text":"<p>             Bases: <code>BaseWatcher</code></p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/push_back_watcher.py</code> <pre><code>class OneTryWatcher(BaseWatcher):\ndef add(self, message_id: str) -&gt; None:\n\"\"\"Add a message.\n        Args:\n            message_id: ID of the message to be added\n        Returns:\n            None\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\npass\ndef is_max(self, message_id: str) -&gt; bool:\n\"\"\"Check if the given message ID is the maximum.\n        Args:\n            message_id: The ID of the message to check.\n        Returns:\n            True if the given message ID is the maximum, False otherwise.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nreturn True\ndef remove(self, message_id: str) -&gt; None:\n\"\"\"Remove a message.\n        Args:\n            message_id: ID of the message to be removed\n        Returns:\n            None\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\npass\n</code></pre>"},{"location":"api/faststream/broker/push_back_watcher/OneTryWatcher/#faststream.broker.push_back_watcher.OneTryWatcher.add","title":"add","text":"<pre><code>add(message_id: str) -&gt; None\n</code></pre> <p>Add a message.</p> PARAMETER  DESCRIPTION <code>message_id</code> <p>ID of the message to be added</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/push_back_watcher.py</code> <pre><code>def add(self, message_id: str) -&gt; None:\n\"\"\"Add a message.\n    Args:\n        message_id: ID of the message to be added\n    Returns:\n        None\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\npass\n</code></pre>"},{"location":"api/faststream/broker/push_back_watcher/OneTryWatcher/#faststream.broker.push_back_watcher.OneTryWatcher.is_max","title":"is_max","text":"<pre><code>is_max(message_id: str) -&gt; bool\n</code></pre> <p>Check if the given message ID is the maximum.</p> PARAMETER  DESCRIPTION <code>message_id</code> <p>The ID of the message to check.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the given message ID is the maximum, False otherwise.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/push_back_watcher.py</code> <pre><code>def is_max(self, message_id: str) -&gt; bool:\n\"\"\"Check if the given message ID is the maximum.\n    Args:\n        message_id: The ID of the message to check.\n    Returns:\n        True if the given message ID is the maximum, False otherwise.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nreturn True\n</code></pre>"},{"location":"api/faststream/broker/push_back_watcher/OneTryWatcher/#faststream.broker.push_back_watcher.OneTryWatcher.remove","title":"remove","text":"<pre><code>remove(message_id: str) -&gt; None\n</code></pre> <p>Remove a message.</p> PARAMETER  DESCRIPTION <code>message_id</code> <p>ID of the message to be removed</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/push_back_watcher.py</code> <pre><code>def remove(self, message_id: str) -&gt; None:\n\"\"\"Remove a message.\n    Args:\n        message_id: ID of the message to be removed\n    Returns:\n        None\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\npass\n</code></pre>"},{"location":"api/faststream/broker/push_back_watcher/WatcherContext/","title":"WatcherContext","text":""},{"location":"api/faststream/broker/push_back_watcher/WatcherContext/#faststream.broker.push_back_watcher.WatcherContext","title":"faststream.broker.push_back_watcher.WatcherContext","text":"<p>A class representing a context for a watcher.</p> METHOD DESCRIPTION <code>__aenter__ </code> <p>called when entering the context</p> <code>__aexit__ </code> <p>called when exiting the context</p> <code>__ack </code> <p>acknowledges the message</p> <code>__nack </code> <p>negatively acknowledges the message</p> <code>__reject </code> <p>rejects the message</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/push_back_watcher.py</code> <pre><code>class WatcherContext:\n\"\"\"A class representing a context for a watcher.\n    Attributes:\n        watcher : the watcher object\n        message : the message being watched\n        extra_ack_args : additional arguments for acknowledging the message\n    Methods:\n        __aenter__ : called when entering the context\n        __aexit__ : called when exiting the context\n        __ack : acknowledges the message\n        __nack : negatively acknowledges the message\n        __reject : rejects the message\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\ndef __init__(\nself,\nwatcher: BaseWatcher,\nmessage: Union[SyncStreamMessage[MsgType], StreamMessage[MsgType]],\n**extra_ack_args: Any,\n):\n\"\"\"Initialize a new instance of the class.\n        Args:\n            watcher: An instance of BaseWatcher.\n            message: An instance of SyncStreamMessage or StreamMessage.\n            **extra_ack_args: Additional arguments for acknowledgement.\n        Attributes:\n            watcher: An instance of BaseWatcher.\n            message: An instance of SyncStreamMessage or StreamMessage.\n            extra_ack_args: Additional arguments for acknowledgement.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nself.watcher = watcher\nself.message = message\nself.extra_ack_args = extra_ack_args or {}\nasync def __aenter__(self) -&gt; None:\nself.watcher.add(self.message.message_id)\nasync def __aexit__(\nself,\nexc_type: Optional[Type[BaseException]],\nexc_val: Optional[BaseException],\nexc_tb: Optional[TracebackType],\n) -&gt; bool:\n\"\"\"Exit the asynchronous context manager.\n        Args:\n            exc_type: The type of the exception raised, if any.\n            exc_val: The exception instance raised, if any.\n            exc_tb: The traceback for the exception raised, if any.\n        Returns:\n            A boolean indicating whether the exit was successful or not.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nif not exc_type:\nawait self.__ack()\nelif isinstance(exc_val, SkipMessage):\nself.watcher.remove(self.message.message_id)\nelif isinstance(exc_val, HandlerException):\nif isinstance(exc_val, AckMessage):\nawait self.__ack()\nelif isinstance(exc_val, NackMessage):\nawait self.__nack()\nelif isinstance(exc_val, RejectMessage):\nawait self.__reject()\nreturn True\nelif self.watcher.is_max(self.message.message_id):\nawait self.__reject()\nelse:\nawait self.__nack()\nreturn False\nasync def __ack(self) -&gt; None:\nawait call_or_await(self.message.ack, **self.extra_ack_args)\nself.watcher.remove(self.message.message_id)\nasync def __nack(self) -&gt; None:\nawait call_or_await(self.message.nack, **self.extra_ack_args)\nasync def __reject(self) -&gt; None:\nawait call_or_await(self.message.reject, **self.extra_ack_args)\nself.watcher.remove(self.message.message_id)\n</code></pre>"},{"location":"api/faststream/broker/push_back_watcher/WatcherContext/#faststream.broker.push_back_watcher.WatcherContext.extra_ack_args","title":"extra_ack_args  <code>instance-attribute</code>","text":"<pre><code>extra_ack_args = extra_ack_args or {}\n</code></pre>"},{"location":"api/faststream/broker/push_back_watcher/WatcherContext/#faststream.broker.push_back_watcher.WatcherContext.message","title":"message  <code>instance-attribute</code>","text":"<pre><code>message = message\n</code></pre>"},{"location":"api/faststream/broker/push_back_watcher/WatcherContext/#faststream.broker.push_back_watcher.WatcherContext.watcher","title":"watcher  <code>instance-attribute</code>","text":"<pre><code>watcher = watcher\n</code></pre>"},{"location":"api/faststream/broker/router/BrokerRoute/","title":"BrokerRoute","text":""},{"location":"api/faststream/broker/router/BrokerRoute/#faststream.broker.router.BrokerRoute","title":"faststream.broker.router.BrokerRoute","text":"<p>             Bases: <code>Generic[MsgType, T_HandlerReturn]</code></p> <p>A generic class to represent a broker route.</p> PARAMETER  DESCRIPTION <code>call</code> <p>callable object representing the route</p> <p> </p> <code>*args</code> <p>variable length arguments for the route</p> <p> DEFAULT: <code>()</code> </p> <code>**kwargs</code> <p>variable length keyword arguments for the route</p> <p> DEFAULT: <code>{}</code> </p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/router.py</code> <pre><code>class BrokerRoute(Generic[MsgType, T_HandlerReturn]):\n\"\"\"A generic class to represent a broker route.\n    Attributes:\n        call : callable object representing the route\n        args : tuple of arguments for the route\n        kwargs : dictionary of keyword arguments for the route\n    Args:\n        call : callable object representing the route\n        *args : variable length arguments for the route\n        **kwargs : variable length keyword arguments for the route\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\ncall: Callable[..., T_HandlerReturn]\nargs: Tuple[Any, ...]\nkwargs: AnyDict\ndef __init__(\nself,\ncall: Callable[..., T_HandlerReturn],\n*args: Any,\n**kwargs: Any,\n):\n\"\"\"Initialize a callable object with arguments and keyword arguments.\n        Args:\n            call: A callable object.\n            *args: Positional arguments to be passed to the callable object.\n            **kwargs: Keyword arguments to be passed to the callable object.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nself.call = call\nself.args = args\nself.kwargs = kwargs\n</code></pre>"},{"location":"api/faststream/broker/router/BrokerRoute/#faststream.broker.router.BrokerRoute.args","title":"args  <code>instance-attribute</code>","text":"<pre><code>args: Tuple[Any, ...] = args\n</code></pre>"},{"location":"api/faststream/broker/router/BrokerRoute/#faststream.broker.router.BrokerRoute.call","title":"call  <code>instance-attribute</code>","text":"<pre><code>call: Callable[..., T_HandlerReturn] = call\n</code></pre>"},{"location":"api/faststream/broker/router/BrokerRoute/#faststream.broker.router.BrokerRoute.kwargs","title":"kwargs  <code>instance-attribute</code>","text":"<pre><code>kwargs: AnyDict = kwargs\n</code></pre>"},{"location":"api/faststream/broker/router/BrokerRouter/","title":"BrokerRouter","text":""},{"location":"api/faststream/broker/router/BrokerRouter/#faststream.broker.router.BrokerRouter","title":"faststream.broker.router.BrokerRouter","text":"<p>             Bases: <code>Generic[PublisherKeyType, MsgType]</code></p> <p>A generic class representing a broker router.</p> METHOD DESCRIPTION <code>_get_publisher_key </code> <p>abstract method to get the publisher key</p> <code>_update_publisher_prefix </code> <p>abstract method to update the publisher prefix</p> <code>__init__ </code> <p>constructor method</p> <code>subscriber </code> <p>abstract method to define a subscriber</p> <code>_wrap_subscriber </code> <p>method to wrap a subscriber function</p> <code>publisher </code> <p>abstract method to define a publisher</p> <code>include_router </code> <p>method to include a router</p> <code>include_routers </code> <p>method to include multiple routers</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/router.py</code> <pre><code>class BrokerRouter(Generic[PublisherKeyType, MsgType]):\n\"\"\"A generic class representing a broker router.\n    Attributes:\n        prefix : prefix for the router\n        _handlers : list of broker routes\n        _publishers : dictionary of publishers\n    Methods:\n        _get_publisher_key : abstract method to get the publisher key\n        _update_publisher_prefix : abstract method to update the publisher prefix\n        __init__ : constructor method\n        subscriber : abstract method to define a subscriber\n        _wrap_subscriber : method to wrap a subscriber function\n        publisher : abstract method to define a publisher\n        include_router : method to include a router\n        include_routers : method to include multiple routers\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nprefix: str\n_handlers: List[BrokerRoute[MsgType, Any]]\n_publishers: Dict[PublisherKeyType, BasePublisher[MsgType]]\n@staticmethod\n@abstractmethod\ndef _get_publisher_key(publisher: BasePublisher[MsgType]) -&gt; PublisherKeyType:\n\"\"\"This is a Python function.\n        _get_publisher_key function:\n        Args:\n            publisher: An instance of BasePublisher class.\n        Returns:\n            The publisher key.\n        Raises:\n            NotImplementedError: This function is not implemented.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nraise NotImplementedError()\n@staticmethod\n@abstractmethod\ndef _update_publisher_prefix(\nprefix: str,\npublisher: BasePublisher[MsgType],\n) -&gt; BasePublisher[MsgType]:\n\"\"\"Updates the publisher prefix.\n        Args:\n            prefix: The new prefix to be set.\n            publisher: The publisher to update.\n        Returns:\n            The updated publisher.\n        Raises:\n            NotImplementedError: If the function is not implemented.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nraise NotImplementedError()\ndef __init__(\nself,\nprefix: str = \"\",\nhandlers: Sequence[BrokerRoute[MsgType, SendableMessage]] = (),\ndependencies: Sequence[Depends] = (),\nmiddlewares: Optional[\nSequence[\nCallable[\n[StreamMessage[MsgType]],\nAsyncContextManager[None],\n]\n]\n] = None,\nparser: Optional[CustomParser[MsgType]] = None,\ndecoder: Optional[CustomDecoder[MsgType]] = None,\n):\n\"\"\"Initialize a class object.\n        Args:\n            prefix (str): Prefix for the object.\n            handlers (Sequence[BrokerRoute[MsgType, SendableMessage]]): Handlers for the object.\n            dependencies (Sequence[Depends]): Dependencies for the object.\n            middlewares (Optional[Sequence[Callable[[StreamMessage[MsgType]], AsyncContextManager[None]]]]): Middlewares for the object.\n            parser (Optional[CustomParser[MsgType]]): Parser for the object.\n            decoder (Optional[CustomDecoder[MsgType]]): Decoder for the object.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nself.prefix = prefix\nself._handlers = list(handlers)\nself._publishers = {}\nself._dependencies = dependencies\nself._middlewares = middlewares\nself._parser = parser\nself._decoder = decoder\n@abstractmethod\ndef subscriber(\nself,\nsubj: str,\n*args: Any,\ndependencies: Sequence[Depends] = (),\nmiddlewares: Optional[\nSequence[\nCallable[\n[StreamMessage[MsgType]],\nAsyncContextManager[None],\n]\n]\n] = None,\nparser: Optional[CustomParser[MsgType]] = None,\ndecoder: Optional[CustomDecoder[MsgType]] = None,\n**kwargs: Any,\n) -&gt; Callable[\n[Callable[P_HandlerParams, T_HandlerReturn]],\nHandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn],\n]:\n\"\"\"A function to subscribe to a subject.\n        Args:\n            subj : subject to subscribe to\n            *args : additional arguments\n            dependencies : sequence of dependencies\n            middlewares : optional sequence of middlewares\n            parser : optional custom parser\n            decoder : optional custom decoder\n            **kwargs : additional keyword arguments\n        Returns:\n            A callable handler function\n        Raises:\n            NotImplementedError: If the function is not implemented\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nraise NotImplementedError()\ndef _wrap_subscriber(\nself,\n*args: Any,\ndependencies: Sequence[Depends] = (),\nmiddlewares: Optional[\nSequence[\nCallable[\n[StreamMessage[MsgType]],\nAsyncContextManager[None],\n]\n]\n] = None,\nparser: Optional[CustomParser[MsgType]] = None,\ndecoder: Optional[CustomDecoder[MsgType]] = None,\n**kwargs: Any,\n) -&gt; Callable[\n[Callable[P_HandlerParams, T_HandlerReturn]],\nHandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn],\n]:\n\"\"\"This is a function named `_wrap_subscriber` that returns a callable object. It is used as a decorator for another function.\n        Args:\n            *args: Variable length arguments\n            dependencies: Sequence of dependencies\n            middlewares: Optional sequence of middlewares\n            parser: Optional custom parser\n            decoder: Optional custom decoder\n            **kwargs: Variable length keyword arguments\n        Returns:\n            A callable object that wraps the decorated function\n        This function is decorated with `@abstractmethod`, indicating that it is an abstract method and must be implemented by any subclass.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\ndef router_subscriber_wrapper(\nfunc: Callable[P_HandlerParams, T_HandlerReturn]\n) -&gt; HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn]:\n\"\"\"Wraps a function with a router subscriber.\n            Args:\n                func: The function to be wrapped.\n            Returns:\n                The wrapped function.\n            !!! note\n                The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n            \"\"\"\nwrapped_func: HandlerCallWrapper[\nMsgType, P_HandlerParams, T_HandlerReturn\n] = HandlerCallWrapper(func)\nroute: BrokerRoute[MsgType, T_HandlerReturn] = BrokerRoute(\nwrapped_func,\n*args,\ndependencies=(*self._dependencies, *dependencies),\nmiddlewares=(*(self._middlewares or ()), *(middlewares or ())) or None,\nparser=parser or self._parser,\ndecoder=decoder or self._decoder,\n**kwargs,\n)\nself._handlers.append(route)\nreturn wrapped_func\nreturn router_subscriber_wrapper\n@abstractmethod\ndef publisher(\nself,\nsubj: str,\n*args: Any,\n**kwargs: Any,\n) -&gt; BasePublisher[MsgType]:\n\"\"\"Publishes a message.\n        Args:\n            subj: Subject of the message\n            *args: Additional arguments\n            **kwargs: Additional keyword arguments\n        Returns:\n            The published message\n        Raises:\n            NotImplementedError: If the method is not implemented\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nraise NotImplementedError()\ndef include_router(self, router: \"BrokerRouter[PublisherKeyType, MsgType]\") -&gt; None:\n\"\"\"Includes a router in the current object.\n        Args:\n            router: The router to be included.\n        Returns:\n            None\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nfor h in router._handlers:\nself.subscriber(*h.args, **h.kwargs)(h.call)\nfor p in router._publishers.values():\np = self._update_publisher_prefix(self.prefix, p)\nkey = self._get_publisher_key(p)\nself._publishers[key] = self._publishers.get(key, p)\ndef include_routers(\nself, *routers: \"BrokerRouter[PublisherKeyType, MsgType]\"\n) -&gt; None:\n\"\"\"Includes routers in the object.\n        Args:\n            *routers: Variable length argument list of routers to include.\n        Returns:\n            None\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nfor r in routers:\nself.include_router(r)\n</code></pre>"},{"location":"api/faststream/broker/router/BrokerRouter/#faststream.broker.router.BrokerRouter.prefix","title":"prefix  <code>instance-attribute</code>","text":"<pre><code>prefix: str = prefix\n</code></pre>"},{"location":"api/faststream/broker/router/BrokerRouter/#faststream.broker.router.BrokerRouter.include_router","title":"include_router","text":"<pre><code>include_router(\nrouter: BrokerRouter[PublisherKeyType, MsgType]\n) -&gt; None\n</code></pre> <p>Includes a router in the current object.</p> PARAMETER  DESCRIPTION <code>router</code> <p>The router to be included.</p> <p> TYPE: <code>BrokerRouter[PublisherKeyType, MsgType]</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/router.py</code> <pre><code>def include_router(self, router: \"BrokerRouter[PublisherKeyType, MsgType]\") -&gt; None:\n\"\"\"Includes a router in the current object.\n    Args:\n        router: The router to be included.\n    Returns:\n        None\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nfor h in router._handlers:\nself.subscriber(*h.args, **h.kwargs)(h.call)\nfor p in router._publishers.values():\np = self._update_publisher_prefix(self.prefix, p)\nkey = self._get_publisher_key(p)\nself._publishers[key] = self._publishers.get(key, p)\n</code></pre>"},{"location":"api/faststream/broker/router/BrokerRouter/#faststream.broker.router.BrokerRouter.include_routers","title":"include_routers","text":"<pre><code>include_routers(\n*routers: BrokerRouter[PublisherKeyType, MsgType]\n) -&gt; None\n</code></pre> <p>Includes routers in the object.</p> PARAMETER  DESCRIPTION <code>*routers</code> <p>Variable length argument list of routers to include.</p> <p> TYPE: <code>BrokerRouter[PublisherKeyType, MsgType]</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/router.py</code> <pre><code>def include_routers(\nself, *routers: \"BrokerRouter[PublisherKeyType, MsgType]\"\n) -&gt; None:\n\"\"\"Includes routers in the object.\n    Args:\n        *routers: Variable length argument list of routers to include.\n    Returns:\n        None\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nfor r in routers:\nself.include_router(r)\n</code></pre>"},{"location":"api/faststream/broker/router/BrokerRouter/#faststream.broker.router.BrokerRouter.publisher","title":"publisher  <code>abstractmethod</code>","text":"<pre><code>publisher(\nsubj: str, *args: Any, **kwargs: Any\n) -&gt; BasePublisher[MsgType]\n</code></pre> <p>Publishes a message.</p> PARAMETER  DESCRIPTION <code>subj</code> <p>Subject of the message</p> <p> TYPE: <code>str</code> </p> <code>*args</code> <p>Additional arguments</p> <p> TYPE: <code>Any</code> DEFAULT: <code>()</code> </p> <code>**kwargs</code> <p>Additional keyword arguments</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>BasePublisher[MsgType]</code> <p>The published message</p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>If the method is not implemented</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/router.py</code> <pre><code>@abstractmethod\ndef publisher(\nself,\nsubj: str,\n*args: Any,\n**kwargs: Any,\n) -&gt; BasePublisher[MsgType]:\n\"\"\"Publishes a message.\n    Args:\n        subj: Subject of the message\n        *args: Additional arguments\n        **kwargs: Additional keyword arguments\n    Returns:\n        The published message\n    Raises:\n        NotImplementedError: If the method is not implemented\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nraise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/broker/router/BrokerRouter/#faststream.broker.router.BrokerRouter.subscriber","title":"subscriber  <code>abstractmethod</code>","text":"<pre><code>subscriber(\nsubj: str,\n*args: Any,\ndependencies: Sequence[Depends] = (),\nmiddlewares: Optional[\nSequence[\nCallable[\n[StreamMessage[MsgType]],\nAsyncContextManager[None],\n]\n]\n] = None,\nparser: Optional[CustomParser[MsgType]] = None,\ndecoder: Optional[CustomDecoder[MsgType]] = None,\n**kwargs: Any\n) -&gt; Callable[\n[Callable[P_HandlerParams, T_HandlerReturn]],\nHandlerCallWrapper[\nMsgType, P_HandlerParams, T_HandlerReturn\n],\n]\n</code></pre> <p>A function to subscribe to a subject.</p> PARAMETER  DESCRIPTION <code>subj</code> <p>subject to subscribe to</p> <p> </p> <code>*args</code> <p>additional arguments</p> <p> DEFAULT: <code>()</code> </p> <code>dependencies</code> <p>sequence of dependencies</p> <p> DEFAULT: <code>()</code> </p> <code>middlewares</code> <p>optional sequence of middlewares</p> <p> DEFAULT: <code>None</code> </p> <code>parser</code> <p>optional custom parser</p> <p> DEFAULT: <code>None</code> </p> <code>decoder</code> <p>optional custom decoder</p> <p> DEFAULT: <code>None</code> </p> <code>**kwargs</code> <p>additional keyword arguments</p> <p> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Callable[[Callable[P_HandlerParams, T_HandlerReturn]], HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn]]</code> <p>A callable handler function</p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>If the function is not implemented</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/router.py</code> <pre><code>@abstractmethod\ndef subscriber(\nself,\nsubj: str,\n*args: Any,\ndependencies: Sequence[Depends] = (),\nmiddlewares: Optional[\nSequence[\nCallable[\n[StreamMessage[MsgType]],\nAsyncContextManager[None],\n]\n]\n] = None,\nparser: Optional[CustomParser[MsgType]] = None,\ndecoder: Optional[CustomDecoder[MsgType]] = None,\n**kwargs: Any,\n) -&gt; Callable[\n[Callable[P_HandlerParams, T_HandlerReturn]],\nHandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn],\n]:\n\"\"\"A function to subscribe to a subject.\n    Args:\n        subj : subject to subscribe to\n        *args : additional arguments\n        dependencies : sequence of dependencies\n        middlewares : optional sequence of middlewares\n        parser : optional custom parser\n        decoder : optional custom decoder\n        **kwargs : additional keyword arguments\n    Returns:\n        A callable handler function\n    Raises:\n        NotImplementedError: If the function is not implemented\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nraise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/broker/schemas/NameRequired/","title":"NameRequired","text":""},{"location":"api/faststream/broker/schemas/NameRequired/#faststream.broker.schemas.NameRequired","title":"faststream.broker.schemas.NameRequired","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent a required name.</p> METHOD DESCRIPTION <code>__eq__</code> <p>object) -&gt; bool: Check if the given value is equal to the current instance.</p> <code>__init__</code> <p>str, **kwargs: Any): Initialize the NameRequired instance.</p> <code>validate</code> <p>Type[NameRequiredCls], value: Union[str, NameRequiredCls]) -&gt; NameRequiredCls: Validate the given value and return a NameRequiredCls instance.</p> <code>validate</code> <p>Type[NameRequiredCls], value: None) -&gt; None: Validate the given value and return None.</p> <code>validate</code> <p>Type[NameRequiredCls], value: Union[str, NameRequiredCls, None]) -&gt; Optional[NameRequiredCls]: Validate the given value and return an optional NameRequiredCls instance.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/schemas.py</code> <pre><code>class NameRequired(BaseModel):\n\"\"\"A class to represent a required name.\n    Attributes:\n        name : optional name\n    Methods:\n        __eq__(self, __value: object) -&gt; bool: Check if the given value is equal to the current instance.\n        __init__(self, name: str, **kwargs: Any): Initialize the NameRequired instance.\n        validate(cls: Type[NameRequiredCls], value: Union[str, NameRequiredCls]) -&gt; NameRequiredCls: Validate the given value and return a NameRequiredCls instance.\n        validate(cls: Type[NameRequiredCls], value: None) -&gt; None: Validate the given value and return None.\n        validate(cls: Type[NameRequiredCls], value: Union[str, NameRequiredCls, None]) -&gt; Optional[NameRequiredCls]: Validate the given value and return an optional NameRequiredCls instance.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nname: Optional[str] = Field(...)\ndef __eq__(self, __value: object) -&gt; bool:\n\"\"\"Compares the current object with another object for equality.\n        Args:\n            __value: The object to compare with.\n        Returns:\n            True if the objects are equal, False otherwise.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nif __value is None:\nreturn False\nif not isinstance(__value, NameRequired):  # pragma: no cover\nreturn NotImplemented\nreturn self.name == __value.name\ndef __init__(self, name: str, **kwargs: Any) -&gt; None:\n\"\"\"This is a Python function.\n        Args:\n            name (str): The name of the object.\n            **kwargs (Any): Additional keyword arguments.\n        Returns:\n            None.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nsuper().__init__(name=name, **kwargs)\n@overload\n@classmethod\ndef validate(\ncls: Type[NameRequiredCls], value: Union[str, NameRequiredCls]\n) -&gt; NameRequiredCls:\n\"\"\"Validates a value.\n        Args:\n            value: The value to validate.\n        Returns:\n            The validated value.\n        Raises:\n            TypeError: If the value is not of the expected type.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n...\n@overload\n@classmethod\ndef validate(cls: Type[NameRequiredCls], value: None) -&gt; None:\n\"\"\"Validate a value.\n        Args:\n            value: The value to be validated\n        Returns:\n            None\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n...\n@classmethod\ndef validate(\ncls: Type[NameRequiredCls], value: Union[str, NameRequiredCls, None]\n) -&gt; Optional[NameRequiredCls]:\n\"\"\"Validates a value.\n        Args:\n            value: The value to be validated.\n        Returns:\n            The validated value.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nif value is not None:\nif isinstance(value, str):\nvalue = cls(value)\nreturn value\n</code></pre>"},{"location":"api/faststream/broker/schemas/NameRequired/#faststream.broker.schemas.NameRequired.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: Optional[str] = Field(...)\n</code></pre>"},{"location":"api/faststream/broker/schemas/NameRequired/#faststream.broker.schemas.NameRequired.validate","title":"validate  <code>classmethod</code>","text":"<pre><code>validate(\nvalue: Union[str, NameRequiredCls, None]\n) -&gt; Optional[NameRequiredCls]\n</code></pre> <p>Validates a value.</p> PARAMETER  DESCRIPTION <code>value</code> <p>The value to be validated.</p> <p> TYPE: <code>Union[str, NameRequiredCls, None]</code> </p> RETURNS DESCRIPTION <code>Optional[NameRequiredCls]</code> <p>The validated value.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/schemas.py</code> <pre><code>@classmethod\ndef validate(\ncls: Type[NameRequiredCls], value: Union[str, NameRequiredCls, None]\n) -&gt; Optional[NameRequiredCls]:\n\"\"\"Validates a value.\n    Args:\n        value: The value to be validated.\n    Returns:\n        The validated value.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nif value is not None:\nif isinstance(value, str):\nvalue = cls(value)\nreturn value\n</code></pre>"},{"location":"api/faststream/broker/schemas/RawDecoced/","title":"RawDecoced","text":""},{"location":"api/faststream/broker/schemas/RawDecoced/#faststream.broker.schemas.RawDecoced","title":"faststream.broker.schemas.RawDecoced","text":"<p>             Bases: <code>BaseModel</code></p> <p>A class to represent a raw decoded message.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/schemas.py</code> <pre><code>class RawDecoced(BaseModel):\n\"\"\"A class to represent a raw decoded message.\n    Attributes:\n        message : the decoded message, which can be either a JSON object or a string\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nmessage: Union[Json[Any], str]\n</code></pre>"},{"location":"api/faststream/broker/schemas/RawDecoced/#faststream.broker.schemas.RawDecoced.message","title":"message  <code>instance-attribute</code>","text":"<pre><code>message: Union[Json[Any], str]\n</code></pre>"},{"location":"api/faststream/broker/security/BaseSecurity/","title":"BaseSecurity","text":""},{"location":"api/faststream/broker/security/BaseSecurity/#faststream.broker.security.BaseSecurity","title":"faststream.broker.security.BaseSecurity","text":"<p>Base class for defining security configurations.</p> <p>This class provides a base for defining security configurations for communication with a broker. It allows setting SSL encryption and provides methods to retrieve security requirements and schemas.</p> PARAMETER  DESCRIPTION <code>ssl_context</code> <p>An SSLContext object for SSL encryption. If None, SSL encryption is disabled.</p> <p> TYPE: <code>Optional[SSLContext]</code> DEFAULT: <code>None</code> </p> <code>use_ssl</code> <p>A boolean indicating whether to use SSL encryption. Defaults to True.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> METHOD DESCRIPTION <code>get_requirement</code> <p>Get the security requirements in the form of a list of dictionaries.</p> <code>get_schema</code> <p>Get the security schema as a dictionary.</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/security.py</code> <pre><code>class BaseSecurity:\n\"\"\"\n    Base class for defining security configurations.\n    This class provides a base for defining security configurations for communication with a broker. It allows setting\n    SSL encryption and provides methods to retrieve security requirements and schemas.\n    Args:\n        ssl_context (Optional[SSLContext]): An SSLContext object for SSL encryption. If None, SSL encryption is disabled.\n        use_ssl (Optional[bool]): A boolean indicating whether to use SSL encryption. Defaults to True.\n    Attributes:\n        use_ssl (bool): A boolean indicating whether SSL encryption is enabled.\n        ssl_context (Optional[SSLContext]): An SSLContext object for SSL encryption. None if SSL is not used.\n    Methods:\n        get_requirement(self) -&gt; List[Dict[str, Any]]:\n            Get the security requirements in the form of a list of dictionaries.\n        get_schema(self) -&gt; Dict[str, Dict[str, str]]:\n            Get the security schema as a dictionary.\n    \"\"\"\ndef __init__(\nself,\nssl_context: Optional[SSLContext] = None,\nuse_ssl: Optional[bool] = None,\n):\nif use_ssl is None:\nuse_ssl = True\nif use_ssl and ssl_context is None:\nraise RuntimeError(ssl_not_set_error_msg)\nself.use_ssl = use_ssl\nself.ssl_context = ssl_context\ndef get_requirement(self) -&gt; List[Dict[str, Any]]:\n\"\"\"\n        Get the security requirements.\n        Returns:\n            List[Dict[str, Any]]: A list of dictionaries representing security requirements.\n        \"\"\"\nreturn []\ndef get_schema(self) -&gt; Dict[str, Dict[str, str]]:\n\"\"\"\n        Get the security schema.\n        Returns:\n            Dict[str, Dict[str, str]]: A dictionary representing the security schema.\n        \"\"\"\nreturn {}\n</code></pre>"},{"location":"api/faststream/broker/security/BaseSecurity/#faststream.broker.security.BaseSecurity.ssl_context","title":"ssl_context  <code>instance-attribute</code>","text":"<pre><code>ssl_context = ssl_context\n</code></pre>"},{"location":"api/faststream/broker/security/BaseSecurity/#faststream.broker.security.BaseSecurity.use_ssl","title":"use_ssl  <code>instance-attribute</code>","text":"<pre><code>use_ssl = use_ssl\n</code></pre>"},{"location":"api/faststream/broker/security/BaseSecurity/#faststream.broker.security.BaseSecurity.get_requirement","title":"get_requirement","text":"<pre><code>get_requirement() -&gt; List[Dict[str, Any]]\n</code></pre> <p>Get the security requirements.</p> RETURNS DESCRIPTION <code>List[Dict[str, Any]]</code> <p>List[Dict[str, Any]]: A list of dictionaries representing security requirements.</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/security.py</code> <pre><code>def get_requirement(self) -&gt; List[Dict[str, Any]]:\n\"\"\"\n    Get the security requirements.\n    Returns:\n        List[Dict[str, Any]]: A list of dictionaries representing security requirements.\n    \"\"\"\nreturn []\n</code></pre>"},{"location":"api/faststream/broker/security/BaseSecurity/#faststream.broker.security.BaseSecurity.get_schema","title":"get_schema","text":"<pre><code>get_schema() -&gt; Dict[str, Dict[str, str]]\n</code></pre> <p>Get the security schema.</p> RETURNS DESCRIPTION <code>Dict[str, Dict[str, str]]</code> <p>Dict[str, Dict[str, str]]: A dictionary representing the security schema.</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/security.py</code> <pre><code>def get_schema(self) -&gt; Dict[str, Dict[str, str]]:\n\"\"\"\n    Get the security schema.\n    Returns:\n        Dict[str, Dict[str, str]]: A dictionary representing the security schema.\n    \"\"\"\nreturn {}\n</code></pre>"},{"location":"api/faststream/broker/security/SASLPlaintext/","title":"SASLPlaintext","text":""},{"location":"api/faststream/broker/security/SASLPlaintext/#faststream.broker.security.SASLPlaintext","title":"faststream.broker.security.SASLPlaintext","text":"<p>             Bases: <code>BaseSecurity</code></p> <p>Security configuration for SASL/PLAINTEXT authentication.</p> <p>This class defines security configuration for SASL/PLAINTEXT authentication, which includes a username and password.</p> PARAMETER  DESCRIPTION <code>username</code> <p>The username for authentication.</p> <p> TYPE: <code>str</code> </p> <code>password</code> <p>The password for authentication.</p> <p> TYPE: <code>str</code> </p> <code>ssl_context</code> <p>An SSLContext object for SSL encryption. If None, SSL encryption is disabled.</p> <p> TYPE: <code>Optional[SSLContext]</code> DEFAULT: <code>None</code> </p> <code>use_ssl</code> <p>A boolean indicating whether to use SSL encryption. Defaults to True.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> METHOD DESCRIPTION <code>get_requirement</code> <p>Get the security requirements for SASL/PLAINTEXT authentication.</p> <code>get_schema</code> <p>Get the security schema for SASL/PLAINTEXT authentication.</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/security.py</code> <pre><code>class SASLPlaintext(BaseSecurity):\n\"\"\"\n    Security configuration for SASL/PLAINTEXT authentication.\n    This class defines security configuration for SASL/PLAINTEXT authentication, which includes a username and password.\n    Args:\n        username (str): The username for authentication.\n        password (str): The password for authentication.\n        ssl_context (Optional[SSLContext]): An SSLContext object for SSL encryption. If None, SSL encryption is disabled.\n        use_ssl (Optional[bool]): A boolean indicating whether to use SSL encryption. Defaults to True.\n    Methods:\n        get_requirement(self) -&gt; List[Dict[str, Any]]:\n            Get the security requirements for SASL/PLAINTEXT authentication.\n        get_schema(self) -&gt; Dict[str, Dict[str, str]]:\n            Get the security schema for SASL/PLAINTEXT authentication.\n    \"\"\"\ndef __init__(\nself,\nusername: str,\npassword: str,\nssl_context: Optional[SSLContext] = None,\nuse_ssl: Optional[bool] = None,\n):\nsuper().__init__(ssl_context, use_ssl)\nself.username = username\nself.password = password\ndef get_requirement(self) -&gt; List[Dict[str, Any]]:\n\"\"\"\n        Get the security requirements for SASL/PLAINTEXT authentication.\n        Returns:\n            List[Dict[str, Any]]: A list of dictionaries representing security requirements.\n        \"\"\"\nreturn [{\"user-password\": []}]\ndef get_schema(self) -&gt; Dict[str, Dict[str, str]]:\n\"\"\"\n        Get the security schema for SASL/PLAINTEXT authentication.\n        Returns:\n            Dict[str, Dict[str, str]]: A dictionary representing the security schema.\n        \"\"\"\nreturn {\"user-password\": {\"type\": \"userPassword\"}}\n</code></pre>"},{"location":"api/faststream/broker/security/SASLPlaintext/#faststream.broker.security.SASLPlaintext.password","title":"password  <code>instance-attribute</code>","text":"<pre><code>password = password\n</code></pre>"},{"location":"api/faststream/broker/security/SASLPlaintext/#faststream.broker.security.SASLPlaintext.username","title":"username  <code>instance-attribute</code>","text":"<pre><code>username = username\n</code></pre>"},{"location":"api/faststream/broker/security/SASLPlaintext/#faststream.broker.security.SASLPlaintext.get_requirement","title":"get_requirement","text":"<pre><code>get_requirement() -&gt; List[Dict[str, Any]]\n</code></pre> <p>Get the security requirements for SASL/PLAINTEXT authentication.</p> RETURNS DESCRIPTION <code>List[Dict[str, Any]]</code> <p>List[Dict[str, Any]]: A list of dictionaries representing security requirements.</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/security.py</code> <pre><code>def get_requirement(self) -&gt; List[Dict[str, Any]]:\n\"\"\"\n    Get the security requirements for SASL/PLAINTEXT authentication.\n    Returns:\n        List[Dict[str, Any]]: A list of dictionaries representing security requirements.\n    \"\"\"\nreturn [{\"user-password\": []}]\n</code></pre>"},{"location":"api/faststream/broker/security/SASLPlaintext/#faststream.broker.security.SASLPlaintext.get_schema","title":"get_schema","text":"<pre><code>get_schema() -&gt; Dict[str, Dict[str, str]]\n</code></pre> <p>Get the security schema for SASL/PLAINTEXT authentication.</p> RETURNS DESCRIPTION <code>Dict[str, Dict[str, str]]</code> <p>Dict[str, Dict[str, str]]: A dictionary representing the security schema.</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/security.py</code> <pre><code>def get_schema(self) -&gt; Dict[str, Dict[str, str]]:\n\"\"\"\n    Get the security schema for SASL/PLAINTEXT authentication.\n    Returns:\n        Dict[str, Dict[str, str]]: A dictionary representing the security schema.\n    \"\"\"\nreturn {\"user-password\": {\"type\": \"userPassword\"}}\n</code></pre>"},{"location":"api/faststream/broker/security/SASLScram256/","title":"SASLScram256","text":""},{"location":"api/faststream/broker/security/SASLScram256/#faststream.broker.security.SASLScram256","title":"faststream.broker.security.SASLScram256","text":"<p>             Bases: <code>BaseSecurity</code></p> <p>Security configuration for SASL/SCRAM-SHA-256 authentication.</p> <p>This class defines security configuration for SASL/SCRAM-SHA-256 authentication, which includes a username and password.</p> PARAMETER  DESCRIPTION <code>username</code> <p>The username for authentication.</p> <p> TYPE: <code>str</code> </p> <code>password</code> <p>The password for authentication.</p> <p> TYPE: <code>str</code> </p> <code>ssl_context</code> <p>An SSLContext object for SSL encryption. If None, SSL encryption is disabled.</p> <p> TYPE: <code>Optional[SSLContext]</code> DEFAULT: <code>None</code> </p> <code>use_ssl</code> <p>A boolean indicating whether to use SSL encryption. Defaults to True.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> METHOD DESCRIPTION <code>get_requirement</code> <p>Get the security requirements for SASL/SCRAM-SHA-256 authentication.</p> <code>get_schema</code> <p>Get the security schema for SASL/SCRAM-SHA-256 authentication.</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/security.py</code> <pre><code>class SASLScram256(BaseSecurity):\n\"\"\"\n    Security configuration for SASL/SCRAM-SHA-256 authentication.\n    This class defines security configuration for SASL/SCRAM-SHA-256 authentication, which includes a username and password.\n    Args:\n        username (str): The username for authentication.\n        password (str): The password for authentication.\n        ssl_context (Optional[SSLContext]): An SSLContext object for SSL encryption. If None, SSL encryption is disabled.\n        use_ssl (Optional[bool]): A boolean indicating whether to use SSL encryption. Defaults to True.\n    Methods:\n        get_requirement(self) -&gt; List[Dict[str, Any]]:\n            Get the security requirements for SASL/SCRAM-SHA-256 authentication.\n        get_schema(self) -&gt; Dict[str, Dict[str, str]]:\n            Get the security schema for SASL/SCRAM-SHA-256 authentication.\n    \"\"\"\ndef __init__(\nself,\nusername: str,\npassword: str,\nssl_context: Optional[SSLContext] = None,\nuse_ssl: Optional[bool] = None,\n):\nsuper().__init__(ssl_context, use_ssl)\nself.username = username\nself.password = password\ndef get_requirement(self) -&gt; List[Dict[str, Any]]:\n\"\"\"\n        Get the security requirements for SASL/SCRAM-SHA-256 authentication.\n        Returns:\n            List[Dict[str, Any]]: A list of dictionaries representing security requirements.\n        \"\"\"\nreturn [{\"scram256\": []}]\ndef get_schema(self) -&gt; Dict[str, Dict[str, str]]:\n\"\"\"\n        Get the security schema for SASL/SCRAM-SHA-256 authentication.\n        Returns:\n            Dict[str, Dict[str, str]]: A dictionary representing the security schema.\n        \"\"\"\nreturn {\"scram256\": {\"type\": \"scramSha256\"}}\n</code></pre>"},{"location":"api/faststream/broker/security/SASLScram256/#faststream.broker.security.SASLScram256.password","title":"password  <code>instance-attribute</code>","text":"<pre><code>password = password\n</code></pre>"},{"location":"api/faststream/broker/security/SASLScram256/#faststream.broker.security.SASLScram256.username","title":"username  <code>instance-attribute</code>","text":"<pre><code>username = username\n</code></pre>"},{"location":"api/faststream/broker/security/SASLScram256/#faststream.broker.security.SASLScram256.get_requirement","title":"get_requirement","text":"<pre><code>get_requirement() -&gt; List[Dict[str, Any]]\n</code></pre> <p>Get the security requirements for SASL/SCRAM-SHA-256 authentication.</p> RETURNS DESCRIPTION <code>List[Dict[str, Any]]</code> <p>List[Dict[str, Any]]: A list of dictionaries representing security requirements.</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/security.py</code> <pre><code>def get_requirement(self) -&gt; List[Dict[str, Any]]:\n\"\"\"\n    Get the security requirements for SASL/SCRAM-SHA-256 authentication.\n    Returns:\n        List[Dict[str, Any]]: A list of dictionaries representing security requirements.\n    \"\"\"\nreturn [{\"scram256\": []}]\n</code></pre>"},{"location":"api/faststream/broker/security/SASLScram256/#faststream.broker.security.SASLScram256.get_schema","title":"get_schema","text":"<pre><code>get_schema() -&gt; Dict[str, Dict[str, str]]\n</code></pre> <p>Get the security schema for SASL/SCRAM-SHA-256 authentication.</p> RETURNS DESCRIPTION <code>Dict[str, Dict[str, str]]</code> <p>Dict[str, Dict[str, str]]: A dictionary representing the security schema.</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/security.py</code> <pre><code>def get_schema(self) -&gt; Dict[str, Dict[str, str]]:\n\"\"\"\n    Get the security schema for SASL/SCRAM-SHA-256 authentication.\n    Returns:\n        Dict[str, Dict[str, str]]: A dictionary representing the security schema.\n    \"\"\"\nreturn {\"scram256\": {\"type\": \"scramSha256\"}}\n</code></pre>"},{"location":"api/faststream/broker/security/SASLScram512/","title":"SASLScram512","text":""},{"location":"api/faststream/broker/security/SASLScram512/#faststream.broker.security.SASLScram512","title":"faststream.broker.security.SASLScram512","text":"<p>             Bases: <code>BaseSecurity</code></p> <p>Security configuration for SASL/SCRAM-SHA-512 authentication.</p> <p>This class defines security configuration for SASL/SCRAM-SHA-512 authentication, which includes a username and password.</p> PARAMETER  DESCRIPTION <code>username</code> <p>The username for authentication.</p> <p> TYPE: <code>str</code> </p> <code>password</code> <p>The password for authentication.</p> <p> TYPE: <code>str</code> </p> <code>ssl_context</code> <p>An SSLContext object for SSL encryption. If None, SSL encryption is disabled.</p> <p> TYPE: <code>Optional[SSLContext]</code> DEFAULT: <code>None</code> </p> <code>use_ssl</code> <p>A boolean indicating whether to use SSL encryption. Defaults to True.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>None</code> </p> METHOD DESCRIPTION <code>get_requirement</code> <p>Get the security requirements for SASL/SCRAM-SHA-512 authentication.</p> <code>get_schema</code> <p>Get the security schema for SASL/SCRAM-SHA-512 authentication.</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/security.py</code> <pre><code>class SASLScram512(BaseSecurity):\n\"\"\"\n    Security configuration for SASL/SCRAM-SHA-512 authentication.\n    This class defines security configuration for SASL/SCRAM-SHA-512 authentication, which includes a username and password.\n    Args:\n        username (str): The username for authentication.\n        password (str): The password for authentication.\n        ssl_context (Optional[SSLContext]): An SSLContext object for SSL encryption. If None, SSL encryption is disabled.\n        use_ssl (Optional[bool]): A boolean indicating whether to use SSL encryption. Defaults to True.\n    Methods:\n        get_requirement(self) -&gt; List[Dict[str, Any]]:\n            Get the security requirements for SASL/SCRAM-SHA-512 authentication.\n        get_schema(self) -&gt; Dict[str, Dict[str, str]]:\n            Get the security schema for SASL/SCRAM-SHA-512 authentication.\n    \"\"\"\ndef __init__(\nself,\nusername: str,\npassword: str,\nssl_context: Optional[SSLContext] = None,\nuse_ssl: Optional[bool] = None,\n):\nsuper().__init__(ssl_context, use_ssl)\nself.username = username\nself.password = password\ndef get_requirement(self) -&gt; List[Dict[str, Any]]:\n\"\"\"\n        Get the security requirements for SASL/SCRAM-SHA-512 authentication.\n        Returns:\n            List[Dict[str, Any]]: A list of dictionaries representing security requirements.\n        \"\"\"\nreturn [{\"scram512\": []}]\ndef get_schema(self) -&gt; Dict[str, Dict[str, str]]:\n\"\"\"\n        Get the security schema for SASL/SCRAM-SHA-512 authentication.\n        Returns:\n            Dict[str, Dict[str, str]]: A dictionary representing the security schema.\n        \"\"\"\nreturn {\"scram512\": {\"type\": \"scramSha512\"}}\n</code></pre>"},{"location":"api/faststream/broker/security/SASLScram512/#faststream.broker.security.SASLScram512.password","title":"password  <code>instance-attribute</code>","text":"<pre><code>password = password\n</code></pre>"},{"location":"api/faststream/broker/security/SASLScram512/#faststream.broker.security.SASLScram512.username","title":"username  <code>instance-attribute</code>","text":"<pre><code>username = username\n</code></pre>"},{"location":"api/faststream/broker/security/SASLScram512/#faststream.broker.security.SASLScram512.get_requirement","title":"get_requirement","text":"<pre><code>get_requirement() -&gt; List[Dict[str, Any]]\n</code></pre> <p>Get the security requirements for SASL/SCRAM-SHA-512 authentication.</p> RETURNS DESCRIPTION <code>List[Dict[str, Any]]</code> <p>List[Dict[str, Any]]: A list of dictionaries representing security requirements.</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/security.py</code> <pre><code>def get_requirement(self) -&gt; List[Dict[str, Any]]:\n\"\"\"\n    Get the security requirements for SASL/SCRAM-SHA-512 authentication.\n    Returns:\n        List[Dict[str, Any]]: A list of dictionaries representing security requirements.\n    \"\"\"\nreturn [{\"scram512\": []}]\n</code></pre>"},{"location":"api/faststream/broker/security/SASLScram512/#faststream.broker.security.SASLScram512.get_schema","title":"get_schema","text":"<pre><code>get_schema() -&gt; Dict[str, Dict[str, str]]\n</code></pre> <p>Get the security schema for SASL/SCRAM-SHA-512 authentication.</p> RETURNS DESCRIPTION <code>Dict[str, Dict[str, str]]</code> <p>Dict[str, Dict[str, str]]: A dictionary representing the security schema.</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/security.py</code> <pre><code>def get_schema(self) -&gt; Dict[str, Dict[str, str]]:\n\"\"\"\n    Get the security schema for SASL/SCRAM-SHA-512 authentication.\n    Returns:\n        Dict[str, Dict[str, str]]: A dictionary representing the security schema.\n    \"\"\"\nreturn {\"scram512\": {\"type\": \"scramSha512\"}}\n</code></pre>"},{"location":"api/faststream/broker/test/TestApp/","title":"TestApp","text":""},{"location":"api/faststream/broker/test/TestApp/#faststream.broker.test.TestApp","title":"faststream.broker.test.TestApp","text":"<p>A class to represent a test application.</p> METHOD DESCRIPTION <code>__init__ </code> <p>initializes the TestApp object</p> <code>__aenter__ </code> <p>enters the asynchronous context and starts the FastStream application</p> <code>__aexit__ </code> <p>exits the asynchronous context and stops the FastStream application</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/test.py</code> <pre><code>class TestApp:\n# make sure pytest doesn't try to collect this class as a test class\n\"\"\"A class to represent a test application.\n    Attributes:\n        app : an instance of FastStream\n        _extra_options : optional dictionary of additional options\n        _event : an instance of anyio.Event\n        _task : an instance of TaskGroup\n    Methods:\n        __init__ : initializes the TestApp object\n        __aenter__ : enters the asynchronous context and starts the FastStream application\n        __aexit__ : exits the asynchronous context and stops the FastStream application\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n__test__ = False\napp: FastStream\n_extra_options: Optional[Dict[str, SettingField]]\n_event: anyio.Event\n_task: TaskGroup\ndef __init__(\nself,\napp: FastStream,\nrun_extra_options: Optional[Dict[str, SettingField]] = None,\n) -&gt; None:\n\"\"\"Initialize a class instance.\n        Args:\n            app: An instance of the FastStream class.\n            run_extra_options: Optional dictionary of extra options for running the application.\n        Returns:\n            None\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nself.app = app\nself._extra_options = run_extra_options\nasync def __aenter__(self) -&gt; FastStream:\nself.app._stop_event = self._event = anyio.Event()\nawait self.app._start(run_extra_options=self._extra_options)\nself._task = tg = anyio.create_task_group()\nawait tg.__aenter__()\ntg.start_soon(self.app._stop)\nreturn self.app\nasync def __aexit__(\nself,\nexc_type: Optional[Type[BaseException]] = None,\nexc_val: Optional[BaseException] = None,\nexec_tb: Optional[TracebackType] = None,\n) -&gt; None:\n\"\"\"Exit the asynchronous context manager.\n        Args:\n            exc_type: The type of the exception raised, if any.\n            exc_val: The exception instance raised, if any.\n            exec_tb: The traceback for the exception raised, if any.\n        Returns:\n            None\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nself._event.set()\nawait self._task.__aexit__(None, None, None)\n</code></pre>"},{"location":"api/faststream/broker/test/TestApp/#faststream.broker.test.TestApp.app","title":"app  <code>instance-attribute</code>","text":"<pre><code>app: FastStream = app\n</code></pre>"},{"location":"api/faststream/broker/test/call_handler/","title":"Call handler","text":""},{"location":"api/faststream/broker/test/call_handler/#faststream.broker.test.call_handler","title":"faststream.broker.test.call_handler  <code>async</code>","text":"<pre><code>call_handler(\nhandler: AsyncHandler[Any],\nmessage: Any,\nrpc: bool = False,\nrpc_timeout: Optional[float] = 30.0,\nraise_timeout: bool = False,\n) -&gt; Optional[SendableMessage]\n</code></pre> <p>Asynchronously call a handler function.</p> PARAMETER  DESCRIPTION <code>handler</code> <p>The handler function to be called.</p> <p> TYPE: <code>AsyncHandler[Any]</code> </p> <code>message</code> <p>The message to be passed to the handler function.</p> <p> TYPE: <code>Any</code> </p> <code>rpc</code> <p>Whether the call is a remote procedure call (RPC).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>rpc_timeout</code> <p>The timeout for the RPC, in seconds.</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>30.0</code> </p> <code>raise_timeout</code> <p>Whether to raise a timeout error if the RPC times out.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Optional[SendableMessage]</code> <p>The result of the handler function if <code>rpc</code> is True, otherwise None.</p> RAISES DESCRIPTION <code>TimeoutError</code> <p>If the RPC times out and <code>raise_timeout</code> is True.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/test.py</code> <pre><code>async def call_handler(\nhandler: AsyncHandler[Any],\nmessage: Any,\nrpc: bool = False,\nrpc_timeout: Optional[float] = 30.0,\nraise_timeout: bool = False,\n) -&gt; Optional[SendableMessage]:\n\"\"\"Asynchronously call a handler function.\n    Args:\n        handler: The handler function to be called.\n        message: The message to be passed to the handler function.\n        rpc: Whether the call is a remote procedure call (RPC).\n        rpc_timeout: The timeout for the RPC, in seconds.\n        raise_timeout: Whether to raise a timeout error if the RPC times out.\n    Returns:\n        The result of the handler function if `rpc` is True, otherwise None.\n    Raises:\n        TimeoutError: If the RPC times out and `raise_timeout` is True.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nscope: Callable[[Optional[float]], ContextManager[CancelScope]]\nif raise_timeout:\nscope = anyio.fail_after\nelse:\nscope = anyio.move_on_after\nwith scope(rpc_timeout):\nresult = await handler.consume(message)\nif rpc is True:\nreturn result\nreturn None\n</code></pre>"},{"location":"api/faststream/broker/test/patch_broker_calls/","title":"Patch broker calls","text":""},{"location":"api/faststream/broker/test/patch_broker_calls/#faststream.broker.test.patch_broker_calls","title":"faststream.broker.test.patch_broker_calls","text":"<pre><code>patch_broker_calls(broker: BrokerUsecase[Any, Any]) -&gt; None\n</code></pre> <p>Patch broker calls.</p> PARAMETER  DESCRIPTION <code>broker</code> <p>The broker to patch.</p> <p> TYPE: <code>BrokerUsecase[Any, Any]</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/test.py</code> <pre><code>def patch_broker_calls(broker: BrokerUsecase[Any, Any]) -&gt; None:\n\"\"\"Patch broker calls.\n    Args:\n        broker: The broker to patch.\n    Returns:\n        None.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nbroker.middlewares = filter(  # type: ignore[assignment]\nlambda x: not isinstance(x, CriticalLogMiddleware), broker.middlewares\n)\nfor handler in broker.handlers.values():\nfor f, _, _, _, _, _ in handler.calls:\nf.refresh(with_mock=False)\n</code></pre>"},{"location":"api/faststream/broker/types/AsyncPublisherProtocol/","title":"AsyncPublisherProtocol","text":""},{"location":"api/faststream/broker/types/AsyncPublisherProtocol/#faststream.broker.types.AsyncPublisherProtocol","title":"faststream.broker.types.AsyncPublisherProtocol","text":"<p>             Bases: <code>Protocol</code></p> <p>A protocol for an asynchronous publisher.</p> METHOD DESCRIPTION <code>publish</code> <p>SendableMessage, correlation_id: Optional[str] = None, **kwargs: Any) -&gt; Optional[SendableMessage]: Publishes a message asynchronously.</p> <p>Args:     message: The message to be published.     correlation_id: The correlation ID for the message (optional).     **kwargs: Additional keyword arguments.</p> <p>Returns:     The published message (optional).</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/types.py</code> <pre><code>class AsyncPublisherProtocol(Protocol):\n\"\"\"A protocol for an asynchronous publisher.\n    Methods:\n        publish(message: SendableMessage, correlation_id: Optional[str] = None, **kwargs: Any) -&gt; Optional[SendableMessage]:\n            Publishes a message asynchronously.\n            Args:\n                message: The message to be published.\n                correlation_id: The correlation ID for the message (optional).\n                **kwargs: Additional keyword arguments.\n            Returns:\n                The published message (optional).\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nasync def publish(\nself,\nmessage: SendableMessage,\ncorrelation_id: Optional[str] = None,\n**kwargs: Any,\n) -&gt; Optional[SendableMessage]:\n\"\"\"Publishes a message.\n        Args:\n            message: The message to be published.\n            correlation_id: Optional correlation ID for the message.\n            **kwargs: Additional keyword arguments.\n        Returns:\n            The published message, or None if the message was not published.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\n...\n</code></pre>"},{"location":"api/faststream/broker/types/AsyncPublisherProtocol/#faststream.broker.types.AsyncPublisherProtocol.publish","title":"publish  <code>async</code>","text":"<pre><code>publish(\nmessage: SendableMessage,\ncorrelation_id: Optional[str] = None,\n**kwargs: Any\n) -&gt; Optional[SendableMessage]\n</code></pre> <p>Publishes a message.</p> PARAMETER  DESCRIPTION <code>message</code> <p>The message to be published.</p> <p> TYPE: <code>SendableMessage</code> </p> <code>correlation_id</code> <p>Optional correlation ID for the message.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>**kwargs</code> <p>Additional keyword arguments.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Optional[SendableMessage]</code> <p>The published message, or None if the message was not published.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/types.py</code> <pre><code>async def publish(\nself,\nmessage: SendableMessage,\ncorrelation_id: Optional[str] = None,\n**kwargs: Any,\n) -&gt; Optional[SendableMessage]:\n\"\"\"Publishes a message.\n    Args:\n        message: The message to be published.\n        correlation_id: Optional correlation ID for the message.\n        **kwargs: Additional keyword arguments.\n    Returns:\n        The published message, or None if the message was not published.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n...\n</code></pre>"},{"location":"api/faststream/broker/utils/change_logger_handlers/","title":"Change logger handlers","text":""},{"location":"api/faststream/broker/utils/change_logger_handlers/#faststream.broker.utils.change_logger_handlers","title":"faststream.broker.utils.change_logger_handlers","text":"<pre><code>change_logger_handlers(\nlogger: logging.Logger, fmt: str\n) -&gt; None\n</code></pre> <p>Change the formatter of the logger handlers.</p> PARAMETER  DESCRIPTION <code>logger</code> <p>The logger object.</p> <p> TYPE: <code>Logger</code> </p> <code>fmt</code> <p>The format string for the formatter.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/utils.py</code> <pre><code>def change_logger_handlers(logger: logging.Logger, fmt: str) -&gt; None:\n\"\"\"Change the formatter of the logger handlers.\n    Args:\n        logger (logging.Logger): The logger object.\n        fmt (str): The format string for the formatter.\n    Returns:\n        None\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nfor handler in logger.handlers:\nformatter = handler.formatter\nif formatter is not None:\nuse_colors = getattr(formatter, \"use_colors\", None)\nif use_colors is not None:\nkwargs = {\"use_colors\": use_colors}\nelse:\nkwargs = {}\nhandler.setFormatter(type(formatter)(fmt, **kwargs))\n</code></pre>"},{"location":"api/faststream/broker/utils/get_watcher/","title":"Get watcher","text":""},{"location":"api/faststream/broker/utils/get_watcher/#faststream.broker.utils.get_watcher","title":"faststream.broker.utils.get_watcher","text":"<pre><code>get_watcher(\nlogger: Optional[logging.Logger],\ntry_number: Union[bool, int] = True,\n) -&gt; BaseWatcher\n</code></pre> <p>Get a watcher object based on the provided parameters.</p> PARAMETER  DESCRIPTION <code>logger</code> <p>Optional logger object for logging messages.</p> <p> TYPE: <code>Optional[Logger]</code> </p> <code>try_number</code> <p>Optional parameter to specify the type of watcher. - If set to True, an EndlessWatcher object will be returned. - If set to False, a OneTryWatcher object will be returned. - If set to an integer, a CounterWatcher object with the specified maximum number of tries will be returned.</p> <p> TYPE: <code>Union[bool, int]</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>BaseWatcher</code> <p>A watcher object based on the provided parameters.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/utils.py</code> <pre><code>def get_watcher(\nlogger: Optional[logging.Logger],\ntry_number: Union[bool, int] = True,\n) -&gt; BaseWatcher:\n\"\"\"Get a watcher object based on the provided parameters.\n    Args:\n        logger: Optional logger object for logging messages.\n        try_number: Optional parameter to specify the type of watcher.\n            - If set to True, an EndlessWatcher object will be returned.\n            - If set to False, a OneTryWatcher object will be returned.\n            - If set to an integer, a CounterWatcher object with the specified maximum number of tries will be returned.\n    Returns:\n        A watcher object based on the provided parameters.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nwatcher: Optional[BaseWatcher]\nif try_number is True:\nwatcher = EndlessWatcher()\nelif try_number is False:\nwatcher = OneTryWatcher()\nelse:\nwatcher = CounterWatcher(logger=logger, max_tries=try_number)\nreturn watcher\n</code></pre>"},{"location":"api/faststream/broker/utils/set_message_context/","title":"Set message context","text":""},{"location":"api/faststream/broker/utils/set_message_context/#faststream.broker.utils.set_message_context","title":"faststream.broker.utils.set_message_context","text":"<pre><code>set_message_context(\nfunc: Callable[\n[StreamMessage[MsgType]],\nAwaitable[WrappedReturn[T_HandlerReturn]],\n]\n) -&gt; Callable[\n[StreamMessage[MsgType]],\nAwaitable[WrappedReturn[T_HandlerReturn]],\n]\n</code></pre> <p>Sets the message context for a function.</p> PARAMETER  DESCRIPTION <code>func</code> <p>The function to set the message context for.</p> <p> TYPE: <code>Callable[[StreamMessage[MsgType]], Awaitable[WrappedReturn[T_HandlerReturn]]]</code> </p> RETURNS DESCRIPTION <code>Callable[[StreamMessage[MsgType]], Awaitable[WrappedReturn[T_HandlerReturn]]]</code> <p>The function with the message context set.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/utils.py</code> <pre><code>def set_message_context(\nfunc: Callable[\n[StreamMessage[MsgType]],\nAwaitable[WrappedReturn[T_HandlerReturn]],\n],\n) -&gt; Callable[[StreamMessage[MsgType]], Awaitable[WrappedReturn[T_HandlerReturn]]]:\n\"\"\"Sets the message context for a function.\n    Args:\n        func: The function to set the message context for.\n    Returns:\n        The function with the message context set.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n@wraps(func)\nasync def set_message_wrapper(\nmessage: StreamMessage[MsgType],\n) -&gt; WrappedReturn[T_HandlerReturn]:\n\"\"\"Wraps a function that handles a stream message.\n        Args:\n            message: The stream message to be handled.\n        Returns:\n            The wrapped return value of the handler function.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nwith context.scope(\"message\", message):\nreturn await func(message)\nreturn set_message_wrapper\n</code></pre>"},{"location":"api/faststream/broker/wrapper/FakePublisher/","title":"FakePublisher","text":""},{"location":"api/faststream/broker/wrapper/FakePublisher/#faststream.broker.wrapper.FakePublisher","title":"faststream.broker.wrapper.FakePublisher","text":"<p>A class to represent a fake publisher.</p> METHOD DESCRIPTION <code>publish </code> <p>asynchronously publishes a message with optional correlation ID and additional keyword arguments</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/wrapper.py</code> <pre><code>class FakePublisher:\n\"\"\"A class to represent a fake publisher.\n    Attributes:\n        method : a callable method that takes arguments and returns an awaitable sendable message\n    Methods:\n        publish : asynchronously publishes a message with optional correlation ID and additional keyword arguments\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\ndef __init__(self, method: Callable[..., Awaitable[SendableMessage]]) -&gt; None:\n\"\"\"Initialize an object.\n        Args:\n            method: A callable that takes any number of arguments and returns an awaitable sendable message.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nself.method = method\nasync def publish(\nself,\nmessage: SendableMessage,\ncorrelation_id: Optional[str] = None,\n**kwargs: Any,\n) -&gt; Optional[SendableMessage]:\n\"\"\"Publish a message.\n        Args:\n            message: The message to be published.\n            correlation_id: Optional correlation ID for the message.\n            **kwargs: Additional keyword arguments.\n        Returns:\n            The published message.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nreturn await self.method(message, correlation_id=correlation_id, **kwargs)\n</code></pre>"},{"location":"api/faststream/broker/wrapper/FakePublisher/#faststream.broker.wrapper.FakePublisher.method","title":"method  <code>instance-attribute</code>","text":"<pre><code>method = method\n</code></pre>"},{"location":"api/faststream/broker/wrapper/FakePublisher/#faststream.broker.wrapper.FakePublisher.publish","title":"publish  <code>async</code>","text":"<pre><code>publish(\nmessage: SendableMessage,\ncorrelation_id: Optional[str] = None,\n**kwargs: Any\n) -&gt; Optional[SendableMessage]\n</code></pre> <p>Publish a message.</p> PARAMETER  DESCRIPTION <code>message</code> <p>The message to be published.</p> <p> TYPE: <code>SendableMessage</code> </p> <code>correlation_id</code> <p>Optional correlation ID for the message.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>**kwargs</code> <p>Additional keyword arguments.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Optional[SendableMessage]</code> <p>The published message.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/wrapper.py</code> <pre><code>async def publish(\nself,\nmessage: SendableMessage,\ncorrelation_id: Optional[str] = None,\n**kwargs: Any,\n) -&gt; Optional[SendableMessage]:\n\"\"\"Publish a message.\n    Args:\n        message: The message to be published.\n        correlation_id: Optional correlation ID for the message.\n        **kwargs: Additional keyword arguments.\n    Returns:\n        The published message.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nreturn await self.method(message, correlation_id=correlation_id, **kwargs)\n</code></pre>"},{"location":"api/faststream/broker/wrapper/HandlerCallWrapper/","title":"HandlerCallWrapper","text":""},{"location":"api/faststream/broker/wrapper/HandlerCallWrapper/#faststream.broker.wrapper.HandlerCallWrapper","title":"faststream.broker.wrapper.HandlerCallWrapper","text":"<p>             Bases: <code>Generic[MsgType, P_HandlerParams, T_HandlerReturn]</code></p> <p>A generic class to wrap handler calls.</p> METHOD DESCRIPTION <code>__new__ </code> <p>Create a new instance of the class</p> <code>__init__ </code> <p>Initialize the instance</p> <code>__call__ </code> <p>Call the wrapped handler</p> <code>set_wrapped </code> <p>Set the wrapped handler call</p> <code>call_wrapped </code> <p>Call the wrapped handler</p> <code>wait_call </code> <p>Wait for the handler call to complete</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/wrapper.py</code> <pre><code>class HandlerCallWrapper(Generic[MsgType, P_HandlerParams, T_HandlerReturn]):\n\"\"\"A generic class to wrap handler calls.\n    Attributes:\n        mock : MagicMock object used for mocking\n        event : an anyio.Event object used for synchronization\n        _wrapped_call : WrappedHandlerCall object representing the wrapped handler call\n        _original_call : original handler call\n        _publishers : list of AsyncPublisherProtocol objects\n    Methods:\n        __new__ : Create a new instance of the class\n        __init__ : Initialize the instance\n        __call__ : Call the wrapped handler\n        set_wrapped : Set the wrapped handler call\n        call_wrapped : Call the wrapped handler\n        wait_call : Wait for the handler call to complete\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nmock: MagicMock\nevent: Optional[anyio.Event]\nfuture: Optional[\"asyncio.Future[Any]\"]\n_wrapped_call: Optional[WrappedHandlerCall[MsgType, T_HandlerReturn]]\n_original_call: Callable[P_HandlerParams, T_HandlerReturn]\n_publishers: List[AsyncPublisherProtocol]\ndef __new__(\ncls,\ncall: Union[\n\"HandlerCallWrapper[MsgType, P_HandlerParams, T_HandlerReturn]\",\nCallable[P_HandlerParams, T_HandlerReturn],\n],\n) -&gt; Self:\n\"\"\"Create a new instance of the class.\n        Args:\n            call: An instance of \"HandlerCallWrapper\" or a callable object\n        Returns:\n            An instance of the class\n        Note:\n            If the \"call\" argument is already an instance of the class, it is returned as is. Otherwise, a new instance of the class is created using the superclass's __new__ method.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nif isinstance(call, cls):\nreturn call\nelse:\nreturn super().__new__(cls)\ndef __init__(\nself,\ncall: Callable[P_HandlerParams, T_HandlerReturn],\n):\n\"\"\"Initialize a handler.\n        Args:\n            call: A callable object that represents the handler function.\n        Attributes:\n            _original_call: The original handler function.\n            _wrapped_call: The wrapped handler function.\n            _publishers: A list of publishers.\n            mock: A MagicMock object.\n            event: The event associated with the handler.\n            __name__: The name of the handler function.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nif not isinstance(call, HandlerCallWrapper):\nself._original_call = call\nself._wrapped_call = None\nself._publishers = []\nself.mock = MagicMock()\nself.event = None\nself.__name__ = getattr(self._original_call, \"__name__\", \"undefined\")\ndef __call__(\nself,\n*args: P_HandlerParams.args,\n**kwargs: P_HandlerParams.kwargs,\n) -&gt; T_HandlerReturn:\n\"\"\"Calls the object as a function.\n        Args:\n            *args: Positional arguments to be passed to the function.\n            **kwargs: Keyword arguments to be passed to the function.\n        Returns:\n            The return value of the function.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nself.mock(*args, **kwargs)\nreturn self._original_call(*args, **kwargs)\ndef set_wrapped(\nself, wrapped: WrappedHandlerCall[MsgType, T_HandlerReturn]\n) -&gt; None:\n\"\"\"Set the wrapped handler call.\n        Args:\n            wrapped: The wrapped handler call to set\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nself._wrapped_call = wrapped\ndef call_wrapped(\nself,\nmessage: StreamMessage[MsgType],\n) -&gt; Union[\nOptional[WrappedReturn[T_HandlerReturn]],\nAwaitable[Optional[WrappedReturn[T_HandlerReturn]]],\n]:\n\"\"\"Calls the wrapped function with the given message.\n        Args:\n            message: The message to be passed to the wrapped function.\n        Returns:\n            The result of the wrapped function call.\n        Raises:\n            AssertionError: If `set_wrapped` has not been called before calling this function.\n            AssertionError: If the broker has not been started before calling this function.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nassert self._wrapped_call, \"You should use `set_wrapped` first\"  # nosec B101\nself.mock(message.decoded_body)\nreturn self._wrapped_call(message)\nasync def wait_call(self, timeout: Optional[float] = None) -&gt; None:\n\"\"\"Waits for a call with an optional timeout.\n        Args:\n            timeout: Optional timeout in seconds\n        Raises:\n            AssertionError: If the broker is not started\n        Returns:\n            None\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nassert (\nself.event and self.future\n), \"You should start the broker first\"  # nosec B101\nwith anyio.fail_after(timeout):\nawait self.future\ndef trigger(\nself,\nresult: Any = None,\nerror: Optional[BaseException] = None,\n) -&gt; None:\nassert (\nself.event and self.future\n), \"You should start the broker first\"  # nosec B101\nself.event.set()\nif self.future.done():\nself.future = asyncio.Future()\nif error:\nself.future.set_exception(error)\nelse:\nself.future.set_result(result)\ndef refresh(self, with_mock: bool = False) -&gt; None:\nself.event = anyio.Event()\nself.future = asyncio.Future()\nif with_mock:\nself.mock.reset_mock()\n</code></pre>"},{"location":"api/faststream/broker/wrapper/HandlerCallWrapper/#faststream.broker.wrapper.HandlerCallWrapper.event","title":"event  <code>instance-attribute</code>","text":"<pre><code>event: Optional[anyio.Event]\n</code></pre>"},{"location":"api/faststream/broker/wrapper/HandlerCallWrapper/#faststream.broker.wrapper.HandlerCallWrapper.future","title":"future  <code>instance-attribute</code>","text":"<pre><code>future: Optional[asyncio.Future[Any]]\n</code></pre>"},{"location":"api/faststream/broker/wrapper/HandlerCallWrapper/#faststream.broker.wrapper.HandlerCallWrapper.mock","title":"mock  <code>instance-attribute</code>","text":"<pre><code>mock: MagicMock\n</code></pre>"},{"location":"api/faststream/broker/wrapper/HandlerCallWrapper/#faststream.broker.wrapper.HandlerCallWrapper.call_wrapped","title":"call_wrapped","text":"<pre><code>call_wrapped(\nmessage: StreamMessage[MsgType],\n) -&gt; Union[\nOptional[WrappedReturn[T_HandlerReturn]],\nAwaitable[Optional[WrappedReturn[T_HandlerReturn]]],\n]\n</code></pre> <p>Calls the wrapped function with the given message.</p> PARAMETER  DESCRIPTION <code>message</code> <p>The message to be passed to the wrapped function.</p> <p> TYPE: <code>StreamMessage[MsgType]</code> </p> RETURNS DESCRIPTION <code>Union[Optional[WrappedReturn[T_HandlerReturn]], Awaitable[Optional[WrappedReturn[T_HandlerReturn]]]]</code> <p>The result of the wrapped function call.</p> RAISES DESCRIPTION <code>AssertionError</code> <p>If <code>set_wrapped</code> has not been called before calling this function.</p> <code>AssertionError</code> <p>If the broker has not been started before calling this function.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/wrapper.py</code> <pre><code>def call_wrapped(\nself,\nmessage: StreamMessage[MsgType],\n) -&gt; Union[\nOptional[WrappedReturn[T_HandlerReturn]],\nAwaitable[Optional[WrappedReturn[T_HandlerReturn]]],\n]:\n\"\"\"Calls the wrapped function with the given message.\n    Args:\n        message: The message to be passed to the wrapped function.\n    Returns:\n        The result of the wrapped function call.\n    Raises:\n        AssertionError: If `set_wrapped` has not been called before calling this function.\n        AssertionError: If the broker has not been started before calling this function.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nassert self._wrapped_call, \"You should use `set_wrapped` first\"  # nosec B101\nself.mock(message.decoded_body)\nreturn self._wrapped_call(message)\n</code></pre>"},{"location":"api/faststream/broker/wrapper/HandlerCallWrapper/#faststream.broker.wrapper.HandlerCallWrapper.refresh","title":"refresh","text":"<pre><code>refresh(with_mock: bool = False) -&gt; None\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/wrapper.py</code> <pre><code>def refresh(self, with_mock: bool = False) -&gt; None:\nself.event = anyio.Event()\nself.future = asyncio.Future()\nif with_mock:\nself.mock.reset_mock()\n</code></pre>"},{"location":"api/faststream/broker/wrapper/HandlerCallWrapper/#faststream.broker.wrapper.HandlerCallWrapper.set_wrapped","title":"set_wrapped","text":"<pre><code>set_wrapped(\nwrapped: WrappedHandlerCall[MsgType, T_HandlerReturn]\n) -&gt; None\n</code></pre> <p>Set the wrapped handler call.</p> PARAMETER  DESCRIPTION <code>wrapped</code> <p>The wrapped handler call to set</p> <p> TYPE: <code>WrappedHandlerCall[MsgType, T_HandlerReturn]</code> </p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/wrapper.py</code> <pre><code>def set_wrapped(\nself, wrapped: WrappedHandlerCall[MsgType, T_HandlerReturn]\n) -&gt; None:\n\"\"\"Set the wrapped handler call.\n    Args:\n        wrapped: The wrapped handler call to set\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nself._wrapped_call = wrapped\n</code></pre>"},{"location":"api/faststream/broker/wrapper/HandlerCallWrapper/#faststream.broker.wrapper.HandlerCallWrapper.trigger","title":"trigger","text":"<pre><code>trigger(\nresult: Any = None,\nerror: Optional[BaseException] = None,\n) -&gt; None\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/wrapper.py</code> <pre><code>def trigger(\nself,\nresult: Any = None,\nerror: Optional[BaseException] = None,\n) -&gt; None:\nassert (\nself.event and self.future\n), \"You should start the broker first\"  # nosec B101\nself.event.set()\nif self.future.done():\nself.future = asyncio.Future()\nif error:\nself.future.set_exception(error)\nelse:\nself.future.set_result(result)\n</code></pre>"},{"location":"api/faststream/broker/wrapper/HandlerCallWrapper/#faststream.broker.wrapper.HandlerCallWrapper.wait_call","title":"wait_call  <code>async</code>","text":"<pre><code>wait_call(timeout: Optional[float] = None) -&gt; None\n</code></pre> <p>Waits for a call with an optional timeout.</p> PARAMETER  DESCRIPTION <code>timeout</code> <p>Optional timeout in seconds</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>AssertionError</code> <p>If the broker is not started</p> RETURNS DESCRIPTION <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/broker/wrapper.py</code> <pre><code>async def wait_call(self, timeout: Optional[float] = None) -&gt; None:\n\"\"\"Waits for a call with an optional timeout.\n    Args:\n        timeout: Optional timeout in seconds\n    Raises:\n        AssertionError: If the broker is not started\n    Returns:\n        None\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nassert (\nself.event and self.future\n), \"You should start the broker first\"  # nosec B101\nwith anyio.fail_after(timeout):\nawait self.future\n</code></pre>"},{"location":"api/faststream/cli/docs/app/gen/","title":"Gen","text":""},{"location":"api/faststream/cli/docs/app/gen/#faststream.cli.docs.app.gen","title":"faststream.cli.docs.app.gen","text":"<pre><code>gen(\napp: str = typer.Argument(\n...,\nhelp=\"[python_module:FastStream] - path to your application\",\n),\nyaml: bool = typer.Option(\nFalse,\n\"--yaml\",\nis_flag=True,\nhelp=\"generate `asyncapi.yaml` schema\",\n),\nout: Optional[str] = typer.Option(\nNone, help=\"output filename\"\n),\n) -&gt; None\n</code></pre> <p>Generate project AsyncAPI schema</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/cli/docs/app.py</code> <pre><code>@docs_app.command(name=\"gen\")\ndef gen(\napp: str = typer.Argument(\n...,\nhelp=\"[python_module:FastStream] - path to your application\",\n),\nyaml: bool = typer.Option(\nFalse,\n\"--yaml\",\nis_flag=True,\nhelp=\"generate `asyncapi.yaml` schema\",\n),\nout: Optional[str] = typer.Option(\nNone,\nhelp=\"output filename\",\n),\n) -&gt; None:\n\"\"\"Generate project AsyncAPI schema\"\"\"\nif \":\" in app:\nmodule, app = get_app_path(app)\nsys.path.insert(0, str(module.parent))\napp_obj = try_import_app(module, app)\nraw_schema = get_app_schema(app_obj)\nelse:\nschema_filepath = Path.cwd() / app\nraw_schema = model_parse(Schema, schema_filepath.read_text())\nif yaml:\ntry:\nschema = raw_schema.to_yaml()\nexcept ImportError as e:  # pragma: no cover\ntyper.echo(INSTALL_YAML, err=True)\nraise typer.Exit(1) from e\nname = out or \"asyncapi.yaml\"\nwith open(name, \"w\") as f:\nf.write(schema)\nelse:\nschema = raw_schema.to_jsonable()\nname = out or \"asyncapi.json\"\nwith open(name, \"w\") as f:\njson.dump(schema, f, indent=2)\ntyper.echo(f\"Your project AsyncAPI scheme was placed to `{name}`\")\n</code></pre>"},{"location":"api/faststream/cli/docs/app/serve/","title":"Serve","text":""},{"location":"api/faststream/cli/docs/app/serve/#faststream.cli.docs.app.serve","title":"faststream.cli.docs.app.serve","text":"<pre><code>serve(\napp: str = typer.Argument(\n...,\nhelp=\"[python_module:FastStream] or [asyncapi.yaml/.json] - path to your application or documentation\",\n),\nhost: str = typer.Option(\n\"localhost\", help=\"documentation hosting address\"\n),\nport: int = typer.Option(\n8000, help=\"documentation hosting port\"\n),\n) -&gt; None\n</code></pre> <p>Serve project AsyncAPI schema</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/cli/docs/app.py</code> <pre><code>@docs_app.command(name=\"serve\")\ndef serve(\napp: str = typer.Argument(\n...,\nhelp=\"[python_module:FastStream] or [asyncapi.yaml/.json] - path to your application or documentation\",\n),\nhost: str = typer.Option(\n\"localhost\",\nhelp=\"documentation hosting address\",\n),\nport: int = typer.Option(\n8000,\nhelp=\"documentation hosting port\",\n),\n) -&gt; None:\n\"\"\"Serve project AsyncAPI schema\"\"\"\nif \":\" in app:\nmodule, app = get_app_path(app)\nsys.path.insert(0, str(module.parent))\napp_obj = try_import_app(module, app)\nraw_schema = get_app_schema(app_obj)\nelse:\nschema_filepath = Path.cwd() / app\nif schema_filepath.suffix == \".json\":\ndata = schema_filepath.read_text()\nelif schema_filepath.suffix == \".yaml\" or schema_filepath.suffix == \".yml\":\ntry:\nimport yaml\nexcept ImportError as e:  # pragma: no cover\ntyper.echo(INSTALL_YAML, err=True)\nraise typer.Exit(1) from e\nwith schema_filepath.open(\"r\") as f:\nschema = yaml.safe_load(f)\ndata = json.dumps(schema)\nelse:\nraise ValueError(\nf\"Unknown extension given - {app}; Please provide app in format [python_module:FastStream] or [asyncapi.yaml/.json] - path to your application or documentation\"\n)\nraw_schema = model_parse(Schema, data)\nserve_app(\nschema=raw_schema,\nhost=host,\nport=port,\n)\n</code></pre>"},{"location":"api/faststream/cli/main/main/","title":"Main","text":""},{"location":"api/faststream/cli/main/main/#faststream.cli.main.main","title":"faststream.cli.main.main","text":"<pre><code>main(\nversion: Optional[bool] = typer.Option(\nFalse,\n\"-v\",\n\"--version\",\ncallback=version_callback,\nis_eager=True,\nhelp=\"Show current platform, python and FastStream version\",\n)\n) -&gt; None\n</code></pre> <p>Generate, run and manage FastStream apps to greater development experience</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/cli/main.py</code> <pre><code>@cli.callback()\ndef main(\nversion: Optional[bool] = typer.Option(\nFalse,\n\"-v\",\n\"--version\",\ncallback=version_callback,\nis_eager=True,\nhelp=\"Show current platform, python and FastStream version\",\n)\n) -&gt; None:\n\"\"\"\n    Generate, run and manage FastStream apps to greater development experience\n    \"\"\"\n</code></pre>"},{"location":"api/faststream/cli/main/run/","title":"Run","text":""},{"location":"api/faststream/cli/main/run/#faststream.cli.main.run","title":"faststream.cli.main.run","text":"<pre><code>run(\nctx: typer.Context,\napp: str = typer.Argument(\n...,\nhelp=\"[python_module:FastStream] - path to your application\",\n),\nworkers: int = typer.Option(\n1,\nshow_default=False,\nhelp=\"Run [workers] applications with process spawning\",\n),\nlog_level: LogLevels = typer.Option(\nLogLevels.info,\ncase_sensitive=False,\nshow_default=False,\nhelp=\"[INFO] default\",\n),\nreload: bool = typer.Option(\nFalse,\n\"--reload\",\nis_flag=True,\nhelp=\"Restart app at directory files changes\",\n),\napp_dir: str = typer.Option(\n\".\",\n\"--app-dir\",\nhelp=\"Look for APP in the specified directory, by adding this to the PYTHONPATH. Defaults to the current working directory.\",\n),\n) -&gt; None\n</code></pre> <p>Run [MODULE:APP] FastStream application</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/cli/main.py</code> <pre><code>@cli.command(\ncontext_settings={\"allow_extra_args\": True, \"ignore_unknown_options\": True}\n)\ndef run(\nctx: typer.Context,\napp: str = typer.Argument(\n...,\nhelp=\"[python_module:FastStream] - path to your application\",\n),\nworkers: int = typer.Option(\n1,\nshow_default=False,\nhelp=\"Run [workers] applications with process spawning\",\n),\nlog_level: LogLevels = typer.Option(\nLogLevels.info,\ncase_sensitive=False,\nshow_default=False,\nhelp=\"[INFO] default\",\n),\nreload: bool = typer.Option(\nFalse,\n\"--reload\",\nis_flag=True,\nhelp=\"Restart app at directory files changes\",\n),\napp_dir: str = typer.Option(\n\".\",\n\"--app-dir\",\nhelp=(\n\"Look for APP in the specified directory, by adding this to the PYTHONPATH.\"\n\" Defaults to the current working directory.\"\n),\n),\n) -&gt; None:\n\"\"\"Run [MODULE:APP] FastStream application\"\"\"\napp, extra = parse_cli_args(app, *ctx.args)\ncasted_log_level = get_log_level(log_level)\nmodule, app = get_app_path(app)\nif app_dir:\nsys.path.insert(0, app_dir)\nargs = (module, app, extra, casted_log_level)\nif reload and workers &gt; 1:\nraise ValueError(\"You can't use reload option with multiprocessing\")\nif reload is True:\nfrom faststream.cli.supervisors.watchfiles import WatchReloader\nWatchReloader(target=_run, args=args, reload_dirs=(str(module.parent),)).run()\nelif workers &gt; 1:\nfrom faststream.cli.supervisors.multiprocess import Multiprocess\nMultiprocess(target=_run, args=(*args, logging.DEBUG), workers=workers).run()\nelse:\n_run(module=module, app=app, extra_options=extra, log_level=casted_log_level)\n</code></pre>"},{"location":"api/faststream/cli/main/version_callback/","title":"Version callback","text":""},{"location":"api/faststream/cli/main/version_callback/#faststream.cli.main.version_callback","title":"faststream.cli.main.version_callback","text":"<pre><code>version_callback(version: bool) -&gt; None\n</code></pre> <p>Callback function for displaying version information.</p> PARAMETER  DESCRIPTION <code>version</code> <p>If True, display version information</p> <p> TYPE: <code>bool</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/cli/main.py</code> <pre><code>def version_callback(version: bool) -&gt; None:\n\"\"\"Callback function for displaying version information.\n    Args:\n        version: If True, display version information\n    Returns:\n        None\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nif version is True:\nimport platform\ntyper.echo(\n\"Running FastStream %s with %s %s on %s\"\n% (\n__version__,\nplatform.python_implementation(),\nplatform.python_version(),\nplatform.system(),\n)\n)\nraise typer.Exit()\n</code></pre>"},{"location":"api/faststream/cli/supervisors/basereload/BaseReload/","title":"BaseReload","text":""},{"location":"api/faststream/cli/supervisors/basereload/BaseReload/#faststream.cli.supervisors.basereload.BaseReload","title":"faststream.cli.supervisors.basereload.BaseReload","text":"<p>A base class for implementing a reloader process.</p> METHOD DESCRIPTION <code>__init__</code> <p>DecoratedCallable, args: Tuple[Any, ...], reload_delay: Optional[float] = 0.5) -&gt; None: Initializes the BaseReload object.</p> <code>run</code> <p>Runs the reloader process.</p> <code>startup</code> <p>Performs startup operations for the reloader process.</p> <code>restart</code> <p>Restarts the process.</p> <code>shutdown</code> <p>Shuts down the reloader process.</p> <code>_stop_process</code> <p>Stops the spawned process.</p> <code>_start_process</code> <p>Starts the spawned process.</p> <code>should_restart</code> <p>Determines whether the process should be restarted.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/cli/supervisors/basereload.py</code> <pre><code>class BaseReload:\n\"\"\"A base class for implementing a reloader process.\n    Attributes:\n        _process : The spawned process\n        _target : The target callable function\n        _args : The arguments to be passed to the target function\n        reload_delay : The delay between reloads\n        should_exit : A threading event to signal the reloader to exit\n        pid : The process ID of the reloader\n        reloader_name : The name of the reloader\n    Methods:\n        __init__(self, target: DecoratedCallable, args: Tuple[Any, ...], reload_delay: Optional[float] = 0.5) -&gt; None:\n            Initializes the BaseReload object.\n        run(self) -&gt; None:\n            Runs the reloader process.\n        startup(self) -&gt; None:\n            Performs startup operations for the reloader process.\n        restart(self) -&gt; None:\n            Restarts the process.\n        shutdown(self) -&gt; None:\n            Shuts down the reloader process.\n        _stop_process(self) -&gt; None:\n            Stops the spawned process.\n        _start_process(self) -&gt; SpawnProcess:\n            Starts the spawned process.\n        should_restart(self) -&gt; bool:\n            Determines whether the process should be restarted.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n_process: SpawnProcess\n_target: DecoratedCallable\n_args: Tuple[Any, ...]\nreload_delay: Optional[float]\nshould_exit: threading.Event\npid: int\nreloader_name: str = \"\"\ndef __init__(\nself,\ntarget: DecoratedCallable,\nargs: Tuple[Any, ...],\nreload_delay: Optional[float] = 0.5,\n) -&gt; None:\n\"\"\"Initialize a class instance.\n        Args:\n            target: The target callable object\n            args: Tuple of arguments to be passed to the target callable\n            reload_delay: Optional delay in seconds before reloading the target callable (default is 0.5 seconds)\n        Returns:\n            None\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nself._target = target\nself._args = args\nself.should_exit = threading.Event()\nself.pid = os.getpid()\nself.reload_delay = reload_delay\nset_exit(lambda *_: self.should_exit.set())\ndef run(self) -&gt; None:\nself.startup()\nwhile not self.should_exit.wait(self.reload_delay):\nif self.should_restart():  # pragma: no branch\nself.restart()\nself.shutdown()\ndef startup(self) -&gt; None:\nlogger.info(f\"Started reloader process [{self.pid}] using {self.reloader_name}\")\nself._process = self._start_process()\ndef restart(self) -&gt; None:\nself._stop_process()\nlogger.info(\"Process successfully reloaded\")\nself._process = self._start_process()\ndef shutdown(self) -&gt; None:\nself._stop_process()\nlogger.info(f\"Stopping reloader process [{self.pid}]\")\ndef _stop_process(self) -&gt; None:\nself._process.terminate()\nself._process.join()\ndef _start_process(self) -&gt; SpawnProcess:\nprocess = get_subprocess(target=self._target, args=self._args)\nprocess.start()\nreturn process\ndef should_restart(self) -&gt; bool:\nraise NotImplementedError(\"Reload strategies should override should_restart()\")\n</code></pre>"},{"location":"api/faststream/cli/supervisors/basereload/BaseReload/#faststream.cli.supervisors.basereload.BaseReload.pid","title":"pid  <code>instance-attribute</code>","text":"<pre><code>pid: int = os.getpid()\n</code></pre>"},{"location":"api/faststream/cli/supervisors/basereload/BaseReload/#faststream.cli.supervisors.basereload.BaseReload.reload_delay","title":"reload_delay  <code>instance-attribute</code>","text":"<pre><code>reload_delay: Optional[float] = reload_delay\n</code></pre>"},{"location":"api/faststream/cli/supervisors/basereload/BaseReload/#faststream.cli.supervisors.basereload.BaseReload.reloader_name","title":"reloader_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>reloader_name: str = ''\n</code></pre>"},{"location":"api/faststream/cli/supervisors/basereload/BaseReload/#faststream.cli.supervisors.basereload.BaseReload.should_exit","title":"should_exit  <code>instance-attribute</code>","text":"<pre><code>should_exit: threading.Event = threading.Event()\n</code></pre>"},{"location":"api/faststream/cli/supervisors/basereload/BaseReload/#faststream.cli.supervisors.basereload.BaseReload.restart","title":"restart","text":"<pre><code>restart() -&gt; None\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/cli/supervisors/basereload.py</code> <pre><code>def restart(self) -&gt; None:\nself._stop_process()\nlogger.info(\"Process successfully reloaded\")\nself._process = self._start_process()\n</code></pre>"},{"location":"api/faststream/cli/supervisors/basereload/BaseReload/#faststream.cli.supervisors.basereload.BaseReload.run","title":"run","text":"<pre><code>run() -&gt; None\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/cli/supervisors/basereload.py</code> <pre><code>def run(self) -&gt; None:\nself.startup()\nwhile not self.should_exit.wait(self.reload_delay):\nif self.should_restart():  # pragma: no branch\nself.restart()\nself.shutdown()\n</code></pre>"},{"location":"api/faststream/cli/supervisors/basereload/BaseReload/#faststream.cli.supervisors.basereload.BaseReload.should_restart","title":"should_restart","text":"<pre><code>should_restart() -&gt; bool\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/cli/supervisors/basereload.py</code> <pre><code>def should_restart(self) -&gt; bool:\nraise NotImplementedError(\"Reload strategies should override should_restart()\")\n</code></pre>"},{"location":"api/faststream/cli/supervisors/basereload/BaseReload/#faststream.cli.supervisors.basereload.BaseReload.shutdown","title":"shutdown","text":"<pre><code>shutdown() -&gt; None\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/cli/supervisors/basereload.py</code> <pre><code>def shutdown(self) -&gt; None:\nself._stop_process()\nlogger.info(f\"Stopping reloader process [{self.pid}]\")\n</code></pre>"},{"location":"api/faststream/cli/supervisors/basereload/BaseReload/#faststream.cli.supervisors.basereload.BaseReload.startup","title":"startup","text":"<pre><code>startup() -&gt; None\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/cli/supervisors/basereload.py</code> <pre><code>def startup(self) -&gt; None:\nlogger.info(f\"Started reloader process [{self.pid}] using {self.reloader_name}\")\nself._process = self._start_process()\n</code></pre>"},{"location":"api/faststream/cli/supervisors/multiprocess/Multiprocess/","title":"Multiprocess","text":""},{"location":"api/faststream/cli/supervisors/multiprocess/Multiprocess/#faststream.cli.supervisors.multiprocess.Multiprocess","title":"faststream.cli.supervisors.multiprocess.Multiprocess","text":"<p>             Bases: <code>BaseReload</code></p> <p>A class to represent a multiprocess.</p> METHOD DESCRIPTION <code>startup </code> <p>starts the parent process and creates worker processes</p> <code>shutdown </code> <p>terminates and joins all worker processes, and stops the parent process</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/cli/supervisors/multiprocess.py</code> <pre><code>class Multiprocess(BaseReload):\n\"\"\"A class to represent a multiprocess.\n    Attributes:\n        target : the target function to be executed by each process\n        args : arguments to be passed to the target function\n        workers : number of worker processes\n    Methods:\n        startup : starts the parent process and creates worker processes\n        shutdown : terminates and joins all worker processes, and stops the parent process\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\ndef __init__(\nself,\ntarget: DecoratedCallable,\nargs: Tuple[Any, ...],\nworkers: int,\n) -&gt; None:\n\"\"\"Initialize a new instance of the class.\n        Args:\n            target: The target callable object to be executed.\n            args: The arguments to be passed to the target callable.\n            workers: The number of workers to be used.\n        Returns:\n            None.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nsuper().__init__(target, args, None)\nself.workers = workers\nself.processes: List[SpawnProcess] = []\ndef startup(self) -&gt; None:\nlogger.info(f\"Started parent process [{self.pid}]\")\nfor _ in range(self.workers):\nprocess = self._start_process()\nlogger.info(f\"Started child process [{process.pid}]\")\nself.processes.append(process)\ndef shutdown(self) -&gt; None:\nfor process in self.processes:\nprocess.terminate()\nlogger.info(f\"Stopping child process [{process.pid}]\")\nprocess.join()\nlogger.info(f\"Stopping parent process [{self.pid}]\")\n</code></pre>"},{"location":"api/faststream/cli/supervisors/multiprocess/Multiprocess/#faststream.cli.supervisors.multiprocess.Multiprocess.processes","title":"processes  <code>instance-attribute</code>","text":"<pre><code>processes: List[SpawnProcess] = []\n</code></pre>"},{"location":"api/faststream/cli/supervisors/multiprocess/Multiprocess/#faststream.cli.supervisors.multiprocess.Multiprocess.workers","title":"workers  <code>instance-attribute</code>","text":"<pre><code>workers = workers\n</code></pre>"},{"location":"api/faststream/cli/supervisors/multiprocess/Multiprocess/#faststream.cli.supervisors.multiprocess.Multiprocess.shutdown","title":"shutdown","text":"<pre><code>shutdown() -&gt; None\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/cli/supervisors/multiprocess.py</code> <pre><code>def shutdown(self) -&gt; None:\nfor process in self.processes:\nprocess.terminate()\nlogger.info(f\"Stopping child process [{process.pid}]\")\nprocess.join()\nlogger.info(f\"Stopping parent process [{self.pid}]\")\n</code></pre>"},{"location":"api/faststream/cli/supervisors/multiprocess/Multiprocess/#faststream.cli.supervisors.multiprocess.Multiprocess.startup","title":"startup","text":"<pre><code>startup() -&gt; None\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/cli/supervisors/multiprocess.py</code> <pre><code>def startup(self) -&gt; None:\nlogger.info(f\"Started parent process [{self.pid}]\")\nfor _ in range(self.workers):\nprocess = self._start_process()\nlogger.info(f\"Started child process [{process.pid}]\")\nself.processes.append(process)\n</code></pre>"},{"location":"api/faststream/cli/supervisors/utils/get_subprocess/","title":"Get subprocess","text":""},{"location":"api/faststream/cli/supervisors/utils/get_subprocess/#faststream.cli.supervisors.utils.get_subprocess","title":"faststream.cli.supervisors.utils.get_subprocess","text":"<pre><code>get_subprocess(\ntarget: DecoratedCallableNone, args: Any\n) -&gt; SpawnProcess\n</code></pre> <p>Spawn a subprocess.</p> PARAMETER  DESCRIPTION <code>target</code> <p>The target function to be executed in the subprocess.</p> <p> TYPE: <code>DecoratedCallableNone</code> </p> <code>args</code> <p>The arguments to be passed to the target function.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>SpawnProcess</code> <p>The spawned subprocess.</p> RAISES DESCRIPTION <code>OSError</code> <p>If there is an error getting the file descriptor of sys.stdin.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/cli/supervisors/utils.py</code> <pre><code>def get_subprocess(target: DecoratedCallableNone, args: Any) -&gt; SpawnProcess:\n\"\"\"Spawn a subprocess.\n    Args:\n        target: The target function to be executed in the subprocess.\n        args: The arguments to be passed to the target function.\n    Returns:\n        The spawned subprocess.\n    Raises:\n        OSError: If there is an error getting the file descriptor of sys.stdin.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nstdin_fileno: Optional[int]\ntry:\nstdin_fileno = sys.stdin.fileno()\nexcept OSError:\nstdin_fileno = None\nreturn spawn.Process(\ntarget=subprocess_started,\nargs=args,\nkwargs={\"t\": target, \"stdin_fileno\": stdin_fileno},\n)\n</code></pre>"},{"location":"api/faststream/cli/supervisors/utils/set_exit/","title":"Set exit","text":""},{"location":"api/faststream/cli/supervisors/utils/set_exit/#faststream.cli.supervisors.utils.set_exit","title":"faststream.cli.supervisors.utils.set_exit","text":"<pre><code>set_exit(\nfunc: Callable[[int, Optional[FrameType]], Any]\n) -&gt; None\n</code></pre> <p>Set exit handler for signals.</p> PARAMETER  DESCRIPTION <code>func</code> <p>A callable object that takes an integer and an optional frame type as arguments and returns any value.</p> <p> TYPE: <code>Callable[[int, Optional[FrameType]], Any]</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/cli/supervisors/utils.py</code> <pre><code>def set_exit(func: Callable[[int, Optional[FrameType]], Any]) -&gt; None:\n\"\"\"Set exit handler for signals.\n    Args:\n        func: A callable object that takes an integer and an optional frame type as arguments and returns any value.\n    Returns:\n        None\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nfor sig in HANDLED_SIGNALS:\nsignal.signal(sig, func)\n</code></pre>"},{"location":"api/faststream/cli/supervisors/utils/subprocess_started/","title":"Subprocess started","text":""},{"location":"api/faststream/cli/supervisors/utils/subprocess_started/#faststream.cli.supervisors.utils.subprocess_started","title":"faststream.cli.supervisors.utils.subprocess_started","text":"<pre><code>subprocess_started(\n*args: Any,\nt: DecoratedCallableNone,\nstdin_fileno: Optional[int]\n) -&gt; None\n</code></pre> <p>Start a subprocess.</p> PARAMETER  DESCRIPTION <code>*args</code> <p>Arguments to be passed to the subprocess.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>()</code> </p> <code>t</code> <p>The decorated callable function.</p> <p> TYPE: <code>DecoratedCallableNone</code> </p> <code>stdin_fileno</code> <p>File descriptor for the standard input of the subprocess.</p> <p> TYPE: <code>Optional[int]</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/cli/supervisors/utils.py</code> <pre><code>def subprocess_started(\n*args: Any,\nt: DecoratedCallableNone,\nstdin_fileno: Optional[int],\n) -&gt; None:\n\"\"\"Start a subprocess.\n    Args:\n        *args: Arguments to be passed to the subprocess.\n        t: The decorated callable function.\n        stdin_fileno: File descriptor for the standard input of the subprocess.\n    Returns:\n        None\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nif stdin_fileno is not None:  # pragma: no cover\nsys.stdin = os.fdopen(stdin_fileno)\nt(*args)\n</code></pre>"},{"location":"api/faststream/cli/supervisors/watchfiles/ExtendedFilter/","title":"ExtendedFilter","text":""},{"location":"api/faststream/cli/supervisors/watchfiles/ExtendedFilter/#faststream.cli.supervisors.watchfiles.ExtendedFilter","title":"faststream.cli.supervisors.watchfiles.ExtendedFilter","text":"<p>             Bases: <code>PythonFilter</code></p> <p>A class that extends the <code>watchfiles.PythonFilter</code> class.</p> METHOD DESCRIPTION <code>__init__ </code> <p>Initializes the <code>ExtendedFilter</code> object Args:     ignore_paths : Optional sequence of paths to ignore     extra_extensions : Sequence of extra extensions to include</p> <p>Returns:     None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/cli/supervisors/watchfiles.py</code> <pre><code>class ExtendedFilter(watchfiles.PythonFilter):\n\"\"\"A class that extends the `watchfiles.PythonFilter` class.\n    Attributes:\n        ignore_dirs : Tuple of directories to ignore\n    Methods:\n        __init__ : Initializes the `ExtendedFilter` object\n            Args:\n                ignore_paths : Optional sequence of paths to ignore\n                extra_extensions : Sequence of extra extensions to include\n            Returns:\n                None\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nignore_dirs: Tuple[str, ...]\ndef __init__(\nself,\n*,\nignore_paths: Optional[Sequence[Union[str, Path]]] = None,\nextra_extensions: Sequence[str] = (),\n) -&gt; None:\n\"\"\"Initialize the class.\n        Args:\n            ignore_paths: Optional sequence of paths to ignore.\n            extra_extensions: Sequence of extra extensions.\n        Returns:\n            None\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nsuper().__init__(ignore_paths=ignore_paths, extra_extensions=extra_extensions)\nself.extensions = self.extensions + (\".env\", \".yaml\")\nself.ignore_dirs = self.ignore_dirs + (\n\"venv\",\n\"env\",\n\".github\",\n\".mypy_cache\",\n\".pytest_cache\",\n\".ruff_cache\",\n)\n</code></pre>"},{"location":"api/faststream/cli/supervisors/watchfiles/ExtendedFilter/#faststream.cli.supervisors.watchfiles.ExtendedFilter.extensions","title":"extensions  <code>instance-attribute</code>","text":"<pre><code>extensions = self.extensions + ('.env', '.yaml')\n</code></pre>"},{"location":"api/faststream/cli/supervisors/watchfiles/ExtendedFilter/#faststream.cli.supervisors.watchfiles.ExtendedFilter.ignore_dirs","title":"ignore_dirs  <code>instance-attribute</code>","text":"<pre><code>ignore_dirs: Tuple[str, ...] = self.ignore_dirs + (\n\"venv\",\n\"env\",\n\".github\",\n\".mypy_cache\",\n\".pytest_cache\",\n\".ruff_cache\",\n)\n</code></pre>"},{"location":"api/faststream/cli/supervisors/watchfiles/WatchReloader/","title":"WatchReloader","text":""},{"location":"api/faststream/cli/supervisors/watchfiles/WatchReloader/#faststream.cli.supervisors.watchfiles.WatchReloader","title":"faststream.cli.supervisors.watchfiles.WatchReloader","text":"<p>             Bases: <code>BaseReload</code></p> <p>A class to reload a target function when files in specified directories change.</p> METHOD DESCRIPTION <code>should_restart</code> <p>Checks if any files in the watched directories have changed and returns True if a change is detected, False otherwise.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/cli/supervisors/watchfiles.py</code> <pre><code>class WatchReloader(BaseReload):\n\"\"\"A class to reload a target function when files in specified directories change.\n    Attributes:\n        target : the function to be reloaded\n        args : arguments to be passed to the target function\n        reload_dirs : directories to watch for file changes\n        reload_delay : delay in seconds between each check for file changes\n    Methods:\n        should_restart() -&gt; bool: Checks if any files in the watched directories have changed and returns True if a change is detected, False otherwise.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\ndef __init__(\nself,\ntarget: DecoratedCallable,\nargs: Tuple[Any, ...],\nreload_dirs: Sequence[Union[Path, str]],\nreload_delay: float = 0.3,\n) -&gt; None:\n\"\"\"Initialize a WatchFilesReloader object.\n        Args:\n            target: The target callable to be executed.\n            args: The arguments to be passed to the target callable.\n            reload_dirs: A sequence of directories to watch for changes.\n            reload_delay: The delay in seconds between checking for changes. Default is 0.3.\n        Returns:\n            None.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nsuper().__init__(target, args, reload_delay)\nself.reloader_name = \"WatchFiles\"\nself.watcher = watchfiles.watch(\n*reload_dirs,\nstep=int(reload_delay * 1000),\nwatch_filter=ExtendedFilter(),\nstop_event=self.should_exit,\nyield_on_timeout=True,\n)\ndef should_restart(self) -&gt; bool:\nfor changes in self.watcher:  # pragma: no branch\nif changes:  # pragma: no branch\nunique_paths = {Path(c[1]).name for c in changes}\nmessage = \"WatchReloader detected file change in '%s'. Reloading...\"\nlogger.info(message % tuple(unique_paths))\nreturn True\nreturn False  # pragma: no cover\n</code></pre>"},{"location":"api/faststream/cli/supervisors/watchfiles/WatchReloader/#faststream.cli.supervisors.watchfiles.WatchReloader.reloader_name","title":"reloader_name  <code>instance-attribute</code>","text":"<pre><code>reloader_name = 'WatchFiles'\n</code></pre>"},{"location":"api/faststream/cli/supervisors/watchfiles/WatchReloader/#faststream.cli.supervisors.watchfiles.WatchReloader.watcher","title":"watcher  <code>instance-attribute</code>","text":"<pre><code>watcher = watchfiles.watch(\n*reload_dirs,\nstep=int(reload_delay * 1000),\nwatch_filter=ExtendedFilter(),\nstop_event=self.should_exit,\nyield_on_timeout=True\n)\n</code></pre>"},{"location":"api/faststream/cli/supervisors/watchfiles/WatchReloader/#faststream.cli.supervisors.watchfiles.WatchReloader.should_restart","title":"should_restart","text":"<pre><code>should_restart() -&gt; bool\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/cli/supervisors/watchfiles.py</code> <pre><code>def should_restart(self) -&gt; bool:\nfor changes in self.watcher:  # pragma: no branch\nif changes:  # pragma: no branch\nunique_paths = {Path(c[1]).name for c in changes}\nmessage = \"WatchReloader detected file change in '%s'. Reloading...\"\nlogger.info(message % tuple(unique_paths))\nreturn True\nreturn False  # pragma: no cover\n</code></pre>"},{"location":"api/faststream/cli/utils/imports/get_app_path/","title":"Get app path","text":""},{"location":"api/faststream/cli/utils/imports/get_app_path/#faststream.cli.utils.imports.get_app_path","title":"faststream.cli.utils.imports.get_app_path","text":"<pre><code>get_app_path(app: str) -&gt; Tuple[Path, str]\n</code></pre> <p>Get the application path.</p> PARAMETER  DESCRIPTION <code>app</code> <p>The name of the application in the format \"module:app_name\".</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Tuple[Path, str]</code> <p>Tuple[Path, str]: A tuple containing the path to the module and the name of the application.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the given app is not in the format \"module:app_name\".</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/cli/utils/imports.py</code> <pre><code>def get_app_path(app: str) -&gt; Tuple[Path, str]:\n\"\"\"Get the application path.\n    Args:\n        app (str): The name of the application in the format \"module:app_name\".\n    Returns:\n        Tuple[Path, str]: A tuple containing the path to the module and the name of the application.\n    Raises:\n        ValueError: If the given app is not in the format \"module:app_name\".\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nif \":\" not in app:\nraise ValueError(f\"{app} is not a FastStream\")\nmodule, app_name = app.split(\":\", 2)\nmod_path = Path.cwd()\nfor i in module.split(\".\"):\nmod_path = mod_path / i\nreturn mod_path, app_name\n</code></pre>"},{"location":"api/faststream/cli/utils/imports/import_object/","title":"Import object","text":""},{"location":"api/faststream/cli/utils/imports/import_object/#faststream.cli.utils.imports.import_object","title":"faststream.cli.utils.imports.import_object","text":"<pre><code>import_object(module: Path, app: str) -&gt; object\n</code></pre> <p>Import an object from a module.</p> PARAMETER  DESCRIPTION <code>module</code> <p>The path to the module file.</p> <p> TYPE: <code>Path</code> </p> <code>app</code> <p>The name of the object to import.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>object</code> <p>The imported object.</p> RAISES DESCRIPTION <code>FileNotFoundError</code> <p>If the module file is not found.</p> <code>ValueError</code> <p>If the module has no loader.</p> <code>AttributeError</code> <p>If the object is not found in the module.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/cli/utils/imports.py</code> <pre><code>def import_object(module: Path, app: str) -&gt; object:\n\"\"\"Import an object from a module.\n    Args:\n        module: The path to the module file.\n        app: The name of the object to import.\n    Returns:\n        The imported object.\n    Raises:\n        FileNotFoundError: If the module file is not found.\n        ValueError: If the module has no loader.\n        AttributeError: If the object is not found in the module.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nspec = spec_from_file_location(\n\"mode\",\nf\"{module}.py\",\nsubmodule_search_locations=[str(module.parent.absolute())],\n)\nif spec is None:  # pragma: no cover\nraise FileNotFoundError(module)\nmod = module_from_spec(spec)\nloader = spec.loader\nif loader is None:  # pragma: no cover\nraise ValueError(f\"{spec} has no loader\")\nloader.exec_module(mod)\ntry:\nobj = getattr(mod, app)\nexcept AttributeError as e:\nraise FileNotFoundError(module) from e\nreturn obj\n</code></pre>"},{"location":"api/faststream/cli/utils/imports/try_import_app/","title":"Try import app","text":""},{"location":"api/faststream/cli/utils/imports/try_import_app/#faststream.cli.utils.imports.try_import_app","title":"faststream.cli.utils.imports.try_import_app","text":"<pre><code>try_import_app(module: Path, app: str) -&gt; FastStream\n</code></pre> <p>Tries to import a FastStream app from a module.</p> PARAMETER  DESCRIPTION <code>module</code> <p>Path to the module containing the app.</p> <p> TYPE: <code>Path</code> </p> <code>app</code> <p>Name of the FastStream app.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>FastStream</code> <p>The imported FastStream app object.</p> RAISES DESCRIPTION <code>FileNotFoundError</code> <p>If the module file is not found.</p> <code>BadParameter</code> <p>If the module or app name is not provided correctly.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/cli/utils/imports.py</code> <pre><code>def try_import_app(module: Path, app: str) -&gt; FastStream:\n\"\"\"Tries to import a FastStream app from a module.\n    Args:\n        module: Path to the module containing the app.\n        app: Name of the FastStream app.\n    Returns:\n        The imported FastStream app object.\n    Raises:\n        FileNotFoundError: If the module file is not found.\n        typer.BadParameter: If the module or app name is not provided correctly.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\ntry:\napp_object = import_object(module, app)\nexcept FileNotFoundError as e:\ntyper.echo(e, err=True)\nraise typer.BadParameter(\n\"Please, input module like [python_file:faststream_app_name]\"\n) from e\nelse:\nreturn app_object  # type: ignore\n</code></pre>"},{"location":"api/faststream/cli/utils/logs/LogLevels/","title":"LogLevels","text":""},{"location":"api/faststream/cli/utils/logs/LogLevels/#faststream.cli.utils.logs.LogLevels","title":"faststream.cli.utils.logs.LogLevels","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p> <p>A class to represent log levels.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/cli/utils/logs.py</code> <pre><code>class LogLevels(str, Enum):\n\"\"\"A class to represent log levels.\n    Attributes:\n        critical : critical log level\n        error : error log level\n        warning : warning log level\n        info : info log level\n        debug : debug log level\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\ncritical = \"critical\"\nerror = \"error\"\nwarning = \"warning\"\ninfo = \"info\"\ndebug = \"debug\"\n</code></pre>"},{"location":"api/faststream/cli/utils/logs/LogLevels/#faststream.cli.utils.logs.LogLevels.critical","title":"critical  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>critical = 'critical'\n</code></pre>"},{"location":"api/faststream/cli/utils/logs/LogLevels/#faststream.cli.utils.logs.LogLevels.debug","title":"debug  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>debug = 'debug'\n</code></pre>"},{"location":"api/faststream/cli/utils/logs/LogLevels/#faststream.cli.utils.logs.LogLevels.error","title":"error  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>error = 'error'\n</code></pre>"},{"location":"api/faststream/cli/utils/logs/LogLevels/#faststream.cli.utils.logs.LogLevels.info","title":"info  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>info = 'info'\n</code></pre>"},{"location":"api/faststream/cli/utils/logs/LogLevels/#faststream.cli.utils.logs.LogLevels.warning","title":"warning  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>warning = 'warning'\n</code></pre>"},{"location":"api/faststream/cli/utils/logs/get_log_level/","title":"Get log level","text":""},{"location":"api/faststream/cli/utils/logs/get_log_level/#faststream.cli.utils.logs.get_log_level","title":"faststream.cli.utils.logs.get_log_level","text":"<pre><code>get_log_level(level: Union[LogLevels, str, int]) -&gt; int\n</code></pre> <p>Get the log level.</p> PARAMETER  DESCRIPTION <code>level</code> <p>The log level to get. Can be an integer, a LogLevels enum value, or a string.</p> <p> TYPE: <code>Union[LogLevels, str, int]</code> </p> RETURNS DESCRIPTION <code>int</code> <p>The log level as an integer.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/cli/utils/logs.py</code> <pre><code>def get_log_level(level: Union[LogLevels, str, int]) -&gt; int:\n\"\"\"Get the log level.\n    Args:\n        level: The log level to get. Can be an integer, a LogLevels enum value, or a string.\n    Returns:\n        The log level as an integer.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nif isinstance(level, int):\nreturn level\nif isinstance(level, LogLevels):\nreturn LOG_LEVELS[level.value]\nif isinstance(level, str):  # pragma: no branch\nreturn LOG_LEVELS[level.lower()]\n</code></pre>"},{"location":"api/faststream/cli/utils/logs/set_log_level/","title":"Set log level","text":""},{"location":"api/faststream/cli/utils/logs/set_log_level/#faststream.cli.utils.logs.set_log_level","title":"faststream.cli.utils.logs.set_log_level","text":"<pre><code>set_log_level(level: int, app: FastStream) -&gt; None\n</code></pre> <p>Sets the log level for an application.</p> PARAMETER  DESCRIPTION <code>level</code> <p>The log level to set.</p> <p> TYPE: <code>int</code> </p> <code>app</code> <p>The application object.</p> <p> TYPE: <code>FastStream</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/cli/utils/logs.py</code> <pre><code>def set_log_level(level: int, app: FastStream) -&gt; None:\n\"\"\"Sets the log level for an application.\n    Args:\n        level (int): The log level to set.\n        app (FastStream): The application object.\n    Returns:\n        None\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nif app.logger:\napp.logger.setLevel(level)\nbroker_logger: Optional[logging.Logger] = getattr(app.broker, \"logger\", None)\nif broker_logger is not None:\nbroker_logger.setLevel(level)\n</code></pre>"},{"location":"api/faststream/cli/utils/parser/parse_cli_args/","title":"Parse cli args","text":""},{"location":"api/faststream/cli/utils/parser/parse_cli_args/#faststream.cli.utils.parser.parse_cli_args","title":"faststream.cli.utils.parser.parse_cli_args","text":"<pre><code>parse_cli_args(\n*args: str,\n) -&gt; Tuple[str, Dict[str, SettingField]]\n</code></pre> <p>Parses command line arguments.</p> PARAMETER  DESCRIPTION <code>*args</code> <p>Command line arguments as strings.</p> <p> TYPE: <code>str</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>Tuple[str, Dict[str, SettingField]]</code> <p>A tuple containing the application name and a dictionary of additional keyword arguments.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/cli/utils/parser.py</code> <pre><code>def parse_cli_args(*args: str) -&gt; Tuple[str, Dict[str, SettingField]]:\n\"\"\"Parses command line arguments.\n    Args:\n        *args: Command line arguments as strings.\n    Returns:\n        A tuple containing the application name and a dictionary of additional keyword arguments.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nextra_kwargs: Dict[str, SettingField] = {}\nk: str = \"\"\nv: SettingField\nfield_args: List[str] = []\napp = \"\"\nfor item in reduce(\nlambda acc, x: acc + x.split(\"=\"),  # type: ignore\nargs,\n[],\n) + [\"-\"]:\nif \":\" in item:\napp = item\nelse:\nif \"-\" in item:\nif k:\nk = k.strip().lstrip(\"-\").replace(\"-\", \"_\")\nif len(field_args) == 0:\nv = not k.startswith(\"no_\")\nelif len(field_args) == 1:\nv = field_args[0]\nelse:\nv = field_args\nextra_kwargs[remove_prefix(k, \"no_\")] = v\nfield_args = []\nk = item\nelse:\nfield_args.append(item)\nreturn app, extra_kwargs\n</code></pre>"},{"location":"api/faststream/cli/utils/parser/remove_prefix/","title":"Remove prefix","text":""},{"location":"api/faststream/cli/utils/parser/remove_prefix/#faststream.cli.utils.parser.remove_prefix","title":"faststream.cli.utils.parser.remove_prefix","text":"<pre><code>remove_prefix(text: str, prefix: str) -&gt; str\n</code></pre> <p>Removes a prefix from a given text.</p> PARAMETER  DESCRIPTION <code>text</code> <p>The text from which the prefix will be removed.</p> <p> TYPE: <code>str</code> </p> <code>prefix</code> <p>The prefix to be removed from the text.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The text with the prefix removed. If the text does not start with the prefix, the original text is returned.</p> <p> TYPE: <code>str</code> </p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/cli/utils/parser.py</code> <pre><code>def remove_prefix(text: str, prefix: str) -&gt; str:\n\"\"\"Removes a prefix from a given text.\n    Args:\n        text (str): The text from which the prefix will be removed.\n        prefix (str): The prefix to be removed from the text.\n    Returns:\n        str: The text with the prefix removed. If the text does not start with the prefix, the original text is returned.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nif text.startswith(prefix):\nreturn text[len(prefix) :]\nreturn text\n</code></pre>"},{"location":"api/faststream/constants/ContentTypes/","title":"ContentTypes","text":""},{"location":"api/faststream/constants/ContentTypes/#faststream.constants.ContentTypes","title":"faststream.constants.ContentTypes","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p> <p>A class to represent content types.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/constants.py</code> <pre><code>class ContentTypes(str, Enum):\n\"\"\"A class to represent content types.\n    Attributes:\n        text : content type for plain text\n        json : content type for JSON data\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\ntext = \"text/plain\"\njson = \"application/json\"\n</code></pre>"},{"location":"api/faststream/constants/ContentTypes/#faststream.constants.ContentTypes.json","title":"json  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>json = 'application/json'\n</code></pre>"},{"location":"api/faststream/constants/ContentTypes/#faststream.constants.ContentTypes.text","title":"text  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>text = 'text/plain'\n</code></pre>"},{"location":"api/faststream/exceptions/AckMessage/","title":"AckMessage","text":""},{"location":"api/faststream/exceptions/AckMessage/#faststream.exceptions.AckMessage","title":"faststream.exceptions.AckMessage","text":"<p>             Bases: <code>HandlerException</code></p> <p>Raise it to <code>ack</code> a message immediately</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/exceptions.py</code> <pre><code>class AckMessage(HandlerException):\n\"\"\"Raise it to `ack` a message immediately\"\"\"\n</code></pre>"},{"location":"api/faststream/exceptions/HandlerException/","title":"HandlerException","text":""},{"location":"api/faststream/exceptions/HandlerException/#faststream.exceptions.HandlerException","title":"faststream.exceptions.HandlerException","text":"<p>             Bases: <code>Exception</code></p> <p>Base Handler Exception</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/exceptions.py</code> <pre><code>class HandlerException(Exception):\n\"\"\"Base Handler Exception\"\"\"\n</code></pre>"},{"location":"api/faststream/exceptions/NackMessage/","title":"NackMessage","text":""},{"location":"api/faststream/exceptions/NackMessage/#faststream.exceptions.NackMessage","title":"faststream.exceptions.NackMessage","text":"<p>             Bases: <code>HandlerException</code></p> <p>Raise it to <code>nack</code> a message immediately</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/exceptions.py</code> <pre><code>class NackMessage(HandlerException):\n\"\"\"Raise it to `nack` a message immediately\"\"\"\n</code></pre>"},{"location":"api/faststream/exceptions/RejectMessage/","title":"RejectMessage","text":""},{"location":"api/faststream/exceptions/RejectMessage/#faststream.exceptions.RejectMessage","title":"faststream.exceptions.RejectMessage","text":"<p>             Bases: <code>HandlerException</code></p> <p>Raise it to <code>reject</code> a message immediately</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/exceptions.py</code> <pre><code>class RejectMessage(HandlerException):\n\"\"\"Raise it to `reject` a message immediately\"\"\"\n</code></pre>"},{"location":"api/faststream/exceptions/SkipMessage/","title":"SkipMessage","text":""},{"location":"api/faststream/exceptions/SkipMessage/#faststream.exceptions.SkipMessage","title":"faststream.exceptions.SkipMessage","text":"<p>             Bases: <code>Exception</code></p> <p>Watcher Instruction to skip message</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/exceptions.py</code> <pre><code>class SkipMessage(Exception):\n\"\"\"Watcher Instruction to skip message\"\"\"\n</code></pre>"},{"location":"api/faststream/exceptions/StopConsume/","title":"StopConsume","text":""},{"location":"api/faststream/exceptions/StopConsume/#faststream.exceptions.StopConsume","title":"faststream.exceptions.StopConsume","text":"<p>             Bases: <code>Exception</code></p> <p>Raise it to stop Handler consuming</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/exceptions.py</code> <pre><code>class StopConsume(Exception):\n\"\"\"Raise it to stop Handler consuming\"\"\"\n</code></pre>"},{"location":"api/faststream/kafka/asyncapi/Handler/","title":"Handler","text":""},{"location":"api/faststream/kafka/asyncapi/Handler/#faststream.kafka.asyncapi.Handler","title":"faststream.kafka.asyncapi.Handler","text":"<p>             Bases: <code>LogicHandler</code>, <code>AsyncAPIOperation</code></p> <p>A class to handle logic and async API operations.</p> METHOD DESCRIPTION <code>schema</code> <p>Returns a dictionary of channels.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/asyncapi.py</code> <pre><code>class Handler(LogicHandler, AsyncAPIOperation):\n\"\"\"A class to handle logic and async API operations.\n    Methods:\n        schema() -&gt; Dict[str, Channel]: Returns a dictionary of channels.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\ndef schema(self) -&gt; Dict[str, Channel]:\nname: str\nif self.name is True:\nname, add_topic = self.call_name, True\nelif self.name is False:  # pragma: no cover\nname, add_topic = \"Handler\", True\nelse:\nname, add_topic = self.name, False\nchannels = {}\nfor t in self.topics:\nif add_topic:\nt_ = to_camelcase(t)\nif not name.lower().endswith(t_.lower()):\nname_ = f\"{name}{t_}\"\nelse:\nname_ = name\nelse:\nname_ = name\npayloads = []\nfor _, _, _, _, _, dep in self.calls:\nbody = parse_handler_params(dep, prefix=name_)\npayloads.append(body)\nchannels[name_] = Channel(\ndescription=self.description,\nsubscribe=Operation(\nmessage=Message(\ntitle=f\"{name_}Message\",\npayload=resolve_payloads(payloads),\ncorrelationId=CorrelationId(\nlocation=\"$message.header#/correlation_id\"\n),\n),\n),\nbindings=ChannelBinding(kafka=kafka.ChannelBinding(topic=t)),\n)\nreturn channels\n</code></pre>"},{"location":"api/faststream/kafka/asyncapi/Handler/#faststream.kafka.asyncapi.Handler.schema","title":"schema","text":"<pre><code>schema() -&gt; Dict[str, Channel]\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/asyncapi.py</code> <pre><code>def schema(self) -&gt; Dict[str, Channel]:\nname: str\nif self.name is True:\nname, add_topic = self.call_name, True\nelif self.name is False:  # pragma: no cover\nname, add_topic = \"Handler\", True\nelse:\nname, add_topic = self.name, False\nchannels = {}\nfor t in self.topics:\nif add_topic:\nt_ = to_camelcase(t)\nif not name.lower().endswith(t_.lower()):\nname_ = f\"{name}{t_}\"\nelse:\nname_ = name\nelse:\nname_ = name\npayloads = []\nfor _, _, _, _, _, dep in self.calls:\nbody = parse_handler_params(dep, prefix=name_)\npayloads.append(body)\nchannels[name_] = Channel(\ndescription=self.description,\nsubscribe=Operation(\nmessage=Message(\ntitle=f\"{name_}Message\",\npayload=resolve_payloads(payloads),\ncorrelationId=CorrelationId(\nlocation=\"$message.header#/correlation_id\"\n),\n),\n),\nbindings=ChannelBinding(kafka=kafka.ChannelBinding(topic=t)),\n)\nreturn channels\n</code></pre>"},{"location":"api/faststream/kafka/asyncapi/Publisher/","title":"Publisher","text":""},{"location":"api/faststream/kafka/asyncapi/Publisher/#faststream.kafka.asyncapi.Publisher","title":"faststream.kafka.asyncapi.Publisher","text":"<p>             Bases: <code>LogicPublisher</code>, <code>AsyncAPIOperation</code></p> <p>A class representing a publisher.</p> METHOD DESCRIPTION <code>schema</code> <p>returns the schema for the publisher</p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>If silent animals are not supported</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/asyncapi.py</code> <pre><code>class Publisher(LogicPublisher, AsyncAPIOperation):\n\"\"\"A class representing a publisher.\n    Attributes:\n        name : name of the publisher\n    Methods:\n        schema() : returns the schema for the publisher\n    Raises:\n        NotImplementedError: If silent animals are not supported\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n@property\ndef name(self) -&gt; str:\nreturn self.title or f\"{self.topic.title()}Publisher\"\ndef schema(self) -&gt; Dict[str, Channel]:\npayloads = []\nfor call in self.calls:\ncall_model = build_call_model(call)\nbody = get_response_schema(\ncall_model,\nprefix=to_camelcase(call_model.call_name),\n)\nif body:\npayloads.append(body)\nreturn {\nself.name: Channel(\ndescription=self.description,\npublish=Operation(\nmessage=Message(\ntitle=f\"{self.name}Message\",\npayload=resolve_payloads(payloads),\ncorrelationId=CorrelationId(\nlocation=\"$message.header#/correlation_id\"\n),\n),\n),\nbindings=ChannelBinding(kafka=kafka.ChannelBinding(topic=self.topic)),\n)\n}\n</code></pre>"},{"location":"api/faststream/kafka/asyncapi/Publisher/#faststream.kafka.asyncapi.Publisher.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"api/faststream/kafka/asyncapi/Publisher/#faststream.kafka.asyncapi.Publisher.schema","title":"schema","text":"<pre><code>schema() -&gt; Dict[str, Channel]\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/asyncapi.py</code> <pre><code>def schema(self) -&gt; Dict[str, Channel]:\npayloads = []\nfor call in self.calls:\ncall_model = build_call_model(call)\nbody = get_response_schema(\ncall_model,\nprefix=to_camelcase(call_model.call_name),\n)\nif body:\npayloads.append(body)\nreturn {\nself.name: Channel(\ndescription=self.description,\npublish=Operation(\nmessage=Message(\ntitle=f\"{self.name}Message\",\npayload=resolve_payloads(payloads),\ncorrelationId=CorrelationId(\nlocation=\"$message.header#/correlation_id\"\n),\n),\n),\nbindings=ChannelBinding(kafka=kafka.ChannelBinding(topic=self.topic)),\n)\n}\n</code></pre>"},{"location":"api/faststream/kafka/broker/KafkaBroker/","title":"KafkaBroker","text":""},{"location":"api/faststream/kafka/broker/KafkaBroker/#faststream.kafka.broker.KafkaBroker","title":"faststream.kafka.broker.KafkaBroker","text":"<p>             Bases: <code>KafkaLoggingMixin</code>, <code>BrokerAsyncUsecase[ConsumerRecord, ConsumerConnectionParams]</code></p> <p>KafkaBroker is a class for managing Kafka message consumption and publishing. It extends BrokerAsyncUsecase to handle asynchronous operations.</p> PARAMETER  DESCRIPTION <code>bootstrap_servers</code> <p>Kafka bootstrap server(s).</p> <p> TYPE: <code>Union[str, Iterable[str]]</code> DEFAULT: <code>'localhost'</code> </p> <code>protocol</code> <p>The protocol used (default is \"kafka\").</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>protocol_version</code> <p>The Kafka protocol version (default is \"auto\").</p> <p> TYPE: <code>str</code> DEFAULT: <code>'auto'</code> </p> <code>client_id</code> <p>The client ID for the Kafka client.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'faststream-' + __version__</code> </p> <code>**kwargs</code> <p>Additional keyword arguments.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> METHOD DESCRIPTION <code>connect</code> <p>Establishes a connection to Kafka.</p> <code>start</code> <p>Starts the KafkaBroker and message handlers.</p> <code>publish</code> <p>Publishes a message to Kafka.</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/broker.py</code> <pre><code>class KafkaBroker(\nKafkaLoggingMixin,\nBrokerAsyncUsecase[aiokafka.ConsumerRecord, ConsumerConnectionParams],\n):\n\"\"\"\n    KafkaBroker is a class for managing Kafka message consumption and publishing.\n    It extends BrokerAsyncUsecase to handle asynchronous operations.\n    Args:\n        bootstrap_servers (Union[str, Iterable[str]]): Kafka bootstrap server(s).\n        protocol (str): The protocol used (default is \"kafka\").\n        protocol_version (str): The Kafka protocol version (default is \"auto\").\n        client_id (str): The client ID for the Kafka client.\n        **kwargs: Additional keyword arguments.\n    Attributes:\n        handlers (Dict[str, Handler]): A dictionary of message handlers.\n        _publishers (Dict[str, Publisher]): A dictionary of message publishers.\n        _producer (Optional[AioKafkaFastProducer]): An optional Kafka producer.\n    Methods:\n        connect(*args, **kwargs): Establishes a connection to Kafka.\n        start(): Starts the KafkaBroker and message handlers.\n        publish(*args, **kwargs): Publishes a message to Kafka.\n    \"\"\"\nhandlers: Dict[str, Handler]  # type: ignore[assignment]\n_publishers: Dict[str, Publisher]  # type: ignore[assignment]\n_producer: Optional[AioKafkaFastProducer]\ndef __init__(\nself,\nbootstrap_servers: Union[str, Iterable[str]] = \"localhost\",\n*,\nprotocol: Optional[str] = None,\nprotocol_version: str = \"auto\",\nclient_id: str = \"faststream-\" + __version__,\nsecurity: Optional[BaseSecurity] = None,\n**kwargs: Any,\n) -&gt; None:\n\"\"\"\n        Initialize a KafkaBroker instance.\n        Args:\n            bootstrap_servers (Union[str, Iterable[str]]): Kafka bootstrap server(s).\n            protocol (str): The protocol used (default is \"kafka\").\n            protocol_version (str): The Kafka protocol version (default is \"auto\").\n            client_id (str): The client ID for the Kafka client.\n            security (Optional[BaseSecurity]): Security protocol to use in communication with the broker (default is None).\n            **kwargs: Additional keyword arguments.\n        \"\"\"\nif protocol is None:\nif security is not None and security.use_ssl:\nprotocol = \"kafka-secure\"\nelse:\nprotocol = \"kafka\"\nsuper().__init__(\nurl=bootstrap_servers,\nprotocol=protocol,\nprotocol_version=protocol_version,\nsecurity=security,\n**kwargs,\nclient_id=client_id,\nbootstrap_servers=bootstrap_servers,\n)\nself.client_id = client_id\nself._producer = None\nasync def _close(\nself,\nexc_type: Optional[Type[BaseException]] = None,\nexc_val: Optional[BaseException] = None,\nexec_tb: Optional[TracebackType] = None,\n) -&gt; None:\n\"\"\"\n        Close the KafkaBroker, stopping the producer and cleaning up resources.\n        Args:\n            exc_type (Optional[Type[BaseException]]): The exception type.\n            exc_val (Optional[BaseException]]): The exception value.\n            exec_tb (Optional[TracebackType]]): The traceback.\n        \"\"\"\nif self._producer is not None:  # pragma: no branch\nawait self._producer.stop()\nself._producer = None\nawait super()._close(exc_type, exc_val, exec_tb)\nasync def connect(\nself,\n*args: Any,\n**kwargs: Any,\n) -&gt; ConsumerConnectionParams:\n\"\"\"\n        Establishes a connection to Kafka and returns connection parameters.\n        Args:\n            *args: Additional arguments.\n            **kwargs: Additional keyword arguments.\n        Returns:\n            ConsumerConnectionParams: The connection parameters.\n        \"\"\"\nconnection = await super().connect(*args, **kwargs)\nfor p in self._publishers.values():\np._producer = self._producer\nreturn connection\n@override\nasync def _connect(  # type: ignore[override]\nself,\n*,\nclient_id: str,\n**kwargs: Any,\n) -&gt; ConsumerConnectionParams:\n\"\"\"\n        Connects to Kafka, initializes the producer, and returns connection parameters.\n        Args:\n            client_id (str): The client ID.\n            **kwargs: Additional keyword arguments.\n        Returns:\n            ConsumerConnectionParams: The connection parameters.\n        \"\"\"\nsecurity_params = parse_security(self.security)\nproducer = aiokafka.AIOKafkaProducer(\n**kwargs, **security_params, client_id=client_id\n)\nawait producer.start()\nself._producer = AioKafkaFastProducer(\nproducer=producer,\n)\nreturn filter_by_dict(ConsumerConnectionParams, {**kwargs, **security_params})\nasync def start(self) -&gt; None:\n\"\"\"\n        Start the KafkaBroker and message handlers.\n        \"\"\"\ncontext.set_local(\n\"log_context\",\nself._get_log_context(None, \"\"),\n)\nawait super().start()\nfor handler in self.handlers.values():\nc = self._get_log_context(None, handler.topics)\nif (name := handler.name) is True:\nname = handler.call_name\nself._log(f\"`{name}` waiting for messages\", extra=c)\nawait handler.start(**(self._connection or {}))\ndef _process_message(\nself,\nfunc: Callable[[KafkaMessage], Awaitable[T_HandlerReturn]],\nwatcher: BaseWatcher,\n) -&gt; Callable[[KafkaMessage], Awaitable[WrappedReturn[T_HandlerReturn]],]:\n\"\"\"\n        Wrap a message processing function with a watcher and publisher.\n        Args:\n            func (Callable[[KafkaMessage], Awaitable[T_HandlerReturn]]): The message processing function.\n            watcher (BaseWatcher): The message watcher.\n        Returns:\n            Callable[[KafkaMessage], Awaitable[WrappedReturn[T_HandlerReturn]]]: The wrapped message processing function.\n        \"\"\"\n@wraps(func)\nasync def process_wrapper(\nmessage: KafkaMessage,\n) -&gt; WrappedReturn[T_HandlerReturn]:\n\"\"\"Asynchronously process a Kafka message and wrap the return value.\n            Args:\n                message (KafkaMessage): The Kafka message to process.\n            Returns:\n                WrappedReturn[T_HandlerReturn]: The wrapped return value.\n            Raises:\n                AssertionError: If the code reaches an unreachable point.\n            !!! note\n                The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n            \"\"\"\nasync with WatcherContext(watcher, message):\nr = await self._execute_handler(func, message)\npub_response: Optional[AsyncPublisherProtocol]\nif message.reply_to:\npub_response = FakePublisher(\npartial(self.publish, topic=message.reply_to)\n)\nelse:\npub_response = None\nreturn r, pub_response\nreturn process_wrapper\n@override\ndef subscriber(  # type: ignore[override]\nself,\n*topics: str,\ngroup_id: Optional[str] = None,\nkey_deserializer: Optional[Callable[[bytes], Any]] = None,\nvalue_deserializer: Optional[Callable[[bytes], Any]] = None,\nfetch_max_wait_ms: int = 500,\nfetch_max_bytes: int = 52428800,\nfetch_min_bytes: int = 1,\nmax_partition_fetch_bytes: int = 1 * 1024 * 1024,\nauto_offset_reset: Literal[\n\"latest\",\n\"earliest\",\n\"none\",\n] = \"latest\",\nenable_auto_commit: bool = True,\nauto_commit_interval_ms: int = 5000,\ncheck_crcs: bool = True,\npartition_assignment_strategy: Sequence[AbstractPartitionAssignor] = (\nRoundRobinPartitionAssignor,\n),\nmax_poll_interval_ms: int = 300000,\nrebalance_timeout_ms: Optional[int] = None,\nsession_timeout_ms: int = 10000,\nheartbeat_interval_ms: int = 3000,\nconsumer_timeout_ms: int = 200,\nmax_poll_records: Optional[int] = None,\nexclude_internal_topics: bool = True,\nisolation_level: Literal[\n\"read_uncommitted\",\n\"read_committed\",\n] = \"read_uncommitted\",\n# broker arguments\ndependencies: Sequence[Depends] = (),\nparser: Optional[\nUnion[\nCustomParser[aiokafka.ConsumerRecord],\nCustomParser[Tuple[aiokafka.ConsumerRecord, ...]],\n]\n] = None,\ndecoder: Optional[\nUnion[\nCustomDecoder[aiokafka.ConsumerRecord],\nCustomDecoder[Tuple[aiokafka.ConsumerRecord, ...]],\n]\n] = None,\nmiddlewares: Optional[\nSequence[\nCallable[\n[aiokafka.ConsumerRecord],\nBaseMiddleware,\n]\n]\n] = None,\nfilter: Union[\nFilter[KafkaMessage],\nFilter[StreamMessage[Tuple[aiokafka.ConsumerRecord, ...]]],\n] = default_filter,\nbatch: bool = False,\nmax_records: Optional[int] = None,\nbatch_timeout_ms: int = 200,\n# AsyncAPI information\ntitle: Optional[str] = None,\ndescription: Optional[str] = None,\n**original_kwargs: Any,\n) -&gt; Callable[\n[Callable[P_HandlerParams, T_HandlerReturn]],\nUnion[\nHandlerCallWrapper[\naiokafka.ConsumerRecord, P_HandlerParams, T_HandlerReturn\n],\nHandlerCallWrapper[\nTuple[aiokafka.ConsumerRecord, ...], P_HandlerParams, T_HandlerReturn\n],\n],\n]:\n\"\"\"\n        Create a message subscriber for the specified topics.\n        Args:\n            *topics (str): The topics to subscribe to.\n            group_id (Optional[str]): The Kafka consumer group ID.\n            key_deserializer (Optional[Callable[[bytes], Any]]): Key deserializer function.\n            value_deserializer (Optional[Callable[[bytes], Any]]): Value deserializer function.\n            fetch_max_wait_ms (int): The maximum time to wait for data.\n            fetch_max_bytes (int): The maximum number of bytes to fetch.\n            fetch_min_bytes (int): The minimum number of bytes to fetch.\n            max_partition_fetch_bytes (int): The maximum bytes to fetch for a partition.\n            auto_offset_reset (Literal[\"latest\", \"earliest\", \"none\"]): Auto offset reset policy.\n            enable_auto_commit (bool): Whether to enable auto-commit.\n            auto_commit_interval_ms (int): Auto-commit interval in milliseconds.\n            check_crcs (bool): Whether to check CRCs.\n            partition_assignment_strategy (Sequence[AbstractPartitionAssignor]): Partition assignment strategy.\n            max_poll_interval_ms (int): Maximum poll interval in milliseconds.\n            rebalance_timeout_ms (Optional[int]): Rebalance timeout in milliseconds.\n            session_timeout_ms (int): Session timeout in milliseconds.\n            heartbeat_interval_ms (int): Heartbeat interval in milliseconds.\n            consumer_timeout_ms (int): Consumer timeout in milliseconds.\n            max_poll_records (Optional[int]): Maximum number of records to poll.\n            exclude_internal_topics (bool): Whether to exclude internal topics.\n            isolation_level (Literal[\"read_uncommitted\", \"read_committed\"]): Isolation level.\n            dependencies (Sequence[Depends]): Additional dependencies for message handling.\n            parser (Optional[Union[CustomParser[aiokafka.ConsumerRecord], CustomParser[Tuple[aiokafka.ConsumerRecord, ...]]]]): Message parser.\n            decoder (Optional[Union[CustomDecoder[aiokafka.ConsumerRecord], CustomDecoder[Tuple[aiokafka.ConsumerRecord, ...]]]]): Message decoder.\n            middlewares (Optional[Sequence[Callable[[aiokafka.ConsumerRecord], BaseMiddleware]]]): Message middlewares.\n            filter (Union[Filter[KafkaMessage], Filter[StreamMessage[Tuple[aiokafka.ConsumerRecord, ...]]]]): Message filter.\n            batch (bool): Whether to process messages in batches.\n            max_records (Optional[int]): Maximum number of records to process in each batch.\n            batch_timeout_ms (int): Batch timeout in milliseconds.\n            title (Optional[str]): AsyncAPI title.\n            description (Optional[str]): AsyncAPI description.\n            **original_kwargs: Additional keyword arguments.\n        Returns:\n            Callable: A decorator that wraps a message handler function.\n        \"\"\"\nsuper().subscriber()\nself._setup_log_context(topics)\nkey = Handler.get_routing_hash(topics, group_id)\nbuilder = partial(\naiokafka.AIOKafkaConsumer,\nkey_deserializer=key_deserializer,\nvalue_deserializer=value_deserializer,\nfetch_max_wait_ms=fetch_max_wait_ms,\nfetch_max_bytes=fetch_max_bytes,\nfetch_min_bytes=fetch_min_bytes,\nmax_partition_fetch_bytes=max_partition_fetch_bytes,\nauto_offset_reset=auto_offset_reset,\nenable_auto_commit=enable_auto_commit,\nauto_commit_interval_ms=auto_commit_interval_ms,\ncheck_crcs=check_crcs,\npartition_assignment_strategy=partition_assignment_strategy,\nmax_poll_interval_ms=max_poll_interval_ms,\nrebalance_timeout_ms=rebalance_timeout_ms,\nsession_timeout_ms=session_timeout_ms,\nheartbeat_interval_ms=heartbeat_interval_ms,\nconsumer_timeout_ms=consumer_timeout_ms,\nmax_poll_records=max_poll_records,\nexclude_internal_topics=exclude_internal_topics,\nisolation_level=isolation_level,\n)\nhandler = self.handlers.get(\nkey,\nHandler(\n*topics,\nlog_context_builder=partial(self._get_log_context, topics=topics),\ngroup_id=group_id,\nclient_id=self.client_id,\nbuilder=builder,\ndescription=description,\ntitle=title,\nbatch=batch,\nbatch_timeout_ms=batch_timeout_ms,\nmax_records=max_records,\n),\n)\nself.handlers[key] = handler\ndef consumer_wrapper(\nfunc: Callable[P_HandlerParams, T_HandlerReturn],\n) -&gt; HandlerCallWrapper[\naiokafka.ConsumerRecord, P_HandlerParams, T_HandlerReturn\n]:\n\"\"\"A wrapper function for a consumer handler.\n            Args:\n                func : The consumer handler function to be wrapped.\n            Returns:\n                The wrapped handler call.\n            Raises:\n                NotImplementedError: If silent animals are not supported.\n            !!! note\n                The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n            \"\"\"\nhandler_call, dependant = self._wrap_handler(\nfunc=func,\nextra_dependencies=dependencies,\n**original_kwargs,\n)\nhandler.add_call(\nhandler=handler_call,\nfilter=filter,\nmiddlewares=middlewares,\nparser=parser or self._global_parser,\ndecoder=decoder or self._global_decoder,\ndependant=dependant,\n)\nreturn handler_call\nreturn consumer_wrapper\n@override\ndef publisher(  # type: ignore[override]\nself,\ntopic: str,\nkey: Optional[bytes] = None,\npartition: Optional[int] = None,\ntimestamp_ms: Optional[int] = None,\nheaders: Optional[Dict[str, str]] = None,\nreply_to: str = \"\",\nbatch: bool = False,\n# AsyncAPI information\ntitle: Optional[str] = None,\ndescription: Optional[str] = None,\n) -&gt; Publisher:\n\"\"\"\n        Create a message publisher for the specified topic.\n        Args:\n            topic (str): The topic to publish messages to.\n            key (Optional[bytes]): Message key.\n            partition (Optional[int]): Partition to send the message to.\n            timestamp_ms (Optional[int]): Message timestamp in milliseconds.\n            headers (Optional[Dict[str, str]]): Message headers.\n            reply_to (str): The topic to which responses should be sent.\n            batch (bool): Whether to publish messages in batches.\n            title (Optional[str]): AsyncAPI title.\n            description (Optional[str]): AsyncAPI description.\n        Returns:\n            Publisher: A message publisher.\n        \"\"\"\npublisher = self._publishers.get(\ntopic,\nPublisher(\ntopic=topic,\nclient_id=self.client_id,\nkey=key,\nbatch=batch,\npartition=partition,\ntimestamp_ms=timestamp_ms,\nheaders=headers,\nreply_to=reply_to,\ntitle=title,\n_description=description,\n),\n)\nsuper().publisher(topic, publisher)\nreturn publisher\n@override\nasync def publish(  # type: ignore[override]\nself,\n*args: Any,\n**kwargs: Any,\n) -&gt; None:\n\"\"\"\n        Publish a message to Kafka.\n        Args:\n            *args: Positional arguments for message publishing.\n            **kwargs: Keyword arguments for message publishing.\n        Raises:\n            RuntimeError: If KafkaBroker is not started yet.\n        \"\"\"\nassert self._producer, \"KafkaBroker is not started yet\"  # nosec B101\nreturn await self._producer.publish(*args, **kwargs)\nasync def publish_batch(\nself,\n*args: Any,\n**kwargs: Any,\n) -&gt; None:\n\"\"\"\n        Publish a batch of messages to Kafka.\n        Args:\n            *args: Positional arguments for message publishing.\n            **kwargs: Keyword arguments for message publishing.\n        Raises:\n            RuntimeError: If KafkaBroker is not started yet.\n        \"\"\"\nassert self._producer, \"KafkaBroker is not started yet\"  # nosec B101\nawait self._producer.publish_batch(*args, **kwargs)\n</code></pre>"},{"location":"api/faststream/kafka/broker/KafkaBroker/#faststream.kafka.broker.KafkaBroker.client_id","title":"client_id  <code>instance-attribute</code>","text":"<pre><code>client_id = client_id\n</code></pre>"},{"location":"api/faststream/kafka/broker/KafkaBroker/#faststream.kafka.broker.KafkaBroker.handlers","title":"handlers  <code>instance-attribute</code>","text":"<pre><code>handlers: Dict[str, Handler]\n</code></pre>"},{"location":"api/faststream/kafka/broker/KafkaBroker/#faststream.kafka.broker.KafkaBroker.connect","title":"connect  <code>async</code>","text":"<pre><code>connect(\n*args: Any, **kwargs: Any\n) -&gt; ConsumerConnectionParams\n</code></pre> <p>Establishes a connection to Kafka and returns connection parameters.</p> PARAMETER  DESCRIPTION <code>*args</code> <p>Additional arguments.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>()</code> </p> <code>**kwargs</code> <p>Additional keyword arguments.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>ConsumerConnectionParams</code> <p>The connection parameters.</p> <p> TYPE: <code>ConsumerConnectionParams</code> </p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/broker.py</code> <pre><code>async def connect(\nself,\n*args: Any,\n**kwargs: Any,\n) -&gt; ConsumerConnectionParams:\n\"\"\"\n    Establishes a connection to Kafka and returns connection parameters.\n    Args:\n        *args: Additional arguments.\n        **kwargs: Additional keyword arguments.\n    Returns:\n        ConsumerConnectionParams: The connection parameters.\n    \"\"\"\nconnection = await super().connect(*args, **kwargs)\nfor p in self._publishers.values():\np._producer = self._producer\nreturn connection\n</code></pre>"},{"location":"api/faststream/kafka/broker/KafkaBroker/#faststream.kafka.broker.KafkaBroker.publish","title":"publish  <code>async</code>","text":"<pre><code>publish(*args: Any, **kwargs: Any) -&gt; None\n</code></pre> <p>Publish a message to Kafka.</p> PARAMETER  DESCRIPTION <code>*args</code> <p>Positional arguments for message publishing.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>()</code> </p> <code>**kwargs</code> <p>Keyword arguments for message publishing.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If KafkaBroker is not started yet.</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/broker.py</code> <pre><code>@override\nasync def publish(  # type: ignore[override]\nself,\n*args: Any,\n**kwargs: Any,\n) -&gt; None:\n\"\"\"\n    Publish a message to Kafka.\n    Args:\n        *args: Positional arguments for message publishing.\n        **kwargs: Keyword arguments for message publishing.\n    Raises:\n        RuntimeError: If KafkaBroker is not started yet.\n    \"\"\"\nassert self._producer, \"KafkaBroker is not started yet\"  # nosec B101\nreturn await self._producer.publish(*args, **kwargs)\n</code></pre>"},{"location":"api/faststream/kafka/broker/KafkaBroker/#faststream.kafka.broker.KafkaBroker.publish_batch","title":"publish_batch  <code>async</code>","text":"<pre><code>publish_batch(*args: Any, **kwargs: Any) -&gt; None\n</code></pre> <p>Publish a batch of messages to Kafka.</p> PARAMETER  DESCRIPTION <code>*args</code> <p>Positional arguments for message publishing.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>()</code> </p> <code>**kwargs</code> <p>Keyword arguments for message publishing.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If KafkaBroker is not started yet.</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/broker.py</code> <pre><code>async def publish_batch(\nself,\n*args: Any,\n**kwargs: Any,\n) -&gt; None:\n\"\"\"\n    Publish a batch of messages to Kafka.\n    Args:\n        *args: Positional arguments for message publishing.\n        **kwargs: Keyword arguments for message publishing.\n    Raises:\n        RuntimeError: If KafkaBroker is not started yet.\n    \"\"\"\nassert self._producer, \"KafkaBroker is not started yet\"  # nosec B101\nawait self._producer.publish_batch(*args, **kwargs)\n</code></pre>"},{"location":"api/faststream/kafka/broker/KafkaBroker/#faststream.kafka.broker.KafkaBroker.publisher","title":"publisher","text":"<pre><code>publisher(\ntopic: str,\nkey: Optional[bytes] = None,\npartition: Optional[int] = None,\ntimestamp_ms: Optional[int] = None,\nheaders: Optional[Dict[str, str]] = None,\nreply_to: str = \"\",\nbatch: bool = False,\ntitle: Optional[str] = None,\ndescription: Optional[str] = None,\n) -&gt; Publisher\n</code></pre> <p>Create a message publisher for the specified topic.</p> PARAMETER  DESCRIPTION <code>topic</code> <p>The topic to publish messages to.</p> <p> TYPE: <code>str</code> </p> <code>key</code> <p>Message key.</p> <p> TYPE: <code>Optional[bytes]</code> DEFAULT: <code>None</code> </p> <code>partition</code> <p>Partition to send the message to.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>timestamp_ms</code> <p>Message timestamp in milliseconds.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>headers</code> <p>Message headers.</p> <p> TYPE: <code>Optional[Dict[str, str]]</code> DEFAULT: <code>None</code> </p> <code>reply_to</code> <p>The topic to which responses should be sent.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>batch</code> <p>Whether to publish messages in batches.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>title</code> <p>AsyncAPI title.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>description</code> <p>AsyncAPI description.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Publisher</code> <p>A message publisher.</p> <p> TYPE: <code>Publisher</code> </p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/broker.py</code> <pre><code>@override\ndef publisher(  # type: ignore[override]\nself,\ntopic: str,\nkey: Optional[bytes] = None,\npartition: Optional[int] = None,\ntimestamp_ms: Optional[int] = None,\nheaders: Optional[Dict[str, str]] = None,\nreply_to: str = \"\",\nbatch: bool = False,\n# AsyncAPI information\ntitle: Optional[str] = None,\ndescription: Optional[str] = None,\n) -&gt; Publisher:\n\"\"\"\n    Create a message publisher for the specified topic.\n    Args:\n        topic (str): The topic to publish messages to.\n        key (Optional[bytes]): Message key.\n        partition (Optional[int]): Partition to send the message to.\n        timestamp_ms (Optional[int]): Message timestamp in milliseconds.\n        headers (Optional[Dict[str, str]]): Message headers.\n        reply_to (str): The topic to which responses should be sent.\n        batch (bool): Whether to publish messages in batches.\n        title (Optional[str]): AsyncAPI title.\n        description (Optional[str]): AsyncAPI description.\n    Returns:\n        Publisher: A message publisher.\n    \"\"\"\npublisher = self._publishers.get(\ntopic,\nPublisher(\ntopic=topic,\nclient_id=self.client_id,\nkey=key,\nbatch=batch,\npartition=partition,\ntimestamp_ms=timestamp_ms,\nheaders=headers,\nreply_to=reply_to,\ntitle=title,\n_description=description,\n),\n)\nsuper().publisher(topic, publisher)\nreturn publisher\n</code></pre>"},{"location":"api/faststream/kafka/broker/KafkaBroker/#faststream.kafka.broker.KafkaBroker.start","title":"start  <code>async</code>","text":"<pre><code>start() -&gt; None\n</code></pre> <p>Start the KafkaBroker and message handlers.</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/broker.py</code> <pre><code>async def start(self) -&gt; None:\n\"\"\"\n    Start the KafkaBroker and message handlers.\n    \"\"\"\ncontext.set_local(\n\"log_context\",\nself._get_log_context(None, \"\"),\n)\nawait super().start()\nfor handler in self.handlers.values():\nc = self._get_log_context(None, handler.topics)\nif (name := handler.name) is True:\nname = handler.call_name\nself._log(f\"`{name}` waiting for messages\", extra=c)\nawait handler.start(**(self._connection or {}))\n</code></pre>"},{"location":"api/faststream/kafka/broker/KafkaBroker/#faststream.kafka.broker.KafkaBroker.subscriber","title":"subscriber","text":"<pre><code>subscriber(\n*topics: str,\ngroup_id: Optional[str] = None,\nkey_deserializer: Optional[\nCallable[[bytes], Any]\n] = None,\nvalue_deserializer: Optional[\nCallable[[bytes], Any]\n] = None,\nfetch_max_wait_ms: int = 500,\nfetch_max_bytes: int = 52428800,\nfetch_min_bytes: int = 1,\nmax_partition_fetch_bytes: int = 1 * 1024 * 1024,\nauto_offset_reset: Literal[\n\"latest\", \"earliest\", \"none\"\n] = \"latest\",\nenable_auto_commit: bool = True,\nauto_commit_interval_ms: int = 5000,\ncheck_crcs: bool = True,\npartition_assignment_strategy: Sequence[\nAbstractPartitionAssignor\n] = (RoundRobinPartitionAssignor),\nmax_poll_interval_ms: int = 300000,\nrebalance_timeout_ms: Optional[int] = None,\nsession_timeout_ms: int = 10000,\nheartbeat_interval_ms: int = 3000,\nconsumer_timeout_ms: int = 200,\nmax_poll_records: Optional[int] = None,\nexclude_internal_topics: bool = True,\nisolation_level: Literal[\n\"read_uncommitted\", \"read_committed\"\n] = \"read_uncommitted\",\ndependencies: Sequence[Depends] = (),\nparser: Optional[\nUnion[\nCustomParser[aiokafka.ConsumerRecord],\nCustomParser[\nTuple[aiokafka.ConsumerRecord, ...]\n],\n]\n] = None,\ndecoder: Optional[\nUnion[\nCustomDecoder[aiokafka.ConsumerRecord],\nCustomDecoder[\nTuple[aiokafka.ConsumerRecord, ...]\n],\n]\n] = None,\nmiddlewares: Optional[\nSequence[\nCallable[\n[aiokafka.ConsumerRecord], BaseMiddleware\n]\n]\n] = None,\nfilter: Union[\nFilter[KafkaMessage],\nFilter[\nStreamMessage[\nTuple[aiokafka.ConsumerRecord, ...]\n]\n],\n] = default_filter,\nbatch: bool = False,\nmax_records: Optional[int] = None,\nbatch_timeout_ms: int = 200,\ntitle: Optional[str] = None,\ndescription: Optional[str] = None,\n**original_kwargs: Any\n) -&gt; Callable[\n[Callable[P_HandlerParams, T_HandlerReturn]],\nUnion[\nHandlerCallWrapper[\naiokafka.ConsumerRecord,\nP_HandlerParams,\nT_HandlerReturn,\n],\nHandlerCallWrapper[\nTuple[aiokafka.ConsumerRecord, ...],\nP_HandlerParams,\nT_HandlerReturn,\n],\n],\n]\n</code></pre> <p>Create a message subscriber for the specified topics.</p> PARAMETER  DESCRIPTION <code>*topics</code> <p>The topics to subscribe to.</p> <p> TYPE: <code>str</code> DEFAULT: <code>()</code> </p> <code>group_id</code> <p>The Kafka consumer group ID.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>key_deserializer</code> <p>Key deserializer function.</p> <p> TYPE: <code>Optional[Callable[[bytes], Any]]</code> DEFAULT: <code>None</code> </p> <code>value_deserializer</code> <p>Value deserializer function.</p> <p> TYPE: <code>Optional[Callable[[bytes], Any]]</code> DEFAULT: <code>None</code> </p> <code>fetch_max_wait_ms</code> <p>The maximum time to wait for data.</p> <p> TYPE: <code>int</code> DEFAULT: <code>500</code> </p> <code>fetch_max_bytes</code> <p>The maximum number of bytes to fetch.</p> <p> TYPE: <code>int</code> DEFAULT: <code>52428800</code> </p> <code>fetch_min_bytes</code> <p>The minimum number of bytes to fetch.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>max_partition_fetch_bytes</code> <p>The maximum bytes to fetch for a partition.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1 * 1024 * 1024</code> </p> <code>auto_offset_reset</code> <p>Auto offset reset policy.</p> <p> TYPE: <code>Literal['latest', 'earliest', 'none']</code> DEFAULT: <code>'latest'</code> </p> <code>enable_auto_commit</code> <p>Whether to enable auto-commit.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>auto_commit_interval_ms</code> <p>Auto-commit interval in milliseconds.</p> <p> TYPE: <code>int</code> DEFAULT: <code>5000</code> </p> <code>check_crcs</code> <p>Whether to check CRCs.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>partition_assignment_strategy</code> <p>Partition assignment strategy.</p> <p> TYPE: <code>Sequence[AbstractPartitionAssignor]</code> DEFAULT: <code>(RoundRobinPartitionAssignor)</code> </p> <code>max_poll_interval_ms</code> <p>Maximum poll interval in milliseconds.</p> <p> TYPE: <code>int</code> DEFAULT: <code>300000</code> </p> <code>rebalance_timeout_ms</code> <p>Rebalance timeout in milliseconds.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>session_timeout_ms</code> <p>Session timeout in milliseconds.</p> <p> TYPE: <code>int</code> DEFAULT: <code>10000</code> </p> <code>heartbeat_interval_ms</code> <p>Heartbeat interval in milliseconds.</p> <p> TYPE: <code>int</code> DEFAULT: <code>3000</code> </p> <code>consumer_timeout_ms</code> <p>Consumer timeout in milliseconds.</p> <p> TYPE: <code>int</code> DEFAULT: <code>200</code> </p> <code>max_poll_records</code> <p>Maximum number of records to poll.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>exclude_internal_topics</code> <p>Whether to exclude internal topics.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>isolation_level</code> <p>Isolation level.</p> <p> TYPE: <code>Literal['read_uncommitted', 'read_committed']</code> DEFAULT: <code>'read_uncommitted'</code> </p> <code>dependencies</code> <p>Additional dependencies for message handling.</p> <p> TYPE: <code>Sequence[Depends]</code> DEFAULT: <code>()</code> </p> <code>parser</code> <p>Message parser.</p> <p> TYPE: <code>Optional[Union[CustomParser[ConsumerRecord], CustomParser[Tuple[ConsumerRecord, ...]]]]</code> DEFAULT: <code>None</code> </p> <code>decoder</code> <p>Message decoder.</p> <p> TYPE: <code>Optional[Union[CustomDecoder[ConsumerRecord], CustomDecoder[Tuple[ConsumerRecord, ...]]]]</code> DEFAULT: <code>None</code> </p> <code>middlewares</code> <p>Message middlewares.</p> <p> TYPE: <code>Optional[Sequence[Callable[[ConsumerRecord], BaseMiddleware]]]</code> DEFAULT: <code>None</code> </p> <code>filter</code> <p>Message filter.</p> <p> TYPE: <code>Union[Filter[KafkaMessage], Filter[StreamMessage[Tuple[ConsumerRecord, ...]]]]</code> DEFAULT: <code>default_filter</code> </p> <code>batch</code> <p>Whether to process messages in batches.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>max_records</code> <p>Maximum number of records to process in each batch.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>batch_timeout_ms</code> <p>Batch timeout in milliseconds.</p> <p> TYPE: <code>int</code> DEFAULT: <code>200</code> </p> <code>title</code> <p>AsyncAPI title.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>description</code> <p>AsyncAPI description.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>**original_kwargs</code> <p>Additional keyword arguments.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Callable</code> <p>A decorator that wraps a message handler function.</p> <p> TYPE: <code>Callable[[Callable[P_HandlerParams, T_HandlerReturn]], Union[HandlerCallWrapper[ConsumerRecord, P_HandlerParams, T_HandlerReturn], HandlerCallWrapper[Tuple[ConsumerRecord, ...], P_HandlerParams, T_HandlerReturn]]]</code> </p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/broker.py</code> <pre><code>@override\ndef subscriber(  # type: ignore[override]\nself,\n*topics: str,\ngroup_id: Optional[str] = None,\nkey_deserializer: Optional[Callable[[bytes], Any]] = None,\nvalue_deserializer: Optional[Callable[[bytes], Any]] = None,\nfetch_max_wait_ms: int = 500,\nfetch_max_bytes: int = 52428800,\nfetch_min_bytes: int = 1,\nmax_partition_fetch_bytes: int = 1 * 1024 * 1024,\nauto_offset_reset: Literal[\n\"latest\",\n\"earliest\",\n\"none\",\n] = \"latest\",\nenable_auto_commit: bool = True,\nauto_commit_interval_ms: int = 5000,\ncheck_crcs: bool = True,\npartition_assignment_strategy: Sequence[AbstractPartitionAssignor] = (\nRoundRobinPartitionAssignor,\n),\nmax_poll_interval_ms: int = 300000,\nrebalance_timeout_ms: Optional[int] = None,\nsession_timeout_ms: int = 10000,\nheartbeat_interval_ms: int = 3000,\nconsumer_timeout_ms: int = 200,\nmax_poll_records: Optional[int] = None,\nexclude_internal_topics: bool = True,\nisolation_level: Literal[\n\"read_uncommitted\",\n\"read_committed\",\n] = \"read_uncommitted\",\n# broker arguments\ndependencies: Sequence[Depends] = (),\nparser: Optional[\nUnion[\nCustomParser[aiokafka.ConsumerRecord],\nCustomParser[Tuple[aiokafka.ConsumerRecord, ...]],\n]\n] = None,\ndecoder: Optional[\nUnion[\nCustomDecoder[aiokafka.ConsumerRecord],\nCustomDecoder[Tuple[aiokafka.ConsumerRecord, ...]],\n]\n] = None,\nmiddlewares: Optional[\nSequence[\nCallable[\n[aiokafka.ConsumerRecord],\nBaseMiddleware,\n]\n]\n] = None,\nfilter: Union[\nFilter[KafkaMessage],\nFilter[StreamMessage[Tuple[aiokafka.ConsumerRecord, ...]]],\n] = default_filter,\nbatch: bool = False,\nmax_records: Optional[int] = None,\nbatch_timeout_ms: int = 200,\n# AsyncAPI information\ntitle: Optional[str] = None,\ndescription: Optional[str] = None,\n**original_kwargs: Any,\n) -&gt; Callable[\n[Callable[P_HandlerParams, T_HandlerReturn]],\nUnion[\nHandlerCallWrapper[\naiokafka.ConsumerRecord, P_HandlerParams, T_HandlerReturn\n],\nHandlerCallWrapper[\nTuple[aiokafka.ConsumerRecord, ...], P_HandlerParams, T_HandlerReturn\n],\n],\n]:\n\"\"\"\n    Create a message subscriber for the specified topics.\n    Args:\n        *topics (str): The topics to subscribe to.\n        group_id (Optional[str]): The Kafka consumer group ID.\n        key_deserializer (Optional[Callable[[bytes], Any]]): Key deserializer function.\n        value_deserializer (Optional[Callable[[bytes], Any]]): Value deserializer function.\n        fetch_max_wait_ms (int): The maximum time to wait for data.\n        fetch_max_bytes (int): The maximum number of bytes to fetch.\n        fetch_min_bytes (int): The minimum number of bytes to fetch.\n        max_partition_fetch_bytes (int): The maximum bytes to fetch for a partition.\n        auto_offset_reset (Literal[\"latest\", \"earliest\", \"none\"]): Auto offset reset policy.\n        enable_auto_commit (bool): Whether to enable auto-commit.\n        auto_commit_interval_ms (int): Auto-commit interval in milliseconds.\n        check_crcs (bool): Whether to check CRCs.\n        partition_assignment_strategy (Sequence[AbstractPartitionAssignor]): Partition assignment strategy.\n        max_poll_interval_ms (int): Maximum poll interval in milliseconds.\n        rebalance_timeout_ms (Optional[int]): Rebalance timeout in milliseconds.\n        session_timeout_ms (int): Session timeout in milliseconds.\n        heartbeat_interval_ms (int): Heartbeat interval in milliseconds.\n        consumer_timeout_ms (int): Consumer timeout in milliseconds.\n        max_poll_records (Optional[int]): Maximum number of records to poll.\n        exclude_internal_topics (bool): Whether to exclude internal topics.\n        isolation_level (Literal[\"read_uncommitted\", \"read_committed\"]): Isolation level.\n        dependencies (Sequence[Depends]): Additional dependencies for message handling.\n        parser (Optional[Union[CustomParser[aiokafka.ConsumerRecord], CustomParser[Tuple[aiokafka.ConsumerRecord, ...]]]]): Message parser.\n        decoder (Optional[Union[CustomDecoder[aiokafka.ConsumerRecord], CustomDecoder[Tuple[aiokafka.ConsumerRecord, ...]]]]): Message decoder.\n        middlewares (Optional[Sequence[Callable[[aiokafka.ConsumerRecord], BaseMiddleware]]]): Message middlewares.\n        filter (Union[Filter[KafkaMessage], Filter[StreamMessage[Tuple[aiokafka.ConsumerRecord, ...]]]]): Message filter.\n        batch (bool): Whether to process messages in batches.\n        max_records (Optional[int]): Maximum number of records to process in each batch.\n        batch_timeout_ms (int): Batch timeout in milliseconds.\n        title (Optional[str]): AsyncAPI title.\n        description (Optional[str]): AsyncAPI description.\n        **original_kwargs: Additional keyword arguments.\n    Returns:\n        Callable: A decorator that wraps a message handler function.\n    \"\"\"\nsuper().subscriber()\nself._setup_log_context(topics)\nkey = Handler.get_routing_hash(topics, group_id)\nbuilder = partial(\naiokafka.AIOKafkaConsumer,\nkey_deserializer=key_deserializer,\nvalue_deserializer=value_deserializer,\nfetch_max_wait_ms=fetch_max_wait_ms,\nfetch_max_bytes=fetch_max_bytes,\nfetch_min_bytes=fetch_min_bytes,\nmax_partition_fetch_bytes=max_partition_fetch_bytes,\nauto_offset_reset=auto_offset_reset,\nenable_auto_commit=enable_auto_commit,\nauto_commit_interval_ms=auto_commit_interval_ms,\ncheck_crcs=check_crcs,\npartition_assignment_strategy=partition_assignment_strategy,\nmax_poll_interval_ms=max_poll_interval_ms,\nrebalance_timeout_ms=rebalance_timeout_ms,\nsession_timeout_ms=session_timeout_ms,\nheartbeat_interval_ms=heartbeat_interval_ms,\nconsumer_timeout_ms=consumer_timeout_ms,\nmax_poll_records=max_poll_records,\nexclude_internal_topics=exclude_internal_topics,\nisolation_level=isolation_level,\n)\nhandler = self.handlers.get(\nkey,\nHandler(\n*topics,\nlog_context_builder=partial(self._get_log_context, topics=topics),\ngroup_id=group_id,\nclient_id=self.client_id,\nbuilder=builder,\ndescription=description,\ntitle=title,\nbatch=batch,\nbatch_timeout_ms=batch_timeout_ms,\nmax_records=max_records,\n),\n)\nself.handlers[key] = handler\ndef consumer_wrapper(\nfunc: Callable[P_HandlerParams, T_HandlerReturn],\n) -&gt; HandlerCallWrapper[\naiokafka.ConsumerRecord, P_HandlerParams, T_HandlerReturn\n]:\n\"\"\"A wrapper function for a consumer handler.\n        Args:\n            func : The consumer handler function to be wrapped.\n        Returns:\n            The wrapped handler call.\n        Raises:\n            NotImplementedError: If silent animals are not supported.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nhandler_call, dependant = self._wrap_handler(\nfunc=func,\nextra_dependencies=dependencies,\n**original_kwargs,\n)\nhandler.add_call(\nhandler=handler_call,\nfilter=filter,\nmiddlewares=middlewares,\nparser=parser or self._global_parser,\ndecoder=decoder or self._global_decoder,\ndependant=dependant,\n)\nreturn handler_call\nreturn consumer_wrapper\n</code></pre>"},{"location":"api/faststream/kafka/fastapi/KafkaRouter/","title":"KafkaRouter","text":""},{"location":"api/faststream/kafka/fastapi/KafkaRouter/#faststream.kafka.fastapi.KafkaRouter","title":"faststream.kafka.fastapi.KafkaRouter","text":"<p>             Bases: <code>StreamRouter[ConsumerRecord]</code></p> <p>A class to route Kafka streams.</p> METHOD DESCRIPTION <code>_setup_log_context </code> <p>sets up the log context for the main broker and including broker</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/fastapi.py</code> <pre><code>class KafkaRouter(StreamRouter[ConsumerRecord]):\n\"\"\"A class to route Kafka streams.\n    Attributes:\n        broker_class : class representing the Kafka broker\n    Methods:\n        _setup_log_context : sets up the log context for the main broker and including broker\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nbroker_class = KafkaBroker\n@staticmethod\ndef _setup_log_context(\nmain_broker: KafkaBroker,\nincluding_broker: KafkaBroker,\n) -&gt; None:\n\"\"\"Set up log context for a Kafka broker.\n        Args:\n            main_broker: The main Kafka broker.\n            including_broker: The Kafka broker to include in the log context.\n        Returns:\n            None\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nfor h in including_broker.handlers.values():\nmain_broker._setup_log_context(h.topics)\n</code></pre>"},{"location":"api/faststream/kafka/fastapi/KafkaRouter/#faststream.kafka.fastapi.KafkaRouter.broker","title":"broker  <code>instance-attribute</code>","text":"<pre><code>broker: KafkaBroker\n</code></pre>"},{"location":"api/faststream/kafka/fastapi/KafkaRouter/#faststream.kafka.fastapi.KafkaRouter.broker_class","title":"broker_class  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>broker_class: Type[KafkaBroker] = KafkaBroker\n</code></pre>"},{"location":"api/faststream/kafka/fastapi/KafkaRouter/#faststream.kafka.fastapi.KafkaRouter.publisher","title":"publisher","text":"<pre><code>publisher(\ntopic: str,\nkey: Optional[bytes] = None,\npartition: Optional[int] = None,\ntimestamp_ms: Optional[int] = None,\nheaders: Optional[Dict[str, str]] = None,\nreply_to: str = \"\",\nbatch: bool = False,\ntitle: Optional[str] = None,\ndescription: Optional[str] = None,\n) -&gt; Publisher\n</code></pre>"},{"location":"api/faststream/kafka/handler/LogicHandler/","title":"LogicHandler","text":""},{"location":"api/faststream/kafka/handler/LogicHandler/#faststream.kafka.handler.LogicHandler","title":"faststream.kafka.handler.LogicHandler","text":"<p>             Bases: <code>AsyncHandler[ConsumerRecord]</code></p> <p>A class to handle logic for consuming messages from Kafka.</p> METHOD DESCRIPTION <code>__init__ </code> <p>constructor method for the LogicHandler class</p> <code>start </code> <p>method to start consuming messages from Kafka</p> <code>close </code> <p>method to close the Kafka consumer and cancel the consuming task</p> <code>add_call </code> <p>method to add a handler call for processing consumed messages</p> <code>_consume </code> <p>method to consume messages from Kafka and call the appropriate handler</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/handler.py</code> <pre><code>class LogicHandler(AsyncHandler[ConsumerRecord]):\n\"\"\"A class to handle logic for consuming messages from Kafka.\n    Attributes:\n        topics : sequence of strings representing the topics to consume from\n        group_id : optional string representing the consumer group ID\n        consumer : optional AIOKafkaConsumer object representing the Kafka consumer\n        task : optional asyncio.Task object representing the task for consuming messages\n        batch : boolean indicating whether to consume messages in batches\n    Methods:\n        __init__ : constructor method for the LogicHandler class\n        start : method to start consuming messages from Kafka\n        close : method to close the Kafka consumer and cancel the consuming task\n        add_call : method to add a handler call for processing consumed messages\n        _consume : method to consume messages from Kafka and call the appropriate handler\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\ntopics: Sequence[str]\ngroup_id: Optional[str] = None\nconsumer: Optional[AIOKafkaConsumer] = None\ntask: Optional[\"asyncio.Task[Any]\"] = None\nbatch: bool = False\n@override\ndef __init__(\nself,\n*topics: str,\nlog_context_builder: Callable[[StreamMessage[Any]], Dict[str, str]],\n# Kafka information\ngroup_id: Optional[str] = None,\nclient_id: str = \"faststream-\" + __version__,\nbuilder: Callable[..., AIOKafkaConsumer],\nbatch: bool = False,\nbatch_timeout_ms: int = 200,\nmax_records: Optional[int] = None,\n# AsyncAPI information\ntitle: Optional[str] = None,\ndescription: Optional[str] = None,\n):\n\"\"\"Initialize a Kafka consumer for the specified topics.\n        Args:\n            *topics: Variable length argument list of topics to consume from.\n            group_id: Optional group ID for the consumer.\n            client_id: Client ID for the consumer.\n            builder: Callable that constructs an AIOKafkaConsumer instance.\n            batch: Flag indicating whether to consume messages in batches.\n            batch_timeout_ms: Timeout in milliseconds for batch consumption.\n            max_records: Maximum number of records to consume in a batch.\n            title: Optional title for the consumer.\n            description: Optional description for the consumer.\n        Raises:\n            NotImplementedError: If silent animals are not supported.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nsuper().__init__(\nlog_context_builder=log_context_builder,\ndescription=description,\ntitle=title,\n)\nself.group_id = group_id\nself.client_id = client_id\nself.topics = topics\nself.batch = batch\nself.batch_timeout_ms = batch_timeout_ms\nself.max_records = max_records\nself.builder = builder\nself.task = None\nself.consumer = None\n# TODO: use **kwargs: Unpack[ConsumerConnectionParams] with py3.12 release 2023-10-02\nasync def start(self, **consumer_kwargs: Any) -&gt; None:\n\"\"\"Start the consumer.\n        Args:\n            **consumer_kwargs: Additional keyword arguments to pass to the consumer.\n        Returns:\n            None\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nself.consumer = consumer = self.builder(\n*self.topics,\ngroup_id=self.group_id,\nclient_id=self.client_id,\n**consumer_kwargs,\n)\nawait consumer.start()\nself.task = asyncio.create_task(self._consume())\nasync def close(self) -&gt; None:\nif self.consumer is not None:\nawait self.consumer.stop()\nself.consumer = None\nif self.task is not None:\nself.task.cancel()\nself.task = None\ndef add_call(\nself,\n*,\nhandler: HandlerCallWrapper[ConsumerRecord, P_HandlerParams, T_HandlerReturn],\ndependant: CallModel[P_HandlerParams, T_HandlerReturn],\nparser: Optional[\nUnion[\nCustomParser[ConsumerRecord],\nCustomParser[Tuple[ConsumerRecord, ...]],\n]\n],\ndecoder: Optional[\nUnion[\nCustomDecoder[ConsumerRecord],\nCustomDecoder[Tuple[ConsumerRecord, ...]],\n]\n],\nfilter: Union[\nFilter[KafkaMessage],\nFilter[StreamMessage[Tuple[ConsumerRecord, ...]]],\n],\nmiddlewares: Optional[Sequence[Callable[[ConsumerRecord], BaseMiddleware]]],\n) -&gt; None:\n\"\"\"Adds a call to the handler.\n        Args:\n            handler: The handler function to be called.\n            dependant: The dependant model.\n            parser: Optional custom parser for parsing the input.\n            decoder: Optional custom decoder for decoding the input.\n            filter: The filter for filtering the input.\n            middlewares: Optional sequence of middlewares to be applied.\n        Returns:\n            None\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nparser_ = resolve_custom_func(\nparser,\n(\nAioKafkaParser.parse_message_batch\nif self.batch\nelse AioKafkaParser.parse_message\n),\n)\ndecoder_ = resolve_custom_func(\ndecoder,  # type: ignore[arg-type]\n(\nAioKafkaParser.decode_message_batch  # type: ignore[arg-type]\nif self.batch\nelse AioKafkaParser.decode_message\n),\n)\nsuper().add_call(\nhandler=handler,\nparser=parser_,\ndecoder=decoder_,\nfilter=filter,  # type: ignore[arg-type]\ndependant=dependant,\nmiddlewares=middlewares,\n)\nasync def _consume(self) -&gt; None:\nassert self.consumer, \"You need to start handler first\"  # nosec B101\nconnected = True\nwhile self.consumer:\ntry:\nif self.batch:\nmessages = await self.consumer.getmany(\ntimeout_ms=self.batch_timeout_ms,\nmax_records=self.max_records,\n)\nif not messages:\nawait anyio.sleep(self.batch_timeout_ms / 1000)\ncontinue\nmsg = tuple(chain(*messages.values()))\nelse:\nmsg = await self.consumer.getone()\nexcept KafkaError:\nif connected is True:\nconnected = False\nawait anyio.sleep(5)\nelse:\nif connected is False:\nconnected = True\nawait self.consume(msg)\n@staticmethod\ndef get_routing_hash(topics: Sequence[str], group_id: Optional[str] = None) -&gt; str:\nreturn \"\".join((*topics, group_id or \"\"))\n</code></pre>"},{"location":"api/faststream/kafka/handler/LogicHandler/#faststream.kafka.handler.LogicHandler.batch","title":"batch  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>batch: bool = batch\n</code></pre>"},{"location":"api/faststream/kafka/handler/LogicHandler/#faststream.kafka.handler.LogicHandler.batch_timeout_ms","title":"batch_timeout_ms  <code>instance-attribute</code>","text":"<pre><code>batch_timeout_ms = batch_timeout_ms\n</code></pre>"},{"location":"api/faststream/kafka/handler/LogicHandler/#faststream.kafka.handler.LogicHandler.builder","title":"builder  <code>instance-attribute</code>","text":"<pre><code>builder = builder\n</code></pre>"},{"location":"api/faststream/kafka/handler/LogicHandler/#faststream.kafka.handler.LogicHandler.client_id","title":"client_id  <code>instance-attribute</code>","text":"<pre><code>client_id = client_id\n</code></pre>"},{"location":"api/faststream/kafka/handler/LogicHandler/#faststream.kafka.handler.LogicHandler.consumer","title":"consumer  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>consumer: Optional[AIOKafkaConsumer] = None\n</code></pre>"},{"location":"api/faststream/kafka/handler/LogicHandler/#faststream.kafka.handler.LogicHandler.group_id","title":"group_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>group_id: Optional[str] = group_id\n</code></pre>"},{"location":"api/faststream/kafka/handler/LogicHandler/#faststream.kafka.handler.LogicHandler.max_records","title":"max_records  <code>instance-attribute</code>","text":"<pre><code>max_records = max_records\n</code></pre>"},{"location":"api/faststream/kafka/handler/LogicHandler/#faststream.kafka.handler.LogicHandler.task","title":"task  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>task: Optional[asyncio.Task[Any]] = None\n</code></pre>"},{"location":"api/faststream/kafka/handler/LogicHandler/#faststream.kafka.handler.LogicHandler.topics","title":"topics  <code>instance-attribute</code>","text":"<pre><code>topics: Sequence[str] = topics\n</code></pre>"},{"location":"api/faststream/kafka/handler/LogicHandler/#faststream.kafka.handler.LogicHandler.add_call","title":"add_call","text":"<pre><code>add_call(\n*,\nhandler: HandlerCallWrapper[\nConsumerRecord, P_HandlerParams, T_HandlerReturn\n],\ndependant: CallModel[P_HandlerParams, T_HandlerReturn],\nparser: Optional[\nUnion[\nCustomParser[ConsumerRecord],\nCustomParser[Tuple[ConsumerRecord, ...]],\n]\n],\ndecoder: Optional[\nUnion[\nCustomDecoder[ConsumerRecord],\nCustomDecoder[Tuple[ConsumerRecord, ...]],\n]\n],\nfilter: Union[\nFilter[KafkaMessage],\nFilter[StreamMessage[Tuple[ConsumerRecord, ...]]],\n],\nmiddlewares: Optional[\nSequence[Callable[[ConsumerRecord], BaseMiddleware]]\n]\n) -&gt; None\n</code></pre> <p>Adds a call to the handler.</p> PARAMETER  DESCRIPTION <code>handler</code> <p>The handler function to be called.</p> <p> TYPE: <code>HandlerCallWrapper[ConsumerRecord, P_HandlerParams, T_HandlerReturn]</code> </p> <code>dependant</code> <p>The dependant model.</p> <p> TYPE: <code>CallModel[P_HandlerParams, T_HandlerReturn]</code> </p> <code>parser</code> <p>Optional custom parser for parsing the input.</p> <p> TYPE: <code>Optional[Union[CustomParser[ConsumerRecord], CustomParser[Tuple[ConsumerRecord, ...]]]]</code> </p> <code>decoder</code> <p>Optional custom decoder for decoding the input.</p> <p> TYPE: <code>Optional[Union[CustomDecoder[ConsumerRecord], CustomDecoder[Tuple[ConsumerRecord, ...]]]]</code> </p> <code>filter</code> <p>The filter for filtering the input.</p> <p> TYPE: <code>Union[Filter[KafkaMessage], Filter[StreamMessage[Tuple[ConsumerRecord, ...]]]]</code> </p> <code>middlewares</code> <p>Optional sequence of middlewares to be applied.</p> <p> TYPE: <code>Optional[Sequence[Callable[[ConsumerRecord], BaseMiddleware]]]</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/handler.py</code> <pre><code>def add_call(\nself,\n*,\nhandler: HandlerCallWrapper[ConsumerRecord, P_HandlerParams, T_HandlerReturn],\ndependant: CallModel[P_HandlerParams, T_HandlerReturn],\nparser: Optional[\nUnion[\nCustomParser[ConsumerRecord],\nCustomParser[Tuple[ConsumerRecord, ...]],\n]\n],\ndecoder: Optional[\nUnion[\nCustomDecoder[ConsumerRecord],\nCustomDecoder[Tuple[ConsumerRecord, ...]],\n]\n],\nfilter: Union[\nFilter[KafkaMessage],\nFilter[StreamMessage[Tuple[ConsumerRecord, ...]]],\n],\nmiddlewares: Optional[Sequence[Callable[[ConsumerRecord], BaseMiddleware]]],\n) -&gt; None:\n\"\"\"Adds a call to the handler.\n    Args:\n        handler: The handler function to be called.\n        dependant: The dependant model.\n        parser: Optional custom parser for parsing the input.\n        decoder: Optional custom decoder for decoding the input.\n        filter: The filter for filtering the input.\n        middlewares: Optional sequence of middlewares to be applied.\n    Returns:\n        None\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nparser_ = resolve_custom_func(\nparser,\n(\nAioKafkaParser.parse_message_batch\nif self.batch\nelse AioKafkaParser.parse_message\n),\n)\ndecoder_ = resolve_custom_func(\ndecoder,  # type: ignore[arg-type]\n(\nAioKafkaParser.decode_message_batch  # type: ignore[arg-type]\nif self.batch\nelse AioKafkaParser.decode_message\n),\n)\nsuper().add_call(\nhandler=handler,\nparser=parser_,\ndecoder=decoder_,\nfilter=filter,  # type: ignore[arg-type]\ndependant=dependant,\nmiddlewares=middlewares,\n)\n</code></pre>"},{"location":"api/faststream/kafka/handler/LogicHandler/#faststream.kafka.handler.LogicHandler.close","title":"close  <code>async</code>","text":"<pre><code>close() -&gt; None\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/handler.py</code> <pre><code>async def close(self) -&gt; None:\nif self.consumer is not None:\nawait self.consumer.stop()\nself.consumer = None\nif self.task is not None:\nself.task.cancel()\nself.task = None\n</code></pre>"},{"location":"api/faststream/kafka/handler/LogicHandler/#faststream.kafka.handler.LogicHandler.get_routing_hash","title":"get_routing_hash  <code>staticmethod</code>","text":"<pre><code>get_routing_hash(\ntopics: Sequence[str], group_id: Optional[str] = None\n) -&gt; str\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/handler.py</code> <pre><code>@staticmethod\ndef get_routing_hash(topics: Sequence[str], group_id: Optional[str] = None) -&gt; str:\nreturn \"\".join((*topics, group_id or \"\"))\n</code></pre>"},{"location":"api/faststream/kafka/handler/LogicHandler/#faststream.kafka.handler.LogicHandler.start","title":"start  <code>async</code>","text":"<pre><code>start(**consumer_kwargs: Any) -&gt; None\n</code></pre> <p>Start the consumer.</p> PARAMETER  DESCRIPTION <code>**consumer_kwargs</code> <p>Additional keyword arguments to pass to the consumer.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/handler.py</code> <pre><code>async def start(self, **consumer_kwargs: Any) -&gt; None:\n\"\"\"Start the consumer.\n    Args:\n        **consumer_kwargs: Additional keyword arguments to pass to the consumer.\n    Returns:\n        None\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nself.consumer = consumer = self.builder(\n*self.topics,\ngroup_id=self.group_id,\nclient_id=self.client_id,\n**consumer_kwargs,\n)\nawait consumer.start()\nself.task = asyncio.create_task(self._consume())\n</code></pre>"},{"location":"api/faststream/kafka/message/KafkaMessage/","title":"KafkaMessage","text":""},{"location":"api/faststream/kafka/message/KafkaMessage/#faststream.kafka.message.KafkaMessage","title":"faststream.kafka.message.KafkaMessage","text":"<p>             Bases: <code>StreamMessage[ConsumerRecord]</code></p> <p>Represents a Kafka message in the FastStream framework.</p> <p>This class extends <code>StreamMessage</code> and is specialized for handling Kafka ConsumerRecord objects.</p> METHOD DESCRIPTION <code>ack</code> <p>Acknowledge the Kafka message.</p> <code>nack</code> <p>Negative acknowledgment of the Kafka message.</p> <code>reject</code> <p>Reject the Kafka message.</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/message.py</code> <pre><code>class KafkaMessage(StreamMessage[aiokafka.ConsumerRecord]):\n\"\"\"\n    Represents a Kafka message in the FastStream framework.\n    This class extends `StreamMessage` and is specialized for handling Kafka ConsumerRecord objects.\n    Methods:\n        ack(**kwargs) -&gt; None:\n            Acknowledge the Kafka message.\n        nack(**kwargs) -&gt; None:\n            Negative acknowledgment of the Kafka message.\n        reject(**kwargs) -&gt; None:\n            Reject the Kafka message.\n    \"\"\"\nasync def ack(self, **kwargs: Any) -&gt; None:\n\"\"\"\n        Acknowledge the Kafka message.\n        Args:\n            **kwargs (Any): Additional keyword arguments.\n        Returns:\n            None: This method does not return a value.\n        \"\"\"\nreturn None\nasync def nack(self, **kwargs: Any) -&gt; None:\n\"\"\"\n        Negative acknowledgment of the Kafka message.\n        Args:\n            **kwargs (Any): Additional keyword arguments.\n        Returns:\n            None: This method does not return a value.\n        \"\"\"\nreturn None\nasync def reject(self, **kwargs: Any) -&gt; None:\n\"\"\"\n        Reject the Kafka message.\n        Args:\n            **kwargs (Any): Additional keyword arguments.\n        Returns:\n            None: This method does not return a value.\n        \"\"\"\nreturn None\n</code></pre>"},{"location":"api/faststream/kafka/message/KafkaMessage/#faststream.kafka.message.KafkaMessage.ack","title":"ack  <code>async</code>","text":"<pre><code>ack(**kwargs: Any) -&gt; None\n</code></pre> <p>Acknowledge the Kafka message.</p> PARAMETER  DESCRIPTION <code>**kwargs</code> <p>Additional keyword arguments.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>None</code> <p>This method does not return a value.</p> <p> TYPE: <code>None</code> </p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/message.py</code> <pre><code>async def ack(self, **kwargs: Any) -&gt; None:\n\"\"\"\n    Acknowledge the Kafka message.\n    Args:\n        **kwargs (Any): Additional keyword arguments.\n    Returns:\n        None: This method does not return a value.\n    \"\"\"\nreturn None\n</code></pre>"},{"location":"api/faststream/kafka/message/KafkaMessage/#faststream.kafka.message.KafkaMessage.nack","title":"nack  <code>async</code>","text":"<pre><code>nack(**kwargs: Any) -&gt; None\n</code></pre> <p>Negative acknowledgment of the Kafka message.</p> PARAMETER  DESCRIPTION <code>**kwargs</code> <p>Additional keyword arguments.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>None</code> <p>This method does not return a value.</p> <p> TYPE: <code>None</code> </p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/message.py</code> <pre><code>async def nack(self, **kwargs: Any) -&gt; None:\n\"\"\"\n    Negative acknowledgment of the Kafka message.\n    Args:\n        **kwargs (Any): Additional keyword arguments.\n    Returns:\n        None: This method does not return a value.\n    \"\"\"\nreturn None\n</code></pre>"},{"location":"api/faststream/kafka/message/KafkaMessage/#faststream.kafka.message.KafkaMessage.reject","title":"reject  <code>async</code>","text":"<pre><code>reject(**kwargs: Any) -&gt; None\n</code></pre> <p>Reject the Kafka message.</p> PARAMETER  DESCRIPTION <code>**kwargs</code> <p>Additional keyword arguments.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>None</code> <p>This method does not return a value.</p> <p> TYPE: <code>None</code> </p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/message.py</code> <pre><code>async def reject(self, **kwargs: Any) -&gt; None:\n\"\"\"\n    Reject the Kafka message.\n    Args:\n        **kwargs (Any): Additional keyword arguments.\n    Returns:\n        None: This method does not return a value.\n    \"\"\"\nreturn None\n</code></pre>"},{"location":"api/faststream/kafka/parser/AioKafkaParser/","title":"AioKafkaParser","text":""},{"location":"api/faststream/kafka/parser/AioKafkaParser/#faststream.kafka.parser.AioKafkaParser","title":"faststream.kafka.parser.AioKafkaParser","text":"Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/parser.py</code> <pre><code>class AioKafkaParser:\n@staticmethod\nasync def parse_message(\nmessage: ConsumerRecord,\n) -&gt; StreamMessage[ConsumerRecord]:\n\"\"\"Parses a Kafka message.\n        Args:\n            message: The Kafka message to parse.\n        Returns:\n            A StreamMessage object representing the parsed message.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nheaders = {i: j.decode() for i, j in message.headers}\nreturn KafkaMessage(\nbody=message.value,\nheaders=headers,\nreply_to=headers.get(\"reply_to\", \"\"),\ncontent_type=headers.get(\"content-type\"),\nmessage_id=f\"{message.offset}-{message.timestamp}\",\ncorrelation_id=headers.get(\"correlation_id\", str(uuid4())),\nraw_message=message,\n)\n@staticmethod\nasync def parse_message_batch(\nmessage: Tuple[ConsumerRecord, ...],\n) -&gt; StreamMessage[Tuple[ConsumerRecord, ...]]:\n\"\"\"Parses a batch of messages from a Kafka consumer.\n        Args:\n            message : A tuple of ConsumerRecord objects representing the messages to parse.\n        Returns:\n            A StreamMessage object containing the parsed messages.\n        Raises:\n            NotImplementedError: If any of the messages are silent (i.e., have no sound).\n        Static Method:\n            This method is a static method. It does not require an instance of the class to be called.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nfirst = message[0]\nlast = message[-1]\nheaders = {i: j.decode() for i, j in first.headers}\nreturn KafkaMessage(\nbody=[m.value for m in message],\nheaders=headers,\nreply_to=headers.get(\"reply_to\", \"\"),\ncontent_type=headers.get(\"content-type\"),\nmessage_id=f\"{first.offset}-{last.offset}-{first.timestamp}\",\ncorrelation_id=headers.get(\"correlation_id\", str(uuid4())),\nraw_message=message,\n)\n@staticmethod\nasync def decode_message(msg: StreamMessage[ConsumerRecord]) -&gt; DecodedMessage:\n\"\"\"Decodes a message.\n        Args:\n            msg: The message to be decoded.\n        Returns:\n            The decoded message.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nreturn decode_message(msg)\n@classmethod\nasync def decode_message_batch(\ncls, msg: StreamMessage[Tuple[ConsumerRecord, ...]]\n) -&gt; List[DecodedMessage]:\n\"\"\"Decode a batch of messages.\n        Args:\n            msg: A stream message containing a tuple of consumer records.\n        Returns:\n            A list of decoded messages.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nreturn [decode_message(await cls.parse_message(m)) for m in msg.raw_message]\n</code></pre>"},{"location":"api/faststream/kafka/parser/AioKafkaParser/#faststream.kafka.parser.AioKafkaParser.decode_message","title":"decode_message  <code>async</code> <code>staticmethod</code>","text":"<pre><code>decode_message(\nmsg: StreamMessage[ConsumerRecord],\n) -&gt; DecodedMessage\n</code></pre> <p>Decodes a message.</p> PARAMETER  DESCRIPTION <code>msg</code> <p>The message to be decoded.</p> <p> TYPE: <code>StreamMessage[ConsumerRecord]</code> </p> RETURNS DESCRIPTION <code>DecodedMessage</code> <p>The decoded message.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/parser.py</code> <pre><code>@staticmethod\nasync def decode_message(msg: StreamMessage[ConsumerRecord]) -&gt; DecodedMessage:\n\"\"\"Decodes a message.\n    Args:\n        msg: The message to be decoded.\n    Returns:\n        The decoded message.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nreturn decode_message(msg)\n</code></pre>"},{"location":"api/faststream/kafka/parser/AioKafkaParser/#faststream.kafka.parser.AioKafkaParser.decode_message_batch","title":"decode_message_batch  <code>async</code> <code>classmethod</code>","text":"<pre><code>decode_message_batch(\nmsg: StreamMessage[Tuple[ConsumerRecord, ...]]\n) -&gt; List[DecodedMessage]\n</code></pre> <p>Decode a batch of messages.</p> PARAMETER  DESCRIPTION <code>msg</code> <p>A stream message containing a tuple of consumer records.</p> <p> TYPE: <code>StreamMessage[Tuple[ConsumerRecord, ...]]</code> </p> RETURNS DESCRIPTION <code>List[DecodedMessage]</code> <p>A list of decoded messages.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/parser.py</code> <pre><code>@classmethod\nasync def decode_message_batch(\ncls, msg: StreamMessage[Tuple[ConsumerRecord, ...]]\n) -&gt; List[DecodedMessage]:\n\"\"\"Decode a batch of messages.\n    Args:\n        msg: A stream message containing a tuple of consumer records.\n    Returns:\n        A list of decoded messages.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nreturn [decode_message(await cls.parse_message(m)) for m in msg.raw_message]\n</code></pre>"},{"location":"api/faststream/kafka/parser/AioKafkaParser/#faststream.kafka.parser.AioKafkaParser.parse_message","title":"parse_message  <code>async</code> <code>staticmethod</code>","text":"<pre><code>parse_message(\nmessage: ConsumerRecord,\n) -&gt; StreamMessage[ConsumerRecord]\n</code></pre> <p>Parses a Kafka message.</p> PARAMETER  DESCRIPTION <code>message</code> <p>The Kafka message to parse.</p> <p> TYPE: <code>ConsumerRecord</code> </p> RETURNS DESCRIPTION <code>StreamMessage[ConsumerRecord]</code> <p>A StreamMessage object representing the parsed message.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/parser.py</code> <pre><code>@staticmethod\nasync def parse_message(\nmessage: ConsumerRecord,\n) -&gt; StreamMessage[ConsumerRecord]:\n\"\"\"Parses a Kafka message.\n    Args:\n        message: The Kafka message to parse.\n    Returns:\n        A StreamMessage object representing the parsed message.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nheaders = {i: j.decode() for i, j in message.headers}\nreturn KafkaMessage(\nbody=message.value,\nheaders=headers,\nreply_to=headers.get(\"reply_to\", \"\"),\ncontent_type=headers.get(\"content-type\"),\nmessage_id=f\"{message.offset}-{message.timestamp}\",\ncorrelation_id=headers.get(\"correlation_id\", str(uuid4())),\nraw_message=message,\n)\n</code></pre>"},{"location":"api/faststream/kafka/parser/AioKafkaParser/#faststream.kafka.parser.AioKafkaParser.parse_message_batch","title":"parse_message_batch  <code>async</code> <code>staticmethod</code>","text":"<pre><code>parse_message_batch(\nmessage: Tuple[ConsumerRecord, ...]\n) -&gt; StreamMessage[Tuple[ConsumerRecord, ...]]\n</code></pre> <p>Parses a batch of messages from a Kafka consumer.</p> PARAMETER  DESCRIPTION <code>message</code> <p>A tuple of ConsumerRecord objects representing the messages to parse.</p> <p> </p> RETURNS DESCRIPTION <code>StreamMessage[Tuple[ConsumerRecord, ...]]</code> <p>A StreamMessage object containing the parsed messages.</p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>If any of the messages are silent (i.e., have no sound).</p> Static Method <p>This method is a static method. It does not require an instance of the class to be called.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/parser.py</code> <pre><code>@staticmethod\nasync def parse_message_batch(\nmessage: Tuple[ConsumerRecord, ...],\n) -&gt; StreamMessage[Tuple[ConsumerRecord, ...]]:\n\"\"\"Parses a batch of messages from a Kafka consumer.\n    Args:\n        message : A tuple of ConsumerRecord objects representing the messages to parse.\n    Returns:\n        A StreamMessage object containing the parsed messages.\n    Raises:\n        NotImplementedError: If any of the messages are silent (i.e., have no sound).\n    Static Method:\n        This method is a static method. It does not require an instance of the class to be called.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nfirst = message[0]\nlast = message[-1]\nheaders = {i: j.decode() for i, j in first.headers}\nreturn KafkaMessage(\nbody=[m.value for m in message],\nheaders=headers,\nreply_to=headers.get(\"reply_to\", \"\"),\ncontent_type=headers.get(\"content-type\"),\nmessage_id=f\"{first.offset}-{last.offset}-{first.timestamp}\",\ncorrelation_id=headers.get(\"correlation_id\", str(uuid4())),\nraw_message=message,\n)\n</code></pre>"},{"location":"api/faststream/kafka/producer/AioKafkaFastProducer/","title":"AioKafkaFastProducer","text":""},{"location":"api/faststream/kafka/producer/AioKafkaFastProducer/#faststream.kafka.producer.AioKafkaFastProducer","title":"faststream.kafka.producer.AioKafkaFastProducer","text":"<p>A class to represent a fast Kafka producer.</p> METHOD DESCRIPTION <code>publish </code> <p>Publishes a message to a Kafka topic.</p> <code>stop </code> <p>Stops the Kafka producer.</p> <code>publish_batch </code> <p>Publishes a batch of messages to a Kafka topic.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/producer.py</code> <pre><code>class AioKafkaFastProducer:\n\"\"\"A class to represent a fast Kafka producer.\n    Attributes:\n        _producer : AIOKafkaProducer object representing the Kafka producer\n    Methods:\n        publish : Publishes a message to a Kafka topic.\n        stop : Stops the Kafka producer.\n        publish_batch : Publishes a batch of messages to a Kafka topic.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n_producer: Optional[AIOKafkaProducer]\ndef __init__(\nself,\nproducer: AIOKafkaProducer,\n):\n\"\"\"Initialize the class.\n        Args:\n            producer: An instance of AIOKafkaProducer.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nself._producer = producer\nasync def publish(\nself,\nmessage: SendableMessage,\ntopic: str,\nkey: Optional[bytes] = None,\npartition: Optional[int] = None,\ntimestamp_ms: Optional[int] = None,\nheaders: Optional[Dict[str, str]] = None,\ncorrelation_id: Optional[str] = None,\n*,\nreply_to: str = \"\",\n) -&gt; None:\n\"\"\"Publish a message to a topic.\n        Args:\n            message: The message to be published.\n            topic: The topic to publish the message to.\n            key: The key associated with the message.\n            partition: The partition to which the message should be sent.\n            timestamp_ms: The timestamp of the message in milliseconds.\n            headers: Additional headers to be included with the message.\n            correlation_id: The correlation ID of the message.\n            reply_to: The topic to which the reply should be sent.\n        Returns:\n            None\n        Raises:\n            AssertionError: If the broker is not connected.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nassert self._producer, \"You need to connect broker at first\"  # nosec B101\nmessage, content_type = encode_message(message)\nheaders_to_send = {\n\"content-type\": content_type or \"\",\n\"correlation_id\": correlation_id or str(uuid4()),\n**(headers or {}),\n}\nif reply_to:\nheaders_to_send.update({\"reply_to\": reply_to})\nawait self._producer.send(\ntopic=topic,\nvalue=message,\nkey=key,\npartition=partition,\ntimestamp_ms=timestamp_ms,\nheaders=[(i, (j or \"\").encode()) for i, j in headers_to_send.items()],\n)\nreturn None\nasync def stop(self) -&gt; None:\nif self._producer is not None:  # pragma: no branch\nawait self._producer.stop()\nasync def publish_batch(\nself,\n*msgs: SendableMessage,\ntopic: str,\npartition: Optional[int] = None,\ntimestamp_ms: Optional[int] = None,\nheaders: Optional[Dict[str, str]] = None,\n) -&gt; None:\n\"\"\"Publish a batch of messages to a topic.\n        Args:\n            *msgs: Variable length argument list of messages to be sent.\n            topic: The topic to which the messages should be published.\n            partition: The partition to which the messages should be sent. Defaults to None.\n            timestamp_ms: The timestamp to be associated with the messages. Defaults to None.\n            headers: Additional headers to be included with the messages. Defaults to None.\n        Returns:\n            None\n        Raises:\n            AssertionError: If the broker is not connected.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nassert self._producer, \"You need to connect broker at first\"  # nosec B101\nbatch = self._producer.create_batch()\nfor msg in msgs:\nmessage, content_type = encode_message(msg)\nheaders_to_send = {\n\"content-type\": content_type or \"\",\n**(headers or {}),\n}\nbatch.append(\nkey=None,\nvalue=message,\ntimestamp=timestamp_ms,\nheaders=[(i, j.encode()) for i, j in headers_to_send.items()],\n)\nawait self._producer.send_batch(batch, topic, partition=partition)\n</code></pre>"},{"location":"api/faststream/kafka/producer/AioKafkaFastProducer/#faststream.kafka.producer.AioKafkaFastProducer.publish","title":"publish  <code>async</code>","text":"<pre><code>publish(\nmessage: SendableMessage,\ntopic: str,\nkey: Optional[bytes] = None,\npartition: Optional[int] = None,\ntimestamp_ms: Optional[int] = None,\nheaders: Optional[Dict[str, str]] = None,\ncorrelation_id: Optional[str] = None,\n*,\nreply_to: str = \"\"\n) -&gt; None\n</code></pre> <p>Publish a message to a topic.</p> PARAMETER  DESCRIPTION <code>message</code> <p>The message to be published.</p> <p> TYPE: <code>SendableMessage</code> </p> <code>topic</code> <p>The topic to publish the message to.</p> <p> TYPE: <code>str</code> </p> <code>key</code> <p>The key associated with the message.</p> <p> TYPE: <code>Optional[bytes]</code> DEFAULT: <code>None</code> </p> <code>partition</code> <p>The partition to which the message should be sent.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>timestamp_ms</code> <p>The timestamp of the message in milliseconds.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>headers</code> <p>Additional headers to be included with the message.</p> <p> TYPE: <code>Optional[Dict[str, str]]</code> DEFAULT: <code>None</code> </p> <code>correlation_id</code> <p>The correlation ID of the message.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>reply_to</code> <p>The topic to which the reply should be sent.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> RAISES DESCRIPTION <code>AssertionError</code> <p>If the broker is not connected.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/producer.py</code> <pre><code>async def publish(\nself,\nmessage: SendableMessage,\ntopic: str,\nkey: Optional[bytes] = None,\npartition: Optional[int] = None,\ntimestamp_ms: Optional[int] = None,\nheaders: Optional[Dict[str, str]] = None,\ncorrelation_id: Optional[str] = None,\n*,\nreply_to: str = \"\",\n) -&gt; None:\n\"\"\"Publish a message to a topic.\n    Args:\n        message: The message to be published.\n        topic: The topic to publish the message to.\n        key: The key associated with the message.\n        partition: The partition to which the message should be sent.\n        timestamp_ms: The timestamp of the message in milliseconds.\n        headers: Additional headers to be included with the message.\n        correlation_id: The correlation ID of the message.\n        reply_to: The topic to which the reply should be sent.\n    Returns:\n        None\n    Raises:\n        AssertionError: If the broker is not connected.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nassert self._producer, \"You need to connect broker at first\"  # nosec B101\nmessage, content_type = encode_message(message)\nheaders_to_send = {\n\"content-type\": content_type or \"\",\n\"correlation_id\": correlation_id or str(uuid4()),\n**(headers or {}),\n}\nif reply_to:\nheaders_to_send.update({\"reply_to\": reply_to})\nawait self._producer.send(\ntopic=topic,\nvalue=message,\nkey=key,\npartition=partition,\ntimestamp_ms=timestamp_ms,\nheaders=[(i, (j or \"\").encode()) for i, j in headers_to_send.items()],\n)\nreturn None\n</code></pre>"},{"location":"api/faststream/kafka/producer/AioKafkaFastProducer/#faststream.kafka.producer.AioKafkaFastProducer.publish_batch","title":"publish_batch  <code>async</code>","text":"<pre><code>publish_batch(\n*msgs: SendableMessage,\ntopic: str,\npartition: Optional[int] = None,\ntimestamp_ms: Optional[int] = None,\nheaders: Optional[Dict[str, str]] = None\n) -&gt; None\n</code></pre> <p>Publish a batch of messages to a topic.</p> PARAMETER  DESCRIPTION <code>*msgs</code> <p>Variable length argument list of messages to be sent.</p> <p> TYPE: <code>SendableMessage</code> DEFAULT: <code>()</code> </p> <code>topic</code> <p>The topic to which the messages should be published.</p> <p> TYPE: <code>str</code> </p> <code>partition</code> <p>The partition to which the messages should be sent. Defaults to None.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>timestamp_ms</code> <p>The timestamp to be associated with the messages. Defaults to None.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>headers</code> <p>Additional headers to be included with the messages. Defaults to None.</p> <p> TYPE: <code>Optional[Dict[str, str]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> RAISES DESCRIPTION <code>AssertionError</code> <p>If the broker is not connected.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/producer.py</code> <pre><code>async def publish_batch(\nself,\n*msgs: SendableMessage,\ntopic: str,\npartition: Optional[int] = None,\ntimestamp_ms: Optional[int] = None,\nheaders: Optional[Dict[str, str]] = None,\n) -&gt; None:\n\"\"\"Publish a batch of messages to a topic.\n    Args:\n        *msgs: Variable length argument list of messages to be sent.\n        topic: The topic to which the messages should be published.\n        partition: The partition to which the messages should be sent. Defaults to None.\n        timestamp_ms: The timestamp to be associated with the messages. Defaults to None.\n        headers: Additional headers to be included with the messages. Defaults to None.\n    Returns:\n        None\n    Raises:\n        AssertionError: If the broker is not connected.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nassert self._producer, \"You need to connect broker at first\"  # nosec B101\nbatch = self._producer.create_batch()\nfor msg in msgs:\nmessage, content_type = encode_message(msg)\nheaders_to_send = {\n\"content-type\": content_type or \"\",\n**(headers or {}),\n}\nbatch.append(\nkey=None,\nvalue=message,\ntimestamp=timestamp_ms,\nheaders=[(i, j.encode()) for i, j in headers_to_send.items()],\n)\nawait self._producer.send_batch(batch, topic, partition=partition)\n</code></pre>"},{"location":"api/faststream/kafka/producer/AioKafkaFastProducer/#faststream.kafka.producer.AioKafkaFastProducer.stop","title":"stop  <code>async</code>","text":"<pre><code>stop() -&gt; None\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/producer.py</code> <pre><code>async def stop(self) -&gt; None:\nif self._producer is not None:  # pragma: no branch\nawait self._producer.stop()\n</code></pre>"},{"location":"api/faststream/kafka/publisher/LogicPublisher/","title":"LogicPublisher","text":""},{"location":"api/faststream/kafka/publisher/LogicPublisher/#faststream.kafka.publisher.LogicPublisher","title":"faststream.kafka.publisher.LogicPublisher  <code>dataclass</code>","text":"<p>             Bases: <code>ABCPublisher[ConsumerRecord]</code></p> <p>A class to publish messages to a Kafka topic.</p> METHOD DESCRIPTION <code>publish </code> <p>Publishes messages to the Kafka topic</p> RAISES DESCRIPTION <code>AssertionError</code> <p>If <code>_producer</code> is not set up or if multiple messages are sent without the <code>batch</code> flag</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/publisher.py</code> <pre><code>@dataclass\nclass LogicPublisher(ABCPublisher[ConsumerRecord]):\n\"\"\"A class to publish messages to a Kafka topic.\n    Attributes:\n        _producer : An optional instance of AioKafkaFastProducer\n        batch : A boolean indicating whether to send messages in batch\n        client_id : A string representing the client ID\n    Methods:\n        publish : Publishes messages to the Kafka topic\n    Raises:\n        AssertionError: If `_producer` is not set up or if multiple messages are sent without the `batch` flag\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n_producer: Optional[AioKafkaFastProducer] = field(default=None, init=False)\nbatch: bool = field(default=False)\nclient_id: str = field(default=\"faststream-\" + __version__)\n@override\nasync def publish(  # type: ignore[override]\nself,\n*messages: SendableMessage,\nmessage: SendableMessage = \"\",\nkey: Optional[bytes] = None,\npartition: Optional[int] = None,\ntimestamp_ms: Optional[int] = None,\nheaders: Optional[Dict[str, str]] = None,\ncorrelation_id: Optional[str] = None,\n) -&gt; None:\n\"\"\"Publish messages to a topic.\n        Args:\n            *messages: Variable length argument list of SendableMessage objects.\n            message: A SendableMessage object. Default is an empty string.\n            key: Optional bytes object representing the message key.\n            partition: Optional integer representing the partition to publish the message to.\n            timestamp_ms: Optional integer representing the timestamp of the message in milliseconds.\n            headers: Optional dictionary of header key-value pairs.\n            correlation_id: Optional string representing the correlation ID of the message.\n        Returns:\n            None\n        Raises:\n            AssertionError: If `_producer` is not set up.\n            AssertionError: If `batch` flag is not set and there are multiple messages.\n            ValueError: If `message` is not a sequence when `messages` is empty.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nassert self._producer, \"Please, setup `_producer` first\"  # nosec B101\nassert (  # nosec B101\nself.batch or len(messages) &lt; 2\n), \"You can't send multiple messages without `batch` flag\"\nif not self.batch:\nreturn await self._producer.publish(\nmessage=next(iter(messages), message),\ntopic=self.topic,\nkey=key or self.key,\npartition=partition or self.partition,\ntimestamp_ms=timestamp_ms or self.timestamp_ms,\ncorrelation_id=correlation_id,\nheaders=headers or self.headers,\nreply_to=self.reply_to or \"\",\n)\nelse:\nto_send: Sequence[SendableMessage]\nif not messages:\nif not isinstance(message, Sequence):\nraise ValueError(\nf\"Message: {messages} should be Sequence type to send in batch\"\n)\nelse:\nto_send = message\nelse:\nto_send = messages\nawait self._producer.publish_batch(\n*to_send,\ntopic=self.topic,\npartition=partition or self.partition,\ntimestamp_ms=timestamp_ms or self.timestamp_ms,\nheaders=headers or self.headers,\n)\nreturn None\n</code></pre>"},{"location":"api/faststream/kafka/publisher/LogicPublisher/#faststream.kafka.publisher.LogicPublisher.batch","title":"batch  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>batch: bool = field(default=False)\n</code></pre>"},{"location":"api/faststream/kafka/publisher/LogicPublisher/#faststream.kafka.publisher.LogicPublisher.client_id","title":"client_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>client_id: str = field(default='faststream-' + __version__)\n</code></pre>"},{"location":"api/faststream/kafka/publisher/LogicPublisher/#faststream.kafka.publisher.LogicPublisher.publish","title":"publish  <code>async</code>","text":"<pre><code>publish(\n*messages: SendableMessage,\nmessage: SendableMessage = \"\",\nkey: Optional[bytes] = None,\npartition: Optional[int] = None,\ntimestamp_ms: Optional[int] = None,\nheaders: Optional[Dict[str, str]] = None,\ncorrelation_id: Optional[str] = None\n) -&gt; None\n</code></pre> <p>Publish messages to a topic.</p> PARAMETER  DESCRIPTION <code>*messages</code> <p>Variable length argument list of SendableMessage objects.</p> <p> TYPE: <code>SendableMessage</code> DEFAULT: <code>()</code> </p> <code>message</code> <p>A SendableMessage object. Default is an empty string.</p> <p> TYPE: <code>SendableMessage</code> DEFAULT: <code>''</code> </p> <code>key</code> <p>Optional bytes object representing the message key.</p> <p> TYPE: <code>Optional[bytes]</code> DEFAULT: <code>None</code> </p> <code>partition</code> <p>Optional integer representing the partition to publish the message to.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>timestamp_ms</code> <p>Optional integer representing the timestamp of the message in milliseconds.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>headers</code> <p>Optional dictionary of header key-value pairs.</p> <p> TYPE: <code>Optional[Dict[str, str]]</code> DEFAULT: <code>None</code> </p> <code>correlation_id</code> <p>Optional string representing the correlation ID of the message.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> RAISES DESCRIPTION <code>AssertionError</code> <p>If <code>_producer</code> is not set up.</p> <code>AssertionError</code> <p>If <code>batch</code> flag is not set and there are multiple messages.</p> <code>ValueError</code> <p>If <code>message</code> is not a sequence when <code>messages</code> is empty.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/publisher.py</code> <pre><code>@override\nasync def publish(  # type: ignore[override]\nself,\n*messages: SendableMessage,\nmessage: SendableMessage = \"\",\nkey: Optional[bytes] = None,\npartition: Optional[int] = None,\ntimestamp_ms: Optional[int] = None,\nheaders: Optional[Dict[str, str]] = None,\ncorrelation_id: Optional[str] = None,\n) -&gt; None:\n\"\"\"Publish messages to a topic.\n    Args:\n        *messages: Variable length argument list of SendableMessage objects.\n        message: A SendableMessage object. Default is an empty string.\n        key: Optional bytes object representing the message key.\n        partition: Optional integer representing the partition to publish the message to.\n        timestamp_ms: Optional integer representing the timestamp of the message in milliseconds.\n        headers: Optional dictionary of header key-value pairs.\n        correlation_id: Optional string representing the correlation ID of the message.\n    Returns:\n        None\n    Raises:\n        AssertionError: If `_producer` is not set up.\n        AssertionError: If `batch` flag is not set and there are multiple messages.\n        ValueError: If `message` is not a sequence when `messages` is empty.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nassert self._producer, \"Please, setup `_producer` first\"  # nosec B101\nassert (  # nosec B101\nself.batch or len(messages) &lt; 2\n), \"You can't send multiple messages without `batch` flag\"\nif not self.batch:\nreturn await self._producer.publish(\nmessage=next(iter(messages), message),\ntopic=self.topic,\nkey=key or self.key,\npartition=partition or self.partition,\ntimestamp_ms=timestamp_ms or self.timestamp_ms,\ncorrelation_id=correlation_id,\nheaders=headers or self.headers,\nreply_to=self.reply_to or \"\",\n)\nelse:\nto_send: Sequence[SendableMessage]\nif not messages:\nif not isinstance(message, Sequence):\nraise ValueError(\nf\"Message: {messages} should be Sequence type to send in batch\"\n)\nelse:\nto_send = message\nelse:\nto_send = messages\nawait self._producer.publish_batch(\n*to_send,\ntopic=self.topic,\npartition=partition or self.partition,\ntimestamp_ms=timestamp_ms or self.timestamp_ms,\nheaders=headers or self.headers,\n)\nreturn None\n</code></pre>"},{"location":"api/faststream/kafka/router/KafkaRouter/","title":"KafkaRouter","text":""},{"location":"api/faststream/kafka/router/KafkaRouter/#faststream.kafka.router.KafkaRouter","title":"faststream.kafka.router.KafkaRouter","text":"<p>             Bases: <code>KafkaRouter</code></p> <p>A class to represent a Kafka router.</p> METHOD DESCRIPTION <code>_get_publisher_key </code> <p>Get the key for a publisher</p> <code>_update_publisher_prefix </code> <p>Update the prefix of a publisher</p> <code>publisher </code> <p>Create a new publisher</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/router.py</code> <pre><code>class KafkaRouter(BaseRouter):\n\"\"\"A class to represent a Kafka router.\n    Attributes:\n        _publishers : Dictionary of publishers\n    Methods:\n        _get_publisher_key : Get the key for a publisher\n        _update_publisher_prefix : Update the prefix of a publisher\n        publisher : Create a new publisher\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n_publishers: Dict[str, Publisher]  # type: ignore[assignment]\n@override\n@staticmethod\ndef _get_publisher_key(publisher: Publisher) -&gt; str:  # type: ignore[override]\n\"\"\"Get the publisher key.\n        Args:\n            publisher: The publisher object.\n        Returns:\n            The publisher key.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nreturn publisher.topic\n@override\n@staticmethod\ndef _update_publisher_prefix(  # type: ignore[override]\nprefix: str,\npublisher: Publisher,\n) -&gt; Publisher:\n\"\"\"Updates the prefix of a publisher.\n        Args:\n            prefix: The prefix to be added to the publisher's topic.\n            publisher: The publisher object to be updated.\n        Returns:\n            The updated publisher object.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\npublisher.topic = prefix + publisher.topic\nreturn publisher\n@override\ndef publisher(  # type: ignore[override]\nself,\ntopic: str,\nkey: Optional[bytes] = None,\npartition: Optional[int] = None,\ntimestamp_ms: Optional[int] = None,\nheaders: Optional[Dict[str, str]] = None,\nreply_to: str = \"\",\nbatch: bool = False,\n# AsyncAPI information\ntitle: Optional[str] = None,\ndescription: Optional[str] = None,\n) -&gt; Publisher:\n\"\"\"Publishes a message to a topic.\n        Args:\n            topic (str): The topic to publish the message to.\n            key (bytes, optional): The key associated with the message.\n            partition (int, optional): The partition to publish the message to.\n            timestamp_ms (int, optional): The timestamp of the message in milliseconds.\n            headers (Dict[str, str], optional): Additional headers for the message.\n            reply_to (str, optional): The topic to reply to.\n            batch (bool, optional): Whether to publish the message as part of a batch.\n            title (str, optional): The title of the message.\n            description (str, optional): The description of the message.\n        Returns:\n            Publisher: The publisher object used to publish the message.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nnew_publisher = self._update_publisher_prefix(\nself.prefix,\nPublisher(\ntopic=topic,\nkey=key,\npartition=partition,\ntimestamp_ms=timestamp_ms,\nheaders=headers,\nreply_to=reply_to,\ntitle=title,\nbatch=batch,\n_description=description,\n),\n)\npublisher_key = self._get_publisher_key(new_publisher)\npublisher = self._publishers[publisher_key] = self._publishers.get(\npublisher_key, new_publisher\n)\nreturn publisher\n</code></pre>"},{"location":"api/faststream/kafka/router/KafkaRouter/#faststream.kafka.router.KafkaRouter.publisher","title":"publisher","text":"<pre><code>publisher(\ntopic: str,\nkey: Optional[bytes] = None,\npartition: Optional[int] = None,\ntimestamp_ms: Optional[int] = None,\nheaders: Optional[Dict[str, str]] = None,\nreply_to: str = \"\",\nbatch: bool = False,\ntitle: Optional[str] = None,\ndescription: Optional[str] = None,\n) -&gt; Publisher\n</code></pre> <p>Publishes a message to a topic.</p> PARAMETER  DESCRIPTION <code>topic</code> <p>The topic to publish the message to.</p> <p> TYPE: <code>str</code> </p> <code>key</code> <p>The key associated with the message.</p> <p> TYPE: <code>bytes</code> DEFAULT: <code>None</code> </p> <code>partition</code> <p>The partition to publish the message to.</p> <p> TYPE: <code>int</code> DEFAULT: <code>None</code> </p> <code>timestamp_ms</code> <p>The timestamp of the message in milliseconds.</p> <p> TYPE: <code>int</code> DEFAULT: <code>None</code> </p> <code>headers</code> <p>Additional headers for the message.</p> <p> TYPE: <code>Dict[str, str]</code> DEFAULT: <code>None</code> </p> <code>reply_to</code> <p>The topic to reply to.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>batch</code> <p>Whether to publish the message as part of a batch.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>title</code> <p>The title of the message.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>description</code> <p>The description of the message.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Publisher</code> <p>The publisher object used to publish the message.</p> <p> TYPE: <code>Publisher</code> </p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/router.py</code> <pre><code>@override\ndef publisher(  # type: ignore[override]\nself,\ntopic: str,\nkey: Optional[bytes] = None,\npartition: Optional[int] = None,\ntimestamp_ms: Optional[int] = None,\nheaders: Optional[Dict[str, str]] = None,\nreply_to: str = \"\",\nbatch: bool = False,\n# AsyncAPI information\ntitle: Optional[str] = None,\ndescription: Optional[str] = None,\n) -&gt; Publisher:\n\"\"\"Publishes a message to a topic.\n    Args:\n        topic (str): The topic to publish the message to.\n        key (bytes, optional): The key associated with the message.\n        partition (int, optional): The partition to publish the message to.\n        timestamp_ms (int, optional): The timestamp of the message in milliseconds.\n        headers (Dict[str, str], optional): Additional headers for the message.\n        reply_to (str, optional): The topic to reply to.\n        batch (bool, optional): Whether to publish the message as part of a batch.\n        title (str, optional): The title of the message.\n        description (str, optional): The description of the message.\n    Returns:\n        Publisher: The publisher object used to publish the message.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nnew_publisher = self._update_publisher_prefix(\nself.prefix,\nPublisher(\ntopic=topic,\nkey=key,\npartition=partition,\ntimestamp_ms=timestamp_ms,\nheaders=headers,\nreply_to=reply_to,\ntitle=title,\nbatch=batch,\n_description=description,\n),\n)\npublisher_key = self._get_publisher_key(new_publisher)\npublisher = self._publishers[publisher_key] = self._publishers.get(\npublisher_key, new_publisher\n)\nreturn publisher\n</code></pre>"},{"location":"api/faststream/kafka/router/KafkaRouter/#faststream.kafka.router.KafkaRouter.subscriber","title":"subscriber","text":"<pre><code>subscriber(\n*topics: str,\ngroup_id: Optional[str] = None,\nkey_deserializer: Optional[\nCallable[[bytes], Any]\n] = None,\nvalue_deserializer: Optional[\nCallable[[bytes], Any]\n] = None,\nfetch_max_wait_ms: int = 500,\nfetch_max_bytes: int = 52428800,\nfetch_min_bytes: int = 1,\nmax_partition_fetch_bytes: int = 1 * 1024 * 1024,\nauto_offset_reset: Literal[\n\"latest\", \"earliest\", \"none\"\n] = \"latest\",\nenable_auto_commit: bool = True,\nauto_commit_interval_ms: int = 5000,\ncheck_crcs: bool = True,\npartition_assignment_strategy: Sequence[\nAbstractPartitionAssignor\n] = (RoundRobinPartitionAssignor),\nmax_poll_interval_ms: int = 300000,\nrebalance_timeout_ms: Optional[int] = None,\nsession_timeout_ms: int = 10000,\nheartbeat_interval_ms: int = 3000,\nconsumer_timeout_ms: int = 200,\nmax_poll_records: Optional[int] = None,\nexclude_internal_topics: bool = True,\nisolation_level: Literal[\n\"read_uncommitted\", \"read_committed\"\n] = \"read_uncommitted\",\ndependencies: Sequence[Depends] = (),\nparser: Optional[\nCustomParser[aiokafka.ConsumerRecord]\n] = None,\ndecoder: Optional[\nCustomDecoder[aiokafka.ConsumerRecord]\n] = None,\nmiddlewares: Optional[\nSequence[\nCallable[\n[aiokafka.ConsumerRecord], BaseMiddleware\n]\n]\n] = None,\nfilter: Filter[KafkaMessage] = default_filter,\nbatch: bool = False,\nmax_records: Optional[int] = None,\nbatch_timeout_ms: int = 200,\nretry: Union[bool, int] = False,\ntitle: Optional[str] = None,\ndescription: Optional[str] = None,\n**__service_kwargs: Any\n) -&gt; Callable[\n[Callable[P_HandlerParams, T_HandlerReturn]],\nHandlerCallWrapper[\naiokafka.ConsumerRecord,\nP_HandlerParams,\nT_HandlerReturn,\n],\n]\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/router.py</code> <pre><code>        publisher: The publisher object to be updated.\nReturns:\nThe updated publisher object.\n!!! note\nThe above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n\"\"\"\n    publisher.topic = prefix + publisher.topic\n    return publisher\n@override\ndef publisher(  # type: ignore[override]\n    self,\n    topic: str,\n    key: Optional[bytes] = None,\n    partition: Optional[int] = None,\n    timestamp_ms: Optional[int] = None,\n    headers: Optional[Dict[str, str]] = None,\n    reply_to: str = \"\",\n    batch: bool = False,\n    # AsyncAPI information\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n) -&gt; Publisher:\n    \"\"\"Publishes a message to a topic.\nArgs:\ntopic (str): The topic to publish the message to.\nkey (bytes, optional): The key associated with the message.\npartition (int, optional): The partition to publish the message to.\ntimestamp_ms (int, optional): The timestamp of the message in milliseconds.\nheaders (Dict[str, str], optional): Additional headers for the message.\nreply_to (str, optional): The topic to reply to.\nbatch (bool, optional): Whether to publish the message as part of a batch.\ntitle (str, optional): The title of the message.\ndescription (str, optional): The description of the message.\nReturns:\nPublisher: The publisher object used to publish the message.\n!!! note\nThe above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n\"\"\"\n    new_publisher = self._update_publisher_prefix(\n        self.prefix,\n        Publisher(\n            topic=topic,\n            key=key,\n            partition=partition,\n            timestamp_ms=timestamp_ms,\n            headers=headers,\n            reply_to=reply_to,\n            title=title,\n            batch=batch,\n            _description=description,\n        ),\n    )\n</code></pre>"},{"location":"api/faststream/kafka/security/parse_security/","title":"Parse security","text":""},{"location":"api/faststream/kafka/security/parse_security/#faststream.kafka.security.parse_security","title":"faststream.kafka.security.parse_security","text":"<pre><code>parse_security(\nsecurity: Optional[BaseSecurity],\n) -&gt; Dict[str, Any]\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/security.py</code> <pre><code>def parse_security(security: Optional[BaseSecurity]) -&gt; Dict[str, Any]:\nif security is None:\nreturn {}\nelif type(security) == BaseSecurity:\nreturn _parse_base_security(security)\nelif type(security) == SASLPlaintext:\nreturn _parse_sasl_plaintext(security)\nelif type(security) == SASLScram256:\nreturn _parse_sasl_scram256(security)\nelif type(security) == SASLScram512:\nreturn _parse_sasl_scram512(security)\nelse:\nraise NotImplementedError(f\"KafkaBroker does not support {type(security)}\")\n</code></pre>"},{"location":"api/faststream/kafka/shared/logging/KafkaLoggingMixin/","title":"KafkaLoggingMixin","text":""},{"location":"api/faststream/kafka/shared/logging/KafkaLoggingMixin/#faststream.kafka.shared.logging.KafkaLoggingMixin","title":"faststream.kafka.shared.logging.KafkaLoggingMixin","text":"<p>             Bases: <code>LoggingMixin</code></p> <p>A class that provides logging functionality for Kafka.</p> METHOD DESCRIPTION <code>__init__ </code> <p>initializes the KafkaLoggingMixin object</p> <code>_get_log_context </code> <p>returns the log context for a given message and topics</p> <code>fmt </code> <p>returns the log format string</p> <code>_setup_log_context </code> <p>sets up the log context for a given list of topics</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/shared/logging.py</code> <pre><code>class KafkaLoggingMixin(LoggingMixin):\n\"\"\"A class that provides logging functionality for Kafka.\n    Attributes:\n        _max_topic_len : maximum length of the topic name\n    Methods:\n        __init__ : initializes the KafkaLoggingMixin object\n        _get_log_context : returns the log context for a given message and topics\n        fmt : returns the log format string\n        _setup_log_context : sets up the log context for a given list of topics\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n_max_topic_len: int\ndef __init__(\nself,\n*args: Any,\nlogger: Optional[logging.Logger] = access_logger,\nlog_level: int = logging.INFO,\nlog_fmt: Optional[str] = None,\n**kwargs: Any,\n) -&gt; None:\n\"\"\"Initialize the class.\n        Args:\n            *args: Variable length argument list\n            logger: Optional logger object\n            log_level: Log level (default: logging.INFO)\n            log_fmt: Optional log format string\n            **kwargs: Arbitrary keyword arguments\n        Returns:\n            None\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nsuper().__init__(\n*args,\nlogger=logger,\nlog_level=log_level,\nlog_fmt=log_fmt,\n**kwargs,\n)\nself._max_topic_len = 4\n@override\ndef _get_log_context(  # type: ignore[override]\nself,\nmessage: Optional[StreamMessage[ConsumerRecord]],\ntopics: Sequence[str] = (),\n) -&gt; AnyDict:\n\"\"\"Get the log context.\n        Args:\n            message: Optional stream message of type ConsumerRecord\n            topics: Sequence of topics\n        Returns:\n            A dictionary containing the log context\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nif topics:\ntopic = \", \".join(topics)\nelif message is not None:\ntopic = message.raw_message.topic\nelse:\ntopic = \"\"\ncontext = {\n\"topic\": topic,\n**super()._get_log_context(message),\n}\nreturn context\n@property\ndef fmt(self) -&gt; str:\nreturn super().fmt or (\n\"%(asctime)s %(levelname)s - \"\nf\"%(topic)-{self._max_topic_len}s | \"\n\"%(message_id)-10s \"\n\"- %(message)s\"\n)\ndef _setup_log_context(self, topics: Iterable[str]) -&gt; None:\n\"\"\"Set up log context.\n        Args:\n            topics: An iterable of topics.\n        Returns:\n            None.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nfor t in topics:\nself._max_topic_len = max((self._max_topic_len, len(t)))\n</code></pre>"},{"location":"api/faststream/kafka/shared/logging/KafkaLoggingMixin/#faststream.kafka.shared.logging.KafkaLoggingMixin.fmt","title":"fmt  <code>property</code>","text":"<pre><code>fmt: str\n</code></pre>"},{"location":"api/faststream/kafka/shared/publisher/ABCPublisher/","title":"ABCPublisher","text":""},{"location":"api/faststream/kafka/shared/publisher/ABCPublisher/#faststream.kafka.shared.publisher.ABCPublisher","title":"faststream.kafka.shared.publisher.ABCPublisher  <code>dataclass</code>","text":"<p>             Bases: <code>ABC</code>, <code>BasePublisher[MsgType]</code></p> <p>A class representing an ABCPublisher.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/shared/publisher.py</code> <pre><code>@dataclass\nclass ABCPublisher(ABC, BasePublisher[MsgType]):\n\"\"\"A class representing an ABCPublisher.\n    Attributes:\n        topic : str\n            The topic of the publisher.\n        key : Optional[bytes]\n            The key of the publisher.\n        partition : Optional[int]\n            The partition of the publisher.\n        timestamp_ms : Optional[int]\n            The timestamp in milliseconds of the publisher.\n        headers : Optional[Dict[str, str]]\n            The headers of the publisher.\n        reply_to : Optional[str]\n            The reply-to address of the publisher.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\ntopic: str = \"\"\nkey: Optional[bytes] = None\npartition: Optional[int] = None\ntimestamp_ms: Optional[int] = None\nheaders: Optional[Dict[str, str]] = None\nreply_to: Optional[str] = \"\"\n</code></pre>"},{"location":"api/faststream/kafka/shared/publisher/ABCPublisher/#faststream.kafka.shared.publisher.ABCPublisher.headers","title":"headers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>headers: Optional[Dict[str, str]] = None\n</code></pre>"},{"location":"api/faststream/kafka/shared/publisher/ABCPublisher/#faststream.kafka.shared.publisher.ABCPublisher.key","title":"key  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>key: Optional[bytes] = None\n</code></pre>"},{"location":"api/faststream/kafka/shared/publisher/ABCPublisher/#faststream.kafka.shared.publisher.ABCPublisher.partition","title":"partition  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>partition: Optional[int] = None\n</code></pre>"},{"location":"api/faststream/kafka/shared/publisher/ABCPublisher/#faststream.kafka.shared.publisher.ABCPublisher.reply_to","title":"reply_to  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>reply_to: Optional[str] = ''\n</code></pre>"},{"location":"api/faststream/kafka/shared/publisher/ABCPublisher/#faststream.kafka.shared.publisher.ABCPublisher.timestamp_ms","title":"timestamp_ms  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>timestamp_ms: Optional[int] = None\n</code></pre>"},{"location":"api/faststream/kafka/shared/publisher/ABCPublisher/#faststream.kafka.shared.publisher.ABCPublisher.topic","title":"topic  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>topic: str = ''\n</code></pre>"},{"location":"api/faststream/kafka/shared/router/KafkaRouter/","title":"KafkaRouter","text":""},{"location":"api/faststream/kafka/shared/router/KafkaRouter/#faststream.kafka.shared.router.KafkaRouter","title":"faststream.kafka.shared.router.KafkaRouter","text":"<p>             Bases: <code>BrokerRouter[str, ConsumerRecord]</code></p> <p>A class to represent a Kafka router.</p> METHOD DESCRIPTION <code>subscriber </code> <p>decorator for subscribing to topics and handling messages</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/shared/router.py</code> <pre><code>class KafkaRouter(BrokerRouter[str, ConsumerRecord]):\n\"\"\"A class to represent a Kafka router.\n    Attributes:\n        prefix : prefix for the topics\n        handlers : sequence of Kafka routes\n        kwargs : additional keyword arguments\n    Methods:\n        subscriber : decorator for subscribing to topics and handling messages\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\ndef __init__(\nself,\nprefix: str = \"\",\nhandlers: Sequence[KafkaRoute[ConsumerRecord, SendableMessage]] = (),\n**kwargs: Any,\n):\n\"\"\"Initialize the class.\n        Args:\n            prefix (str): Prefix string.\n            handlers (Sequence[KafkaRoute[ConsumerRecord, SendableMessage]]): Sequence of KafkaRoute objects.\n            **kwargs (Any): Additional keyword arguments.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nfor h in handlers:\nh.args = tuple(prefix + x for x in h.args)\nsuper().__init__(prefix, handlers, **kwargs)\ndef subscriber(\nself,\n*topics: str,\n**broker_kwargs: Any,\n) -&gt; Callable[\n[Callable[P_HandlerParams, T_HandlerReturn]],\nHandlerCallWrapper[ConsumerRecord, P_HandlerParams, T_HandlerReturn],\n]:\n\"\"\"A function to subscribe to topics.\n        Args:\n            *topics : variable number of topic names\n            **broker_kwargs : keyword arguments for the broker\n        Returns:\n            A callable function that wraps the handler function\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nreturn self._wrap_subscriber(\n*(self.prefix + x for x in topics),\n**broker_kwargs,\n)\n</code></pre>"},{"location":"api/faststream/kafka/shared/router/KafkaRouter/#faststream.kafka.shared.router.KafkaRouter.subscriber","title":"subscriber","text":"<pre><code>subscriber(\n*topics: str, **broker_kwargs: Any\n) -&gt; Callable[\n[Callable[P_HandlerParams, T_HandlerReturn]],\nHandlerCallWrapper[\nConsumerRecord, P_HandlerParams, T_HandlerReturn\n],\n]\n</code></pre> <p>A function to subscribe to topics.</p> PARAMETER  DESCRIPTION <code>*topics</code> <p>variable number of topic names</p> <p> DEFAULT: <code>()</code> </p> <code>**broker_kwargs</code> <p>keyword arguments for the broker</p> <p> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Callable[[Callable[P_HandlerParams, T_HandlerReturn]], HandlerCallWrapper[ConsumerRecord, P_HandlerParams, T_HandlerReturn]]</code> <p>A callable function that wraps the handler function</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/shared/router.py</code> <pre><code>def subscriber(\nself,\n*topics: str,\n**broker_kwargs: Any,\n) -&gt; Callable[\n[Callable[P_HandlerParams, T_HandlerReturn]],\nHandlerCallWrapper[ConsumerRecord, P_HandlerParams, T_HandlerReturn],\n]:\n\"\"\"A function to subscribe to topics.\n    Args:\n        *topics : variable number of topic names\n        **broker_kwargs : keyword arguments for the broker\n    Returns:\n        A callable function that wraps the handler function\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nreturn self._wrap_subscriber(\n*(self.prefix + x for x in topics),\n**broker_kwargs,\n)\n</code></pre>"},{"location":"api/faststream/kafka/shared/schemas/ConsumerConnectionParams/","title":"ConsumerConnectionParams","text":""},{"location":"api/faststream/kafka/shared/schemas/ConsumerConnectionParams/#faststream.kafka.shared.schemas.ConsumerConnectionParams","title":"faststream.kafka.shared.schemas.ConsumerConnectionParams","text":"<p>             Bases: <code>TypedDict</code></p> <p>A class to represent the connection parameters for a consumer.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/shared/schemas.py</code> <pre><code>class ConsumerConnectionParams(TypedDict, total=False):\n\"\"\"A class to represent the connection parameters for a consumer.\n    Attributes:\n        bootstrap_servers : Required. The bootstrap servers to connect to.\n        loop : Optional. The event loop to use for asynchronous operations.\n        client_id : The client ID to use for the connection.\n        request_timeout_ms : The timeout for network requests in milliseconds.\n        retry_backoff_ms : The backoff time in milliseconds for retrying failed requests.\n        metadata_max_age_ms : The maximum age of metadata in milliseconds.\n        security_protocol : The security protocol to use for the connection. Must be one of \"SSL\" or \"PLAINTEXT\".\n        api_version : The API version to use for the connection.\n        connections_max_idle_ms : The maximum idle time in milliseconds before closing a connection.\n        sasl_mechanism : The SASL mechanism to use for authentication. Must be one of \"PLAIN\", \"GSSAPI\", \"SCRAM-SHA-256\", \"SCRAM-SHA-512\", or \"OAUTHBEARER\".\n        sasl_plain_password : The password to use for PLAIN SASL mechanism.\n        sasl_plain_username : The username to use for PLAIN SASL mechanism.\n        sasl_kerberos_service_name : The service\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nbootstrap_servers: Required[Union[str, List[str]]]\nloop: Optional[AbstractEventLoop]\nclient_id: str\nrequest_timeout_ms: int\nretry_backoff_ms: int\nmetadata_max_age_ms: int\nsecurity_protocol: Literal[\n\"SSL\",\n\"PLAINTEXT\",\n]\napi_version: str\nconnections_max_idle_ms: int\nsasl_mechanism: Literal[\n\"PLAIN\",\n\"GSSAPI\",\n\"SCRAM-SHA-256\",\n\"SCRAM-SHA-512\",\n\"OAUTHBEARER\",\n]\nsasl_plain_password: str\nsasl_plain_username: str\nsasl_kerberos_service_name: str\nsasl_kerberos_domain_name: str\nssl_context: ssl.SSLContext\nsasl_oauth_token_provider: AbstractTokenProvider\n</code></pre>"},{"location":"api/faststream/kafka/shared/schemas/ConsumerConnectionParams/#faststream.kafka.shared.schemas.ConsumerConnectionParams.api_version","title":"api_version  <code>instance-attribute</code>","text":"<pre><code>api_version: str\n</code></pre>"},{"location":"api/faststream/kafka/shared/schemas/ConsumerConnectionParams/#faststream.kafka.shared.schemas.ConsumerConnectionParams.bootstrap_servers","title":"bootstrap_servers  <code>instance-attribute</code>","text":"<pre><code>bootstrap_servers: Required[Union[str, List[str]]]\n</code></pre>"},{"location":"api/faststream/kafka/shared/schemas/ConsumerConnectionParams/#faststream.kafka.shared.schemas.ConsumerConnectionParams.client_id","title":"client_id  <code>instance-attribute</code>","text":"<pre><code>client_id: str\n</code></pre>"},{"location":"api/faststream/kafka/shared/schemas/ConsumerConnectionParams/#faststream.kafka.shared.schemas.ConsumerConnectionParams.connections_max_idle_ms","title":"connections_max_idle_ms  <code>instance-attribute</code>","text":"<pre><code>connections_max_idle_ms: int\n</code></pre>"},{"location":"api/faststream/kafka/shared/schemas/ConsumerConnectionParams/#faststream.kafka.shared.schemas.ConsumerConnectionParams.loop","title":"loop  <code>instance-attribute</code>","text":"<pre><code>loop: Optional[AbstractEventLoop]\n</code></pre>"},{"location":"api/faststream/kafka/shared/schemas/ConsumerConnectionParams/#faststream.kafka.shared.schemas.ConsumerConnectionParams.metadata_max_age_ms","title":"metadata_max_age_ms  <code>instance-attribute</code>","text":"<pre><code>metadata_max_age_ms: int\n</code></pre>"},{"location":"api/faststream/kafka/shared/schemas/ConsumerConnectionParams/#faststream.kafka.shared.schemas.ConsumerConnectionParams.request_timeout_ms","title":"request_timeout_ms  <code>instance-attribute</code>","text":"<pre><code>request_timeout_ms: int\n</code></pre>"},{"location":"api/faststream/kafka/shared/schemas/ConsumerConnectionParams/#faststream.kafka.shared.schemas.ConsumerConnectionParams.retry_backoff_ms","title":"retry_backoff_ms  <code>instance-attribute</code>","text":"<pre><code>retry_backoff_ms: int\n</code></pre>"},{"location":"api/faststream/kafka/shared/schemas/ConsumerConnectionParams/#faststream.kafka.shared.schemas.ConsumerConnectionParams.sasl_kerberos_domain_name","title":"sasl_kerberos_domain_name  <code>instance-attribute</code>","text":"<pre><code>sasl_kerberos_domain_name: str\n</code></pre>"},{"location":"api/faststream/kafka/shared/schemas/ConsumerConnectionParams/#faststream.kafka.shared.schemas.ConsumerConnectionParams.sasl_kerberos_service_name","title":"sasl_kerberos_service_name  <code>instance-attribute</code>","text":"<pre><code>sasl_kerberos_service_name: str\n</code></pre>"},{"location":"api/faststream/kafka/shared/schemas/ConsumerConnectionParams/#faststream.kafka.shared.schemas.ConsumerConnectionParams.sasl_mechanism","title":"sasl_mechanism  <code>instance-attribute</code>","text":"<pre><code>sasl_mechanism: Literal[\n\"PLAIN\",\n\"GSSAPI\",\n\"SCRAM-SHA-256\",\n\"SCRAM-SHA-512\",\n\"OAUTHBEARER\",\n]\n</code></pre>"},{"location":"api/faststream/kafka/shared/schemas/ConsumerConnectionParams/#faststream.kafka.shared.schemas.ConsumerConnectionParams.sasl_oauth_token_provider","title":"sasl_oauth_token_provider  <code>instance-attribute</code>","text":"<pre><code>sasl_oauth_token_provider: AbstractTokenProvider\n</code></pre>"},{"location":"api/faststream/kafka/shared/schemas/ConsumerConnectionParams/#faststream.kafka.shared.schemas.ConsumerConnectionParams.sasl_plain_password","title":"sasl_plain_password  <code>instance-attribute</code>","text":"<pre><code>sasl_plain_password: str\n</code></pre>"},{"location":"api/faststream/kafka/shared/schemas/ConsumerConnectionParams/#faststream.kafka.shared.schemas.ConsumerConnectionParams.sasl_plain_username","title":"sasl_plain_username  <code>instance-attribute</code>","text":"<pre><code>sasl_plain_username: str\n</code></pre>"},{"location":"api/faststream/kafka/shared/schemas/ConsumerConnectionParams/#faststream.kafka.shared.schemas.ConsumerConnectionParams.security_protocol","title":"security_protocol  <code>instance-attribute</code>","text":"<pre><code>security_protocol: Literal['SSL', 'PLAINTEXT']\n</code></pre>"},{"location":"api/faststream/kafka/shared/schemas/ConsumerConnectionParams/#faststream.kafka.shared.schemas.ConsumerConnectionParams.ssl_context","title":"ssl_context  <code>instance-attribute</code>","text":"<pre><code>ssl_context: ssl.SSLContext\n</code></pre>"},{"location":"api/faststream/kafka/test/FakeProducer/","title":"FakeProducer","text":""},{"location":"api/faststream/kafka/test/FakeProducer/#faststream.kafka.test.FakeProducer","title":"faststream.kafka.test.FakeProducer","text":"<p>             Bases: <code>AioKafkaFastProducer</code></p> <p>A fake Kafka producer for testing purposes.</p> <p>This class extends AioKafkaFastProducer and is used to simulate Kafka message publishing during tests.</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/test.py</code> <pre><code>class FakeProducer(AioKafkaFastProducer):\n\"\"\"\n    A fake Kafka producer for testing purposes.\n    This class extends AioKafkaFastProducer and is used to simulate Kafka message publishing during tests.\n    \"\"\"\ndef __init__(self, broker: KafkaBroker):\n\"\"\"\n        Initialize the FakeProducer.\n        Args:\n            broker (KafkaBroker): The KafkaBroker instance to associate with this FakeProducer.\n        \"\"\"\nself.broker = broker\n@override\nasync def publish(  # type: ignore[override]\nself,\nmessage: SendableMessage,\ntopic: str,\nkey: Optional[bytes] = None,\npartition: Optional[int] = None,\ntimestamp_ms: Optional[int] = None,\nheaders: Optional[Dict[str, str]] = None,\ncorrelation_id: Optional[str] = None,\n*,\nreply_to: str = \"\",\nrpc: bool = False,\nrpc_timeout: Optional[float] = None,\nraise_timeout: bool = False,\n) -&gt; Optional[SendableMessage]:\n\"\"\"\n        Publish a message to the Kafka broker.\n        Args:\n            message (SendableMessage): The message to be published.\n            topic (str): The Kafka topic to publish the message to.\n            key (Optional[bytes], optional): The message key. Defaults to None.\n            partition (Optional[int], optional): The Kafka partition to use. Defaults to None.\n            timestamp_ms (Optional[int], optional): The message timestamp in milliseconds. Defaults to None.\n            headers (Optional[Dict[str, str]], optional): Additional headers for the message. Defaults to None.\n            correlation_id (Optional[str], optional): The correlation ID for the message. Defaults to None.\n            reply_to (str, optional): The topic to which responses should be sent. Defaults to \"\".\n            rpc (bool, optional): If True, treat the message as an RPC request. Defaults to False.\n            rpc_timeout (Optional[float], optional): Timeout for RPC requests. Defaults to None.\n            raise_timeout (bool, optional): If True, raise an exception on timeout. Defaults to False.\n        Returns:\n            Optional[SendableMessage]: The response message, if this was an RPC request, otherwise None.\n        \"\"\"\nincoming = build_message(\nmessage=message,\ntopic=topic,\nkey=key,\npartition=partition,\ntimestamp_ms=timestamp_ms,\nheaders=headers,\ncorrelation_id=correlation_id,\nreply_to=reply_to,\n)\nfor handler in self.broker.handlers.values():  # pragma: no branch\nif topic in handler.topics:\nr = await call_handler(\nhandler=handler,\nmessage=[incoming] if handler.batch else incoming,\nrpc=rpc,\nrpc_timeout=rpc_timeout,\nraise_timeout=raise_timeout,\n)\nif rpc:  # pragma: no branch\nreturn r\nreturn None\nasync def publish_batch(\nself,\n*msgs: SendableMessage,\ntopic: str,\npartition: Optional[int] = None,\ntimestamp_ms: Optional[int] = None,\nheaders: Optional[Dict[str, str]] = None,\n) -&gt; None:\n\"\"\"\n        Publish a batch of messages to the Kafka broker.\n        Args:\n            *msgs (SendableMessage): Variable number of messages to be published.\n            topic (str): The Kafka topic to publish the messages to.\n            partition (Optional[int], optional): The Kafka partition to use. Defaults to None.\n            timestamp_ms (Optional[int], optional): The message timestamp in milliseconds. Defaults to None.\n            headers (Optional[Dict[str, str]], optional): Additional headers for the messages. Defaults to None.\n        Returns:\n            None: This method does not return a value.\n        \"\"\"\nfor handler in self.broker.handlers.values():  # pragma: no branch\nif topic in handler.topics:\nawait call_handler(\nhandler=handler,\nmessage=[\nbuild_message(\nmessage=message,\ntopic=topic,\npartition=partition,\ntimestamp_ms=timestamp_ms,\nheaders=headers,\n)\nfor message in msgs\n],\n)\nreturn None\n</code></pre>"},{"location":"api/faststream/kafka/test/FakeProducer/#faststream.kafka.test.FakeProducer.broker","title":"broker  <code>instance-attribute</code>","text":"<pre><code>broker = broker\n</code></pre>"},{"location":"api/faststream/kafka/test/FakeProducer/#faststream.kafka.test.FakeProducer.publish","title":"publish  <code>async</code>","text":"<pre><code>publish(\nmessage: SendableMessage,\ntopic: str,\nkey: Optional[bytes] = None,\npartition: Optional[int] = None,\ntimestamp_ms: Optional[int] = None,\nheaders: Optional[Dict[str, str]] = None,\ncorrelation_id: Optional[str] = None,\n*,\nreply_to: str = \"\",\nrpc: bool = False,\nrpc_timeout: Optional[float] = None,\nraise_timeout: bool = False\n) -&gt; Optional[SendableMessage]\n</code></pre> <p>Publish a message to the Kafka broker.</p> PARAMETER  DESCRIPTION <code>message</code> <p>The message to be published.</p> <p> TYPE: <code>SendableMessage</code> </p> <code>topic</code> <p>The Kafka topic to publish the message to.</p> <p> TYPE: <code>str</code> </p> <code>key</code> <p>The message key. Defaults to None.</p> <p> TYPE: <code>Optional[bytes]</code> DEFAULT: <code>None</code> </p> <code>partition</code> <p>The Kafka partition to use. Defaults to None.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>timestamp_ms</code> <p>The message timestamp in milliseconds. Defaults to None.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>headers</code> <p>Additional headers for the message. Defaults to None.</p> <p> TYPE: <code>Optional[Dict[str, str]]</code> DEFAULT: <code>None</code> </p> <code>correlation_id</code> <p>The correlation ID for the message. Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>reply_to</code> <p>The topic to which responses should be sent. Defaults to \"\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>rpc</code> <p>If True, treat the message as an RPC request. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>rpc_timeout</code> <p>Timeout for RPC requests. Defaults to None.</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>None</code> </p> <code>raise_timeout</code> <p>If True, raise an exception on timeout. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Optional[SendableMessage]</code> <p>Optional[SendableMessage]: The response message, if this was an RPC request, otherwise None.</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/test.py</code> <pre><code>@override\nasync def publish(  # type: ignore[override]\nself,\nmessage: SendableMessage,\ntopic: str,\nkey: Optional[bytes] = None,\npartition: Optional[int] = None,\ntimestamp_ms: Optional[int] = None,\nheaders: Optional[Dict[str, str]] = None,\ncorrelation_id: Optional[str] = None,\n*,\nreply_to: str = \"\",\nrpc: bool = False,\nrpc_timeout: Optional[float] = None,\nraise_timeout: bool = False,\n) -&gt; Optional[SendableMessage]:\n\"\"\"\n    Publish a message to the Kafka broker.\n    Args:\n        message (SendableMessage): The message to be published.\n        topic (str): The Kafka topic to publish the message to.\n        key (Optional[bytes], optional): The message key. Defaults to None.\n        partition (Optional[int], optional): The Kafka partition to use. Defaults to None.\n        timestamp_ms (Optional[int], optional): The message timestamp in milliseconds. Defaults to None.\n        headers (Optional[Dict[str, str]], optional): Additional headers for the message. Defaults to None.\n        correlation_id (Optional[str], optional): The correlation ID for the message. Defaults to None.\n        reply_to (str, optional): The topic to which responses should be sent. Defaults to \"\".\n        rpc (bool, optional): If True, treat the message as an RPC request. Defaults to False.\n        rpc_timeout (Optional[float], optional): Timeout for RPC requests. Defaults to None.\n        raise_timeout (bool, optional): If True, raise an exception on timeout. Defaults to False.\n    Returns:\n        Optional[SendableMessage]: The response message, if this was an RPC request, otherwise None.\n    \"\"\"\nincoming = build_message(\nmessage=message,\ntopic=topic,\nkey=key,\npartition=partition,\ntimestamp_ms=timestamp_ms,\nheaders=headers,\ncorrelation_id=correlation_id,\nreply_to=reply_to,\n)\nfor handler in self.broker.handlers.values():  # pragma: no branch\nif topic in handler.topics:\nr = await call_handler(\nhandler=handler,\nmessage=[incoming] if handler.batch else incoming,\nrpc=rpc,\nrpc_timeout=rpc_timeout,\nraise_timeout=raise_timeout,\n)\nif rpc:  # pragma: no branch\nreturn r\nreturn None\n</code></pre>"},{"location":"api/faststream/kafka/test/FakeProducer/#faststream.kafka.test.FakeProducer.publish_batch","title":"publish_batch  <code>async</code>","text":"<pre><code>publish_batch(\n*msgs: SendableMessage,\ntopic: str,\npartition: Optional[int] = None,\ntimestamp_ms: Optional[int] = None,\nheaders: Optional[Dict[str, str]] = None\n) -&gt; None\n</code></pre> <p>Publish a batch of messages to the Kafka broker.</p> PARAMETER  DESCRIPTION <code>*msgs</code> <p>Variable number of messages to be published.</p> <p> TYPE: <code>SendableMessage</code> DEFAULT: <code>()</code> </p> <code>topic</code> <p>The Kafka topic to publish the messages to.</p> <p> TYPE: <code>str</code> </p> <code>partition</code> <p>The Kafka partition to use. Defaults to None.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>timestamp_ms</code> <p>The message timestamp in milliseconds. Defaults to None.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>headers</code> <p>Additional headers for the messages. Defaults to None.</p> <p> TYPE: <code>Optional[Dict[str, str]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>None</code> <p>This method does not return a value.</p> <p> TYPE: <code>None</code> </p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/test.py</code> <pre><code>async def publish_batch(\nself,\n*msgs: SendableMessage,\ntopic: str,\npartition: Optional[int] = None,\ntimestamp_ms: Optional[int] = None,\nheaders: Optional[Dict[str, str]] = None,\n) -&gt; None:\n\"\"\"\n    Publish a batch of messages to the Kafka broker.\n    Args:\n        *msgs (SendableMessage): Variable number of messages to be published.\n        topic (str): The Kafka topic to publish the messages to.\n        partition (Optional[int], optional): The Kafka partition to use. Defaults to None.\n        timestamp_ms (Optional[int], optional): The message timestamp in milliseconds. Defaults to None.\n        headers (Optional[Dict[str, str]], optional): Additional headers for the messages. Defaults to None.\n    Returns:\n        None: This method does not return a value.\n    \"\"\"\nfor handler in self.broker.handlers.values():  # pragma: no branch\nif topic in handler.topics:\nawait call_handler(\nhandler=handler,\nmessage=[\nbuild_message(\nmessage=message,\ntopic=topic,\npartition=partition,\ntimestamp_ms=timestamp_ms,\nheaders=headers,\n)\nfor message in msgs\n],\n)\nreturn None\n</code></pre>"},{"location":"api/faststream/kafka/test/TestKafkaBroker/","title":"TestKafkaBroker","text":""},{"location":"api/faststream/kafka/test/TestKafkaBroker/#faststream.kafka.test.TestKafkaBroker","title":"faststream.kafka.test.TestKafkaBroker","text":"<p>A context manager for creating a test KafkaBroker instance with optional mocking.</p> <p>This class serves as a context manager for creating a KafkaBroker instance for testing purposes. It can either use the original KafkaBroker instance (if <code>with_real</code> is True) or replace certain components with mocks (if <code>with_real</code> is False) to isolate the broker during testing.</p> PARAMETER  DESCRIPTION <code>broker</code> <p>The KafkaBroker instance to be used in testing.</p> <p> TYPE: <code>KafkaBroker</code> </p> <code>with_real</code> <p>If True, the original broker is returned; if False, components are replaced with mock objects. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> METHOD DESCRIPTION <code>__aenter__</code> <p>Enter the context and return the KafkaBroker instance.</p> <code>__aexit__</code> <p>Any) -&gt; None: Exit the context.</p> <p>Example usage:</p> <p>```python real_broker = KafkaBroker() with TestKafkaBroker(real_broker, with_real=True) as broker:     # Use the real KafkaBroker instance for testing.</p> <p>with TestKafkaBroker(real_broker, with_real=False) as broker:     # Use a mocked KafkaBroker instance for testing.</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/test.py</code> <pre><code>class TestKafkaBroker:\n\"\"\"\n    A context manager for creating a test KafkaBroker instance with optional mocking.\n    This class serves as a context manager for creating a KafkaBroker instance for testing purposes. It can either use the\n    original KafkaBroker instance (if `with_real` is True) or replace certain components with mocks (if `with_real` is\n    False) to isolate the broker during testing.\n    Args:\n        broker (KafkaBroker): The KafkaBroker instance to be used in testing.\n        with_real (bool, optional): If True, the original broker is returned; if False, components are replaced with\n            mock objects. Defaults to False.\n    Attributes:\n        broker (KafkaBroker): The KafkaBroker instance provided for testing.\n        with_real (bool): A boolean flag indicating whether to use the original broker (True) or replace components with\n            mocks (False).\n    Methods:\n        __aenter__(self) -&gt; KafkaBroker:\n            Enter the context and return the KafkaBroker instance.\n        __aexit__(self, *args: Any) -&gt; None:\n            Exit the context.\n    Example usage:\n    ```python\n    real_broker = KafkaBroker()\n    with TestKafkaBroker(real_broker, with_real=True) as broker:\n        # Use the real KafkaBroker instance for testing.\n    with TestKafkaBroker(real_broker, with_real=False) as broker:\n        # Use a mocked KafkaBroker instance for testing.\n    \"\"\"\n# This is set so pytest ignores this class\n__test__ = False\ndef __init__(self, broker: KafkaBroker, with_real: bool = False):\n\"\"\"\n        Initialize a TestKafkaBroker instance.\n        Args:\n            broker (KafkaBroker): The KafkaBroker instance to be used in testing.\n            with_real (bool, optional): If True, the original broker is returned; if False, components are replaced with\n                mock objects. Defaults to False.\n        \"\"\"\nself.with_real = with_real\nself.broker = broker\n@asynccontextmanager\nasync def _create_ctx(self) -&gt; AsyncGenerator[KafkaBroker, None]:\n\"\"\"\n        Create the context for the context manager.\n        Yields:\n            KafkaBroker: The KafkaBroker instance for testing, either with or without mocks.\n        \"\"\"\nif not self.with_real:\nself.broker.start = AsyncMock(wraps=partial(_fake_start, self.broker))  # type: ignore[method-assign]\nself.broker._connect = MethodType(_fake_connect, self.broker)  # type: ignore[method-assign]\nself.broker.close = AsyncMock()  # type: ignore[method-assign]\nelse:\n_fake_start(self.broker)\nasync with self.broker:\ntry:\nawait self.broker.start()\nyield self.broker\nfinally:\n_fake_close(self.broker)\nasync def __aenter__(self) -&gt; KafkaBroker:\n\"\"\"\n        Enter the context and return the KafkaBroker instance.\n        Returns:\n            KafkaBroker: The KafkaBroker instance for testing, either with or without mocks.\n        \"\"\"\nself._ctx = self._create_ctx()\nreturn await self._ctx.__aenter__()\nasync def __aexit__(self, *args: Any) -&gt; None:\n\"\"\"\n        Exit the context.\n        Args:\n            *args: Variable-length argument list.\n        \"\"\"\nawait self._ctx.__aexit__(*args)\n</code></pre>"},{"location":"api/faststream/kafka/test/TestKafkaBroker/#faststream.kafka.test.TestKafkaBroker.broker","title":"broker  <code>instance-attribute</code>","text":"<pre><code>broker = broker\n</code></pre>"},{"location":"api/faststream/kafka/test/TestKafkaBroker/#faststream.kafka.test.TestKafkaBroker.with_real","title":"with_real  <code>instance-attribute</code>","text":"<pre><code>with_real = with_real\n</code></pre>"},{"location":"api/faststream/kafka/test/build_message/","title":"Build message","text":""},{"location":"api/faststream/kafka/test/build_message/#faststream.kafka.test.build_message","title":"faststream.kafka.test.build_message","text":"<pre><code>build_message(\nmessage: SendableMessage,\ntopic: str,\npartition: Optional[int] = None,\ntimestamp_ms: Optional[int] = None,\nkey: Optional[bytes] = None,\nheaders: Optional[Dict[str, str]] = None,\ncorrelation_id: Optional[str] = None,\n*,\nreply_to: str = \"\"\n) -&gt; ConsumerRecord\n</code></pre> <p>Build a Kafka ConsumerRecord for a sendable message.</p> PARAMETER  DESCRIPTION <code>message</code> <p>The sendable message to be encoded.</p> <p> TYPE: <code>SendableMessage</code> </p> <code>topic</code> <p>The Kafka topic for the message.</p> <p> TYPE: <code>str</code> </p> <code>partition</code> <p>The Kafka partition for the message. Defaults to None.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>timestamp_ms</code> <p>The message timestamp in milliseconds. Defaults to None.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>key</code> <p>The message key. Defaults to None.</p> <p> TYPE: <code>Optional[bytes]</code> DEFAULT: <code>None</code> </p> <code>headers</code> <p>Additional headers for the message. Defaults to None.</p> <p> TYPE: <code>Optional[Dict[str, str]]</code> DEFAULT: <code>None</code> </p> <code>correlation_id</code> <p>The correlation ID for the message. Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>reply_to</code> <p>The topic to which responses should be sent. Defaults to \"\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> RETURNS DESCRIPTION <code>ConsumerRecord</code> <p>A Kafka ConsumerRecord object.</p> <p> TYPE: <code>ConsumerRecord</code> </p> Source code in <code>/home/runner/work/faststream/faststream/faststream/kafka/test.py</code> <pre><code>def build_message(\nmessage: SendableMessage,\ntopic: str,\npartition: Optional[int] = None,\ntimestamp_ms: Optional[int] = None,\nkey: Optional[bytes] = None,\nheaders: Optional[Dict[str, str]] = None,\ncorrelation_id: Optional[str] = None,\n*,\nreply_to: str = \"\",\n) -&gt; ConsumerRecord:\n\"\"\"\n    Build a Kafka ConsumerRecord for a sendable message.\n    Args:\n        message (SendableMessage): The sendable message to be encoded.\n        topic (str): The Kafka topic for the message.\n        partition (Optional[int], optional): The Kafka partition for the message. Defaults to None.\n        timestamp_ms (Optional[int], optional): The message timestamp in milliseconds. Defaults to None.\n        key (Optional[bytes], optional): The message key. Defaults to None.\n        headers (Optional[Dict[str, str]], optional): Additional headers for the message. Defaults to None.\n        correlation_id (Optional[str], optional): The correlation ID for the message. Defaults to None.\n        reply_to (str, optional): The topic to which responses should be sent. Defaults to \"\".\n    Returns:\n        ConsumerRecord: A Kafka ConsumerRecord object.\n    \"\"\"\nmsg, content_type = encode_message(message)\nk = key or b\"\"\nheaders = {\n\"content-type\": content_type or \"\",\n\"correlation_id\": correlation_id or str(uuid4()),\n\"reply_to\": reply_to,\n**(headers or {}),\n}\nreturn ConsumerRecord(\nvalue=msg,\ntopic=topic,\npartition=partition or 0,\ntimestamp=timestamp_ms or int(datetime.now().timestamp()),\ntimestamp_type=0,\nkey=k,\nserialized_key_size=len(k),\nserialized_value_size=len(msg),\nchecksum=sum(msg),\noffset=0,\nheaders=[(i, j.encode()) for i, j in headers.items()],\n)\n</code></pre>"},{"location":"api/faststream/log/formatter/ColourizedFormatter/","title":"ColourizedFormatter","text":""},{"location":"api/faststream/log/formatter/ColourizedFormatter/#faststream.log.formatter.ColourizedFormatter","title":"faststream.log.formatter.ColourizedFormatter","text":"<p>             Bases: <code>Formatter</code></p> <p>A class to format log messages with colorized level names.</p> METHOD DESCRIPTION <code>__init__ </code> <p>Initialize the formatter with specified format strings.</p> <code>color_level_name </code> <p>Colorize the level name based on the log level.</p> <code>formatMessage </code> <p>Format the log record message with colorized level name.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/log/formatter.py</code> <pre><code>class ColourizedFormatter(logging.Formatter):\n\"\"\"A class to format log messages with colorized level names.\n    Attributes:\n        level_name_colors : A dictionary mapping log level names to functions that colorize the level names.\n    Methods:\n        __init__ : Initialize the formatter with specified format strings.\n        color_level_name : Colorize the level name based on the log level.\n        formatMessage : Format the log record message with colorized level name.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nlevel_name_colors: DefaultDict[str, Callable[[str], str]] = defaultdict(\nlambda: str,\n**{\nstr(logging.DEBUG): lambda level_name: click.style(\nstr(level_name), fg=\"cyan\"\n),\nstr(logging.INFO): lambda level_name: click.style(\nstr(level_name), fg=\"green\"\n),\nstr(logging.WARNING): lambda level_name: click.style(\nstr(level_name), fg=\"yellow\"\n),\nstr(logging.ERROR): lambda level_name: click.style(\nstr(level_name), fg=\"red\"\n),\nstr(logging.CRITICAL): lambda level_name: click.style(\nstr(level_name), fg=\"bright_red\"\n),\n},\n)\ndef __init__(\nself,\nfmt: Optional[str] = None,\ndatefmt: Optional[str] = None,\nstyle: Literal[\"%\", \"{\", \"$\"] = \"%\",\nuse_colors: Optional[bool] = None,\n):\n\"\"\"\n        Initialize the formatter with specified format strings.\n        Initialize the formatter either with the specified format string, or a\n        default as described above. Allow for specialized date formatting with\n        the optional datefmt argument. If datefmt is omitted, you get an\n        ISO8601-like (or RFC 3339-like) format.\n        Use a style parameter of '%', '{' or '$' to specify that you want to\n        use one of %-formatting, :meth:`str.format` (``{}``) formatting or\n        :class:`string.Template` formatting in your format string.\n        \"\"\"\nif use_colors in (True, False):\nself.use_colors = use_colors\nelse:\nself.use_colors = sys.stdout.isatty()\nsuper().__init__(fmt=fmt, datefmt=datefmt, style=style)\ndef color_level_name(self, level_name: str, level_no: int) -&gt; str:\n\"\"\"Returns the colored level name.\n        Args:\n            level_name: The name of the level.\n            level_no: The number of the level.\n        Returns:\n            The colored level name.\n        Raises:\n            KeyError: If the level number is not found in the level name colors dictionary.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nreturn self.level_name_colors[str(level_no)](level_name)\ndef formatMessage(self, record: logging.LogRecord) -&gt; str:\n\"\"\"Formats the log message.\n        Args:\n            record (logging.LogRecord): The log record to format.\n        Returns:\n            str: The formatted log message.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nlevelname = expand_log_field(record.levelname, 8)\nif self.use_colors is True:  # pragma: no cover\nlevelname = self.color_level_name(levelname, record.levelno)\nrecord.__dict__[\"levelname\"] = levelname\nreturn super().formatMessage(record)\n</code></pre>"},{"location":"api/faststream/log/formatter/ColourizedFormatter/#faststream.log.formatter.ColourizedFormatter.level_name_colors","title":"level_name_colors  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>level_name_colors: DefaultDict[\nstr, Callable[[str], str]\n] = defaultdict(\nlambda: str,\n**{\nstr(logging.DEBUG): lambda: click.style(\nstr(level_name), fg=\"cyan\"\n),\nstr(logging.INFO): lambda: click.style(\nstr(level_name), fg=\"green\"\n),\nstr(logging.WARNING): lambda: click.style(\nstr(level_name), fg=\"yellow\"\n),\nstr(logging.ERROR): lambda: click.style(\nstr(level_name), fg=\"red\"\n),\nstr(logging.CRITICAL): lambda: click.style(\nstr(level_name), fg=\"bright_red\"\n),\n}\n)\n</code></pre>"},{"location":"api/faststream/log/formatter/ColourizedFormatter/#faststream.log.formatter.ColourizedFormatter.use_colors","title":"use_colors  <code>instance-attribute</code>","text":"<pre><code>use_colors = use_colors\n</code></pre>"},{"location":"api/faststream/log/formatter/ColourizedFormatter/#faststream.log.formatter.ColourizedFormatter.color_level_name","title":"color_level_name","text":"<pre><code>color_level_name(level_name: str, level_no: int) -&gt; str\n</code></pre> <p>Returns the colored level name.</p> PARAMETER  DESCRIPTION <code>level_name</code> <p>The name of the level.</p> <p> TYPE: <code>str</code> </p> <code>level_no</code> <p>The number of the level.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The colored level name.</p> RAISES DESCRIPTION <code>KeyError</code> <p>If the level number is not found in the level name colors dictionary.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/log/formatter.py</code> <pre><code>def color_level_name(self, level_name: str, level_no: int) -&gt; str:\n\"\"\"Returns the colored level name.\n    Args:\n        level_name: The name of the level.\n        level_no: The number of the level.\n    Returns:\n        The colored level name.\n    Raises:\n        KeyError: If the level number is not found in the level name colors dictionary.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nreturn self.level_name_colors[str(level_no)](level_name)\n</code></pre>"},{"location":"api/faststream/log/formatter/ColourizedFormatter/#faststream.log.formatter.ColourizedFormatter.formatMessage","title":"formatMessage","text":"<pre><code>formatMessage(record: logging.LogRecord) -&gt; str\n</code></pre> <p>Formats the log message.</p> PARAMETER  DESCRIPTION <code>record</code> <p>The log record to format.</p> <p> TYPE: <code>LogRecord</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The formatted log message.</p> <p> TYPE: <code>str</code> </p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/log/formatter.py</code> <pre><code>def formatMessage(self, record: logging.LogRecord) -&gt; str:\n\"\"\"Formats the log message.\n    Args:\n        record (logging.LogRecord): The log record to format.\n    Returns:\n        str: The formatted log message.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nlevelname = expand_log_field(record.levelname, 8)\nif self.use_colors is True:  # pragma: no cover\nlevelname = self.color_level_name(levelname, record.levelno)\nrecord.__dict__[\"levelname\"] = levelname\nreturn super().formatMessage(record)\n</code></pre>"},{"location":"api/faststream/log/formatter/expand_log_field/","title":"Expand log field","text":""},{"location":"api/faststream/log/formatter/expand_log_field/#faststream.log.formatter.expand_log_field","title":"faststream.log.formatter.expand_log_field","text":"<pre><code>expand_log_field(field: str, symbols: int) -&gt; str\n</code></pre> <p>Expands a log field by adding spaces.</p> PARAMETER  DESCRIPTION <code>field</code> <p>The log field to expand.</p> <p> TYPE: <code>str</code> </p> <code>symbols</code> <p>The desired length of the expanded field.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The expanded log field.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/log/formatter.py</code> <pre><code>def expand_log_field(field: str, symbols: int) -&gt; str:\n\"\"\"Expands a log field by adding spaces.\n    Args:\n        field: The log field to expand.\n        symbols: The desired length of the expanded field.\n    Returns:\n        The expanded log field.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nreturn field + (\" \" * (symbols - len(field)))\n</code></pre>"},{"location":"api/faststream/log/formatter/make_record_with_extra/","title":"Make record with extra","text":""},{"location":"api/faststream/log/formatter/make_record_with_extra/#faststream.log.formatter.make_record_with_extra","title":"faststream.log.formatter.make_record_with_extra","text":"<pre><code>make_record_with_extra(\nself: logging.Logger,\nname: str,\nlevel: int,\nfn: str,\nlno: int,\nmsg: str,\nargs: Tuple[str],\nexc_info: Optional[\nUnion[\nTuple[\nType[BaseException],\nBaseException,\nOptional[TracebackType],\n],\nTuple[None, None, None],\n]\n],\nfunc: Optional[str] = None,\nextra: Optional[Mapping[str, object]] = None,\nsinfo: Optional[str] = None,\n) -&gt; logging.LogRecord\n</code></pre> <p>Creates a log record with additional information.</p> PARAMETER  DESCRIPTION <code>self</code> <p>The logger object.</p> <p> TYPE: <code>Logger</code> </p> <code>name</code> <p>The name of the logger.</p> <p> TYPE: <code>str</code> </p> <code>level</code> <p>The logging level.</p> <p> TYPE: <code>int</code> </p> <code>fn</code> <p>The filename where the log message originated.</p> <p> TYPE: <code>str</code> </p> <code>lno</code> <p>The line number where the log message originated.</p> <p> TYPE: <code>int</code> </p> <code>msg</code> <p>The log message.</p> <p> TYPE: <code>str</code> </p> <code>args</code> <p>The arguments for the log message.</p> <p> TYPE: <code>Tuple[str]</code> </p> <code>exc_info</code> <p>Information about an exception.</p> <p> TYPE: <code>Optional[Union[Tuple[Type[BaseException], BaseException, Optional[TracebackType]], Tuple[None, None, None]]]</code> </p> <code>func</code> <p>The name of the function where the log message originated.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>extra</code> <p>Additional information to include in the log record.</p> <p> TYPE: <code>Optional[Mapping[str, object]]</code> DEFAULT: <code>None</code> </p> <code>sinfo</code> <p>Stack information.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>LogRecord</code> <p>The log record.</p> Note <p>If <code>extra</code> is <code>None</code>, it will be set to the value of <code>context.get_local(\"log_context\")</code>.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/log/formatter.py</code> <pre><code>def make_record_with_extra(\nself: logging.Logger,\nname: str,\nlevel: int,\nfn: str,\nlno: int,\nmsg: str,\nargs: Tuple[str],\nexc_info: Optional[\nUnion[\nTuple[Type[BaseException], BaseException, Optional[TracebackType]],\nTuple[None, None, None],\n]\n],\nfunc: Optional[str] = None,\nextra: Optional[Mapping[str, object]] = None,\nsinfo: Optional[str] = None,\n) -&gt; logging.LogRecord:\n\"\"\"Creates a log record with additional information.\n    Args:\n        self: The logger object.\n        name: The name of the logger.\n        level: The logging level.\n        fn: The filename where the log message originated.\n        lno: The line number where the log message originated.\n        msg: The log message.\n        args: The arguments for the log message.\n        exc_info: Information about an exception.\n        func: The name of the function where the log message originated.\n        extra: Additional information to include in the log record.\n        sinfo: Stack information.\n    Returns:\n        The log record.\n    Note:\n        If `extra` is `None`, it will be set to the value of `context.get_local(\"log_context\")`.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nif extra is None:\nextra = context.get_local(\"log_context\")\nrecord = original_makeRecord(\nself,\nname,\nlevel,\nfn,\nlno,\nmsg,\nargs,\nexc_info,\nfunc,\nextra,\nsinfo,\n)\nreturn record\n</code></pre>"},{"location":"api/faststream/log/logging/configure_formatter/","title":"Configure formatter","text":""},{"location":"api/faststream/log/logging/configure_formatter/#faststream.log.logging.configure_formatter","title":"faststream.log.logging.configure_formatter","text":"<pre><code>configure_formatter(\nformatter: Type[logging.Formatter],\n*args: Any,\n**kwargs: Any\n) -&gt; logging.Formatter\n</code></pre> <p>Configures a logging formatter.</p> PARAMETER  DESCRIPTION <code>formatter</code> <p>The type of logging formatter to configure.</p> <p> TYPE: <code>Type[Formatter]</code> </p> <code>*args</code> <p>Additional positional arguments to pass to the formatter constructor.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>()</code> </p> <code>**kwargs</code> <p>Additional keyword arguments to pass to the formatter constructor.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Formatter</code> <p>An instance of the configured logging formatter.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/log/logging.py</code> <pre><code>def configure_formatter(\nformatter: Type[logging.Formatter], *args: Any, **kwargs: Any\n) -&gt; logging.Formatter:\n\"\"\"Configures a logging formatter.\n    Args:\n        formatter: The type of logging formatter to configure.\n        *args: Additional positional arguments to pass to the formatter constructor.\n        **kwargs: Additional keyword arguments to pass to the formatter constructor.\n    Returns:\n        An instance of the configured logging formatter.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nreturn formatter(*args, **kwargs)\n</code></pre>"},{"location":"api/faststream/rabbit/asyncapi/Handler/","title":"Handler","text":""},{"location":"api/faststream/rabbit/asyncapi/Handler/#faststream.rabbit.asyncapi.Handler","title":"faststream.rabbit.asyncapi.Handler","text":"<p>             Bases: <code>RMQAsyncAPIChannel</code>, <code>LogicHandler</code></p> <p>A class that serves as a handler for RMQAsyncAPIChannel and LogicHandler.</p> METHOD DESCRIPTION <code>- name</code> <p>Returns the name of the handler.</p> <code>- get_payloads</code> <p>Returns a list of payloads.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/asyncapi.py</code> <pre><code>class Handler(RMQAsyncAPIChannel, LogicHandler):\n\"\"\"A class that serves as a handler for RMQAsyncAPIChannel and LogicHandler.\n    Methods:\n        - name(): Returns the name of the handler.\n        - get_payloads(): Returns a list of payloads.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n@property\ndef name(self) -&gt; str:\noriginal = super().name\nname: str\nqueue_ = to_camelcase(self.queue.name)\nif original is True:\nif not self.call_name.lower().endswith(queue_.lower()):\nname = f\"{self.call_name}{queue_}\"\nelse:\nname = self.call_name\nelif original is False:  # pragma: no cover\nname = f\"Handler{queue_}\"\nelse:\nname = original\nreturn name\ndef get_payloads(self) -&gt; List[AnyDict]:\npayloads = []\nfor _, _, _, _, _, dep in self.calls:\nbody = parse_handler_params(dep, prefix=self.name)\npayloads.append(body)\nreturn payloads\n</code></pre>"},{"location":"api/faststream/rabbit/asyncapi/Handler/#faststream.rabbit.asyncapi.Handler.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"api/faststream/rabbit/asyncapi/Handler/#faststream.rabbit.asyncapi.Handler.get_payloads","title":"get_payloads","text":"<pre><code>get_payloads() -&gt; List[AnyDict]\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/asyncapi.py</code> <pre><code>def get_payloads(self) -&gt; List[AnyDict]:\npayloads = []\nfor _, _, _, _, _, dep in self.calls:\nbody = parse_handler_params(dep, prefix=self.name)\npayloads.append(body)\nreturn payloads\n</code></pre>"},{"location":"api/faststream/rabbit/asyncapi/Publisher/","title":"Publisher","text":""},{"location":"api/faststream/rabbit/asyncapi/Publisher/#faststream.rabbit.asyncapi.Publisher","title":"faststream.rabbit.asyncapi.Publisher","text":"<p>             Bases: <code>RMQAsyncAPIChannel</code>, <code>LogicPublisher</code></p> <p>A class representing a publisher.</p> METHOD DESCRIPTION <code>get_payloads </code> <p>Get the payloads for the publisher</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/asyncapi.py</code> <pre><code>class Publisher(RMQAsyncAPIChannel, LogicPublisher):\n\"\"\"A class representing a publisher.\n    Attributes:\n        name : name of the publisher\n    Methods:\n        get_payloads : Get the payloads for the publisher\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n@property\ndef name(self) -&gt; str:\nreturn self.title or f\"{self.queue.name.title()}Publisher\"\ndef get_payloads(self) -&gt; List[AnyDict]:\npayloads = []\nfor call in self.calls:\ncall_model = build_call_model(call)\nbody = get_response_schema(\ncall_model,\nprefix=to_camelcase(call_model.call_name),\n)\nif body:\npayloads.append(body)\nreturn payloads\n</code></pre>"},{"location":"api/faststream/rabbit/asyncapi/Publisher/#faststream.rabbit.asyncapi.Publisher.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"api/faststream/rabbit/asyncapi/Publisher/#faststream.rabbit.asyncapi.Publisher.get_payloads","title":"get_payloads","text":"<pre><code>get_payloads() -&gt; List[AnyDict]\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/asyncapi.py</code> <pre><code>def get_payloads(self) -&gt; List[AnyDict]:\npayloads = []\nfor call in self.calls:\ncall_model = build_call_model(call)\nbody = get_response_schema(\ncall_model,\nprefix=to_camelcase(call_model.call_name),\n)\nif body:\npayloads.append(body)\nreturn payloads\n</code></pre>"},{"location":"api/faststream/rabbit/asyncapi/RMQAsyncAPIChannel/","title":"RMQAsyncAPIChannel","text":""},{"location":"api/faststream/rabbit/asyncapi/RMQAsyncAPIChannel/#faststream.rabbit.asyncapi.RMQAsyncAPIChannel","title":"faststream.rabbit.asyncapi.RMQAsyncAPIChannel","text":"<p>             Bases: <code>AsyncAPIOperation</code>, <code>BaseRMQInformation</code></p> <p>A class representing an RMQAsyncAPIChannel.</p> METHOD DESCRIPTION <code>get_payloads</code> <p>Abstract method that returns a list of dictionaries representing the payloads.</p> <code>schema</code> <p>Returns a dictionary representing the schema of the channel.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/asyncapi.py</code> <pre><code>class RMQAsyncAPIChannel(AsyncAPIOperation, BaseRMQInformation):\n\"\"\"A class representing an RMQAsyncAPIChannel.\n    Methods:\n        get_payloads: Abstract method that returns a list of dictionaries representing the payloads.\n        schema: Returns a dictionary representing the schema of the channel.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n@abstractmethod\ndef get_payloads(self) -&gt; List[AnyDict]:\nraise NotImplementedError()\ndef schema(self) -&gt; Dict[str, Channel]:\npayloads = self.get_payloads()\nreturn {\nself.name: Channel(\ndescription=self.description,  # type: ignore[attr-defined]\nsubscribe=Operation(\nbindings=OperationBinding(\namqp=amqp.OperationBinding(\ncc=self.queue.name,\n),\n)\nif _is_exchange(self.exchange)\nelse None,\nmessage=Message(\ntitle=f\"{self.name}Message\",\npayload=resolve_payloads(payloads),\ncorrelationId=CorrelationId(\nlocation=\"$message.header#/correlation_id\"\n),\n),\n),\nbindings=ChannelBinding(\namqp=amqp.ChannelBinding(\n**{\n\"is\": \"routingKey\",  # type: ignore\n\"queue\": amqp.Queue(\nname=self.queue.name,\ndurable=self.queue.durable,\nexclusive=self.queue.exclusive,\nautoDelete=self.queue.auto_delete,\n)\nif _is_exchange(self.exchange)\nelse None,\n\"exchange\": (\namqp.Exchange(type=\"default\")\nif self.exchange is None\nelse amqp.Exchange(\ntype=self.exchange.type,  # type: ignore\nname=self.exchange.name,\ndurable=self.exchange.durable,\nautoDelete=self.exchange.auto_delete,\n)\n),\n}\n)\n),\n)\n}\n</code></pre>"},{"location":"api/faststream/rabbit/asyncapi/RMQAsyncAPIChannel/#faststream.rabbit.asyncapi.RMQAsyncAPIChannel.get_payloads","title":"get_payloads  <code>abstractmethod</code>","text":"<pre><code>get_payloads() -&gt; List[AnyDict]\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/asyncapi.py</code> <pre><code>@abstractmethod\ndef get_payloads(self) -&gt; List[AnyDict]:\nraise NotImplementedError()\n</code></pre>"},{"location":"api/faststream/rabbit/asyncapi/RMQAsyncAPIChannel/#faststream.rabbit.asyncapi.RMQAsyncAPIChannel.schema","title":"schema","text":"<pre><code>schema() -&gt; Dict[str, Channel]\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/asyncapi.py</code> <pre><code>def schema(self) -&gt; Dict[str, Channel]:\npayloads = self.get_payloads()\nreturn {\nself.name: Channel(\ndescription=self.description,  # type: ignore[attr-defined]\nsubscribe=Operation(\nbindings=OperationBinding(\namqp=amqp.OperationBinding(\ncc=self.queue.name,\n),\n)\nif _is_exchange(self.exchange)\nelse None,\nmessage=Message(\ntitle=f\"{self.name}Message\",\npayload=resolve_payloads(payloads),\ncorrelationId=CorrelationId(\nlocation=\"$message.header#/correlation_id\"\n),\n),\n),\nbindings=ChannelBinding(\namqp=amqp.ChannelBinding(\n**{\n\"is\": \"routingKey\",  # type: ignore\n\"queue\": amqp.Queue(\nname=self.queue.name,\ndurable=self.queue.durable,\nexclusive=self.queue.exclusive,\nautoDelete=self.queue.auto_delete,\n)\nif _is_exchange(self.exchange)\nelse None,\n\"exchange\": (\namqp.Exchange(type=\"default\")\nif self.exchange is None\nelse amqp.Exchange(\ntype=self.exchange.type,  # type: ignore\nname=self.exchange.name,\ndurable=self.exchange.durable,\nautoDelete=self.exchange.auto_delete,\n)\n),\n}\n)\n),\n)\n}\n</code></pre>"},{"location":"api/faststream/rabbit/broker/RabbitBroker/","title":"RabbitBroker","text":""},{"location":"api/faststream/rabbit/broker/RabbitBroker/#faststream.rabbit.broker.RabbitBroker","title":"faststream.rabbit.broker.RabbitBroker","text":"<p>             Bases: <code>RabbitLoggingMixin</code>, <code>BrokerAsyncUsecase[IncomingMessage, RobustConnection]</code></p> <p>A RabbitMQ broker for FastAPI applications.</p> <p>This class extends the base <code>BrokerAsyncUsecase</code> and provides asynchronous support for RabbitMQ as a message broker.</p> PARAMETER  DESCRIPTION <code>url</code> <p>The RabbitMQ connection URL. Defaults to \"amqp://guest:guest@localhost:5672/\".</p> <p> TYPE: <code>Union[str, URL, None]</code> DEFAULT: <code>'amqp://guest:guest@localhost:5672/'</code> </p> <code>max_consumers</code> <p>Maximum number of consumers to limit message consumption. Defaults to None.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>protocol</code> <p>The protocol to use (e.g., \"amqp\"). Defaults to \"amqp\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>'amqp'</code> </p> <code>protocol_version</code> <p>The protocol version to use (e.g., \"0.9.1\"). Defaults to \"0.9.1\".</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>'0.9.1'</code> </p> <code>**kwargs</code> <p>Additional keyword arguments.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/broker.py</code> <pre><code>class RabbitBroker(\nRabbitLoggingMixin,\nBrokerAsyncUsecase[aio_pika.IncomingMessage, aio_pika.RobustConnection],\n):\n\"\"\"\n    A RabbitMQ broker for FastAPI applications.\n    This class extends the base `BrokerAsyncUsecase` and provides asynchronous support for RabbitMQ as a message broker.\n    Args:\n        url (Union[str, URL, None], optional): The RabbitMQ connection URL. Defaults to \"amqp://guest:guest@localhost:5672/\".\n        max_consumers (Optional[int], optional): Maximum number of consumers to limit message consumption. Defaults to None.\n        protocol (str, optional): The protocol to use (e.g., \"amqp\"). Defaults to \"amqp\".\n        protocol_version (Optional[str], optional): The protocol version to use (e.g., \"0.9.1\"). Defaults to \"0.9.1\".\n        **kwargs: Additional keyword arguments.\n    Attributes:\n        handlers (Dict[int, Handler]): A dictionary of message handlers.\n        _publishers (Dict[int, Publisher]): A dictionary of message publishers.\n        declarer (Optional[RabbitDeclarer]): The RabbitMQ declarer instance.\n        _producer (Optional[AioPikaFastProducer]): The RabbitMQ producer instance.\n        _connection (Optional[aio_pika.RobustConnection]): The RabbitMQ connection instance.\n        _channel (Optional[aio_pika.RobustChannel]): The RabbitMQ channel instance.\n    \"\"\"\nhandlers: Dict[int, Handler]  # type: ignore[assignment]\n_publishers: Dict[int, Publisher]  # type: ignore[assignment]\ndeclarer: Optional[RabbitDeclarer]\n_producer: Optional[AioPikaFastProducer]\n_connection: Optional[aio_pika.RobustConnection]\n_channel: Optional[aio_pika.RobustChannel]\ndef __init__(\nself,\nurl: Union[str, URL, None] = \"amqp://guest:guest@localhost:5672/\",\n*,\nmax_consumers: Optional[int] = None,\nprotocol: str = \"amqp\",\nprotocol_version: Optional[str] = \"0.9.1\",\nsecurity: Optional[BaseSecurity] = None,\n**kwargs: Any,\n) -&gt; None:\n\"\"\"\n        Initialize the RabbitBroker.\n        Args:\n            url (Union[str, URL, None], optional): The RabbitMQ connection URL. Defaults to \"amqp://guest:guest@localhost:5672/\".\n            max_consumers (Optional[int], optional): Maximum number of consumers to limit message consumption. Defaults to None.\n            protocol (str, optional): The protocol to use (e.g., \"amqp\"). Defaults to \"amqp\".\n            protocol_version (Optional[str], optional): The protocol version to use (e.g., \"0.9.1\"). Defaults to \"0.9.1\".\n            **kwargs: Additional keyword arguments.\n        \"\"\"\nsuper().__init__(\nurl=url,\nprotocol=protocol,\nprotocol_version=protocol_version,\nsecurity=security,\n**kwargs,\n)\nself._max_consumers = max_consumers\nself._channel = None\nself.declarer = None\nself._producer = None\nasync def _close(\nself,\nexc_type: Optional[Type[BaseException]] = None,\nexc_val: Optional[BaseException] = None,\nexec_tb: Optional[TracebackType] = None,\n) -&gt; None:\n\"\"\"\n        Close the RabbitMQ broker.\n        Args:\n            exc_type (Optional[Type[BaseException]], optional): The type of exception. Defaults to None.\n            exc_val (Optional[BaseException], optional): The exception instance. Defaults to None.\n            exec_tb (Optional[TracebackType], optional): The traceback. Defaults to None.\n        \"\"\"\nif self._channel is not None:\nawait self._channel.close()\nself._channel = None\nif self.declarer is not None:\nself.declarer = None\nif self._producer is not None:\nself._producer = None\nif self._connection is not None:  # pragma: no branch\nawait self._connection.close()\nawait super()._close(exc_type, exc_val, exec_tb)\nasync def connect(self, *args: Any, **kwargs: Any) -&gt; aio_pika.RobustConnection:\n\"\"\"\n        Connect to the RabbitMQ server.\n        Args:\n            *args: Additional positional arguments.\n            **kwargs: Additional keyword arguments.\n        Returns:\n            aio_pika.RobustConnection: The RabbitMQ connection instance.\n        \"\"\"\nconnection = await super().connect(*args, **kwargs)\nfor p in self._publishers.values():\np._producer = self._producer\nreturn connection\nasync def _connect(\nself,\n**kwargs: Any,\n) -&gt; aio_pika.RobustConnection:\n\"\"\"\n        Connect to the RabbitMQ server.\n        Args:\n            **kwargs: Additional keyword arguments.\n        Returns:\n            aio_pika.RobustConnection: The RabbitMQ connection instance.\n        \"\"\"\nconnection = cast(\naio_pika.RobustConnection,\nawait aio_pika.connect_robust(**kwargs, **parse_security(self.security)),\n)\nif self._channel is None:  # pragma: no branch\nmax_consumers = self._max_consumers\nchannel = self._channel = cast(\naio_pika.RobustChannel,\nawait connection.channel(),\n)\ndeclarer = self.declarer = RabbitDeclarer(channel)\nself.declarer.queues[RABBIT_REPLY] = cast(\naio_pika.RobustQueue,\nawait channel.get_queue(RABBIT_REPLY, ensure=False),\n)\nself._producer = AioPikaFastProducer(\nchannel,\ndeclarer,\ndecoder=self._global_decoder,\nparser=self._global_parser,\n)\nif max_consumers:\nc = self._get_log_context(None, RabbitQueue(\"\"), RabbitExchange(\"\"))\nself._log(f\"Set max consumers to {max_consumers}\", extra=c)\nawait channel.set_qos(prefetch_count=int(max_consumers))\nreturn connection\nasync def start(self) -&gt; None:\n\"\"\"\n        Start the RabbitMQ broker.\n        Raises:\n            RuntimeError: If the declarer is not initialized in the `connect` method.\n        \"\"\"\ncontext.set_local(\n\"log_context\",\nself._get_log_context(None, RabbitQueue(\"\"), RabbitExchange(\"\")),\n)\nawait super().start()\nassert (  # nosec B101\nself.declarer\n), \"Declarer should be initialized in `connect` method\"\nfor handler in self.handlers.values():\nc = self._get_log_context(None, handler.queue, handler.exchange)\nself._log(f\"`{handler.name}` waiting for messages\", extra=c)\nawait handler.start(self.declarer)\n@override\ndef subscriber(  # type: ignore[override]\nself,\nqueue: Union[str, RabbitQueue],\nexchange: Union[str, RabbitExchange, None] = None,\n*,\nconsume_args: Optional[AnyDict] = None,\n# broker arguments\ndependencies: Sequence[Depends] = (),\nparser: Optional[CustomParser[aio_pika.IncomingMessage]] = None,\ndecoder: Optional[CustomDecoder[aio_pika.IncomingMessage]] = None,\nmiddlewares: Optional[\nSequence[Callable[[aio_pika.IncomingMessage], BaseMiddleware]]\n] = None,\nfilter: Filter[RabbitMessage] = default_filter,\n# AsyncAPI information\ntitle: Optional[str] = None,\ndescription: Optional[str] = None,\n**original_kwargs: Any,\n) -&gt; Callable[\n[Callable[P_HandlerParams, T_HandlerReturn]],\nHandlerCallWrapper[aio_pika.IncomingMessage, P_HandlerParams, T_HandlerReturn],\n]:\n\"\"\"\n        Decorator to define a message subscriber.\n        Args:\n            queue (Union[str, RabbitQueue]): The name of the RabbitMQ queue.\n            exchange (Union[str, RabbitExchange, None], optional): The name of the RabbitMQ exchange. Defaults to None.\n            consume_args (Optional[AnyDict], optional): Additional arguments for message consumption.\n            title (Optional[str]): Title for AsyncAPI docs.\n            description (Optional[str]): Description for AsyncAPI docs.\n        Returns:\n            Callable: A decorator function for defining message subscribers.\n        \"\"\"\nsuper().subscriber()\nr_queue = RabbitQueue.validate(queue)\nr_exchange = RabbitExchange.validate(exchange)\nself._setup_log_context(r_queue, r_exchange)\nkey = get_routing_hash(r_queue, r_exchange)\nhandler = self.handlers.get(\nkey,\nHandler(\nlog_context_builder=partial(\nself._get_log_context, queue=r_queue, exchange=r_exchange\n),\nqueue=r_queue,\nexchange=r_exchange,\nconsume_args=consume_args,\ndescription=description,\ntitle=title,\n),\n)\nself.handlers[key] = handler\ndef consumer_wrapper(\nfunc: Callable[P_HandlerParams, T_HandlerReturn],\n) -&gt; HandlerCallWrapper[\naio_pika.IncomingMessage, P_HandlerParams, T_HandlerReturn\n]:\n\"\"\"Wraps a consumer function with additional functionality.\n            Args:\n                func: The consumer function to be wrapped.\n            Returns:\n                The wrapped consumer function.\n            Raises:\n                NotImplementedError: If silent animals are not supported.\n            !!! note\n                The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n            \"\"\"\nhandler_call, dependant = self._wrap_handler(\nfunc,\nextra_dependencies=dependencies,\n**original_kwargs,\n)\nhandler.add_call(\nhandler=handler_call,\nfilter=to_async(filter),\nmiddlewares=middlewares,\nparser=parser or self._global_parser,\ndecoder=decoder or self._global_decoder,\ndependant=dependant,\n)\nreturn handler_call\nreturn consumer_wrapper\n@override\ndef publisher(  # type: ignore[override]\nself,\nqueue: Union[RabbitQueue, str] = \"\",\nexchange: Union[RabbitExchange, str, None] = None,\n*,\nrouting_key: str = \"\",\nmandatory: bool = True,\nimmediate: bool = False,\ntimeout: TimeoutType = None,\npersist: bool = False,\nreply_to: Optional[str] = None,\n# AsyncAPI information\ntitle: Optional[str] = None,\ndescription: Optional[str] = None,\n**message_kwargs: Any,\n) -&gt; Publisher:\n\"\"\"\n        Define a message publisher.\n        Args:\n            queue (Union[RabbitQueue, str], optional): The name of the RabbitMQ queue. Defaults to \"\".\n            exchange (Union[RabbitExchange, str, None], optional): The name of the RabbitMQ exchange. Defaults to None.\n            routing_key (str, optional): The routing key for messages. Defaults to \"\".\n            mandatory (bool, optional): Whether the message is mandatory. Defaults to True.\n            immediate (bool, optional): Whether the message should be sent immediately. Defaults to False.\n            timeout (TimeoutType, optional): Timeout for message publishing. Defaults to None.\n            persist (bool, optional): Whether to persist messages. Defaults to False.\n            reply_to (Optional[str], optional): The reply-to queue name. Defaults to None.\n            title (Optional[str]): Title for AsyncAPI docs.\n            description (Optional[str]): Description for AsyncAPI docs.\n            **message_kwargs (Any): Additional message properties and content.\n        Returns:\n            Publisher: A message publisher instance.\n        \"\"\"\nq, ex = RabbitQueue.validate(queue), RabbitExchange.validate(exchange)\nkey = get_routing_hash(q, ex)\npublisher = self._publishers.get(\nkey,\nPublisher(\ntitle=title,\nqueue=q,\nexchange=ex,\nrouting_key=routing_key,\nmandatory=mandatory,\nimmediate=immediate,\ntimeout=timeout,\npersist=persist,\nreply_to=reply_to,\nmessage_kwargs=message_kwargs,\n_description=description,\n),\n)\nsuper().publisher(key, publisher)\nreturn publisher\n@override\nasync def publish(  # type: ignore[override]\nself,\n*args: Any,\n**kwargs: Any,\n) -&gt; Union[aiormq.abc.ConfirmationFrameType, SendableMessage]:\n\"\"\"\n        Publish a message to the RabbitMQ broker.\n        Args:\n            *args: Additional positional arguments.\n            **kwargs: Additional keyword arguments.\n        Returns:\n            Union[aiormq.abc.ConfirmationFrameType, SendableMessage]: The confirmation frame or the response message.\n        \"\"\"\nassert self._producer, \"RabbitBroker channel is not started yet\"  # nosec B101\nreturn await self._producer.publish(*args, **kwargs)\ndef _process_message(\nself,\nfunc: Callable[\n[StreamMessage[aio_pika.IncomingMessage]], Awaitable[T_HandlerReturn]\n],\nwatcher: BaseWatcher,\n) -&gt; Callable[\n[StreamMessage[aio_pika.IncomingMessage]],\nAwaitable[WrappedReturn[T_HandlerReturn]],\n]:\n\"\"\"\n        Process a message using the provided handler function.\n        Args:\n            func (Callable): The handler function for processing the message.\n            watcher (BaseWatcher): The message watcher for tracking message processing.\n        Returns:\n            Callable: A wrapper function for processing messages.\n        \"\"\"\n@wraps(func)\nasync def process_wrapper(\nmessage: RabbitMessage,\n) -&gt; WrappedReturn[T_HandlerReturn]:\n\"\"\"Asynchronously process a message and wrap the return value.\n            Args:\n                message: The RabbitMessage to process.\n            Returns:\n                A tuple containing the return value of the handler function and an optional AsyncPublisherProtocol.\n            Raises:\n                AssertionError: If the code reaches an unreachable point.\n            !!! note\n                The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n            \"\"\"\nasync with WatcherContext(watcher, message):\nr = await self._execute_handler(func, message)\npub_response: Optional[AsyncPublisherProtocol]\nif message.reply_to:\npub_response = FakePublisher(\npartial(self.publish, routing_key=message.reply_to)\n)\nelse:\npub_response = None\nreturn r, pub_response\nreturn process_wrapper\nasync def declare_queue(\nself,\nqueue: RabbitQueue,\n) -&gt; aio_pika.RobustQueue:\n\"\"\"\n        Declare a RabbitMQ queue.\n        Args:\n            queue (RabbitQueue): The RabbitMQ queue to declare.\n        Returns:\n            aio_pika.RobustQueue: The declared RabbitMQ queue.\n        Raises:\n            RuntimeError: If the declarer is not initialized in the `connect` method.\n        \"\"\"\nassert (  # nosec B101\nself.declarer\n), \"Declarer should be initialized in `connect` method\"\nreturn await self.declarer.declare_queue(queue)\nasync def declare_exchange(\nself,\nexchange: RabbitExchange,\n) -&gt; aio_pika.RobustExchange:\n\"\"\"\n        Declare a RabbitMQ exchange.\n        Args:\n            exchange (RabbitExchange): The RabbitMQ exchange to declare.\n        Returns:\n            aio_pika.RobustExchange: The declared RabbitMQ exchange.\n        Raises:\n            RuntimeError: If the declarer is not initialized in the `connect` method.\n        \"\"\"\nassert (  # nosec B101\nself.declarer\n), \"Declarer should be initialized in `connect` method\"\nreturn await self.declarer.declare_exchange(exchange)\n</code></pre>"},{"location":"api/faststream/rabbit/broker/RabbitBroker/#faststream.rabbit.broker.RabbitBroker.declarer","title":"declarer  <code>instance-attribute</code>","text":"<pre><code>declarer: Optional[RabbitDeclarer] = None\n</code></pre>"},{"location":"api/faststream/rabbit/broker/RabbitBroker/#faststream.rabbit.broker.RabbitBroker.handlers","title":"handlers  <code>instance-attribute</code>","text":"<pre><code>handlers: Dict[int, Handler]\n</code></pre>"},{"location":"api/faststream/rabbit/broker/RabbitBroker/#faststream.rabbit.broker.RabbitBroker.connect","title":"connect  <code>async</code>","text":"<pre><code>connect(\n*args: Any, **kwargs: Any\n) -&gt; aio_pika.RobustConnection\n</code></pre> <p>Connect to the RabbitMQ server.</p> PARAMETER  DESCRIPTION <code>*args</code> <p>Additional positional arguments.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>()</code> </p> <code>**kwargs</code> <p>Additional keyword arguments.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>RobustConnection</code> <p>aio_pika.RobustConnection: The RabbitMQ connection instance.</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/broker.py</code> <pre><code>async def connect(self, *args: Any, **kwargs: Any) -&gt; aio_pika.RobustConnection:\n\"\"\"\n    Connect to the RabbitMQ server.\n    Args:\n        *args: Additional positional arguments.\n        **kwargs: Additional keyword arguments.\n    Returns:\n        aio_pika.RobustConnection: The RabbitMQ connection instance.\n    \"\"\"\nconnection = await super().connect(*args, **kwargs)\nfor p in self._publishers.values():\np._producer = self._producer\nreturn connection\n</code></pre>"},{"location":"api/faststream/rabbit/broker/RabbitBroker/#faststream.rabbit.broker.RabbitBroker.declare_exchange","title":"declare_exchange  <code>async</code>","text":"<pre><code>declare_exchange(\nexchange: RabbitExchange,\n) -&gt; aio_pika.RobustExchange\n</code></pre> <p>Declare a RabbitMQ exchange.</p> PARAMETER  DESCRIPTION <code>exchange</code> <p>The RabbitMQ exchange to declare.</p> <p> TYPE: <code>RabbitExchange</code> </p> RETURNS DESCRIPTION <code>RobustExchange</code> <p>aio_pika.RobustExchange: The declared RabbitMQ exchange.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If the declarer is not initialized in the <code>connect</code> method.</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/broker.py</code> <pre><code>async def declare_exchange(\nself,\nexchange: RabbitExchange,\n) -&gt; aio_pika.RobustExchange:\n\"\"\"\n    Declare a RabbitMQ exchange.\n    Args:\n        exchange (RabbitExchange): The RabbitMQ exchange to declare.\n    Returns:\n        aio_pika.RobustExchange: The declared RabbitMQ exchange.\n    Raises:\n        RuntimeError: If the declarer is not initialized in the `connect` method.\n    \"\"\"\nassert (  # nosec B101\nself.declarer\n), \"Declarer should be initialized in `connect` method\"\nreturn await self.declarer.declare_exchange(exchange)\n</code></pre>"},{"location":"api/faststream/rabbit/broker/RabbitBroker/#faststream.rabbit.broker.RabbitBroker.declare_queue","title":"declare_queue  <code>async</code>","text":"<pre><code>declare_queue(queue: RabbitQueue) -&gt; aio_pika.RobustQueue\n</code></pre> <p>Declare a RabbitMQ queue.</p> PARAMETER  DESCRIPTION <code>queue</code> <p>The RabbitMQ queue to declare.</p> <p> TYPE: <code>RabbitQueue</code> </p> RETURNS DESCRIPTION <code>RobustQueue</code> <p>aio_pika.RobustQueue: The declared RabbitMQ queue.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If the declarer is not initialized in the <code>connect</code> method.</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/broker.py</code> <pre><code>async def declare_queue(\nself,\nqueue: RabbitQueue,\n) -&gt; aio_pika.RobustQueue:\n\"\"\"\n    Declare a RabbitMQ queue.\n    Args:\n        queue (RabbitQueue): The RabbitMQ queue to declare.\n    Returns:\n        aio_pika.RobustQueue: The declared RabbitMQ queue.\n    Raises:\n        RuntimeError: If the declarer is not initialized in the `connect` method.\n    \"\"\"\nassert (  # nosec B101\nself.declarer\n), \"Declarer should be initialized in `connect` method\"\nreturn await self.declarer.declare_queue(queue)\n</code></pre>"},{"location":"api/faststream/rabbit/broker/RabbitBroker/#faststream.rabbit.broker.RabbitBroker.publish","title":"publish  <code>async</code>","text":"<pre><code>publish(\n*args: Any, **kwargs: Any\n) -&gt; Union[\naiormq.abc.ConfirmationFrameType, SendableMessage\n]\n</code></pre> <p>Publish a message to the RabbitMQ broker.</p> PARAMETER  DESCRIPTION <code>*args</code> <p>Additional positional arguments.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>()</code> </p> <code>**kwargs</code> <p>Additional keyword arguments.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Union[ConfirmationFrameType, SendableMessage]</code> <p>Union[aiormq.abc.ConfirmationFrameType, SendableMessage]: The confirmation frame or the response message.</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/broker.py</code> <pre><code>@override\nasync def publish(  # type: ignore[override]\nself,\n*args: Any,\n**kwargs: Any,\n) -&gt; Union[aiormq.abc.ConfirmationFrameType, SendableMessage]:\n\"\"\"\n    Publish a message to the RabbitMQ broker.\n    Args:\n        *args: Additional positional arguments.\n        **kwargs: Additional keyword arguments.\n    Returns:\n        Union[aiormq.abc.ConfirmationFrameType, SendableMessage]: The confirmation frame or the response message.\n    \"\"\"\nassert self._producer, \"RabbitBroker channel is not started yet\"  # nosec B101\nreturn await self._producer.publish(*args, **kwargs)\n</code></pre>"},{"location":"api/faststream/rabbit/broker/RabbitBroker/#faststream.rabbit.broker.RabbitBroker.publisher","title":"publisher","text":"<pre><code>publisher(\nqueue: Union[RabbitQueue, str] = \"\",\nexchange: Union[RabbitExchange, str, None] = None,\n*,\nrouting_key: str = \"\",\nmandatory: bool = True,\nimmediate: bool = False,\ntimeout: TimeoutType = None,\npersist: bool = False,\nreply_to: Optional[str] = None,\ntitle: Optional[str] = None,\ndescription: Optional[str] = None,\n**message_kwargs: Any\n) -&gt; Publisher\n</code></pre> <p>Define a message publisher.</p> PARAMETER  DESCRIPTION <code>queue</code> <p>The name of the RabbitMQ queue. Defaults to \"\".</p> <p> TYPE: <code>Union[RabbitQueue, str]</code> DEFAULT: <code>''</code> </p> <code>exchange</code> <p>The name of the RabbitMQ exchange. Defaults to None.</p> <p> TYPE: <code>Union[RabbitExchange, str, None]</code> DEFAULT: <code>None</code> </p> <code>routing_key</code> <p>The routing key for messages. Defaults to \"\".</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>mandatory</code> <p>Whether the message is mandatory. Defaults to True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>immediate</code> <p>Whether the message should be sent immediately. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>timeout</code> <p>Timeout for message publishing. Defaults to None.</p> <p> TYPE: <code>TimeoutType</code> DEFAULT: <code>None</code> </p> <code>persist</code> <p>Whether to persist messages. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>reply_to</code> <p>The reply-to queue name. Defaults to None.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>title</code> <p>Title for AsyncAPI docs.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>description</code> <p>Description for AsyncAPI docs.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>**message_kwargs</code> <p>Additional message properties and content.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Publisher</code> <p>A message publisher instance.</p> <p> TYPE: <code>Publisher</code> </p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/broker.py</code> <pre><code>@override\ndef publisher(  # type: ignore[override]\nself,\nqueue: Union[RabbitQueue, str] = \"\",\nexchange: Union[RabbitExchange, str, None] = None,\n*,\nrouting_key: str = \"\",\nmandatory: bool = True,\nimmediate: bool = False,\ntimeout: TimeoutType = None,\npersist: bool = False,\nreply_to: Optional[str] = None,\n# AsyncAPI information\ntitle: Optional[str] = None,\ndescription: Optional[str] = None,\n**message_kwargs: Any,\n) -&gt; Publisher:\n\"\"\"\n    Define a message publisher.\n    Args:\n        queue (Union[RabbitQueue, str], optional): The name of the RabbitMQ queue. Defaults to \"\".\n        exchange (Union[RabbitExchange, str, None], optional): The name of the RabbitMQ exchange. Defaults to None.\n        routing_key (str, optional): The routing key for messages. Defaults to \"\".\n        mandatory (bool, optional): Whether the message is mandatory. Defaults to True.\n        immediate (bool, optional): Whether the message should be sent immediately. Defaults to False.\n        timeout (TimeoutType, optional): Timeout for message publishing. Defaults to None.\n        persist (bool, optional): Whether to persist messages. Defaults to False.\n        reply_to (Optional[str], optional): The reply-to queue name. Defaults to None.\n        title (Optional[str]): Title for AsyncAPI docs.\n        description (Optional[str]): Description for AsyncAPI docs.\n        **message_kwargs (Any): Additional message properties and content.\n    Returns:\n        Publisher: A message publisher instance.\n    \"\"\"\nq, ex = RabbitQueue.validate(queue), RabbitExchange.validate(exchange)\nkey = get_routing_hash(q, ex)\npublisher = self._publishers.get(\nkey,\nPublisher(\ntitle=title,\nqueue=q,\nexchange=ex,\nrouting_key=routing_key,\nmandatory=mandatory,\nimmediate=immediate,\ntimeout=timeout,\npersist=persist,\nreply_to=reply_to,\nmessage_kwargs=message_kwargs,\n_description=description,\n),\n)\nsuper().publisher(key, publisher)\nreturn publisher\n</code></pre>"},{"location":"api/faststream/rabbit/broker/RabbitBroker/#faststream.rabbit.broker.RabbitBroker.start","title":"start  <code>async</code>","text":"<pre><code>start() -&gt; None\n</code></pre> <p>Start the RabbitMQ broker.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If the declarer is not initialized in the <code>connect</code> method.</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/broker.py</code> <pre><code>async def start(self) -&gt; None:\n\"\"\"\n    Start the RabbitMQ broker.\n    Raises:\n        RuntimeError: If the declarer is not initialized in the `connect` method.\n    \"\"\"\ncontext.set_local(\n\"log_context\",\nself._get_log_context(None, RabbitQueue(\"\"), RabbitExchange(\"\")),\n)\nawait super().start()\nassert (  # nosec B101\nself.declarer\n), \"Declarer should be initialized in `connect` method\"\nfor handler in self.handlers.values():\nc = self._get_log_context(None, handler.queue, handler.exchange)\nself._log(f\"`{handler.name}` waiting for messages\", extra=c)\nawait handler.start(self.declarer)\n</code></pre>"},{"location":"api/faststream/rabbit/broker/RabbitBroker/#faststream.rabbit.broker.RabbitBroker.subscriber","title":"subscriber","text":"<pre><code>subscriber(\nqueue: Union[str, RabbitQueue],\nexchange: Union[str, RabbitExchange, None] = None,\n*,\nconsume_args: Optional[AnyDict] = None,\ndependencies: Sequence[Depends] = (),\nparser: Optional[\nCustomParser[aio_pika.IncomingMessage]\n] = None,\ndecoder: Optional[\nCustomDecoder[aio_pika.IncomingMessage]\n] = None,\nmiddlewares: Optional[\nSequence[\nCallable[\n[aio_pika.IncomingMessage], BaseMiddleware\n]\n]\n] = None,\nfilter: Filter[RabbitMessage] = default_filter,\ntitle: Optional[str] = None,\ndescription: Optional[str] = None,\n**original_kwargs: Any\n) -&gt; Callable[\n[Callable[P_HandlerParams, T_HandlerReturn]],\nHandlerCallWrapper[\naio_pika.IncomingMessage,\nP_HandlerParams,\nT_HandlerReturn,\n],\n]\n</code></pre> <p>Decorator to define a message subscriber.</p> PARAMETER  DESCRIPTION <code>queue</code> <p>The name of the RabbitMQ queue.</p> <p> TYPE: <code>Union[str, RabbitQueue]</code> </p> <code>exchange</code> <p>The name of the RabbitMQ exchange. Defaults to None.</p> <p> TYPE: <code>Union[str, RabbitExchange, None]</code> DEFAULT: <code>None</code> </p> <code>consume_args</code> <p>Additional arguments for message consumption.</p> <p> TYPE: <code>Optional[AnyDict]</code> DEFAULT: <code>None</code> </p> <code>title</code> <p>Title for AsyncAPI docs.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>description</code> <p>Description for AsyncAPI docs.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Callable</code> <p>A decorator function for defining message subscribers.</p> <p> TYPE: <code>Callable[[Callable[P_HandlerParams, T_HandlerReturn]], HandlerCallWrapper[IncomingMessage, P_HandlerParams, T_HandlerReturn]]</code> </p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/broker.py</code> <pre><code>@override\ndef subscriber(  # type: ignore[override]\nself,\nqueue: Union[str, RabbitQueue],\nexchange: Union[str, RabbitExchange, None] = None,\n*,\nconsume_args: Optional[AnyDict] = None,\n# broker arguments\ndependencies: Sequence[Depends] = (),\nparser: Optional[CustomParser[aio_pika.IncomingMessage]] = None,\ndecoder: Optional[CustomDecoder[aio_pika.IncomingMessage]] = None,\nmiddlewares: Optional[\nSequence[Callable[[aio_pika.IncomingMessage], BaseMiddleware]]\n] = None,\nfilter: Filter[RabbitMessage] = default_filter,\n# AsyncAPI information\ntitle: Optional[str] = None,\ndescription: Optional[str] = None,\n**original_kwargs: Any,\n) -&gt; Callable[\n[Callable[P_HandlerParams, T_HandlerReturn]],\nHandlerCallWrapper[aio_pika.IncomingMessage, P_HandlerParams, T_HandlerReturn],\n]:\n\"\"\"\n    Decorator to define a message subscriber.\n    Args:\n        queue (Union[str, RabbitQueue]): The name of the RabbitMQ queue.\n        exchange (Union[str, RabbitExchange, None], optional): The name of the RabbitMQ exchange. Defaults to None.\n        consume_args (Optional[AnyDict], optional): Additional arguments for message consumption.\n        title (Optional[str]): Title for AsyncAPI docs.\n        description (Optional[str]): Description for AsyncAPI docs.\n    Returns:\n        Callable: A decorator function for defining message subscribers.\n    \"\"\"\nsuper().subscriber()\nr_queue = RabbitQueue.validate(queue)\nr_exchange = RabbitExchange.validate(exchange)\nself._setup_log_context(r_queue, r_exchange)\nkey = get_routing_hash(r_queue, r_exchange)\nhandler = self.handlers.get(\nkey,\nHandler(\nlog_context_builder=partial(\nself._get_log_context, queue=r_queue, exchange=r_exchange\n),\nqueue=r_queue,\nexchange=r_exchange,\nconsume_args=consume_args,\ndescription=description,\ntitle=title,\n),\n)\nself.handlers[key] = handler\ndef consumer_wrapper(\nfunc: Callable[P_HandlerParams, T_HandlerReturn],\n) -&gt; HandlerCallWrapper[\naio_pika.IncomingMessage, P_HandlerParams, T_HandlerReturn\n]:\n\"\"\"Wraps a consumer function with additional functionality.\n        Args:\n            func: The consumer function to be wrapped.\n        Returns:\n            The wrapped consumer function.\n        Raises:\n            NotImplementedError: If silent animals are not supported.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nhandler_call, dependant = self._wrap_handler(\nfunc,\nextra_dependencies=dependencies,\n**original_kwargs,\n)\nhandler.add_call(\nhandler=handler_call,\nfilter=to_async(filter),\nmiddlewares=middlewares,\nparser=parser or self._global_parser,\ndecoder=decoder or self._global_decoder,\ndependant=dependant,\n)\nreturn handler_call\nreturn consumer_wrapper\n</code></pre>"},{"location":"api/faststream/rabbit/fastapi/RabbitRouter/","title":"RabbitRouter","text":""},{"location":"api/faststream/rabbit/fastapi/RabbitRouter/#faststream.rabbit.fastapi.RabbitRouter","title":"faststream.rabbit.fastapi.RabbitRouter","text":"<p>             Bases: <code>StreamRouter[IncomingMessage]</code></p> <p>A class to represent a RabbitMQ router for incoming messages.</p> METHOD DESCRIPTION <code>_setup_log_context </code> <p>sets up the log context for the main broker and the including broker</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/fastapi.py</code> <pre><code>class RabbitRouter(StreamRouter[IncomingMessage]):\n\"\"\"A class to represent a RabbitMQ router for incoming messages.\n    Attributes:\n        broker_class : the class representing the RabbitMQ broker\n    Methods:\n        _setup_log_context : sets up the log context for the main broker and the including broker\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nbroker_class = RabbitBroker\n@staticmethod\ndef _setup_log_context(\nmain_broker: RabbitBroker,\nincluding_broker: RabbitBroker,\n) -&gt; None:\n\"\"\"Sets up the log context for a main broker and an including broker.\n        Args:\n            main_broker: The main broker object.\n            including_broker: The including broker object.\n        Returns:\n            None\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nfor h in including_broker.handlers.values():\nmain_broker._setup_log_context(h.queue, h.exchange)\n</code></pre>"},{"location":"api/faststream/rabbit/fastapi/RabbitRouter/#faststream.rabbit.fastapi.RabbitRouter.broker","title":"broker  <code>instance-attribute</code>","text":"<pre><code>broker: RabbitBroker\n</code></pre>"},{"location":"api/faststream/rabbit/fastapi/RabbitRouter/#faststream.rabbit.fastapi.RabbitRouter.broker_class","title":"broker_class  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>broker_class: Type[RabbitBroker] = RabbitBroker\n</code></pre>"},{"location":"api/faststream/rabbit/fastapi/RabbitRouter/#faststream.rabbit.fastapi.RabbitRouter.add_api_mq_route","title":"add_api_mq_route","text":"<pre><code>add_api_mq_route(\nqueue: Union[str, RabbitQueue],\n*,\nendpoint: Callable[..., T_HandlerReturn],\nexchange: Union[str, RabbitExchange, None] = None,\nconsume_args: Optional[AnyDict] = None,\ndependencies: Sequence[params.Depends] = (),\nfilter: Filter[RabbitMessage] = default_filter,\nparser: Optional[\nCustomParser[aio_pika.IncomingMessage]\n] = None,\ndecoder: Optional[\nCustomDecoder[aio_pika.IncomingMessage]\n] = None,\nmiddlewares: Optional[\nSequence[\nCallable[\n[aio_pika.IncomingMessage], BaseMiddleware\n]\n]\n] = None,\nretry: Union[bool, int] = False,\ntitle: Optional[str] = None,\ndescription: Optional[str] = None,\n**__service_kwargs: Any\n) -&gt; Callable[\n[IncomingMessage, bool], Awaitable[T_HandlerReturn]\n]\n</code></pre>"},{"location":"api/faststream/rabbit/fastapi/RabbitRouter/#faststream.rabbit.fastapi.RabbitRouter.publisher","title":"publisher","text":"<pre><code>publisher(\nqueue: Union[RabbitQueue, str] = \"\",\nexchange: Union[RabbitExchange, str, None] = None,\n*,\nrouting_key: str = \"\",\nmandatory: bool = True,\nimmediate: bool = False,\ntimeout: TimeoutType = None,\npersist: bool = False,\nreply_to: Optional[str] = None,\ntitle: Optional[str] = None,\ndescription: Optional[str] = None,\nheaders: Optional[aio_pika.abc.HeadersType] = None,\ncontent_type: Optional[str] = None,\ncontent_encoding: Optional[str] = None,\npriority: Optional[int] = None,\ncorrelation_id: Optional[str] = None,\nexpiration: Optional[aio_pika.abc.DateType] = None,\nmessage_id: Optional[str] = None,\ntimestamp: Optional[aio_pika.abc.DateType] = None,\ntype: Optional[str] = None,\nuser_id: Optional[str] = None,\napp_id: Optional[str] = None\n) -&gt; Publisher\n</code></pre>"},{"location":"api/faststream/rabbit/fastapi/RabbitRouter/#faststream.rabbit.fastapi.RabbitRouter.subscriber","title":"subscriber","text":"<pre><code>subscriber(\nqueue: Union[str, RabbitQueue],\nexchange: Union[str, RabbitExchange, None] = None,\n*,\nconsume_args: Optional[AnyDict] = None,\ndependencies: Sequence[params.Depends] = (),\nfilter: Filter[RabbitMessage] = default_filter,\nparser: Optional[\nCustomParser[aio_pika.IncomingMessage]\n] = None,\ndecoder: Optional[\nCustomDecoder[aio_pika.IncomingMessage]\n] = None,\nmiddlewares: Optional[\nSequence[\nCallable[\n[aio_pika.IncomingMessage], BaseMiddleware\n]\n]\n] = None,\nretry: Union[bool, int] = False,\ntitle: Optional[str] = None,\ndescription: Optional[str] = None,\n**__service_kwargs: Any\n) -&gt; Callable[\n[Callable[P_HandlerParams, T_HandlerReturn]],\nHandlerCallWrapper[\naio_pika.IncomingMessage,\nP_HandlerParams,\nT_HandlerReturn,\n],\n]\n</code></pre>"},{"location":"api/faststream/rabbit/handler/LogicHandler/","title":"LogicHandler","text":""},{"location":"api/faststream/rabbit/handler/LogicHandler/#faststream.rabbit.handler.LogicHandler","title":"faststream.rabbit.handler.LogicHandler","text":"<p>             Bases: <code>AsyncHandler[IncomingMessage]</code>, <code>BaseRMQInformation</code></p> <p>A class to handle logic for RabbitMQ message consumption.</p> METHOD DESCRIPTION <code>__init__ </code> <p>Initializes the LogicHandler object</p> <code>add_call </code> <p>Adds a call to be handled by the LogicHandler</p> <code>start </code> <p>Starts consuming messages from the queue</p> <code>close </code> <p>Closes the consumer and cancels message consumption</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/handler.py</code> <pre><code>class LogicHandler(AsyncHandler[aio_pika.IncomingMessage], BaseRMQInformation):\n\"\"\"A class to handle logic for RabbitMQ message consumption.\n    Attributes:\n        queue : RabbitQueue object representing the queue to consume from\n        exchange : Optional RabbitExchange object representing the exchange to bind the queue to\n        consume_args : Additional arguments to pass when consuming from the queue\n        _consumer_tag : Optional string representing the consumer tag\n        _queue_obj : Optional aio_pika.RobustQueue object representing the declared queue\n    Methods:\n        __init__ : Initializes the LogicHandler object\n        add_call : Adds a call to be handled by the LogicHandler\n        start : Starts consuming messages from the queue\n        close : Closes the consumer and cancels message consumption\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nqueue: RabbitQueue\nexchange: Optional[RabbitExchange]\nconsume_args: AnyDict\n_consumer_tag: Optional[str]\n_queue_obj: Optional[aio_pika.RobustQueue]\ndef __init__(\nself,\nqueue: RabbitQueue,\nlog_context_builder: Callable[[StreamMessage[Any]], Dict[str, str]],\n# RMQ information\nexchange: Optional[RabbitExchange] = None,\nconsume_args: Optional[AnyDict] = None,\n# AsyncAPI information\ndescription: Optional[str] = None,\ntitle: Optional[str] = None,\n):\n\"\"\"Initialize a RabbitMQ consumer.\n        Args:\n            queue: RabbitQueue object representing the queue to consume from\n            exchange: RabbitExchange object representing the exchange to bind the queue to (optional)\n            consume_args: Additional arguments for consuming from the queue (optional)\n            description: Description of the consumer (optional)\n            title: Title of the consumer (optional)\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nsuper().__init__(\nlog_context_builder=log_context_builder,\ndescription=description,\ntitle=title,\n)\nself.queue = queue\nself.exchange = exchange\nself.consume_args = consume_args or {}\nself._consumer_tag = None\nself._queue_obj = None\ndef add_call(\nself,\n*,\nhandler: HandlerCallWrapper[\naio_pika.IncomingMessage, P_HandlerParams, T_HandlerReturn\n],\ndependant: CallModel[P_HandlerParams, T_HandlerReturn],\nparser: Optional[CustomParser[aio_pika.IncomingMessage]],\ndecoder: Optional[CustomDecoder[aio_pika.IncomingMessage]],\nfilter: Filter[RabbitMessage],\nmiddlewares: Optional[\nSequence[Callable[[aio_pika.IncomingMessage], BaseMiddleware]]\n],\n) -&gt; None:\n\"\"\"Add a call to the handler.\n        Args:\n            handler: The handler for the call.\n            dependant: The dependant for the call.\n            parser: Optional custom parser for the call.\n            decoder: Optional custom decoder for the call.\n            filter: The filter for the call.\n            middlewares: Optional sequence of middlewares for the call.\n        Returns:\n            None\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nsuper().add_call(\nhandler=handler,\nparser=resolve_custom_func(parser, AioPikaParser.parse_message),\ndecoder=resolve_custom_func(decoder, AioPikaParser.decode_message),\nfilter=filter,  # type: ignore[arg-type]\ndependant=dependant,\nmiddlewares=middlewares,\n)\n@override\nasync def start(self, declarer: RabbitDeclarer) -&gt; None:  # type: ignore[override]\n\"\"\"Starts the consumer for the RabbitMQ queue.\n        Args:\n            declarer: RabbitDeclarer object used to declare the queue and exchange\n        Returns:\n            None\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nself._queue_obj = queue = await declarer.declare_queue(self.queue)\nif self.exchange is not None:\nexchange = await declarer.declare_exchange(self.exchange)\nawait queue.bind(\nexchange,\nrouting_key=self.queue.routing,\narguments=self.queue.bind_arguments,\n)\nself._consumer_tag = await queue.consume(\n# NOTE: aio-pika expects AbstractIncomingMessage, not IncomingMessage\nself.consume,  # type: ignore[arg-type]\narguments=self.consume_args,\n)\nasync def close(self) -&gt; None:\nif self._queue_obj is not None:\nif self._consumer_tag is not None:  # pragma: no branch\nawait self._queue_obj.cancel(self._consumer_tag)\nself._consumer_tag = None\nself._queue_obj = None\n</code></pre>"},{"location":"api/faststream/rabbit/handler/LogicHandler/#faststream.rabbit.handler.LogicHandler.consume_args","title":"consume_args  <code>instance-attribute</code>","text":"<pre><code>consume_args: AnyDict = consume_args or {}\n</code></pre>"},{"location":"api/faststream/rabbit/handler/LogicHandler/#faststream.rabbit.handler.LogicHandler.exchange","title":"exchange  <code>instance-attribute</code>","text":"<pre><code>exchange: Optional[RabbitExchange] = exchange\n</code></pre>"},{"location":"api/faststream/rabbit/handler/LogicHandler/#faststream.rabbit.handler.LogicHandler.queue","title":"queue  <code>instance-attribute</code>","text":"<pre><code>queue: RabbitQueue = queue\n</code></pre>"},{"location":"api/faststream/rabbit/handler/LogicHandler/#faststream.rabbit.handler.LogicHandler.add_call","title":"add_call","text":"<pre><code>add_call(\n*,\nhandler: HandlerCallWrapper[\naio_pika.IncomingMessage,\nP_HandlerParams,\nT_HandlerReturn,\n],\ndependant: CallModel[P_HandlerParams, T_HandlerReturn],\nparser: Optional[\nCustomParser[aio_pika.IncomingMessage]\n],\ndecoder: Optional[\nCustomDecoder[aio_pika.IncomingMessage]\n],\nfilter: Filter[RabbitMessage],\nmiddlewares: Optional[\nSequence[\nCallable[\n[aio_pika.IncomingMessage], BaseMiddleware\n]\n]\n]\n) -&gt; None\n</code></pre> <p>Add a call to the handler.</p> PARAMETER  DESCRIPTION <code>handler</code> <p>The handler for the call.</p> <p> TYPE: <code>HandlerCallWrapper[IncomingMessage, P_HandlerParams, T_HandlerReturn]</code> </p> <code>dependant</code> <p>The dependant for the call.</p> <p> TYPE: <code>CallModel[P_HandlerParams, T_HandlerReturn]</code> </p> <code>parser</code> <p>Optional custom parser for the call.</p> <p> TYPE: <code>Optional[CustomParser[IncomingMessage]]</code> </p> <code>decoder</code> <p>Optional custom decoder for the call.</p> <p> TYPE: <code>Optional[CustomDecoder[IncomingMessage]]</code> </p> <code>filter</code> <p>The filter for the call.</p> <p> TYPE: <code>Filter[RabbitMessage]</code> </p> <code>middlewares</code> <p>Optional sequence of middlewares for the call.</p> <p> TYPE: <code>Optional[Sequence[Callable[[IncomingMessage], BaseMiddleware]]]</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/handler.py</code> <pre><code>def add_call(\nself,\n*,\nhandler: HandlerCallWrapper[\naio_pika.IncomingMessage, P_HandlerParams, T_HandlerReturn\n],\ndependant: CallModel[P_HandlerParams, T_HandlerReturn],\nparser: Optional[CustomParser[aio_pika.IncomingMessage]],\ndecoder: Optional[CustomDecoder[aio_pika.IncomingMessage]],\nfilter: Filter[RabbitMessage],\nmiddlewares: Optional[\nSequence[Callable[[aio_pika.IncomingMessage], BaseMiddleware]]\n],\n) -&gt; None:\n\"\"\"Add a call to the handler.\n    Args:\n        handler: The handler for the call.\n        dependant: The dependant for the call.\n        parser: Optional custom parser for the call.\n        decoder: Optional custom decoder for the call.\n        filter: The filter for the call.\n        middlewares: Optional sequence of middlewares for the call.\n    Returns:\n        None\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nsuper().add_call(\nhandler=handler,\nparser=resolve_custom_func(parser, AioPikaParser.parse_message),\ndecoder=resolve_custom_func(decoder, AioPikaParser.decode_message),\nfilter=filter,  # type: ignore[arg-type]\ndependant=dependant,\nmiddlewares=middlewares,\n)\n</code></pre>"},{"location":"api/faststream/rabbit/handler/LogicHandler/#faststream.rabbit.handler.LogicHandler.close","title":"close  <code>async</code>","text":"<pre><code>close() -&gt; None\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/handler.py</code> <pre><code>async def close(self) -&gt; None:\nif self._queue_obj is not None:\nif self._consumer_tag is not None:  # pragma: no branch\nawait self._queue_obj.cancel(self._consumer_tag)\nself._consumer_tag = None\nself._queue_obj = None\n</code></pre>"},{"location":"api/faststream/rabbit/handler/LogicHandler/#faststream.rabbit.handler.LogicHandler.start","title":"start  <code>async</code>","text":"<pre><code>start(declarer: RabbitDeclarer) -&gt; None\n</code></pre> <p>Starts the consumer for the RabbitMQ queue.</p> PARAMETER  DESCRIPTION <code>declarer</code> <p>RabbitDeclarer object used to declare the queue and exchange</p> <p> TYPE: <code>RabbitDeclarer</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/handler.py</code> <pre><code>@override\nasync def start(self, declarer: RabbitDeclarer) -&gt; None:  # type: ignore[override]\n\"\"\"Starts the consumer for the RabbitMQ queue.\n    Args:\n        declarer: RabbitDeclarer object used to declare the queue and exchange\n    Returns:\n        None\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nself._queue_obj = queue = await declarer.declare_queue(self.queue)\nif self.exchange is not None:\nexchange = await declarer.declare_exchange(self.exchange)\nawait queue.bind(\nexchange,\nrouting_key=self.queue.routing,\narguments=self.queue.bind_arguments,\n)\nself._consumer_tag = await queue.consume(\n# NOTE: aio-pika expects AbstractIncomingMessage, not IncomingMessage\nself.consume,  # type: ignore[arg-type]\narguments=self.consume_args,\n)\n</code></pre>"},{"location":"api/faststream/rabbit/helpers/RabbitDeclarer/","title":"RabbitDeclarer","text":""},{"location":"api/faststream/rabbit/helpers/RabbitDeclarer/#faststream.rabbit.helpers.RabbitDeclarer","title":"faststream.rabbit.helpers.RabbitDeclarer","text":"<p>             Bases: <code>Singleton</code></p> <p>A class to declare RabbitMQ queues and exchanges.</p> METHOD DESCRIPTION <code>__init__</code> <p>aio_pika.RobustChannel) -&gt; None Initializes the RabbitDeclarer with a channel.</p> <code>declare_queue</code> <p>RabbitQueue) -&gt; aio_pika.RobustQueue Declares a queue and returns the declared queue object.</p> <code>declare_exchange</code> <p>RabbitExchange) -&gt; aio_pika.RobustExchange Declares an exchange and returns the declared exchange object.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/helpers.py</code> <pre><code>class RabbitDeclarer(Singleton):\n\"\"\"A class to declare RabbitMQ queues and exchanges.\n    Attributes:\n        channel : aio_pika.RobustChannel\n            The RabbitMQ channel to use for declaration.\n        queues : Dict[Union[RabbitQueue, str], aio_pika.RobustQueue]\n            A dictionary to store the declared queues.\n        exchanges : Dict[Union[RabbitExchange, str], aio_pika.RobustExchange]\n            A dictionary to store the declared exchanges.\n    Methods:\n        __init__(channel: aio_pika.RobustChannel) -&gt; None\n            Initializes the RabbitDeclarer with a channel.\n        declare_queue(queue: RabbitQueue) -&gt; aio_pika.RobustQueue\n            Declares a queue and returns the declared queue object.\n        declare_exchange(exchange: RabbitExchange) -&gt; aio_pika.RobustExchange\n            Declares an exchange and returns the declared exchange object.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nchannel: aio_pika.RobustChannel\nqueues: Dict[Union[RabbitQueue, str], aio_pika.RobustQueue]\nexchanges: Dict[Union[RabbitExchange, str], aio_pika.RobustExchange]\ndef __init__(self, channel: aio_pika.RobustChannel) -&gt; None:\n\"\"\"Initialize the class.\n        Args:\n            channel: Aio_pika RobustChannel object\n        Attributes:\n            channel: Aio_pika RobustChannel object\n            queues: A dictionary to store queues\n            exchanges: A dictionary to store exchanges\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nself.channel = channel\nself.queues = {}\nself.exchanges = {}\nasync def declare_queue(\nself,\nqueue: RabbitQueue,\n) -&gt; aio_pika.RobustQueue:\n\"\"\"Declare a queue.\n        Args:\n            queue: RabbitQueue object representing the queue to be declared.\n        Returns:\n            aio_pika.RobustQueue: The declared queue.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nq = self.queues.get(queue)\nif q is None:\nq = cast(\naio_pika.RobustQueue,\nawait self.channel.declare_queue(\n**model_to_dict(\nqueue,\nexclude={\n\"routing_key\",\n\"bind_arguments\",\n},\n)\n),\n)\nself.queues[queue] = q\nreturn q\nasync def declare_exchange(\nself,\nexchange: RabbitExchange,\n) -&gt; aio_pika.RobustExchange:\n\"\"\"Declare an exchange.\n        Args:\n            exchange: RabbitExchange object representing the exchange to be declared.\n        Returns:\n            aio_pika.RobustExchange: The declared exchange.\n        Raises:\n            NotImplementedError: If silent animals are not supported.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nexch = self.exchanges.get(exchange)\nif exch is None:\nexch = cast(\naio_pika.RobustExchange,\nawait self.channel.declare_exchange(\n**model_to_dict(\nexchange,\nexclude={\n\"routing_key\",\n\"bind_arguments\",\n\"bind_to\",\n},\n)\n),\n)\nself.exchanges[exchange] = exch\nif exchange.bind_to is not None:\nparent = await self.declare_exchange(exchange.bind_to)\nawait exch.bind(\nexchange=parent,\nrouting_key=exchange.routing_key,\narguments=exchange.arguments,\n)\nreturn exch\n</code></pre>"},{"location":"api/faststream/rabbit/helpers/RabbitDeclarer/#faststream.rabbit.helpers.RabbitDeclarer.channel","title":"channel  <code>instance-attribute</code>","text":"<pre><code>channel: aio_pika.RobustChannel = channel\n</code></pre>"},{"location":"api/faststream/rabbit/helpers/RabbitDeclarer/#faststream.rabbit.helpers.RabbitDeclarer.exchanges","title":"exchanges  <code>instance-attribute</code>","text":"<pre><code>exchanges: Dict[\nUnion[RabbitExchange, str], aio_pika.RobustExchange\n] = {}\n</code></pre>"},{"location":"api/faststream/rabbit/helpers/RabbitDeclarer/#faststream.rabbit.helpers.RabbitDeclarer.queues","title":"queues  <code>instance-attribute</code>","text":"<pre><code>queues: Dict[\nUnion[RabbitQueue, str], aio_pika.RobustQueue\n] = {}\n</code></pre>"},{"location":"api/faststream/rabbit/helpers/RabbitDeclarer/#faststream.rabbit.helpers.RabbitDeclarer.declare_exchange","title":"declare_exchange  <code>async</code>","text":"<pre><code>declare_exchange(\nexchange: RabbitExchange,\n) -&gt; aio_pika.RobustExchange\n</code></pre> <p>Declare an exchange.</p> PARAMETER  DESCRIPTION <code>exchange</code> <p>RabbitExchange object representing the exchange to be declared.</p> <p> TYPE: <code>RabbitExchange</code> </p> RETURNS DESCRIPTION <code>RobustExchange</code> <p>aio_pika.RobustExchange: The declared exchange.</p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>If silent animals are not supported.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/helpers.py</code> <pre><code>async def declare_exchange(\nself,\nexchange: RabbitExchange,\n) -&gt; aio_pika.RobustExchange:\n\"\"\"Declare an exchange.\n    Args:\n        exchange: RabbitExchange object representing the exchange to be declared.\n    Returns:\n        aio_pika.RobustExchange: The declared exchange.\n    Raises:\n        NotImplementedError: If silent animals are not supported.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nexch = self.exchanges.get(exchange)\nif exch is None:\nexch = cast(\naio_pika.RobustExchange,\nawait self.channel.declare_exchange(\n**model_to_dict(\nexchange,\nexclude={\n\"routing_key\",\n\"bind_arguments\",\n\"bind_to\",\n},\n)\n),\n)\nself.exchanges[exchange] = exch\nif exchange.bind_to is not None:\nparent = await self.declare_exchange(exchange.bind_to)\nawait exch.bind(\nexchange=parent,\nrouting_key=exchange.routing_key,\narguments=exchange.arguments,\n)\nreturn exch\n</code></pre>"},{"location":"api/faststream/rabbit/helpers/RabbitDeclarer/#faststream.rabbit.helpers.RabbitDeclarer.declare_queue","title":"declare_queue  <code>async</code>","text":"<pre><code>declare_queue(queue: RabbitQueue) -&gt; aio_pika.RobustQueue\n</code></pre> <p>Declare a queue.</p> PARAMETER  DESCRIPTION <code>queue</code> <p>RabbitQueue object representing the queue to be declared.</p> <p> TYPE: <code>RabbitQueue</code> </p> RETURNS DESCRIPTION <code>RobustQueue</code> <p>aio_pika.RobustQueue: The declared queue.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/helpers.py</code> <pre><code>async def declare_queue(\nself,\nqueue: RabbitQueue,\n) -&gt; aio_pika.RobustQueue:\n\"\"\"Declare a queue.\n    Args:\n        queue: RabbitQueue object representing the queue to be declared.\n    Returns:\n        aio_pika.RobustQueue: The declared queue.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nq = self.queues.get(queue)\nif q is None:\nq = cast(\naio_pika.RobustQueue,\nawait self.channel.declare_queue(\n**model_to_dict(\nqueue,\nexclude={\n\"routing_key\",\n\"bind_arguments\",\n},\n)\n),\n)\nself.queues[queue] = q\nreturn q\n</code></pre>"},{"location":"api/faststream/rabbit/message/RabbitMessage/","title":"RabbitMessage","text":""},{"location":"api/faststream/rabbit/message/RabbitMessage/#faststream.rabbit.message.RabbitMessage","title":"faststream.rabbit.message.RabbitMessage","text":"<p>             Bases: <code>StreamMessage[IncomingMessage]</code></p> <p>A message class for working with RabbitMQ messages.</p> <p>This class extends <code>StreamMessage</code> to provide additional functionality for acknowledging, rejecting, or nack-ing RabbitMQ messages.</p> METHOD DESCRIPTION <code>ack</code> <p>Acknowledge the RabbitMQ message.</p> <code>nack</code> <p>Negative Acknowledgment of the RabbitMQ message.</p> <code>reject</code> <p>Reject the RabbitMQ message.</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/message.py</code> <pre><code>class RabbitMessage(StreamMessage[aio_pika.IncomingMessage]):\n\"\"\"\n    A message class for working with RabbitMQ messages.\n    This class extends `StreamMessage` to provide additional functionality for acknowledging, rejecting,\n    or nack-ing RabbitMQ messages.\n    Methods:\n        ack(**kwargs) -&gt; None:\n            Acknowledge the RabbitMQ message.\n        nack(**kwargs) -&gt; None:\n            Negative Acknowledgment of the RabbitMQ message.\n        reject(**kwargs) -&gt; None:\n            Reject the RabbitMQ message.\n    \"\"\"\nasync def ack(self, **kwargs: Any) -&gt; None:\n\"\"\"\n        Acknowledge the RabbitMQ message.\n        Acknowledgment indicates that the message has been successfully processed.\n        Args:\n            **kwargs (Any): Additional keyword arguments (not used).\n        \"\"\"\npika_message = self.raw_message\nif (\npika_message._IncomingMessage__processed  # type: ignore[attr-defined]\nor pika_message._IncomingMessage__no_ack  # type: ignore[attr-defined]\n):\nreturn\nawait pika_message.ack()\nasync def nack(self, **kwargs: Any) -&gt; None:\n\"\"\"\n        Negative Acknowledgment of the RabbitMQ message.\n        Nack-ing a message indicates that the message processing has failed and should be requeued.\n        Args:\n            **kwargs (Any): Additional keyword arguments (not used).\n        \"\"\"\npika_message = self.raw_message\nif (\npika_message._IncomingMessage__processed  # type: ignore[attr-defined]\nor pika_message._IncomingMessage__no_ack  # type: ignore[attr-defined]\n):\nreturn\nawait pika_message.nack()\nasync def reject(self, **kwargs: Any) -&gt; None:\n\"\"\"\n        Reject the RabbitMQ message.\n        Rejecting a message indicates that the message processing has failed, and it should not be requeued.\n        Args:\n            **kwargs (Any): Additional keyword arguments (not used).\n        \"\"\"\npika_message = self.raw_message\nif (\npika_message._IncomingMessage__processed  # type: ignore[attr-defined]\nor pika_message._IncomingMessage__no_ack  # type: ignore[attr-defined]\n):\nreturn\nawait pika_message.reject()\n</code></pre>"},{"location":"api/faststream/rabbit/message/RabbitMessage/#faststream.rabbit.message.RabbitMessage.ack","title":"ack  <code>async</code>","text":"<pre><code>ack(**kwargs: Any) -&gt; None\n</code></pre> <p>Acknowledge the RabbitMQ message.</p> <p>Acknowledgment indicates that the message has been successfully processed.</p> PARAMETER  DESCRIPTION <code>**kwargs</code> <p>Additional keyword arguments (not used).</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/message.py</code> <pre><code>async def ack(self, **kwargs: Any) -&gt; None:\n\"\"\"\n    Acknowledge the RabbitMQ message.\n    Acknowledgment indicates that the message has been successfully processed.\n    Args:\n        **kwargs (Any): Additional keyword arguments (not used).\n    \"\"\"\npika_message = self.raw_message\nif (\npika_message._IncomingMessage__processed  # type: ignore[attr-defined]\nor pika_message._IncomingMessage__no_ack  # type: ignore[attr-defined]\n):\nreturn\nawait pika_message.ack()\n</code></pre>"},{"location":"api/faststream/rabbit/message/RabbitMessage/#faststream.rabbit.message.RabbitMessage.nack","title":"nack  <code>async</code>","text":"<pre><code>nack(**kwargs: Any) -&gt; None\n</code></pre> <p>Negative Acknowledgment of the RabbitMQ message.</p> <p>Nack-ing a message indicates that the message processing has failed and should be requeued.</p> PARAMETER  DESCRIPTION <code>**kwargs</code> <p>Additional keyword arguments (not used).</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/message.py</code> <pre><code>async def nack(self, **kwargs: Any) -&gt; None:\n\"\"\"\n    Negative Acknowledgment of the RabbitMQ message.\n    Nack-ing a message indicates that the message processing has failed and should be requeued.\n    Args:\n        **kwargs (Any): Additional keyword arguments (not used).\n    \"\"\"\npika_message = self.raw_message\nif (\npika_message._IncomingMessage__processed  # type: ignore[attr-defined]\nor pika_message._IncomingMessage__no_ack  # type: ignore[attr-defined]\n):\nreturn\nawait pika_message.nack()\n</code></pre>"},{"location":"api/faststream/rabbit/message/RabbitMessage/#faststream.rabbit.message.RabbitMessage.reject","title":"reject  <code>async</code>","text":"<pre><code>reject(**kwargs: Any) -&gt; None\n</code></pre> <p>Reject the RabbitMQ message.</p> <p>Rejecting a message indicates that the message processing has failed, and it should not be requeued.</p> PARAMETER  DESCRIPTION <code>**kwargs</code> <p>Additional keyword arguments (not used).</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/message.py</code> <pre><code>async def reject(self, **kwargs: Any) -&gt; None:\n\"\"\"\n    Reject the RabbitMQ message.\n    Rejecting a message indicates that the message processing has failed, and it should not be requeued.\n    Args:\n        **kwargs (Any): Additional keyword arguments (not used).\n    \"\"\"\npika_message = self.raw_message\nif (\npika_message._IncomingMessage__processed  # type: ignore[attr-defined]\nor pika_message._IncomingMessage__no_ack  # type: ignore[attr-defined]\n):\nreturn\nawait pika_message.reject()\n</code></pre>"},{"location":"api/faststream/rabbit/parser/AioPikaParser/","title":"AioPikaParser","text":""},{"location":"api/faststream/rabbit/parser/AioPikaParser/#faststream.rabbit.parser.AioPikaParser","title":"faststream.rabbit.parser.AioPikaParser","text":"<p>A class for parsing, encoding, and decoding messages using aio-pika.</p> METHOD DESCRIPTION <code>parse_message</code> <p>aio_pika.IncomingMessage) -&gt; StreamMessage[aio_pika.IncomingMessage]: Parses an incoming message and returns a StreamMessage object.</p> <code>decode_message</code> <p>StreamMessage[aio_pika.IncomingMessage]) -&gt; DecodedMessage: Decodes a StreamMessage object and returns a DecodedMessage object.</p> <code>encode_message</code> <p>AioPikaSendableMessage, persist: bool = False, callback_queue: Optional[aio_pika.abc.AbstractRobustQueue] = None, reply_to: Optional[str] = None, **message_kwargs: Any) -&gt; aio_pika.Message: Encodes a message into an aio_pika.Message object.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/parser.py</code> <pre><code>class AioPikaParser:\n\"\"\"A class for parsing, encoding, and decoding messages using aio-pika.\n    Methods:\n        parse_message(message: aio_pika.IncomingMessage) -&gt; StreamMessage[aio_pika.IncomingMessage]:\n            Parses an incoming message and returns a StreamMessage object.\n        decode_message(msg: StreamMessage[aio_pika.IncomingMessage]) -&gt; DecodedMessage:\n            Decodes a StreamMessage object and returns a DecodedMessage object.\n        encode_message(message: AioPikaSendableMessage, persist: bool = False, callback_queue: Optional[aio_pika.abc.AbstractRobustQueue] = None, reply_to: Optional[str] = None, **message_kwargs: Any) -&gt; aio_pika.Message:\n            Encodes a message into an aio_pika.Message object.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n@staticmethod\nasync def parse_message(\nmessage: aio_pika.IncomingMessage,\n) -&gt; StreamMessage[aio_pika.IncomingMessage]:\n\"\"\"Parses an incoming message and returns a RabbitMessage object.\n        Args:\n            message: The incoming message to parse.\n        Returns:\n            A StreamMessage object representing the parsed message.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nreturn RabbitMessage(\nbody=message.body,\nheaders=message.headers,\nreply_to=message.reply_to or \"\",\ncontent_type=message.content_type,\nmessage_id=message.message_id or str(uuid4()),\ncorrelation_id=message.correlation_id or str(uuid4()),\nraw_message=message,\n)\n@staticmethod\nasync def decode_message(\nmsg: StreamMessage[aio_pika.IncomingMessage],\n) -&gt; DecodedMessage:\n\"\"\"Decode a message.\n        Args:\n            msg: The message to decode.\n        Returns:\n            The decoded message.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nreturn decode_message(msg)\n@staticmethod\ndef encode_message(\nmessage: AioPikaSendableMessage,\npersist: bool = False,\ncallback_queue: Optional[aio_pika.abc.AbstractRobustQueue] = None,\nreply_to: Optional[str] = None,\n**message_kwargs: Any,\n) -&gt; aio_pika.Message:\n\"\"\"Encodes a message for sending using AioPika.\n        Args:\n            message (AioPikaSendableMessage): The message to encode.\n            persist (bool, optional): Whether to persist the message. Defaults to False.\n            callback_queue (aio_pika.abc.AbstractRobustQueue, optional): The callback queue to use for replies. Defaults to None.\n            reply_to (str, optional): The reply-to queue to use for replies. Defaults to None.\n            **message_kwargs (Any): Additional keyword arguments to include in the encoded message.\n        Returns:\n            aio_pika.Message: The encoded message.\n        Raises:\n            NotImplementedError: If the message is not an instance of aio_pika.Message.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nif not isinstance(message, aio_pika.Message):\nmessage, content_type = encode_message(message)\ndelivery_mode = (\nDeliveryMode.PERSISTENT if persist else DeliveryMode.NOT_PERSISTENT\n)\nmessage = aio_pika.Message(\nmessage,\n**{\n\"delivery_mode\": delivery_mode,\n\"content_type\": content_type,\n\"reply_to\": callback_queue or reply_to,\n\"correlation_id\": str(uuid4()),\n**message_kwargs,\n},\n)\nreturn message\n</code></pre>"},{"location":"api/faststream/rabbit/parser/AioPikaParser/#faststream.rabbit.parser.AioPikaParser.decode_message","title":"decode_message  <code>async</code> <code>staticmethod</code>","text":"<pre><code>decode_message(\nmsg: StreamMessage[aio_pika.IncomingMessage],\n) -&gt; DecodedMessage\n</code></pre> <p>Decode a message.</p> PARAMETER  DESCRIPTION <code>msg</code> <p>The message to decode.</p> <p> TYPE: <code>StreamMessage[IncomingMessage]</code> </p> RETURNS DESCRIPTION <code>DecodedMessage</code> <p>The decoded message.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/parser.py</code> <pre><code>@staticmethod\nasync def decode_message(\nmsg: StreamMessage[aio_pika.IncomingMessage],\n) -&gt; DecodedMessage:\n\"\"\"Decode a message.\n    Args:\n        msg: The message to decode.\n    Returns:\n        The decoded message.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nreturn decode_message(msg)\n</code></pre>"},{"location":"api/faststream/rabbit/parser/AioPikaParser/#faststream.rabbit.parser.AioPikaParser.encode_message","title":"encode_message  <code>staticmethod</code>","text":"<pre><code>encode_message(\nmessage: AioPikaSendableMessage,\npersist: bool = False,\ncallback_queue: Optional[\naio_pika.abc.AbstractRobustQueue\n] = None,\nreply_to: Optional[str] = None,\n**message_kwargs: Any\n) -&gt; aio_pika.Message\n</code></pre> <p>Encodes a message for sending using AioPika.</p> PARAMETER  DESCRIPTION <code>message</code> <p>The message to encode.</p> <p> TYPE: <code>AioPikaSendableMessage</code> </p> <code>persist</code> <p>Whether to persist the message. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>callback_queue</code> <p>The callback queue to use for replies. Defaults to None.</p> <p> TYPE: <code>AbstractRobustQueue</code> DEFAULT: <code>None</code> </p> <code>reply_to</code> <p>The reply-to queue to use for replies. Defaults to None.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>**message_kwargs</code> <p>Additional keyword arguments to include in the encoded message.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Message</code> <p>aio_pika.Message: The encoded message.</p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>If the message is not an instance of aio_pika.Message.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/parser.py</code> <pre><code>@staticmethod\ndef encode_message(\nmessage: AioPikaSendableMessage,\npersist: bool = False,\ncallback_queue: Optional[aio_pika.abc.AbstractRobustQueue] = None,\nreply_to: Optional[str] = None,\n**message_kwargs: Any,\n) -&gt; aio_pika.Message:\n\"\"\"Encodes a message for sending using AioPika.\n    Args:\n        message (AioPikaSendableMessage): The message to encode.\n        persist (bool, optional): Whether to persist the message. Defaults to False.\n        callback_queue (aio_pika.abc.AbstractRobustQueue, optional): The callback queue to use for replies. Defaults to None.\n        reply_to (str, optional): The reply-to queue to use for replies. Defaults to None.\n        **message_kwargs (Any): Additional keyword arguments to include in the encoded message.\n    Returns:\n        aio_pika.Message: The encoded message.\n    Raises:\n        NotImplementedError: If the message is not an instance of aio_pika.Message.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nif not isinstance(message, aio_pika.Message):\nmessage, content_type = encode_message(message)\ndelivery_mode = (\nDeliveryMode.PERSISTENT if persist else DeliveryMode.NOT_PERSISTENT\n)\nmessage = aio_pika.Message(\nmessage,\n**{\n\"delivery_mode\": delivery_mode,\n\"content_type\": content_type,\n\"reply_to\": callback_queue or reply_to,\n\"correlation_id\": str(uuid4()),\n**message_kwargs,\n},\n)\nreturn message\n</code></pre>"},{"location":"api/faststream/rabbit/parser/AioPikaParser/#faststream.rabbit.parser.AioPikaParser.parse_message","title":"parse_message  <code>async</code> <code>staticmethod</code>","text":"<pre><code>parse_message(\nmessage: aio_pika.IncomingMessage,\n) -&gt; StreamMessage[aio_pika.IncomingMessage]\n</code></pre> <p>Parses an incoming message and returns a RabbitMessage object.</p> PARAMETER  DESCRIPTION <code>message</code> <p>The incoming message to parse.</p> <p> TYPE: <code>IncomingMessage</code> </p> RETURNS DESCRIPTION <code>StreamMessage[IncomingMessage]</code> <p>A StreamMessage object representing the parsed message.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/parser.py</code> <pre><code>@staticmethod\nasync def parse_message(\nmessage: aio_pika.IncomingMessage,\n) -&gt; StreamMessage[aio_pika.IncomingMessage]:\n\"\"\"Parses an incoming message and returns a RabbitMessage object.\n    Args:\n        message: The incoming message to parse.\n    Returns:\n        A StreamMessage object representing the parsed message.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nreturn RabbitMessage(\nbody=message.body,\nheaders=message.headers,\nreply_to=message.reply_to or \"\",\ncontent_type=message.content_type,\nmessage_id=message.message_id or str(uuid4()),\ncorrelation_id=message.correlation_id or str(uuid4()),\nraw_message=message,\n)\n</code></pre>"},{"location":"api/faststream/rabbit/producer/AioPikaFastProducer/","title":"AioPikaFastProducer","text":""},{"location":"api/faststream/rabbit/producer/AioPikaFastProducer/#faststream.rabbit.producer.AioPikaFastProducer","title":"faststream.rabbit.producer.AioPikaFastProducer","text":"<p>A class for fast producing messages using aio-pika.</p> METHOD DESCRIPTION <code>__init__</code> <p>Initializes the AioPikaFastProducer object.</p> <code>publish</code> <p>Publishes a message to a queue or exchange.</p> <code>_publish</code> <p>Publishes a message to an exchange.</p> <p>Note: This docstring is incomplete as it is difficult to understand the purpose and functionality of the class and its methods without more context.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/producer.py</code> <pre><code>class AioPikaFastProducer:\n\"\"\"A class for fast producing messages using aio-pika.\n    Attributes:\n        _channel : aio_pika.RobustChannel\n            The channel used for publishing messages.\n        _rpc_lock : anyio.Lock\n            Lock used for RPC calls.\n        _decoder : AsyncDecoder[aio_pika.IncomingMessage]\n            Decoder used for decoding incoming messages.\n        _parser : AsyncParser[aio_pika.IncomingMessage]\n            Parser used for parsing incoming messages.\n        declarer : RabbitDeclarer\n            The declarer object used for declaring exchanges and queues.\n    Methods:\n        __init__(channel, declarer, parser, decoder): Initializes the AioPikaFastProducer object.\n        publish(message, queue, exchange, routing_key, mandatory, immediate, timeout, rpc, rpc_timeout, raise_timeout, persist, reply_to, **message_kwargs): Publishes a message to a queue or exchange.\n        _publish(message, exchange, routing_key, mandatory, immediate, timeout, persist, reply_to, **message_kwargs): Publishes a message to an exchange.\n    Note: This docstring is incomplete as it is difficult to understand the purpose and functionality of the class and its methods without more context.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n_channel: aio_pika.RobustChannel\n_rpc_lock: anyio.Lock\n_decoder: AsyncDecoder[aio_pika.IncomingMessage]\n_parser: AsyncParser[aio_pika.IncomingMessage]\ndeclarer: RabbitDeclarer\ndef __init__(\nself,\nchannel: aio_pika.RobustChannel,\ndeclarer: RabbitDeclarer,\nparser: Optional[AsyncCustomParser[aio_pika.IncomingMessage]],\ndecoder: Optional[AsyncCustomDecoder[aio_pika.IncomingMessage]],\n):\n\"\"\"Initialize a class instance.\n        Args:\n            channel: The aio_pika.RobustChannel object.\n            declarer: The RabbitDeclarer object.\n            parser: An optional AsyncCustomParser object for parsing incoming messages.\n            decoder: An optional AsyncCustomDecoder object for decoding incoming messages.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nself._channel = channel\nself.declarer = declarer\nself._parser = resolve_custom_func(parser, AioPikaParser.parse_message)\nself._decoder = resolve_custom_func(decoder, AioPikaParser.decode_message)\nself._rpc_lock = anyio.Lock()\nasync def publish(\nself,\nmessage: AioPikaSendableMessage = \"\",\nqueue: Union[RabbitQueue, str] = \"\",\nexchange: Union[RabbitExchange, str, None] = None,\n*,\nrouting_key: str = \"\",\nmandatory: bool = True,\nimmediate: bool = False,\ntimeout: TimeoutType = None,\nrpc: bool = False,\nrpc_timeout: Optional[float] = 30.0,\nraise_timeout: bool = False,\npersist: bool = False,\nreply_to: Optional[str] = None,\n**message_kwargs: Any,\n) -&gt; Union[aiormq.abc.ConfirmationFrameType, SendableMessage]:\n\"\"\"Publish a message to a RabbitMQ queue.\n        Args:\n            message (AioPikaSendableMessage): The message to be published.\n            queue (Union[RabbitQueue, str]): The queue to publish the message to.\n            exchange (Union[RabbitExchange, str, None]): The exchange to publish the message to.\n            routing_key (str): The routing key for the message.\n            mandatory (bool): Whether the message is mandatory.\n            immediate (bool): Whether the message should be delivered immediately.\n            timeout (TimeoutType): The timeout for the operation.\n            rpc (bool): Whether the message is for RPC.\n            rpc_timeout (Optional[float]): The timeout for RPC.\n            raise_timeout (bool): Whether to raise an exception on timeout.\n            persist (bool): Whether the message should be persisted.\n            reply_to (Optional[str]): The reply-to queue for RPC.\n            **message_kwargs (Any): Additional keyword arguments for the message.\n        Returns:\n            Union[aiormq.abc.ConfirmationFrameType, SendableMessage]: The result of the publish operation.\n        Raises:\n            WRONG_PUBLISH_ARGS: If reply_to is not None when rpc is True.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\np_queue = RabbitQueue.validate(queue)\ncontext: AsyncContextManager[\nOptional[MemoryObjectReceiveStream[aio_pika.IncomingMessage]]\n]\nif rpc is True:\nif reply_to is not None:\nraise WRONG_PUBLISH_ARGS\nelse:\ncontext = _RPCCallback(\nself._rpc_lock,\nself.declarer.queues[RABBIT_REPLY],\n)\nelse:\ncontext = _fake_context()\nasync with context as response_queue:\nr = await self._publish(\nmessage=message,\nexchange=exchange,\nrouting_key=routing_key or p_queue.routing or \"\",\nmandatory=mandatory,\nimmediate=immediate,\ntimeout=timeout,\npersist=persist,\nreply_to=RABBIT_REPLY if response_queue else reply_to,\n**message_kwargs,\n)\nif response_queue is None:\nreturn r\nelse:\nscope: Callable[[Optional[float]], ContextManager[CancelScope]]\nif raise_timeout:\nscope = anyio.fail_after\nelse:\nscope = anyio.move_on_after\nmsg: Optional[aio_pika.IncomingMessage] = None\nwith scope(rpc_timeout):\nmsg = await response_queue.receive()\nif msg:\nreturn await self._decoder(await self._parser(msg))\nreturn None\nasync def _publish(\nself,\nmessage: AioPikaSendableMessage = \"\",\nexchange: Union[RabbitExchange, str, None] = None,\n*,\nrouting_key: str = \"\",\nmandatory: bool = True,\nimmediate: bool = False,\ntimeout: TimeoutType = None,\npersist: bool = False,\nreply_to: Optional[str] = None,\n**message_kwargs: Any,\n) -&gt; Union[aiormq.abc.ConfirmationFrameType, SendableMessage]:\n\"\"\"Publish a message to a RabbitMQ exchange.\n        Args:\n            message (AioPikaSendableMessage): The message to be published.\n            exchange (Union[RabbitExchange, str, None]): The exchange to publish the message to.\n            routing_key (str): The routing key for the message.\n            mandatory (bool): Whether the message is mandatory.\n            immediate (bool): Whether the message should be delivered immediately.\n            timeout (TimeoutType): The timeout for the operation.\n            persist (bool): Whether the message should be persisted.\n            reply_to (Optional[str]): The reply-to address for the message.\n            **message_kwargs (Any): Additional keyword arguments for the message.\n        Returns:\n            Union[aiormq.abc.ConfirmationFrameType, SendableMessage]: The result of the publish operation.\n        Raises:\n            NotImplementedError: If silent animals are not supported.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\np_exchange = RabbitExchange.validate(exchange)\nif p_exchange is None:\nexchange_obj = self._channel.default_exchange\nelse:\nexchange_obj = await self.declarer.declare_exchange(p_exchange)\nmessage = AioPikaParser.encode_message(\nmessage=message,\npersist=persist,\nreply_to=reply_to,\n**message_kwargs,\n)\nreturn await exchange_obj.publish(\nmessage=message,\nrouting_key=routing_key,\nmandatory=mandatory,\nimmediate=immediate,\ntimeout=timeout,\n)\n</code></pre>"},{"location":"api/faststream/rabbit/producer/AioPikaFastProducer/#faststream.rabbit.producer.AioPikaFastProducer.declarer","title":"declarer  <code>instance-attribute</code>","text":"<pre><code>declarer: RabbitDeclarer = declarer\n</code></pre>"},{"location":"api/faststream/rabbit/producer/AioPikaFastProducer/#faststream.rabbit.producer.AioPikaFastProducer.publish","title":"publish  <code>async</code>","text":"<pre><code>publish(\nmessage: AioPikaSendableMessage = \"\",\nqueue: Union[RabbitQueue, str] = \"\",\nexchange: Union[RabbitExchange, str, None] = None,\n*,\nrouting_key: str = \"\",\nmandatory: bool = True,\nimmediate: bool = False,\ntimeout: TimeoutType = None,\nrpc: bool = False,\nrpc_timeout: Optional[float] = 30.0,\nraise_timeout: bool = False,\npersist: bool = False,\nreply_to: Optional[str] = None,\n**message_kwargs: Any\n) -&gt; Union[\naiormq.abc.ConfirmationFrameType, SendableMessage\n]\n</code></pre> <p>Publish a message to a RabbitMQ queue.</p> PARAMETER  DESCRIPTION <code>message</code> <p>The message to be published.</p> <p> TYPE: <code>AioPikaSendableMessage</code> DEFAULT: <code>''</code> </p> <code>queue</code> <p>The queue to publish the message to.</p> <p> TYPE: <code>Union[RabbitQueue, str]</code> DEFAULT: <code>''</code> </p> <code>exchange</code> <p>The exchange to publish the message to.</p> <p> TYPE: <code>Union[RabbitExchange, str, None]</code> DEFAULT: <code>None</code> </p> <code>routing_key</code> <p>The routing key for the message.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>mandatory</code> <p>Whether the message is mandatory.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>immediate</code> <p>Whether the message should be delivered immediately.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>timeout</code> <p>The timeout for the operation.</p> <p> TYPE: <code>TimeoutType</code> DEFAULT: <code>None</code> </p> <code>rpc</code> <p>Whether the message is for RPC.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>rpc_timeout</code> <p>The timeout for RPC.</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>30.0</code> </p> <code>raise_timeout</code> <p>Whether to raise an exception on timeout.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>persist</code> <p>Whether the message should be persisted.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>reply_to</code> <p>The reply-to queue for RPC.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>**message_kwargs</code> <p>Additional keyword arguments for the message.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Union[ConfirmationFrameType, SendableMessage]</code> <p>Union[aiormq.abc.ConfirmationFrameType, SendableMessage]: The result of the publish operation.</p> RAISES DESCRIPTION <code>WRONG_PUBLISH_ARGS</code> <p>If reply_to is not None when rpc is True.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/producer.py</code> <pre><code>async def publish(\nself,\nmessage: AioPikaSendableMessage = \"\",\nqueue: Union[RabbitQueue, str] = \"\",\nexchange: Union[RabbitExchange, str, None] = None,\n*,\nrouting_key: str = \"\",\nmandatory: bool = True,\nimmediate: bool = False,\ntimeout: TimeoutType = None,\nrpc: bool = False,\nrpc_timeout: Optional[float] = 30.0,\nraise_timeout: bool = False,\npersist: bool = False,\nreply_to: Optional[str] = None,\n**message_kwargs: Any,\n) -&gt; Union[aiormq.abc.ConfirmationFrameType, SendableMessage]:\n\"\"\"Publish a message to a RabbitMQ queue.\n    Args:\n        message (AioPikaSendableMessage): The message to be published.\n        queue (Union[RabbitQueue, str]): The queue to publish the message to.\n        exchange (Union[RabbitExchange, str, None]): The exchange to publish the message to.\n        routing_key (str): The routing key for the message.\n        mandatory (bool): Whether the message is mandatory.\n        immediate (bool): Whether the message should be delivered immediately.\n        timeout (TimeoutType): The timeout for the operation.\n        rpc (bool): Whether the message is for RPC.\n        rpc_timeout (Optional[float]): The timeout for RPC.\n        raise_timeout (bool): Whether to raise an exception on timeout.\n        persist (bool): Whether the message should be persisted.\n        reply_to (Optional[str]): The reply-to queue for RPC.\n        **message_kwargs (Any): Additional keyword arguments for the message.\n    Returns:\n        Union[aiormq.abc.ConfirmationFrameType, SendableMessage]: The result of the publish operation.\n    Raises:\n        WRONG_PUBLISH_ARGS: If reply_to is not None when rpc is True.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\np_queue = RabbitQueue.validate(queue)\ncontext: AsyncContextManager[\nOptional[MemoryObjectReceiveStream[aio_pika.IncomingMessage]]\n]\nif rpc is True:\nif reply_to is not None:\nraise WRONG_PUBLISH_ARGS\nelse:\ncontext = _RPCCallback(\nself._rpc_lock,\nself.declarer.queues[RABBIT_REPLY],\n)\nelse:\ncontext = _fake_context()\nasync with context as response_queue:\nr = await self._publish(\nmessage=message,\nexchange=exchange,\nrouting_key=routing_key or p_queue.routing or \"\",\nmandatory=mandatory,\nimmediate=immediate,\ntimeout=timeout,\npersist=persist,\nreply_to=RABBIT_REPLY if response_queue else reply_to,\n**message_kwargs,\n)\nif response_queue is None:\nreturn r\nelse:\nscope: Callable[[Optional[float]], ContextManager[CancelScope]]\nif raise_timeout:\nscope = anyio.fail_after\nelse:\nscope = anyio.move_on_after\nmsg: Optional[aio_pika.IncomingMessage] = None\nwith scope(rpc_timeout):\nmsg = await response_queue.receive()\nif msg:\nreturn await self._decoder(await self._parser(msg))\nreturn None\n</code></pre>"},{"location":"api/faststream/rabbit/publisher/LogicPublisher/","title":"LogicPublisher","text":""},{"location":"api/faststream/rabbit/publisher/LogicPublisher/#faststream.rabbit.publisher.LogicPublisher","title":"faststream.rabbit.publisher.LogicPublisher  <code>dataclass</code>","text":"<p>             Bases: <code>ABCPublisher[IncomingMessage]</code></p> <p>A class to publish messages for logic processing.</p> METHOD DESCRIPTION <code>publish </code> <p>Publishes a message for logic processing.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/publisher.py</code> <pre><code>@dataclass\nclass LogicPublisher(ABCPublisher[IncomingMessage]):\n\"\"\"A class to publish messages for logic processing.\n    Attributes:\n        _producer : An optional AioPikaFastProducer object.\n    Methods:\n        publish : Publishes a message for logic processing.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n_producer: Optional[AioPikaFastProducer] = field(default=None, init=False)\n@override\nasync def publish(  # type: ignore[override]\nself,\nmessage: AioPikaSendableMessage = \"\",\n*,\nrpc: bool = False,\nrpc_timeout: Optional[float] = 30.0,\nraise_timeout: bool = False,\ncorrelation_id: Optional[str] = None,\n**message_kwargs: Any,\n) -&gt; Union[aiormq.abc.ConfirmationFrameType, SendableMessage]:\n\"\"\"Publish a message.\n        Args:\n            message: The message to be published.\n            rpc: Whether the message is for RPC (Remote Procedure Call).\n            rpc_timeout: Timeout for RPC.\n            raise_timeout: Whether to raise an exception if timeout occurs.\n            correlation_id: Correlation ID for the message.\n            **message_kwargs: Additional keyword arguments for the message.\n        Returns:\n            ConfirmationFrameType or SendableMessage: The result of the publish operation.\n        Raises:\n            AssertionError: If `_producer` is not set up.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nassert self._producer, \"Please, setup `_producer` first\"  # nosec B101\nreturn await self._producer.publish(\nmessage=message,\nqueue=self.queue,\nexchange=self.exchange,\nrouting_key=self.routing_key,\nmandatory=self.mandatory,\nimmediate=self.immediate,\ntimeout=self.timeout,\nrpc=rpc,\nrpc_timeout=rpc_timeout,\nraise_timeout=raise_timeout,\npersist=self.persist,\nreply_to=self.reply_to,\ncorrelation_id=correlation_id,\n**self.message_kwargs,\n**message_kwargs,\n)\n</code></pre>"},{"location":"api/faststream/rabbit/publisher/LogicPublisher/#faststream.rabbit.publisher.LogicPublisher.name","title":"name","text":"<pre><code>name() -&gt; str\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/publisher.py</code> <pre><code>    _producer : An optional AioPikaFastProducer object.\nMethods:\n</code></pre>"},{"location":"api/faststream/rabbit/publisher/LogicPublisher/#faststream.rabbit.publisher.LogicPublisher.publish","title":"publish  <code>async</code>","text":"<pre><code>publish(\nmessage: AioPikaSendableMessage = \"\",\n*,\nrpc: bool = False,\nrpc_timeout: Optional[float] = 30.0,\nraise_timeout: bool = False,\ncorrelation_id: Optional[str] = None,\n**message_kwargs: Any\n) -&gt; Union[\naiormq.abc.ConfirmationFrameType, SendableMessage\n]\n</code></pre> <p>Publish a message.</p> PARAMETER  DESCRIPTION <code>message</code> <p>The message to be published.</p> <p> TYPE: <code>AioPikaSendableMessage</code> DEFAULT: <code>''</code> </p> <code>rpc</code> <p>Whether the message is for RPC (Remote Procedure Call).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>rpc_timeout</code> <p>Timeout for RPC.</p> <p> TYPE: <code>Optional[float]</code> DEFAULT: <code>30.0</code> </p> <code>raise_timeout</code> <p>Whether to raise an exception if timeout occurs.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>correlation_id</code> <p>Correlation ID for the message.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>**message_kwargs</code> <p>Additional keyword arguments for the message.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Union[ConfirmationFrameType, SendableMessage]</code> <p>ConfirmationFrameType or SendableMessage: The result of the publish operation.</p> RAISES DESCRIPTION <code>AssertionError</code> <p>If <code>_producer</code> is not set up.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/publisher.py</code> <pre><code>@override\nasync def publish(  # type: ignore[override]\nself,\nmessage: AioPikaSendableMessage = \"\",\n*,\nrpc: bool = False,\nrpc_timeout: Optional[float] = 30.0,\nraise_timeout: bool = False,\ncorrelation_id: Optional[str] = None,\n**message_kwargs: Any,\n) -&gt; Union[aiormq.abc.ConfirmationFrameType, SendableMessage]:\n\"\"\"Publish a message.\n    Args:\n        message: The message to be published.\n        rpc: Whether the message is for RPC (Remote Procedure Call).\n        rpc_timeout: Timeout for RPC.\n        raise_timeout: Whether to raise an exception if timeout occurs.\n        correlation_id: Correlation ID for the message.\n        **message_kwargs: Additional keyword arguments for the message.\n    Returns:\n        ConfirmationFrameType or SendableMessage: The result of the publish operation.\n    Raises:\n        AssertionError: If `_producer` is not set up.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nassert self._producer, \"Please, setup `_producer` first\"  # nosec B101\nreturn await self._producer.publish(\nmessage=message,\nqueue=self.queue,\nexchange=self.exchange,\nrouting_key=self.routing_key,\nmandatory=self.mandatory,\nimmediate=self.immediate,\ntimeout=self.timeout,\nrpc=rpc,\nrpc_timeout=rpc_timeout,\nraise_timeout=raise_timeout,\npersist=self.persist,\nreply_to=self.reply_to,\ncorrelation_id=correlation_id,\n**self.message_kwargs,\n**message_kwargs,\n)\n</code></pre>"},{"location":"api/faststream/rabbit/router/RabbitRouter/","title":"RabbitRouter","text":""},{"location":"api/faststream/rabbit/router/RabbitRouter/#faststream.rabbit.router.RabbitRouter","title":"faststream.rabbit.router.RabbitRouter","text":"<p>             Bases: <code>RabbitRouter</code></p> <p>A class representing a RabbitMQ router for publishing messages.</p> METHOD DESCRIPTION <code>_get_publisher_key </code> <p>Returns the key for a given Publisher object</p> <code>_update_publisher_prefix </code> <p>Updates the prefix of a given Publisher object</p> <code>publisher </code> <p>Publishes a message to RabbitMQ</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/router.py</code> <pre><code>class RabbitRouter(BaseRouter):\n\"\"\"A class representing a RabbitMQ router for publishing messages.\n    Attributes:\n        _publishers : A dictionary mapping integer keys to Publisher objects\n    Methods:\n        _get_publisher_key : Returns the key for a given Publisher object\n        _update_publisher_prefix : Updates the prefix of a given Publisher object\n        publisher : Publishes a message to RabbitMQ\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n_publishers: Dict[int, Publisher]\n@staticmethod\ndef _get_publisher_key(publisher: Publisher) -&gt; int:\n\"\"\"Get the publisher key.\n        Args:\n            publisher: The publisher object.\n        Returns:\n            The publisher key as an integer.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nreturn get_routing_hash(publisher.queue, publisher.exchange)\n@staticmethod\ndef _update_publisher_prefix(prefix: str, publisher: Publisher) -&gt; Publisher:\n\"\"\"Updates the publisher prefix.\n        Args:\n            prefix (str): The prefix to be added to the publisher's queue name.\n            publisher (Publisher): The publisher object to be updated.\n        Returns:\n            Publisher: The updated publisher object.\n        Note:\n            This function is intended to be used as a decorator.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\npublisher.queue = model_copy(\npublisher.queue, update={\"name\": prefix + publisher.queue.name}\n)\nreturn publisher\n@override\ndef publisher(  # type: ignore[override]\nself,\nqueue: Union[RabbitQueue, str] = \"\",\nexchange: Union[RabbitExchange, str, None] = None,\n*,\nrouting_key: str = \"\",\nmandatory: bool = True,\nimmediate: bool = False,\ntimeout: TimeoutType = None,\npersist: bool = False,\nreply_to: Optional[str] = None,\n# AsyncAPI information\ntitle: Optional[str] = None,\ndescription: Optional[str] = None,\n**message_kwargs: Any,\n) -&gt; Publisher:\n\"\"\"Publishes a message to a RabbitMQ queue or exchange.\n        Args:\n            queue: The RabbitMQ queue to publish the message to. Can be either a RabbitQueue object or a string representing the queue name.\n            exchange: The RabbitMQ exchange to publish the message to. Can be either a RabbitExchange object, a string representing the exchange name, or None.\n            routing_key: The routing key to use when publishing the message.\n            mandatory: Whether the message is mandatory or not.\n            immediate: Whether the message should be delivered immediately or not.\n            timeout: The timeout for the publish operation.\n            persist: Whether the message should be persisted or not.\n            reply_to: The reply-to address for the message.\n            title: The title of the message (AsyncAPI information).\n            description: The description of the message (AsyncAPI information).\n            **message_kwargs: Additional keyword arguments to include in the message.\n        Returns:\n            The Publisher object used to publish the message.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nnew_publisher = self._update_publisher_prefix(\nself.prefix,\nPublisher(\nqueue=RabbitQueue.validate(queue),\nexchange=RabbitExchange.validate(exchange),\nrouting_key=routing_key,\nmandatory=mandatory,\nimmediate=immediate,\ntimeout=timeout,\npersist=persist,\nreply_to=reply_to,\nmessage_kwargs=message_kwargs,\ntitle=title,\n_description=description,\n),\n)\nkey = self._get_publisher_key(new_publisher)\npublisher = self._publishers[key] = self._publishers.get(key, new_publisher)\nreturn publisher\n</code></pre>"},{"location":"api/faststream/rabbit/router/RabbitRouter/#faststream.rabbit.router.RabbitRouter.publisher","title":"publisher","text":"<pre><code>publisher(\nqueue: Union[RabbitQueue, str] = \"\",\nexchange: Union[RabbitExchange, str, None] = None,\n*,\nrouting_key: str = \"\",\nmandatory: bool = True,\nimmediate: bool = False,\ntimeout: TimeoutType = None,\npersist: bool = False,\nreply_to: Optional[str] = None,\ntitle: Optional[str] = None,\ndescription: Optional[str] = None,\n**message_kwargs: Any\n) -&gt; Publisher\n</code></pre> <p>Publishes a message to a RabbitMQ queue or exchange.</p> PARAMETER  DESCRIPTION <code>queue</code> <p>The RabbitMQ queue to publish the message to. Can be either a RabbitQueue object or a string representing the queue name.</p> <p> TYPE: <code>Union[RabbitQueue, str]</code> DEFAULT: <code>''</code> </p> <code>exchange</code> <p>The RabbitMQ exchange to publish the message to. Can be either a RabbitExchange object, a string representing the exchange name, or None.</p> <p> TYPE: <code>Union[RabbitExchange, str, None]</code> DEFAULT: <code>None</code> </p> <code>routing_key</code> <p>The routing key to use when publishing the message.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>mandatory</code> <p>Whether the message is mandatory or not.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>immediate</code> <p>Whether the message should be delivered immediately or not.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>timeout</code> <p>The timeout for the publish operation.</p> <p> TYPE: <code>TimeoutType</code> DEFAULT: <code>None</code> </p> <code>persist</code> <p>Whether the message should be persisted or not.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>reply_to</code> <p>The reply-to address for the message.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>title</code> <p>The title of the message (AsyncAPI information).</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>description</code> <p>The description of the message (AsyncAPI information).</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>**message_kwargs</code> <p>Additional keyword arguments to include in the message.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Publisher</code> <p>The Publisher object used to publish the message.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/router.py</code> <pre><code>@override\ndef publisher(  # type: ignore[override]\nself,\nqueue: Union[RabbitQueue, str] = \"\",\nexchange: Union[RabbitExchange, str, None] = None,\n*,\nrouting_key: str = \"\",\nmandatory: bool = True,\nimmediate: bool = False,\ntimeout: TimeoutType = None,\npersist: bool = False,\nreply_to: Optional[str] = None,\n# AsyncAPI information\ntitle: Optional[str] = None,\ndescription: Optional[str] = None,\n**message_kwargs: Any,\n) -&gt; Publisher:\n\"\"\"Publishes a message to a RabbitMQ queue or exchange.\n    Args:\n        queue: The RabbitMQ queue to publish the message to. Can be either a RabbitQueue object or a string representing the queue name.\n        exchange: The RabbitMQ exchange to publish the message to. Can be either a RabbitExchange object, a string representing the exchange name, or None.\n        routing_key: The routing key to use when publishing the message.\n        mandatory: Whether the message is mandatory or not.\n        immediate: Whether the message should be delivered immediately or not.\n        timeout: The timeout for the publish operation.\n        persist: Whether the message should be persisted or not.\n        reply_to: The reply-to address for the message.\n        title: The title of the message (AsyncAPI information).\n        description: The description of the message (AsyncAPI information).\n        **message_kwargs: Additional keyword arguments to include in the message.\n    Returns:\n        The Publisher object used to publish the message.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nnew_publisher = self._update_publisher_prefix(\nself.prefix,\nPublisher(\nqueue=RabbitQueue.validate(queue),\nexchange=RabbitExchange.validate(exchange),\nrouting_key=routing_key,\nmandatory=mandatory,\nimmediate=immediate,\ntimeout=timeout,\npersist=persist,\nreply_to=reply_to,\nmessage_kwargs=message_kwargs,\ntitle=title,\n_description=description,\n),\n)\nkey = self._get_publisher_key(new_publisher)\npublisher = self._publishers[key] = self._publishers.get(key, new_publisher)\nreturn publisher\n</code></pre>"},{"location":"api/faststream/rabbit/router/RabbitRouter/#faststream.rabbit.router.RabbitRouter.subscriber","title":"subscriber","text":"<pre><code>subscriber(\nqueue: Union[str, RabbitQueue],\nexchange: Union[str, RabbitExchange, None] = None,\n*,\nconsume_args: Optional[AnyDict] = None,\ndependencies: Sequence[Depends] = (),\nfilter: Filter[RabbitMessage] = default_filter,\nparser: Optional[\nCustomParser[aio_pika.IncomingMessage]\n] = None,\ndecoder: Optional[\nCustomDecoder[aio_pika.IncomingMessage]\n] = None,\nmiddlewares: Optional[\nSequence[\nCallable[\n[aio_pika.IncomingMessage], BaseMiddleware\n]\n]\n] = None,\nretry: Union[bool, int] = False,\ntitle: Optional[str] = None,\ndescription: Optional[str] = None,\n**__service_kwargs: Any\n) -&gt; Callable[\n[Callable[P_HandlerParams, T_HandlerReturn]],\nHandlerCallWrapper[\naio_pika.IncomingMessage,\nP_HandlerParams,\nT_HandlerReturn,\n],\n]\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/router.py</code> <pre><code>def _update_publisher_prefix(prefix: str, publisher: Publisher) -&gt; Publisher:\n\"\"\"Updates the publisher prefix.\n    Args:\n        prefix (str): The prefix to be added to the publisher's queue name.\n        publisher (Publisher): The publisher object to be updated.\n    Returns:\n        Publisher: The updated publisher object.\n    Note:\n        This function is intended to be used as a decorator.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\npublisher.queue = model_copy(\npublisher.queue, update={\"name\": prefix + publisher.queue.name}\n)\nreturn publisher\n@override\ndef publisher(  # type: ignore[override]\nself,\nqueue: Union[RabbitQueue, str] = \"\",\nexchange: Union[RabbitExchange, str, None] = None,\n*,\nrouting_key: str = \"\",\nmandatory: bool = True,\n</code></pre>"},{"location":"api/faststream/rabbit/security/parse_security/","title":"Parse security","text":""},{"location":"api/faststream/rabbit/security/parse_security/#faststream.rabbit.security.parse_security","title":"faststream.rabbit.security.parse_security","text":"<pre><code>parse_security(\nsecurity: Optional[BaseSecurity],\n) -&gt; Dict[str, Any]\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/security.py</code> <pre><code>def parse_security(security: Optional[BaseSecurity]) -&gt; Dict[str, Any]:\nif security is None:\nreturn {}\nelse:\nraise NotImplementedError(f\"RabbitBroker does not support {type(security)}\")\n</code></pre>"},{"location":"api/faststream/rabbit/shared/constants/ExchangeType/","title":"ExchangeType","text":""},{"location":"api/faststream/rabbit/shared/constants/ExchangeType/#faststream.rabbit.shared.constants.ExchangeType","title":"faststream.rabbit.shared.constants.ExchangeType","text":"<p>             Bases: <code>str</code>, <code>Enum</code></p> <p>A class to represent the exchange type.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/shared/constants.py</code> <pre><code>@unique\nclass ExchangeType(str, Enum):\n\"\"\"A class to represent the exchange type.\n    Attributes:\n        FANOUT : fanout exchange type\n        DIRECT : direct exchange type\n        TOPIC : topic exchange type\n        HEADERS : headers exchange type\n        X_DELAYED_MESSAGE : x-delayed-message exchange type\n        X_CONSISTENT_HASH : x-consistent-hash exchange type\n        X_MODULUS_HASH : x-modulus-hash exchange type\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nFANOUT = \"fanout\"\nDIRECT = \"direct\"\nTOPIC = \"topic\"\nHEADERS = \"headers\"\nX_DELAYED_MESSAGE = \"x-delayed-message\"\nX_CONSISTENT_HASH = \"x-consistent-hash\"\nX_MODULUS_HASH = \"x-modulus-hash\"\n</code></pre>"},{"location":"api/faststream/rabbit/shared/constants/ExchangeType/#faststream.rabbit.shared.constants.ExchangeType.DIRECT","title":"DIRECT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DIRECT = 'direct'\n</code></pre>"},{"location":"api/faststream/rabbit/shared/constants/ExchangeType/#faststream.rabbit.shared.constants.ExchangeType.FANOUT","title":"FANOUT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FANOUT = 'fanout'\n</code></pre>"},{"location":"api/faststream/rabbit/shared/constants/ExchangeType/#faststream.rabbit.shared.constants.ExchangeType.HEADERS","title":"HEADERS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>HEADERS = 'headers'\n</code></pre>"},{"location":"api/faststream/rabbit/shared/constants/ExchangeType/#faststream.rabbit.shared.constants.ExchangeType.TOPIC","title":"TOPIC  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TOPIC = 'topic'\n</code></pre>"},{"location":"api/faststream/rabbit/shared/constants/ExchangeType/#faststream.rabbit.shared.constants.ExchangeType.X_CONSISTENT_HASH","title":"X_CONSISTENT_HASH  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>X_CONSISTENT_HASH = 'x-consistent-hash'\n</code></pre>"},{"location":"api/faststream/rabbit/shared/constants/ExchangeType/#faststream.rabbit.shared.constants.ExchangeType.X_DELAYED_MESSAGE","title":"X_DELAYED_MESSAGE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>X_DELAYED_MESSAGE = 'x-delayed-message'\n</code></pre>"},{"location":"api/faststream/rabbit/shared/constants/ExchangeType/#faststream.rabbit.shared.constants.ExchangeType.X_MODULUS_HASH","title":"X_MODULUS_HASH  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>X_MODULUS_HASH = 'x-modulus-hash'\n</code></pre>"},{"location":"api/faststream/rabbit/shared/logging/RabbitLoggingMixin/","title":"RabbitLoggingMixin","text":""},{"location":"api/faststream/rabbit/shared/logging/RabbitLoggingMixin/#faststream.rabbit.shared.logging.RabbitLoggingMixin","title":"faststream.rabbit.shared.logging.RabbitLoggingMixin","text":"<p>             Bases: <code>LoggingMixin</code></p> <p>A class that extends the LoggingMixin class and adds additional functionality for logging RabbitMQ related information.</p> METHOD DESCRIPTION <code>__init__ </code> <p>Initializes the RabbitLoggingMixin object.</p> <code>_get_log_context </code> <p>Overrides the _get_log_context method of the LoggingMixin class to include RabbitMQ related context information.</p> <code>fmt </code> <p>Returns the log format string.</p> <code>_setup_log_context </code> <p>Sets up the log context by updating the maximum lengths of the queue and exchange names.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/shared/logging.py</code> <pre><code>class RabbitLoggingMixin(LoggingMixin):\n\"\"\"A class that extends the LoggingMixin class and adds additional functionality for logging RabbitMQ related information.\n    Attributes:\n        _max_queue_len : maximum length of the queue name\n        _max_exchange_len : maximum length of the exchange name\n    Methods:\n        __init__ : Initializes the RabbitLoggingMixin object.\n        _get_log_context : Overrides the _get_log_context method of the LoggingMixin class to include RabbitMQ related context information.\n        fmt : Returns the log format string.\n        _setup_log_context : Sets up the log context by updating the maximum lengths of the queue and exchange names.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n_max_queue_len: int\n_max_exchange_len: int\ndef __init__(\nself,\n*args: Any,\nlogger: Optional[logging.Logger] = access_logger,\nlog_level: int = logging.INFO,\nlog_fmt: Optional[str] = None,\n**kwargs: Any,\n) -&gt; None:\n\"\"\"Initialize the class.\n        Args:\n            *args: Variable length argument list\n            logger: Optional logger object\n            log_level: Logging level\n            log_fmt: Optional log format\n            **kwargs: Arbitrary keyword arguments\n        Returns:\n            None\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nsuper().__init__(\n*args,\nlogger=logger,\nlog_level=log_level,\nlog_fmt=log_fmt,\n**kwargs,\n)\nself._max_queue_len = 4\nself._max_exchange_len = 4\n@override\ndef _get_log_context(  # type: ignore[override]\nself,\nmessage: Optional[StreamMessage[Any]],\nqueue: RabbitQueue,\nexchange: Optional[RabbitExchange] = None,\n) -&gt; AnyDict:\n\"\"\"Get the log context.\n        Args:\n            message: Optional stream message.\n            queue: RabbitQueue object.\n            exchange: Optional RabbitExchange object.\n        Returns:\n            Dictionary containing the log context.\n        Note:\n            This is a private method and should not be called directly.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\ncontext = {\n\"queue\": queue.name,\n\"exchange\": exchange.name if exchange else \"default\",\n**super()._get_log_context(message),\n}\nreturn context\n@property\ndef fmt(self) -&gt; str:\nreturn super().fmt or (\n\"%(asctime)s %(levelname)s - \"\nf\"%(exchange)-{self._max_exchange_len}s | \"\nf\"%(queue)-{self._max_queue_len}s | \"\nf\"%(message_id)-10s \"\n\"- %(message)s\"\n)\ndef _setup_log_context(\nself,\nqueue: Optional[RabbitQueue] = None,\nexchange: Optional[RabbitExchange] = None,\n) -&gt; None:\n\"\"\"Set up log context.\n        Args:\n            queue: Optional RabbitQueue object representing the queue.\n            exchange: Optional RabbitExchange object representing the exchange.\n        Returns:\n            None\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nif exchange is not None:\nself._max_exchange_len = max(\nself._max_exchange_len, len(exchange.name or \"\")\n)\nif queue is not None:  # pragma: no branch\nself._max_queue_len = max(self._max_queue_len, len(queue.name))\n</code></pre>"},{"location":"api/faststream/rabbit/shared/logging/RabbitLoggingMixin/#faststream.rabbit.shared.logging.RabbitLoggingMixin.fmt","title":"fmt  <code>property</code>","text":"<pre><code>fmt: str\n</code></pre>"},{"location":"api/faststream/rabbit/shared/publisher/ABCPublisher/","title":"ABCPublisher","text":""},{"location":"api/faststream/rabbit/shared/publisher/ABCPublisher/#faststream.rabbit.shared.publisher.ABCPublisher","title":"faststream.rabbit.shared.publisher.ABCPublisher  <code>dataclass</code>","text":"<p>             Bases: <code>ABC</code>, <code>BasePublisher[MsgType]</code>, <code>BaseRMQInformation</code></p> <p>A class representing an ABCPublisher.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/shared/publisher.py</code> <pre><code>@dataclass\nclass ABCPublisher(ABC, BasePublisher[MsgType], BaseRMQInformation):\n\"\"\"A class representing an ABCPublisher.\n    Attributes:\n        routing_key : str, optional\n            The routing key for the publisher.\n        mandatory : bool, optional\n            Whether the message is mandatory or not.\n        immediate : bool, optional\n            Whether the message should be immediately delivered or not.\n        persist : bool, optional\n            Whether the message should be persisted or not.\n        timeout : TimeoutType, optional\n            The timeout for the message.\n        reply_to : str, optional\n            The reply-to address for the message.\n        message_kwargs : dict, optional\n            Additional keyword arguments for the message.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nrouting_key: str = \"\"\nmandatory: bool = True\nimmediate: bool = False\npersist: bool = False\ntimeout: TimeoutType = None\nreply_to: Optional[str] = None\nmessage_kwargs: AnyDict = field(default_factory=dict)\n</code></pre>"},{"location":"api/faststream/rabbit/shared/publisher/ABCPublisher/#faststream.rabbit.shared.publisher.ABCPublisher.immediate","title":"immediate  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>immediate: bool = False\n</code></pre>"},{"location":"api/faststream/rabbit/shared/publisher/ABCPublisher/#faststream.rabbit.shared.publisher.ABCPublisher.mandatory","title":"mandatory  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mandatory: bool = True\n</code></pre>"},{"location":"api/faststream/rabbit/shared/publisher/ABCPublisher/#faststream.rabbit.shared.publisher.ABCPublisher.message_kwargs","title":"message_kwargs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>message_kwargs: AnyDict = field(default_factory=dict)\n</code></pre>"},{"location":"api/faststream/rabbit/shared/publisher/ABCPublisher/#faststream.rabbit.shared.publisher.ABCPublisher.persist","title":"persist  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>persist: bool = False\n</code></pre>"},{"location":"api/faststream/rabbit/shared/publisher/ABCPublisher/#faststream.rabbit.shared.publisher.ABCPublisher.reply_to","title":"reply_to  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>reply_to: Optional[str] = None\n</code></pre>"},{"location":"api/faststream/rabbit/shared/publisher/ABCPublisher/#faststream.rabbit.shared.publisher.ABCPublisher.routing_key","title":"routing_key  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>routing_key: str = ''\n</code></pre>"},{"location":"api/faststream/rabbit/shared/publisher/ABCPublisher/#faststream.rabbit.shared.publisher.ABCPublisher.timeout","title":"timeout  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>timeout: TimeoutType = None\n</code></pre>"},{"location":"api/faststream/rabbit/shared/router/RabbitRouter/","title":"RabbitRouter","text":""},{"location":"api/faststream/rabbit/shared/router/RabbitRouter/#faststream.rabbit.shared.router.RabbitRouter","title":"faststream.rabbit.shared.router.RabbitRouter","text":"<p>             Bases: <code>BrokerRouter[int, IncomingMessage]</code></p> <p>A class representing a RabbitMQ router for handling incoming messages.</p> METHOD DESCRIPTION <code>__init__ </code> <p>initializes the RabbitRouter object</p> <code>subscriber </code> <p>decorator for subscribing to a queue and registering a handler function</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/shared/router.py</code> <pre><code>class RabbitRouter(BrokerRouter[int, IncomingMessage]):\n\"\"\"A class representing a RabbitMQ router for handling incoming messages.\n    Attributes:\n        prefix : prefix for the queue name\n        handlers : sequence of RabbitRoutes for handling incoming messages\n        kwargs : additional keyword arguments\n    Methods:\n        __init__ : initializes the RabbitRouter object\n        subscriber : decorator for subscribing to a queue and registering a handler function\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\ndef __init__(\nself,\nprefix: str = \"\",\nhandlers: Sequence[RabbitRoute[IncomingMessage, SendableMessage]] = (),\n**kwargs: Any,\n):\n\"\"\"Override the `__init__` method of the parent class.\n        Args:\n            prefix: A prefix string\n            handlers: A sequence of RabbitRoute objects\n            **kwargs: Additional keyword arguments\n        Raises:\n            NotImplementedError: If silent animals are not supported\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nfor h in handlers:\nif (q := h.kwargs.pop(\"queue\", None)) is None:\nq, h.args = h.args[0], h.args[1:]\nqueue = RabbitQueue.validate(q)\nnew_q = model_copy(queue, update={\"name\": prefix + queue.name})\nh.args = (new_q, *h.args)\nsuper().__init__(prefix, handlers, **kwargs)\n@override\ndef subscriber(  # type: ignore[override]\nself,\nqueue: Union[str, RabbitQueue],\n*broker_args: Any,\n**broker_kwargs: Any,\n) -&gt; Callable[\n[Callable[P_HandlerParams, T_HandlerReturn]],\nHandlerCallWrapper[IncomingMessage, P_HandlerParams, T_HandlerReturn],\n]:\n\"\"\"A function to subscribe to a RabbitMQ queue.\n        Args:\n            self : the instance of the class\n            queue : the queue to subscribe to, can be a string or a RabbitQueue object\n            *broker_args : additional arguments for the broker\n            **broker_kwargs : additional keyword arguments for the broker\n        Returns:\n            A callable object that wraps the handler function for the incoming messages from the queue.\n        Raises:\n            TypeError: If the queue is not a string or a RabbitQueue object\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nq = RabbitQueue.validate(queue)\nnew_q = model_copy(q, update={\"name\": self.prefix + q.name})\nreturn self._wrap_subscriber(new_q, *broker_args, **broker_kwargs)\n</code></pre>"},{"location":"api/faststream/rabbit/shared/router/RabbitRouter/#faststream.rabbit.shared.router.RabbitRouter.subscriber","title":"subscriber","text":"<pre><code>subscriber(\nqueue: Union[str, RabbitQueue],\n*broker_args: Any,\n**broker_kwargs: Any\n) -&gt; Callable[\n[Callable[P_HandlerParams, T_HandlerReturn]],\nHandlerCallWrapper[\nIncomingMessage, P_HandlerParams, T_HandlerReturn\n],\n]\n</code></pre> <p>A function to subscribe to a RabbitMQ queue.</p> PARAMETER  DESCRIPTION <code>self</code> <p>the instance of the class</p> <p> </p> <code>queue</code> <p>the queue to subscribe to, can be a string or a RabbitQueue object</p> <p> </p> <code>*broker_args</code> <p>additional arguments for the broker</p> <p> DEFAULT: <code>()</code> </p> <code>**broker_kwargs</code> <p>additional keyword arguments for the broker</p> <p> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Callable[[Callable[P_HandlerParams, T_HandlerReturn]], HandlerCallWrapper[IncomingMessage, P_HandlerParams, T_HandlerReturn]]</code> <p>A callable object that wraps the handler function for the incoming messages from the queue.</p> RAISES DESCRIPTION <code>TypeError</code> <p>If the queue is not a string or a RabbitQueue object</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/shared/router.py</code> <pre><code>@override\ndef subscriber(  # type: ignore[override]\nself,\nqueue: Union[str, RabbitQueue],\n*broker_args: Any,\n**broker_kwargs: Any,\n) -&gt; Callable[\n[Callable[P_HandlerParams, T_HandlerReturn]],\nHandlerCallWrapper[IncomingMessage, P_HandlerParams, T_HandlerReturn],\n]:\n\"\"\"A function to subscribe to a RabbitMQ queue.\n    Args:\n        self : the instance of the class\n        queue : the queue to subscribe to, can be a string or a RabbitQueue object\n        *broker_args : additional arguments for the broker\n        **broker_kwargs : additional keyword arguments for the broker\n    Returns:\n        A callable object that wraps the handler function for the incoming messages from the queue.\n    Raises:\n        TypeError: If the queue is not a string or a RabbitQueue object\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nq = RabbitQueue.validate(queue)\nnew_q = model_copy(q, update={\"name\": self.prefix + q.name})\nreturn self._wrap_subscriber(new_q, *broker_args, **broker_kwargs)\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/BaseRMQInformation/","title":"BaseRMQInformation","text":""},{"location":"api/faststream/rabbit/shared/schemas/BaseRMQInformation/#faststream.rabbit.shared.schemas.BaseRMQInformation","title":"faststream.rabbit.shared.schemas.BaseRMQInformation  <code>dataclass</code>","text":"<p>BaseRMQInformation.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/shared/schemas.py</code> <pre><code>@dataclass\nclass BaseRMQInformation:\n\"\"\"BaseRMQInformation.\n    Attributes:\n        queue : RabbitQueue object representing the queue\n        exchange : Optional RabbitExchange object representing the exchange\n        _description : Optional string describing the class\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nqueue: RabbitQueue = field(default=RabbitQueue(\"\"))\nexchange: Optional[RabbitExchange] = field(default=None)\n_description: Optional[str] = field(default=None)\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/BaseRMQInformation/#faststream.rabbit.shared.schemas.BaseRMQInformation.exchange","title":"exchange  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>exchange: Optional[RabbitExchange] = field(default=None)\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/BaseRMQInformation/#faststream.rabbit.shared.schemas.BaseRMQInformation.queue","title":"queue  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>queue: RabbitQueue = field(default=RabbitQueue(''))\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/RabbitExchange/","title":"RabbitExchange","text":""},{"location":"api/faststream/rabbit/shared/schemas/RabbitExchange/#faststream.rabbit.shared.schemas.RabbitExchange","title":"faststream.rabbit.shared.schemas.RabbitExchange","text":"<p>             Bases: <code>NameRequired</code></p> <p>A class to represent a RabbitMQ exchange.</p> METHOD DESCRIPTION <code>__hash__ </code> <p>returns the hash value of the exchange</p> <code>__init__ </code> <p>initializes the RabbitExchange object</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/shared/schemas.py</code> <pre><code>class RabbitExchange(NameRequired):\n\"\"\"A class to represent a RabbitMQ exchange.\n    Attributes:\n        name : name of the exchange\n        type : type of the exchange\n        durable : whether the exchange is durable or not\n        auto_delete : whether the exchange is auto-deleted or not\n        internal : whether the exchange is internal or not\n        passive : whether the exchange is passive or not\n        arguments : additional arguments for the exchange\n        timeout : timeout for the exchange\n        robust : whether the exchange is robust or not\n        bind_to : exchange to bind to\n        bind_arguments : additional arguments for the binding\n        routing_key : routing key for the exchange\n    Methods:\n        __hash__ : returns the hash value of the exchange\n        __init__ : initializes the RabbitExchange object\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\ntype: str = ExchangeType.DIRECT.value\ndurable: bool = False\nauto_delete: bool = False\ninternal: bool = False\npassive: bool = False\narguments: Optional[AnyDict] = None\ntimeout: TimeoutType = None\nrobust: bool = True\nbind_to: Optional[\"RabbitExchange\"] = None\nbind_arguments: Optional[AnyDict] = None\nrouting_key: str = \"\"\ndef __hash__(self) -&gt; int:\nreturn sum(\n(\nhash(self.name),\nhash(self.type),\nint(self.durable),\nint(self.auto_delete),\n)\n)\ndef __init__(\nself,\nname: str,\ntype: ExchangeType = ExchangeType.DIRECT,\ndurable: bool = False,\nauto_delete: bool = False,\ninternal: bool = False,\npassive: bool = False,\narguments: Optional[AnyDict] = None,\ntimeout: TimeoutType = None,\nrobust: bool = True,\nbind_to: Optional[\"RabbitExchange\"] = None,\nbind_arguments: Optional[AnyDict] = None,\nrouting_key: str = \"\",\n):\n\"\"\"Initialize a RabbitExchange object.\n        Args:\n            name (str): Name of the exchange.\n            type (ExchangeType, optional): Type of the exchange. Defaults to ExchangeType.DIRECT.\n            durable (bool, optional): Whether the exchange should survive broker restarts. Defaults to False.\n            auto_delete (bool, optional): Whether the exchange should be deleted when no longer in use. Defaults to False.\n            internal (bool, optional): Whether the exchange is used for internal purposes and should not be published to directly. Defaults to False.\n            passive (bool, optional): Whether to check if the exchange exists before creating it. Defaults to False.\n            arguments (Optional[AnyDict], optional): Additional arguments for the exchange. Defaults to None.\n            timeout (TimeoutType, optional): Timeout for the operation. Defaults to None.\n            robust (bool, optional): Whether to use robust mode for the exchange. Defaults to True.\n            bind_to (Optional[\"RabbitExchange\"], optional): Exchange to bind to. Defaults to None.\n            bind_arguments (Optional[AnyDict], optional): Arguments for the binding. Defaults to None.\n            routing_key (str, optional): Routing key for the exchange. Defaults to \"\".\n        Raises:\n            NotImplementedError:\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nsuper().__init__(\nname=name,\ntype=type.value,\ndurable=durable,\nauto_delete=auto_delete,\nrouting_key=routing_key,\nbind_to=bind_to,\nbind_arguments=bind_arguments,\nrobust=robust,\ninternal=internal,\npassive=passive,\ntimeout=timeout,\narguments=arguments,\n)\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/RabbitExchange/#faststream.rabbit.shared.schemas.RabbitExchange.arguments","title":"arguments  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>arguments: Optional[AnyDict] = None\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/RabbitExchange/#faststream.rabbit.shared.schemas.RabbitExchange.auto_delete","title":"auto_delete  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>auto_delete: bool = False\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/RabbitExchange/#faststream.rabbit.shared.schemas.RabbitExchange.bind_arguments","title":"bind_arguments  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bind_arguments: Optional[AnyDict] = None\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/RabbitExchange/#faststream.rabbit.shared.schemas.RabbitExchange.bind_to","title":"bind_to  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bind_to: Optional[RabbitExchange] = None\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/RabbitExchange/#faststream.rabbit.shared.schemas.RabbitExchange.durable","title":"durable  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>durable: bool = False\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/RabbitExchange/#faststream.rabbit.shared.schemas.RabbitExchange.internal","title":"internal  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>internal: bool = False\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/RabbitExchange/#faststream.rabbit.shared.schemas.RabbitExchange.passive","title":"passive  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>passive: bool = False\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/RabbitExchange/#faststream.rabbit.shared.schemas.RabbitExchange.robust","title":"robust  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>robust: bool = True\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/RabbitExchange/#faststream.rabbit.shared.schemas.RabbitExchange.routing_key","title":"routing_key  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>routing_key: str = ''\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/RabbitExchange/#faststream.rabbit.shared.schemas.RabbitExchange.timeout","title":"timeout  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>timeout: TimeoutType = None\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/RabbitExchange/#faststream.rabbit.shared.schemas.RabbitExchange.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>type: str = ExchangeType.DIRECT.value\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/RabbitQueue/","title":"RabbitQueue","text":""},{"location":"api/faststream/rabbit/shared/schemas/RabbitQueue/#faststream.rabbit.shared.schemas.RabbitQueue","title":"faststream.rabbit.shared.schemas.RabbitQueue","text":"<p>             Bases: <code>NameRequired</code></p> <p>A class to represent a RabbitMQ queue.</p> METHOD DESCRIPTION <code>__hash__ </code> <p>returns the hash value of the queue</p> <code>routing </code> <p>returns the routing key of the queue</p> <code>__init__ </code> <p>initializes the RabbitQueue object with the given parameters</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/shared/schemas.py</code> <pre><code>class RabbitQueue(NameRequired):\n\"\"\"A class to represent a RabbitMQ queue.\n    Attributes:\n        name : name of the queue\n        durable : whether the queue is durable or not\n        exclusive : whether the queue is exclusive or not\n        passive : whether the queue is passive or not\n        auto_delete : whether the queue is auto delete or not\n        arguments : additional arguments for the queue\n        timeout : timeout for the queue\n        robust : whether the queue is robust or not\n        routing_key : routing key for the queue\n        bind_arguments : additional arguments for binding the queue\n    Methods:\n        __hash__ : returns the hash value of the queue\n        routing : returns the routing key of the queue\n        __init__ : initializes the RabbitQueue object with the given parameters\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nname: str = \"\"\ndurable: bool = False\nexclusive: bool = False\npassive: bool = False\nauto_delete: bool = False\narguments: Optional[AnyDict] = None\ntimeout: TimeoutType = None\nrobust: bool = True\nrouting_key: str = \"\"\nbind_arguments: Optional[AnyDict] = None\ndef __hash__(self) -&gt; int:\nreturn sum(\n(\nhash(self.name),\nint(self.durable),\nint(self.exclusive),\nint(self.auto_delete),\n)\n)\n@property\ndef routing(self) -&gt; Optional[str]:\nreturn self.routing_key or self.name or None\ndef __init__(\nself,\nname: str,\ndurable: bool = False,\nexclusive: bool = False,\npassive: bool = False,\nauto_delete: bool = False,\narguments: Optional[AnyDict] = None,\ntimeout: TimeoutType = None,\nrobust: bool = True,\nbind_arguments: Optional[AnyDict] = None,\nrouting_key: str = \"\",\n):\n\"\"\"Initialize a class object.\n        Args:\n            name (str): The name of the object.\n            durable (bool, optional): Whether the object is durable. Defaults to False.\n            exclusive (bool, optional): Whether the object is exclusive. Defaults to False.\n            passive (bool, optional): Whether the object is passive. Defaults to False.\n            auto_delete (bool, optional): Whether the object is auto delete. Defaults to False.\n            arguments (dict, optional): Additional arguments for the object. Defaults to None.\n            timeout (TimeoutType, optional): Timeout for the object. Defaults to None.\n            robust (bool, optional): Whether the object is robust. Defaults to True.\n            bind_arguments (dict, optional): Bind arguments for the object. Defaults to None.\n            routing_key (str, optional): Routing key for the object. Defaults to \"\".\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nsuper().__init__(\nname=name,\ndurable=durable,\nexclusive=exclusive,\nbind_arguments=bind_arguments,\nrouting_key=routing_key,\nrobust=robust,\npassive=passive,\nauto_delete=auto_delete,\narguments=arguments,\ntimeout=timeout,\n)\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/RabbitQueue/#faststream.rabbit.shared.schemas.RabbitQueue.arguments","title":"arguments  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>arguments: Optional[AnyDict] = None\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/RabbitQueue/#faststream.rabbit.shared.schemas.RabbitQueue.auto_delete","title":"auto_delete  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>auto_delete: bool = False\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/RabbitQueue/#faststream.rabbit.shared.schemas.RabbitQueue.bind_arguments","title":"bind_arguments  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bind_arguments: Optional[AnyDict] = None\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/RabbitQueue/#faststream.rabbit.shared.schemas.RabbitQueue.durable","title":"durable  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>durable: bool = False\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/RabbitQueue/#faststream.rabbit.shared.schemas.RabbitQueue.exclusive","title":"exclusive  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>exclusive: bool = False\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/RabbitQueue/#faststream.rabbit.shared.schemas.RabbitQueue.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str = ''\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/RabbitQueue/#faststream.rabbit.shared.schemas.RabbitQueue.passive","title":"passive  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>passive: bool = False\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/RabbitQueue/#faststream.rabbit.shared.schemas.RabbitQueue.robust","title":"robust  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>robust: bool = True\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/RabbitQueue/#faststream.rabbit.shared.schemas.RabbitQueue.routing","title":"routing  <code>property</code>","text":"<pre><code>routing: Optional[str]\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/RabbitQueue/#faststream.rabbit.shared.schemas.RabbitQueue.routing_key","title":"routing_key  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>routing_key: str = ''\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/RabbitQueue/#faststream.rabbit.shared.schemas.RabbitQueue.timeout","title":"timeout  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>timeout: TimeoutType = None\n</code></pre>"},{"location":"api/faststream/rabbit/shared/schemas/get_routing_hash/","title":"Get routing hash","text":""},{"location":"api/faststream/rabbit/shared/schemas/get_routing_hash/#faststream.rabbit.shared.schemas.get_routing_hash","title":"faststream.rabbit.shared.schemas.get_routing_hash","text":"<pre><code>get_routing_hash(\nqueue: RabbitQueue,\nexchange: Optional[RabbitExchange] = None,\n) -&gt; int\n</code></pre> <p>Calculate the routing hash for a RabbitMQ queue and exchange.</p> PARAMETER  DESCRIPTION <code>queue</code> <p>The RabbitMQ queue.</p> <p> TYPE: <code>RabbitQueue</code> </p> <code>exchange</code> <p>The RabbitMQ exchange (optional).</p> <p> TYPE: <code>Optional[RabbitExchange]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>int</code> <p>The routing hash as an integer.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/shared/schemas.py</code> <pre><code>def get_routing_hash(\nqueue: RabbitQueue,\nexchange: Optional[RabbitExchange] = None,\n) -&gt; int:\n\"\"\"Calculate the routing hash for a RabbitMQ queue and exchange.\n    Args:\n        queue: The RabbitMQ queue.\n        exchange: The RabbitMQ exchange (optional).\n    Returns:\n        The routing hash as an integer.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nreturn hash(queue) + hash(exchange or \"\")\n</code></pre>"},{"location":"api/faststream/rabbit/test/FakeProducer/","title":"FakeProducer","text":""},{"location":"api/faststream/rabbit/test/FakeProducer/#faststream.rabbit.test.FakeProducer","title":"faststream.rabbit.test.FakeProducer","text":"<p>             Bases: <code>AioPikaFastProducer</code></p> <p>A fake RabbitMQ producer for testing purposes.</p> <p>This class extends AioPikaFastProducer and is used to simulate RabbitMQ message publishing during tests.</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/test.py</code> <pre><code>class FakeProducer(AioPikaFastProducer):\n\"\"\"\n    A fake RabbitMQ producer for testing purposes.\n    This class extends AioPikaFastProducer and is used to simulate RabbitMQ message publishing during tests.\n    \"\"\"\ndef __init__(self, broker: RabbitBroker):\n\"\"\"\n        Initialize a FakeProducer instance.\n        Args:\n            broker (RabbitBroker): The RabbitBroker instance to be used for message publishing.\n        \"\"\"\nself.broker = broker\nasync def publish(\nself,\nmessage: AioPikaSendableMessage = \"\",\nqueue: Union[RabbitQueue, str] = \"\",\nexchange: Union[RabbitExchange, str, None] = None,\n*,\nrouting_key: str = \"\",\nmandatory: bool = True,\nimmediate: bool = False,\ntimeout: TimeoutType = None,\nrpc: bool = False,\nrpc_timeout: Optional[float] = 30.0,\nraise_timeout: bool = False,\npersist: bool = False,\nreply_to: Optional[str] = None,\n**message_kwargs: Any,\n) -&gt; Optional[SendableMessage]:\n\"\"\"\n        Publish a message to a RabbitMQ queue or exchange.\n        Args:\n            message (AioPikaSendableMessage, optional): The message to be published.\n            queue (Union[RabbitQueue, str], optional): The target queue for the message.\n            exchange (Union[RabbitExchange, str, None], optional): The target exchange for the message.\n            routing_key (str, optional): The routing key for the message.\n            mandatory (bool, optional): Whether the message is mandatory.\n            immediate (bool, optional): Whether the message should be sent immediately.\n            timeout (TimeoutType, optional): The timeout for the message.\n            rpc (bool, optional): Whether the message is for RPC.\n            rpc_timeout (float, optional): The RPC timeout.\n            raise_timeout (bool, optional): Whether to raise a timeout exception.\n            persist (bool, optional): Whether to persist the message.\n            reply_to (str, optional): The reply-to address for RPC messages.\n            **message_kwargs (Any): Additional message properties and content.\n        Returns:\n            Optional[SendableMessage]: The published message if successful, or None if not.\n        \"\"\"\nexch = RabbitExchange.validate(exchange)\nincoming = build_message(\nmessage=message,\nqueue=queue,\nexchange=exch,\nrouting_key=routing_key,\nreply_to=reply_to,\n**message_kwargs,\n)\nfor handler in self.broker.handlers.values():  # pragma: no branch\nif handler.exchange == exch:\ncall: bool = False\nif (\nhandler.exchange is None\nor handler.exchange.type == ExchangeType.DIRECT\n):\ncall = handler.queue.name == incoming.routing_key\nelif handler.exchange.type == ExchangeType.FANOUT:\ncall = True\nelif handler.exchange.type == ExchangeType.TOPIC:\ncall = bool(\nre.match(\nhandler.queue.name.replace(\".\", r\"\\.\").replace(\"*\", \".*\"),\nincoming.routing_key or \"\",\n)\n)\nelif handler.exchange.type == ExchangeType.HEADERS:  # pramga: no branch\nqueue_headers = handler.queue.bind_arguments\nmsg_headers = incoming.headers\nif not queue_headers:\ncall = True\nelse:\nmatcher = queue_headers.pop(\"x-match\", \"all\")\nfull = True\nnone = True\nfor k, v in queue_headers.items():\nif msg_headers.get(k) != v:\nfull = False\nelse:\nnone = False\nif not none:\ncall = (matcher == \"any\") or full\nelse:  # pragma: no cover\nraise AssertionError(\"unreachable\")\nif call:\nr = await call_handler(\nhandler=handler,\nmessage=incoming,\nrpc=rpc,\nrpc_timeout=rpc_timeout,\nraise_timeout=raise_timeout,\n)\nif rpc:  # pragma: no branch\nreturn r\nreturn None\n</code></pre>"},{"location":"api/faststream/rabbit/test/FakeProducer/#faststream.rabbit.test.FakeProducer.broker","title":"broker  <code>instance-attribute</code>","text":"<pre><code>broker = broker\n</code></pre>"},{"location":"api/faststream/rabbit/test/FakeProducer/#faststream.rabbit.test.FakeProducer.publish","title":"publish  <code>async</code>","text":"<pre><code>publish(\nmessage: AioPikaSendableMessage = \"\",\nqueue: Union[RabbitQueue, str] = \"\",\nexchange: Union[RabbitExchange, str, None] = None,\n*,\nrouting_key: str = \"\",\nmandatory: bool = True,\nimmediate: bool = False,\ntimeout: TimeoutType = None,\nrpc: bool = False,\nrpc_timeout: Optional[float] = 30.0,\nraise_timeout: bool = False,\npersist: bool = False,\nreply_to: Optional[str] = None,\n**message_kwargs: Any\n) -&gt; Optional[SendableMessage]\n</code></pre> <p>Publish a message to a RabbitMQ queue or exchange.</p> PARAMETER  DESCRIPTION <code>message</code> <p>The message to be published.</p> <p> TYPE: <code>AioPikaSendableMessage</code> DEFAULT: <code>''</code> </p> <code>queue</code> <p>The target queue for the message.</p> <p> TYPE: <code>Union[RabbitQueue, str]</code> DEFAULT: <code>''</code> </p> <code>exchange</code> <p>The target exchange for the message.</p> <p> TYPE: <code>Union[RabbitExchange, str, None]</code> DEFAULT: <code>None</code> </p> <code>routing_key</code> <p>The routing key for the message.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>mandatory</code> <p>Whether the message is mandatory.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>immediate</code> <p>Whether the message should be sent immediately.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>timeout</code> <p>The timeout for the message.</p> <p> TYPE: <code>TimeoutType</code> DEFAULT: <code>None</code> </p> <code>rpc</code> <p>Whether the message is for RPC.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>rpc_timeout</code> <p>The RPC timeout.</p> <p> TYPE: <code>float</code> DEFAULT: <code>30.0</code> </p> <code>raise_timeout</code> <p>Whether to raise a timeout exception.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>persist</code> <p>Whether to persist the message.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>reply_to</code> <p>The reply-to address for RPC messages.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>**message_kwargs</code> <p>Additional message properties and content.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Optional[SendableMessage]</code> <p>Optional[SendableMessage]: The published message if successful, or None if not.</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/test.py</code> <pre><code>async def publish(\nself,\nmessage: AioPikaSendableMessage = \"\",\nqueue: Union[RabbitQueue, str] = \"\",\nexchange: Union[RabbitExchange, str, None] = None,\n*,\nrouting_key: str = \"\",\nmandatory: bool = True,\nimmediate: bool = False,\ntimeout: TimeoutType = None,\nrpc: bool = False,\nrpc_timeout: Optional[float] = 30.0,\nraise_timeout: bool = False,\npersist: bool = False,\nreply_to: Optional[str] = None,\n**message_kwargs: Any,\n) -&gt; Optional[SendableMessage]:\n\"\"\"\n    Publish a message to a RabbitMQ queue or exchange.\n    Args:\n        message (AioPikaSendableMessage, optional): The message to be published.\n        queue (Union[RabbitQueue, str], optional): The target queue for the message.\n        exchange (Union[RabbitExchange, str, None], optional): The target exchange for the message.\n        routing_key (str, optional): The routing key for the message.\n        mandatory (bool, optional): Whether the message is mandatory.\n        immediate (bool, optional): Whether the message should be sent immediately.\n        timeout (TimeoutType, optional): The timeout for the message.\n        rpc (bool, optional): Whether the message is for RPC.\n        rpc_timeout (float, optional): The RPC timeout.\n        raise_timeout (bool, optional): Whether to raise a timeout exception.\n        persist (bool, optional): Whether to persist the message.\n        reply_to (str, optional): The reply-to address for RPC messages.\n        **message_kwargs (Any): Additional message properties and content.\n    Returns:\n        Optional[SendableMessage]: The published message if successful, or None if not.\n    \"\"\"\nexch = RabbitExchange.validate(exchange)\nincoming = build_message(\nmessage=message,\nqueue=queue,\nexchange=exch,\nrouting_key=routing_key,\nreply_to=reply_to,\n**message_kwargs,\n)\nfor handler in self.broker.handlers.values():  # pragma: no branch\nif handler.exchange == exch:\ncall: bool = False\nif (\nhandler.exchange is None\nor handler.exchange.type == ExchangeType.DIRECT\n):\ncall = handler.queue.name == incoming.routing_key\nelif handler.exchange.type == ExchangeType.FANOUT:\ncall = True\nelif handler.exchange.type == ExchangeType.TOPIC:\ncall = bool(\nre.match(\nhandler.queue.name.replace(\".\", r\"\\.\").replace(\"*\", \".*\"),\nincoming.routing_key or \"\",\n)\n)\nelif handler.exchange.type == ExchangeType.HEADERS:  # pramga: no branch\nqueue_headers = handler.queue.bind_arguments\nmsg_headers = incoming.headers\nif not queue_headers:\ncall = True\nelse:\nmatcher = queue_headers.pop(\"x-match\", \"all\")\nfull = True\nnone = True\nfor k, v in queue_headers.items():\nif msg_headers.get(k) != v:\nfull = False\nelse:\nnone = False\nif not none:\ncall = (matcher == \"any\") or full\nelse:  # pragma: no cover\nraise AssertionError(\"unreachable\")\nif call:\nr = await call_handler(\nhandler=handler,\nmessage=incoming,\nrpc=rpc,\nrpc_timeout=rpc_timeout,\nraise_timeout=raise_timeout,\n)\nif rpc:  # pragma: no branch\nreturn r\nreturn None\n</code></pre>"},{"location":"api/faststream/rabbit/test/PatchedMessage/","title":"PatchedMessage","text":""},{"location":"api/faststream/rabbit/test/PatchedMessage/#faststream.rabbit.test.PatchedMessage","title":"faststream.rabbit.test.PatchedMessage","text":"<p>             Bases: <code>IncomingMessage</code></p> <p>Patched message class for testing purposes.</p> <p>This class extends aio_pika's IncomingMessage class and is used to simulate RabbitMQ message handling during tests.</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/test.py</code> <pre><code>class PatchedMessage(IncomingMessage):\n\"\"\"\n    Patched message class for testing purposes.\n    This class extends aio_pika's IncomingMessage class and is used to simulate RabbitMQ message handling during tests.\n    \"\"\"\nasync def ack(self, multiple: bool = False) -&gt; None:\n\"\"\"Asynchronously acknowledge a message.\n        Args:\n            multiple (bool, optional): Whether to acknowledge multiple messages at once. Defaults to False.\n        Returns:\n            None\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\npass\nasync def nack(self, multiple: bool = False, requeue: bool = True) -&gt; None:\n\"\"\"Nack the message.\n        Args:\n            multiple: Whether to nack multiple messages. Default is False.\n            requeue: Whether to requeue the message. Default is True.\n        Returns:\n            None\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\npass\nasync def reject(self, requeue: bool = False) -&gt; None:\n\"\"\"Rejects a task.\n        Args:\n            requeue: Whether to requeue the task if it fails (default: False)\n        Returns:\n            None\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\npass\n</code></pre>"},{"location":"api/faststream/rabbit/test/PatchedMessage/#faststream.rabbit.test.PatchedMessage.ack","title":"ack  <code>async</code>","text":"<pre><code>ack(multiple: bool = False) -&gt; None\n</code></pre> <p>Asynchronously acknowledge a message.</p> PARAMETER  DESCRIPTION <code>multiple</code> <p>Whether to acknowledge multiple messages at once. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/test.py</code> <pre><code>async def ack(self, multiple: bool = False) -&gt; None:\n\"\"\"Asynchronously acknowledge a message.\n    Args:\n        multiple (bool, optional): Whether to acknowledge multiple messages at once. Defaults to False.\n    Returns:\n        None\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\npass\n</code></pre>"},{"location":"api/faststream/rabbit/test/PatchedMessage/#faststream.rabbit.test.PatchedMessage.nack","title":"nack  <code>async</code>","text":"<pre><code>nack(multiple: bool = False, requeue: bool = True) -&gt; None\n</code></pre> <p>Nack the message.</p> PARAMETER  DESCRIPTION <code>multiple</code> <p>Whether to nack multiple messages. Default is False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>requeue</code> <p>Whether to requeue the message. Default is True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/test.py</code> <pre><code>async def nack(self, multiple: bool = False, requeue: bool = True) -&gt; None:\n\"\"\"Nack the message.\n    Args:\n        multiple: Whether to nack multiple messages. Default is False.\n        requeue: Whether to requeue the message. Default is True.\n    Returns:\n        None\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\npass\n</code></pre>"},{"location":"api/faststream/rabbit/test/PatchedMessage/#faststream.rabbit.test.PatchedMessage.reject","title":"reject  <code>async</code>","text":"<pre><code>reject(requeue: bool = False) -&gt; None\n</code></pre> <p>Rejects a task.</p> PARAMETER  DESCRIPTION <code>requeue</code> <p>Whether to requeue the task if it fails (default: False)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/test.py</code> <pre><code>async def reject(self, requeue: bool = False) -&gt; None:\n\"\"\"Rejects a task.\n    Args:\n        requeue: Whether to requeue the task if it fails (default: False)\n    Returns:\n        None\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\npass\n</code></pre>"},{"location":"api/faststream/rabbit/test/TestRabbitBroker/","title":"TestRabbitBroker","text":""},{"location":"api/faststream/rabbit/test/TestRabbitBroker/#faststream.rabbit.test.TestRabbitBroker","title":"faststream.rabbit.test.TestRabbitBroker","text":"<p>A context manager for creating a test RabbitBroker instance with optional mocking.</p> <p>This class is designed to be used as a context manager for creating a RabbitBroker instance, optionally replacing some of its components with mocks for testing purposes. If the <code>with_real</code> attribute is set to True, it operates as a pass-through context manager, returning the original RabbitBroker instance without any modifications. If <code>with_real</code> is set to False, it replaces certain components like the channel, declarer, and start/connect/close methods with mock objects to isolate the broker for testing.</p> PARAMETER  DESCRIPTION <code>broker</code> <p>The RabbitBroker instance to be used in testing.</p> <p> TYPE: <code>RabbitBroker</code> </p> <code>with_real</code> <p>If True, the original broker is returned; if False, components are replaced with mock objects. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> METHOD DESCRIPTION <code>__aenter__</code> <p>Enter the context and return the RabbitBroker instance.</p> <code>__aexit__</code> <p>Any) -&gt; None: Exit the context.</p> <p>Example usage:</p> <pre><code>real_broker = RabbitBroker()\nwith TestRabbitBroker(real_broker, with_real=True) as broker:\n# Use the real RabbitBroker instance for testing.\nwith TestRabbitBroker(real_broker, with_real=False) as broker:\n# Use a mocked RabbitBroker instance for testing.\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/test.py</code> <pre><code>class TestRabbitBroker:\n\"\"\"\n    A context manager for creating a test RabbitBroker instance with optional mocking.\n    This class is designed to be used as a context manager for creating a RabbitBroker instance, optionally replacing some\n    of its components with mocks for testing purposes. If the `with_real` attribute is set to True, it operates as a\n    pass-through context manager, returning the original RabbitBroker instance without any modifications. If `with_real`\n    is set to False, it replaces certain components like the channel, declarer, and start/connect/close methods with mock\n    objects to isolate the broker for testing.\n    Args:\n        broker (RabbitBroker): The RabbitBroker instance to be used in testing.\n        with_real (bool, optional): If True, the original broker is returned; if False, components are replaced with\n            mock objects. Defaults to False.\n    Attributes:\n        broker (RabbitBroker): The RabbitBroker instance provided for testing.\n        with_real (bool): A boolean flag indicating whether to use the original broker (True) or replace components with\n            mocks (False).\n    Methods:\n        __aenter__(self) -&gt; RabbitBroker:\n            Enter the context and return the RabbitBroker instance.\n        __aexit__(self, *args: Any) -&gt; None:\n            Exit the context.\n    Example usage:\n    ```python\n    real_broker = RabbitBroker()\n    with TestRabbitBroker(real_broker, with_real=True) as broker:\n        # Use the real RabbitBroker instance for testing.\n    with TestRabbitBroker(real_broker, with_real=False) as broker:\n        # Use a mocked RabbitBroker instance for testing.\n    ```\n    \"\"\"\n# This is set so pytest ignores this class\n__test__ = False\ndef __init__(self, broker: RabbitBroker, with_real: bool = False):\n\"\"\"\n        Initialize a TestRabbitBroker instance.\n        Args:\n            broker (RabbitBroker): The RabbitBroker instance to be used in testing.\n            with_real (bool, optional): If True, the original broker is returned; if False, components are replaced with\n                mock objects. Defaults to False.\n        \"\"\"\nself.with_real = with_real\nself.broker = broker\n@asynccontextmanager\nasync def _create_ctx(self) -&gt; AsyncGenerator[RabbitBroker, None]:\n\"\"\"\n        Create the context for the context manager.\n        Yields:\n            RabbitBroker: The RabbitBroker instance for testing, either with or without mocks.\n        \"\"\"\nif not self.with_real:\nself.broker._channel = AsyncMock()\nself.broker.declarer = AsyncMock()\nself.broker.start = AsyncMock(wraps=partial(_fake_start, self.broker))  # type: ignore[method-assign]\nself.broker._connect = MethodType(_fake_connect, self.broker)  # type: ignore[method-assign]\nself.broker.close = AsyncMock()  # type: ignore[method-assign]\nelse:\n_fake_start(self.broker)\nasync with self.broker:\ntry:\nawait self.broker.start()\nyield self.broker\nfinally:\n_fake_close(self.broker)\nasync def __aenter__(self) -&gt; RabbitBroker:\n\"\"\"\n        Enter the context and return the RabbitBroker instance.\n        Returns:\n            RabbitBroker: The RabbitBroker instance for testing, either with or without mocks.\n        \"\"\"\nself._ctx = self._create_ctx()\nreturn await self._ctx.__aenter__()\nasync def __aexit__(self, *args: Any) -&gt; None:\n\"\"\"\n        Exit the context.\n        Args:\n            *args: Variable-length argument list.\n        \"\"\"\nawait self._ctx.__aexit__(*args)\n</code></pre>"},{"location":"api/faststream/rabbit/test/TestRabbitBroker/#faststream.rabbit.test.TestRabbitBroker.broker","title":"broker  <code>instance-attribute</code>","text":"<pre><code>broker = broker\n</code></pre>"},{"location":"api/faststream/rabbit/test/TestRabbitBroker/#faststream.rabbit.test.TestRabbitBroker.with_real","title":"with_real  <code>instance-attribute</code>","text":"<pre><code>with_real = with_real\n</code></pre>"},{"location":"api/faststream/rabbit/test/build_message/","title":"Build message","text":""},{"location":"api/faststream/rabbit/test/build_message/#faststream.rabbit.test.build_message","title":"faststream.rabbit.test.build_message","text":"<pre><code>build_message(\nmessage: AioPikaSendableMessage = \"\",\nqueue: Union[RabbitQueue, str] = \"\",\nexchange: Union[RabbitExchange, str, None] = None,\n*,\nrouting_key: str = \"\",\nreply_to: Optional[str] = None,\n**message_kwargs: Any\n) -&gt; PatchedMessage\n</code></pre> <p>Build a patched RabbitMQ message for testing.</p> PARAMETER  DESCRIPTION <code>message</code> <p>The message content.</p> <p> TYPE: <code>AioPikaSendableMessage</code> DEFAULT: <code>''</code> </p> <code>queue</code> <p>The message queue.</p> <p> TYPE: <code>Union[RabbitQueue, str]</code> DEFAULT: <code>''</code> </p> <code>exchange</code> <p>The message exchange.</p> <p> TYPE: <code>Union[RabbitExchange, str, None]</code> DEFAULT: <code>None</code> </p> <code>routing_key</code> <p>The message routing key.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>reply_to</code> <p>The reply-to queue.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>**message_kwargs</code> <p>Additional message arguments.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>PatchedMessage</code> <p>A patched RabbitMQ message.</p> <p> TYPE: <code>PatchedMessage</code> </p> Source code in <code>/home/runner/work/faststream/faststream/faststream/rabbit/test.py</code> <pre><code>def build_message(\nmessage: AioPikaSendableMessage = \"\",\nqueue: Union[RabbitQueue, str] = \"\",\nexchange: Union[RabbitExchange, str, None] = None,\n*,\nrouting_key: str = \"\",\nreply_to: Optional[str] = None,\n**message_kwargs: Any,\n) -&gt; PatchedMessage:\n\"\"\"\n    Build a patched RabbitMQ message for testing.\n    Args:\n        message (AioPikaSendableMessage): The message content.\n        queue (Union[RabbitQueue, str]): The message queue.\n        exchange (Union[RabbitExchange, str, None]): The message exchange.\n        routing_key (str): The message routing key.\n        reply_to (Optional[str]): The reply-to queue.\n        **message_kwargs (Any): Additional message arguments.\n    Returns:\n        PatchedMessage: A patched RabbitMQ message.\n    \"\"\"\nque = RabbitQueue.validate(queue)\nexch = RabbitExchange.validate(exchange)\nmsg = AioPikaParser.encode_message(\nmessage=message,\npersist=False,\nreply_to=reply_to,\ncallback_queue=None,\n**message_kwargs,\n)\nrouting = routing_key or (que.name if que else \"\")\nreturn PatchedMessage(\naiormq.abc.DeliveredMessage(\ndelivery=spec.Basic.Deliver(\nexchange=exch.name if exch and exch.name else \"\",\nrouting_key=routing,\n),\nheader=ContentHeader(\nproperties=spec.Basic.Properties(\ncontent_type=msg.content_type,\nmessage_id=str(uuid4()),\nheaders=msg.headers,\nreply_to=reply_to,\n)\n),\nbody=msg.body,\nchannel=AsyncMock(),\n)\n)\n</code></pre>"},{"location":"api/faststream/utils/classes/Singleton/","title":"Singleton","text":""},{"location":"api/faststream/utils/classes/Singleton/#faststream.utils.classes.Singleton","title":"faststream.utils.classes.Singleton","text":"<p>A class to implement the Singleton design pattern.</p> METHOD DESCRIPTION <code>__new__ </code> <p>creates a new instance of the class if it doesn't exist, otherwise returns the existing instance</p> <code>_drop </code> <p>sets the instance to None, allowing a new instance to be created</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/utils/classes.py</code> <pre><code>class Singleton:\n\"\"\"A class to implement the Singleton design pattern.\n    Attributes:\n        _instance : the single instance of the class\n    Methods:\n        __new__ : creates a new instance of the class if it doesn't exist, otherwise returns the existing instance\n        _drop : sets the instance to None, allowing a new instance to be created\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n_instance = None\ndef __new__(cls, *args: Any, **kwargs: Any) -&gt; \"Singleton\":\n\"\"\"Create a singleton instance of a class.\n        Args:\n            *args: Variable length argument list\n            **kwargs: Arbitrary keyword arguments\n        Returns:\n            The singleton instance of the class\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nif cls._instance is None:\ncls._instance = super().__new__(cls)\nreturn cls._instance\n@classmethod\ndef _drop(cls) -&gt; None:\n\"\"\"Drop the instance of a class.\n        Returns:\n            None\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\ncls._instance = None\n</code></pre>"},{"location":"api/faststream/utils/context/main/ContextRepo/","title":"ContextRepo","text":""},{"location":"api/faststream/utils/context/main/ContextRepo/#faststream.utils.context.main.ContextRepo","title":"faststream.utils.context.main.ContextRepo","text":"<p>             Bases: <code>Singleton</code></p> <p>A class to represent a context repository.</p> METHOD DESCRIPTION <code>__init__ </code> <p>initializes the ContextRepo object</p> <code>set_global </code> <p>sets a global context variable</p> <code>reset_global </code> <p>resets a global context variable</p> <code>set_local </code> <p>sets a local context variable</p> <code>reset_local </code> <p>resets a local context variable</p> <code>get_local </code> <p>gets the value of a local context variable</p> <code>clear </code> <p>clears the global and scope context</p> <code>get </code> <p>gets the value of a context variable</p> <code>__getattr__ </code> <p>gets the value of a context variable using attribute access</p> <code>context </code> <p>gets the current context as a dictionary</p> <code>scope </code> <p>creates a context scope for a specific key and value</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/utils/context/main.py</code> <pre><code>class ContextRepo(Singleton):\n\"\"\"A class to represent a context repository.\n    Attributes:\n        _global_context : dictionary representing the global context\n        _scope_context : dictionary representing the scope context\n    Methods:\n        __init__ : initializes the ContextRepo object\n        set_global : sets a global context variable\n        reset_global : resets a global context variable\n        set_local : sets a local context variable\n        reset_local : resets a local context variable\n        get_local : gets the value of a local context variable\n        clear : clears the global and scope context\n        get : gets the value of a context variable\n        __getattr__ : gets the value of a context variable using attribute access\n        context : gets the current context as a dictionary\n        scope : creates a context scope for a specific key and value\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n_global_context: AnyDict\n_scope_context: Dict[str, ContextVar[Any]]\ndef __init__(self) -&gt; None:\n\"\"\"Initialize the class.\n        Attributes:\n            _global_context : a dictionary representing the global context\n            _scope_context : a dictionary representing the scope context\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nself._global_context = {\"context\": self}\nself._scope_context = {}\ndef set_global(self, key: str, v: Any) -&gt; None:\n\"\"\"Sets a value in the global context.\n        Args:\n            key: The key to set in the global context.\n            v: The value to set.\n        Returns:\n            None.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nself._global_context[key] = v\ndef reset_global(self, key: str) -&gt; None:\n\"\"\"Resets a key in the global context.\n        Args:\n            key (str): The key to reset in the global context.\n        Returns:\n            None\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nself._global_context.pop(key, None)\ndef set_local(self, key: str, value: T) -&gt; \"Token[T]\":\n\"\"\"Set a local context variable.\n        Args:\n            key (str): The key for the context variable.\n            value (T): The value to set for the context variable.\n        Returns:\n            Token[T]: A token representing the context variable.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\ncontext_var = self._scope_context.get(key)\nif context_var is None:\ncontext_var = ContextVar(key, default=None)\nself._scope_context[key] = context_var\nreturn context_var.set(value)\ndef reset_local(self, key: str, tag: \"Token[Any]\") -&gt; None:\n\"\"\"Resets the local context for a given key.\n        Args:\n            key (str): The key to reset the local context for.\n            tag (Token[Any]): The tag associated with the local context.\n        Returns:\n            None\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nself._scope_context[key].reset(tag)\ndef get_local(self, key: str) -&gt; Any:\n\"\"\"Get the value of a local variable.\n        Args:\n            key: The key of the local variable to retrieve.\n        Returns:\n            The value of the local variable.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\ncontext_var = self._scope_context.get(key)\nif context_var is not None:  # pragma: no branch\nreturn context_var.get()\ndef clear(self) -&gt; None:\nself._global_context = {\"context\": self}\nself._scope_context = {}\ndef get(self, key: str) -&gt; Any:\n\"\"\"Get the value associated with a key.\n        Args:\n            key: The key to retrieve the value for.\n        Returns:\n            The value associated with the key.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nreturn self._global_context.get(key, self.get_local(key))\ndef __getattr__(self, __name: str) -&gt; Any:\n\"\"\"This is a function that is part of a class. It is used to get an attribute value using the `__getattr__` method.\n        Args:\n            __name: The name of the attribute to get.\n        Returns:\n            The value of the attribute.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nreturn self.get(__name)\n@property\ndef context(self) -&gt; AnyDict:\nreturn {\n**self._global_context,\n**{i: j.get() for i, j in self._scope_context.items()},\n}\n@contextmanager\ndef scope(self, key: str, value: Any) -&gt; Iterator[None]:\n\"\"\"Sets a local variable and yields control to the caller. After the caller is done, the local variable is reset.\n        Args:\n            key: The key of the local variable\n            value: The value to set the local variable to\n        Yields:\n            None\n        Returns:\n            An iterator that yields None\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\ntoken = self.set_local(key, value)\ntry:\nyield\nfinally:\nself.reset_local(key, token)\n</code></pre>"},{"location":"api/faststream/utils/context/main/ContextRepo/#faststream.utils.context.main.ContextRepo.context","title":"context  <code>property</code>","text":"<pre><code>context: AnyDict\n</code></pre>"},{"location":"api/faststream/utils/context/main/ContextRepo/#faststream.utils.context.main.ContextRepo.clear","title":"clear","text":"<pre><code>clear() -&gt; None\n</code></pre> Source code in <code>/home/runner/work/faststream/faststream/faststream/utils/context/main.py</code> <pre><code>def clear(self) -&gt; None:\nself._global_context = {\"context\": self}\nself._scope_context = {}\n</code></pre>"},{"location":"api/faststream/utils/context/main/ContextRepo/#faststream.utils.context.main.ContextRepo.get","title":"get","text":"<pre><code>get(key: str) -&gt; Any\n</code></pre> <p>Get the value associated with a key.</p> PARAMETER  DESCRIPTION <code>key</code> <p>The key to retrieve the value for.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Any</code> <p>The value associated with the key.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/utils/context/main.py</code> <pre><code>def get(self, key: str) -&gt; Any:\n\"\"\"Get the value associated with a key.\n    Args:\n        key: The key to retrieve the value for.\n    Returns:\n        The value associated with the key.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nreturn self._global_context.get(key, self.get_local(key))\n</code></pre>"},{"location":"api/faststream/utils/context/main/ContextRepo/#faststream.utils.context.main.ContextRepo.get_local","title":"get_local","text":"<pre><code>get_local(key: str) -&gt; Any\n</code></pre> <p>Get the value of a local variable.</p> PARAMETER  DESCRIPTION <code>key</code> <p>The key of the local variable to retrieve.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Any</code> <p>The value of the local variable.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/utils/context/main.py</code> <pre><code>def get_local(self, key: str) -&gt; Any:\n\"\"\"Get the value of a local variable.\n    Args:\n        key: The key of the local variable to retrieve.\n    Returns:\n        The value of the local variable.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\ncontext_var = self._scope_context.get(key)\nif context_var is not None:  # pragma: no branch\nreturn context_var.get()\n</code></pre>"},{"location":"api/faststream/utils/context/main/ContextRepo/#faststream.utils.context.main.ContextRepo.reset_global","title":"reset_global","text":"<pre><code>reset_global(key: str) -&gt; None\n</code></pre> <p>Resets a key in the global context.</p> PARAMETER  DESCRIPTION <code>key</code> <p>The key to reset in the global context.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/utils/context/main.py</code> <pre><code>def reset_global(self, key: str) -&gt; None:\n\"\"\"Resets a key in the global context.\n    Args:\n        key (str): The key to reset in the global context.\n    Returns:\n        None\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nself._global_context.pop(key, None)\n</code></pre>"},{"location":"api/faststream/utils/context/main/ContextRepo/#faststream.utils.context.main.ContextRepo.reset_local","title":"reset_local","text":"<pre><code>reset_local(key: str, tag: Token[Any]) -&gt; None\n</code></pre> <p>Resets the local context for a given key.</p> PARAMETER  DESCRIPTION <code>key</code> <p>The key to reset the local context for.</p> <p> TYPE: <code>str</code> </p> <code>tag</code> <p>The tag associated with the local context.</p> <p> TYPE: <code>Token[Any]</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/utils/context/main.py</code> <pre><code>def reset_local(self, key: str, tag: \"Token[Any]\") -&gt; None:\n\"\"\"Resets the local context for a given key.\n    Args:\n        key (str): The key to reset the local context for.\n        tag (Token[Any]): The tag associated with the local context.\n    Returns:\n        None\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nself._scope_context[key].reset(tag)\n</code></pre>"},{"location":"api/faststream/utils/context/main/ContextRepo/#faststream.utils.context.main.ContextRepo.scope","title":"scope","text":"<pre><code>scope(key: str, value: Any) -&gt; Iterator[None]\n</code></pre> <p>Sets a local variable and yields control to the caller. After the caller is done, the local variable is reset.</p> PARAMETER  DESCRIPTION <code>key</code> <p>The key of the local variable</p> <p> TYPE: <code>str</code> </p> <code>value</code> <p>The value to set the local variable to</p> <p> TYPE: <code>Any</code> </p> YIELDS DESCRIPTION <code>Iterator[None]</code> <p>None</p> RETURNS DESCRIPTION <code>Iterator[None]</code> <p>An iterator that yields None</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/utils/context/main.py</code> <pre><code>@contextmanager\ndef scope(self, key: str, value: Any) -&gt; Iterator[None]:\n\"\"\"Sets a local variable and yields control to the caller. After the caller is done, the local variable is reset.\n    Args:\n        key: The key of the local variable\n        value: The value to set the local variable to\n    Yields:\n        None\n    Returns:\n        An iterator that yields None\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\ntoken = self.set_local(key, value)\ntry:\nyield\nfinally:\nself.reset_local(key, token)\n</code></pre>"},{"location":"api/faststream/utils/context/main/ContextRepo/#faststream.utils.context.main.ContextRepo.set_global","title":"set_global","text":"<pre><code>set_global(key: str, v: Any) -&gt; None\n</code></pre> <p>Sets a value in the global context.</p> PARAMETER  DESCRIPTION <code>key</code> <p>The key to set in the global context.</p> <p> TYPE: <code>str</code> </p> <code>v</code> <p>The value to set.</p> <p> TYPE: <code>Any</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/utils/context/main.py</code> <pre><code>def set_global(self, key: str, v: Any) -&gt; None:\n\"\"\"Sets a value in the global context.\n    Args:\n        key: The key to set in the global context.\n        v: The value to set.\n    Returns:\n        None.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nself._global_context[key] = v\n</code></pre>"},{"location":"api/faststream/utils/context/main/ContextRepo/#faststream.utils.context.main.ContextRepo.set_local","title":"set_local","text":"<pre><code>set_local(key: str, value: T) -&gt; Token[T]\n</code></pre> <p>Set a local context variable.</p> PARAMETER  DESCRIPTION <code>key</code> <p>The key for the context variable.</p> <p> TYPE: <code>str</code> </p> <code>value</code> <p>The value to set for the context variable.</p> <p> TYPE: <code>T</code> </p> RETURNS DESCRIPTION <code>Token[T]</code> <p>Token[T]: A token representing the context variable.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/utils/context/main.py</code> <pre><code>def set_local(self, key: str, value: T) -&gt; \"Token[T]\":\n\"\"\"Set a local context variable.\n    Args:\n        key (str): The key for the context variable.\n        value (T): The value to set for the context variable.\n    Returns:\n        Token[T]: A token representing the context variable.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\ncontext_var = self._scope_context.get(key)\nif context_var is None:\ncontext_var = ContextVar(key, default=None)\nself._scope_context[key] = context_var\nreturn context_var.set(value)\n</code></pre>"},{"location":"api/faststream/utils/context/types/Context/","title":"Context","text":""},{"location":"api/faststream/utils/context/types/Context/#faststream.utils.context.types.Context","title":"faststream.utils.context.types.Context","text":"<p>             Bases: <code>CustomField</code></p> <p>A class to represent a context.</p> METHOD DESCRIPTION <code>__init__ </code> <p>constructor method</p> <code>use </code> <p>method to use the context</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/utils/context/types.py</code> <pre><code>class Context(CustomField):\n\"\"\"A class to represent a context.\n    Attributes:\n        param_name : name of the parameter\n    Methods:\n        __init__ : constructor method\n        use : method to use the context\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nparam_name: str\ndef __init__(\nself,\nreal_name: str = \"\",\n*,\ncast: bool = False,\ndefault: Any = _empty,\n):\n\"\"\"Initialize the object.\n        Args:\n            real_name: The real name of the object.\n            cast: Whether to cast the object.\n            default: The default value of the object.\n        Raises:\n            TypeError: If the default value is not provided.\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nself.name = real_name\nself.default = default\nsuper().__init__(\ncast=cast,\nrequired=(default is _empty),\n)\ndef use(self, **kwargs: Any) -&gt; AnyDict:\n\"\"\"Use the given keyword arguments.\n        Args:\n            **kwargs: Keyword arguments to be used\n        Returns:\n            A dictionary containing the updated keyword arguments\n        Raises:\n            KeyError: If the parameter name is not found in the keyword arguments\n            AttributeError: If the parameter name is not a valid attribute\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nname = self.name or self.param_name\ntry:\nkwargs[self.param_name] = resolve_context(name)\nexcept (KeyError, AttributeError):\nif self.required is False:\nkwargs[self.param_name] = self.default\nreturn kwargs\n</code></pre>"},{"location":"api/faststream/utils/context/types/Context/#faststream.utils.context.types.Context.default","title":"default  <code>instance-attribute</code>","text":"<pre><code>default = default\n</code></pre>"},{"location":"api/faststream/utils/context/types/Context/#faststream.utils.context.types.Context.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name = real_name\n</code></pre>"},{"location":"api/faststream/utils/context/types/Context/#faststream.utils.context.types.Context.param_name","title":"param_name  <code>instance-attribute</code>","text":"<pre><code>param_name: str\n</code></pre>"},{"location":"api/faststream/utils/context/types/Context/#faststream.utils.context.types.Context.use","title":"use","text":"<pre><code>use(**kwargs: Any) -&gt; AnyDict\n</code></pre> <p>Use the given keyword arguments.</p> PARAMETER  DESCRIPTION <code>**kwargs</code> <p>Keyword arguments to be used</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>AnyDict</code> <p>A dictionary containing the updated keyword arguments</p> RAISES DESCRIPTION <code>KeyError</code> <p>If the parameter name is not found in the keyword arguments</p> <code>AttributeError</code> <p>If the parameter name is not a valid attribute</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/utils/context/types.py</code> <pre><code>def use(self, **kwargs: Any) -&gt; AnyDict:\n\"\"\"Use the given keyword arguments.\n    Args:\n        **kwargs: Keyword arguments to be used\n    Returns:\n        A dictionary containing the updated keyword arguments\n    Raises:\n        KeyError: If the parameter name is not found in the keyword arguments\n        AttributeError: If the parameter name is not a valid attribute\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nname = self.name or self.param_name\ntry:\nkwargs[self.param_name] = resolve_context(name)\nexcept (KeyError, AttributeError):\nif self.required is False:\nkwargs[self.param_name] = self.default\nreturn kwargs\n</code></pre>"},{"location":"api/faststream/utils/context/types/resolve_context/","title":"Resolve context","text":""},{"location":"api/faststream/utils/context/types/resolve_context/#faststream.utils.context.types.resolve_context","title":"faststream.utils.context.types.resolve_context","text":"<pre><code>resolve_context(argument: str) -&gt; Any\n</code></pre> <p>Resolve the context of an argument.</p> PARAMETER  DESCRIPTION <code>argument</code> <p>A string representing the argument.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Any</code> <p>The resolved context of the argument.</p> RAISES DESCRIPTION <code>AttributeError</code> <p>If the attribute does not exist in the context.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/utils/context/types.py</code> <pre><code>def resolve_context(argument: str) -&gt; Any:\n\"\"\"Resolve the context of an argument.\n    Args:\n        argument: A string representing the argument.\n    Returns:\n        The resolved context of the argument.\n    Raises:\n        AttributeError: If the attribute does not exist in the context.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nkeys = argument.split(\".\")\nv = context.context[keys[0]]\nfor i in keys[1:]:\nv = getattr(v, i)\nreturn v\n</code></pre>"},{"location":"api/faststream/utils/data/filter_by_dict/","title":"Filter by dict","text":""},{"location":"api/faststream/utils/data/filter_by_dict/#faststream.utils.data.filter_by_dict","title":"faststream.utils.data.filter_by_dict","text":"<pre><code>filter_by_dict(\ntyped_dict: Type[TypedDictCls], data: AnyDict\n) -&gt; TypedDictCls\n</code></pre> <p>Filter a dictionary based on a typed dictionary.</p> PARAMETER  DESCRIPTION <code>typed_dict</code> <p>The typed dictionary to filter by.</p> <p> TYPE: <code>Type[TypedDictCls]</code> </p> <code>data</code> <p>The dictionary to filter.</p> <p> TYPE: <code>AnyDict</code> </p> RETURNS DESCRIPTION <code>TypedDictCls</code> <p>A new instance of the typed dictionary with only the keys present in the data dictionary.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/utils/data.py</code> <pre><code>def filter_by_dict(typed_dict: Type[TypedDictCls], data: AnyDict) -&gt; TypedDictCls:\n\"\"\"Filter a dictionary based on a typed dictionary.\n    Args:\n        typed_dict: The typed dictionary to filter by.\n        data: The dictionary to filter.\n    Returns:\n        A new instance of the typed dictionary with only the keys present in the data dictionary.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nannotations = typed_dict.__annotations__\nreturn typed_dict(  # type: ignore\n{k: v for k, v in data.items() if k in annotations}\n)\n</code></pre>"},{"location":"api/faststream/utils/functions/get_function_positional_arguments/","title":"Get function positional arguments","text":""},{"location":"api/faststream/utils/functions/get_function_positional_arguments/#faststream.utils.functions.get_function_positional_arguments","title":"faststream.utils.functions.get_function_positional_arguments","text":"<pre><code>get_function_positional_arguments(\nfunc: AnyCallable,\n) -&gt; List[str]\n</code></pre> <p>Get the positional arguments of a function.</p> PARAMETER  DESCRIPTION <code>func</code> <p>The function to get the positional arguments from.</p> <p> TYPE: <code>AnyCallable</code> </p> RETURNS DESCRIPTION <code>List[str]</code> <p>A list of strings representing the names of the positional arguments.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/utils/functions.py</code> <pre><code>def get_function_positional_arguments(func: AnyCallable) -&gt; List[str]:\n\"\"\"Get the positional arguments of a function.\n    Args:\n        func: The function to get the positional arguments from.\n    Returns:\n        A list of strings representing the names of the positional arguments.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nsignature = inspect.signature(func)\narg_kinds = (\ninspect.Parameter.POSITIONAL_ONLY,\ninspect.Parameter.POSITIONAL_OR_KEYWORD,\n)\nreturn [\nparam.name for param in signature.parameters.values() if param.kind in arg_kinds\n]\n</code></pre>"},{"location":"api/faststream/utils/functions/to_async/","title":"To async","text":""},{"location":"api/faststream/utils/functions/to_async/#faststream.utils.functions.to_async","title":"faststream.utils.functions.to_async","text":"<pre><code>to_async(\nfunc: Union[\nCallable[F_Spec, F_Return],\nCallable[F_Spec, Awaitable[F_Return]],\n]\n) -&gt; Callable[F_Spec, Awaitable[F_Return]]\n</code></pre> <p>Converts a synchronous function to an asynchronous function.</p> PARAMETER  DESCRIPTION <code>func</code> <p>The synchronous function to be converted.</p> <p> TYPE: <code>Union[Callable[F_Spec, F_Return], Callable[F_Spec, Awaitable[F_Return]]]</code> </p> RETURNS DESCRIPTION <code>Callable[F_Spec, Awaitable[F_Return]]</code> <p>The asynchronous version of the input function.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/utils/functions.py</code> <pre><code>def to_async(\nfunc: Union[\nCallable[F_Spec, F_Return],\nCallable[F_Spec, Awaitable[F_Return]],\n]\n) -&gt; Callable[F_Spec, Awaitable[F_Return]]:\n\"\"\"Converts a synchronous function to an asynchronous function.\n    Args:\n        func: The synchronous function to be converted.\n    Returns:\n        The asynchronous version of the input function.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\n@wraps(func)\nasync def to_async_wrapper(*args: F_Spec.args, **kwargs: F_Spec.kwargs) -&gt; F_Return:\n\"\"\"Wraps a function to make it asynchronous.\n        Args:\n            func: The function to be wrapped\n            args: Positional arguments to be passed to the function\n            kwargs: Keyword arguments to be passed to the function\n        Returns:\n            The result of the wrapped function\n        Raises:\n            Any exceptions raised by the wrapped function\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nreturn await call_or_await(func, *args, **kwargs)\nreturn to_async_wrapper\n</code></pre>"},{"location":"api/faststream/utils/no_cast/NoCast/","title":"NoCast","text":""},{"location":"api/faststream/utils/no_cast/NoCast/#faststream.utils.no_cast.NoCast","title":"faststream.utils.no_cast.NoCast","text":"<p>             Bases: <code>CustomField</code></p> <p>A class that represents a custom field without casting.</p> METHOD DESCRIPTION <code>__init__ </code> <p>Initializes the NoCast object.</p> <code>use </code> <p>Returns the provided keyword arguments as a dictionary.</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/utils/no_cast.py</code> <pre><code>class NoCast(CustomField):\n\"\"\"A class that represents a custom field without casting.\n    Methods:\n        __init__ : Initializes the NoCast object.\n        use : Returns the provided keyword arguments as a dictionary.\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\ndef __init__(self) -&gt; None:\nsuper().__init__(cast=False)\ndef use(self, **kwargs: Any) -&gt; AnyDict:\n\"\"\"Return a dictionary containing the keyword arguments passed to the function.\n        Args:\n            **kwargs: Keyword arguments\n        Returns:\n            Dictionary containing the keyword arguments\n        !!! note\n            The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n        \"\"\"\nreturn kwargs\n</code></pre>"},{"location":"api/faststream/utils/no_cast/NoCast/#faststream.utils.no_cast.NoCast.use","title":"use","text":"<pre><code>use(**kwargs: Any) -&gt; AnyDict\n</code></pre> <p>Return a dictionary containing the keyword arguments passed to the function.</p> PARAMETER  DESCRIPTION <code>**kwargs</code> <p>Keyword arguments</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>AnyDict</code> <p>Dictionary containing the keyword arguments</p> <p>Note</p> <p>The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)</p> Source code in <code>/home/runner/work/faststream/faststream/faststream/utils/no_cast.py</code> <pre><code>def use(self, **kwargs: Any) -&gt; AnyDict:\n\"\"\"Return a dictionary containing the keyword arguments passed to the function.\n    Args:\n        **kwargs: Keyword arguments\n    Returns:\n        Dictionary containing the keyword arguments\n    !!! note\n        The above docstring is autogenerated by docstring-gen library (https://docstring-gen.airt.ai)\n    \"\"\"\nreturn kwargs\n</code></pre>"},{"location":"getting-started/","title":"QUICK START","text":"<p>Install using <code>pip</code>:</p> KafkaRabbitMQ <pre><code>pip install \"faststream[kafka]\"\n</code></pre> <p>Tip</p> <p>To start a new project, we need a test broker container <pre><code>docker run -d --rm -p 9092:9092 --name test-mq \\\n-e KAFKA_ENABLE_KRAFT=yes \\\n-e KAFKA_CFG_NODE_ID=1 \\\n-e KAFKA_CFG_PROCESS_ROLES=broker,controller \\\n-e KAFKA_CFG_CONTROLLER_LISTENER_NAMES=CONTROLLER \\\n-e KAFKA_CFG_LISTENERS=PLAINTEXT://:9092,CONTROLLER://:9093 \\\n-e KAFKA_CFG_LISTENER_SECURITY_PROTOCOL_MAP=CONTROLLER:PLAINTEXT,PLAINTEXT:PLAINTEXT \\\n-e KAFKA_CFG_ADVERTISED_LISTENERS=PLAINTEXT://127.0.0.1:9092 \\\n-e KAFKA_BROKER_ID=1 \\\n-e KAFKA_CFG_CONTROLLER_QUORUM_VOTERS=1@kafka:9093 \\\n-e ALLOW_PLAINTEXT_LISTENER=yes \\\nbitnami/kafka:3.5.0\n</code></pre></p> <pre><code>pip install \"faststream[rabbit]\"\n</code></pre> <p>Tip</p> <p>To start a new project, we need a test broker container <pre><code>docker run -d --rm -p 5672:5672 --name test-mq rabbitmq:alpine\n</code></pre></p>"},{"location":"getting-started/#basic-usage","title":"Basic Usage","text":"<p>To create a basic application, add the following code to a new file (e.g. <code>serve.py</code>):</p> KafkaRabbitMQ serve.py<pre><code>from faststream import FastStream\nfrom faststream.kafka import KafkaBroker\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\n@broker.subscriber(\"test\")\nasync def base_handler(body):\nprint(body)\n</code></pre> serve.py<pre><code>from faststream import FastStream\nfrom faststream.rabbit import RabbitBroker\nbroker = RabbitBroker(\"amqp://guest:guest@localhost:5672/\")\napp = FastStream(broker)\n@broker.subscriber(\"test\")\nasync def base_handler(body):\nprint(body)\n</code></pre> <p>And just run this command:</p> <pre><code>faststream run serve:app\n</code></pre> <p>After running the command, you should see the following output:</p> <pre><code>INFO     - FastStream app starting...\nINFO     - test |            - `BaseHandler` waiting for messages\nINFO     - FastStream app started successfully! To exit, press CTRL+C\n</code></pre> <p>Enjoy your new development experience!</p> Don't forget to stop the test broker container <pre><code>docker container stop test-mq\n</code></pre>"},{"location":"getting-started/logging/","title":"Application and Access Logging","text":"<p>FastStream uses two previously configured loggers:</p> <ul> <li><code>faststream</code> - used by <code>FastStream</code> app</li> <li><code>faststream.access</code> - used by the broker</li> </ul>"},{"location":"getting-started/logging/#logging-requests","title":"Logging Requests","text":"<p>To log requests, it is strongly recommended to use the <code>access_logger</code> of your broker, as it is available from the Context of your application.</p> <pre><code>from faststream import Logger\nfrom faststream.rabbit import RabbitBroker\nbroker = RabbitBroker()\n@broker.subscriber(\"test\")\nasync def func(logger: Logger):\nlogger.info(\"message received\")\n</code></pre> <p>This approach offers several advantages:</p> <ul> <li>The logger already contains the request context, including the message ID and broker-based parameters.</li> <li>By replacing the <code>logger</code> when initializing the broker, you will automatically replace all loggers inside your functions.</li> </ul>"},{"location":"getting-started/logging/#logging-levels","title":"Logging Levels","text":"<p>If you use the FastStream CLI, you can change the current logging level of the entire application directly from the command line.</p> <p>The <code>--log-level</code> flag sets the current logging level for both the broker and the <code>FastStream</code> app. This allows you to configure the levels of not only the default loggers but also your custom loggers, if you use them inside FastStream.</p> <pre><code>faststream run serve:app --log-level debug\n</code></pre> <p>If you want to completely disable the default logging of <code>FastStream</code>, you can set <code>logger=None</code></p> <pre><code>from faststream import FastStream\nfrom faststream.rabbit import RabbitBroker\nbroker = RabbitBroker(logger=None)  # Disables broker logs\napp = FastStream(broker, logger=None)  # Disables application logs\n</code></pre> <p>Warning</p> <p>Be careful: the <code>logger</code> that you get from the context will also have the value <code>None</code> if you turn off broker logging.</p> <p>If you don't want to lose access to the `logger' inside your context but want to disable the default logs of FastStream, you can lower the level of logs that the broker publishes itself.</p> <pre><code>import logging\nfrom faststream.rabbit import RabbitBroker\n# Sets the broker logs to the DEBUG level\nbroker = RabbitBroker(log_level=logging.DEBUG)\n</code></pre>"},{"location":"getting-started/logging/#formatting-logs","title":"Formatting Logs","text":"<p>If you are not satisfied with the current format of your application logs, you can change it directly in your broker's constructor.</p> <pre><code>from faststream.rabbit import RabbitBroker\nbroker = RabbitBroker(log_fmt=\"%(asctime)s %(levelname)s - %(message)s\")\n</code></pre>"},{"location":"getting-started/logging/#using-your-own-loggers","title":"Using Your Own Loggers","text":"<p>Since FastStream works with the standard <code>logging.Logger</code> object, you can initiate an application and a broker using your own logger.</p> <pre><code>import logging\nfrom faststream import FastStream\nfrom faststream.rabbit import RabbitBroker\nlogger = logging.getLogger(\"my_logger\")\nbroker = RabbitBroker(logger=logger)\napp = FastStream(broker, logger=logger)\n</code></pre> <p>By doing this, you will lose information about the context of the current request. However, you can retrieve it directly from the context anywhere in your code.</p> <pre><code>from faststream import context\nlog_context: dict[str, str] = context.get_local(\"log_context\")\n</code></pre>"},{"location":"getting-started/logging/#logger-access","title":"Logger Access","text":"<p>If you want to override default logger's behavior, you can access them directly via <code>logging</code>.</p> <pre><code>import logging\nlogger = logging.getLogger(\"faststream\")\naccess_logger = logging.getLogger(\"faststream.access\")\n</code></pre> <p>Or you can import them from FastStream.</p> <pre><code>from faststream.log import access_logger, logger\n</code></pre>"},{"location":"getting-started/asyncapi/custom/","title":"Customize AsyncAPI Schema","text":"<ul> <li>setup custom FastStream app info</li> <li>setup custom broker information</li> <li>setup custom handler information</li> <li>setup payload information via pydantic model</li> <li>generate schema.json, customize manually and serve it instead</li> </ul>"},{"location":"getting-started/asyncapi/export/","title":"How to Generate and Serve AsyncAPI Documentation","text":"<p>In this guide, let's explore how to generate and serve AsyncAPI documentation for our FastStream application.</p>"},{"location":"getting-started/asyncapi/export/#writing-the-faststream-application","title":"Writing the FastStream Application","text":"<p>Here's an example Python application using FastStream that consumes data from a topic, increments the value, and outputs the data to another topic. Save it in a file called <code>basic.py</code>.</p> <pre><code>from pydantic import BaseModel, Field, NonNegativeFloat\nfrom faststream import FastStream, Logger\nfrom faststream.kafka import KafkaBroker\nclass DataBasic(BaseModel):\ndata: NonNegativeFloat = Field(\n..., examples=[0.5], description=\"Float data example\"\n)\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\n@broker.publisher(\"output_data\")\n@broker.subscriber(\"input_data\")\nasync def on_input_data(msg: DataBasic, logger: Logger) -&gt; DataBasic:\nlogger.info(msg)\nreturn DataBasic(data=msg.data + 1.0)\n</code></pre>"},{"location":"getting-started/asyncapi/export/#generating-the-asyncapi-specification","title":"Generating the AsyncAPI Specification","text":"<p>Now that we have a FastStream application, we can proceed with generating the AsyncAPI specification using a CLI command.</p> <pre><code>faststream docs gen basic:app\n</code></pre> <p>The above command will generate the AsyncAPI specification and save it in a file called <code>asyncapi.json</code>.</p> <p>If you prefer <code>yaml</code> instead of <code>json</code>, please run the following command to generate <code>asyncapi.yaml</code>.</p> <pre><code>faststream docs gen --yaml basic:app\n</code></pre> <p>Note</p> <p>To generate the documentation in yaml format, please install the necessary dependency to work with YAML file format at first.</p> <pre><code>pip install PyYAML\n</code></pre>"},{"location":"getting-started/asyncapi/hosting/","title":"Serving the AsyncAPI Documentation","text":"<p>FastStream provides a command to serve the AsyncAPI documentation.</p> <p>Note</p> <p>This feature requires an Internet connection to obtain the AsyncAPI HTML via CDN.</p> <pre><code>faststream docs serve basic:app\n</code></pre> <p>In the above command, we are providing the path in the format of <code>python_module:FastStream</code>. Alternatively, you can also specify <code>asyncapi.json</code> or <code>asyncapi.yaml</code> to serve the AsyncAPI documentation.</p> <pre><code>faststream docs serve asyncapi.json\n# or\nfaststream docs serve asyncapi.yaml\n</code></pre> <p>After running the command, it should serve the AsyncAPI documentation on port 8000 and display the following logs in the terminal.</p> <pre><code>INFO:     Started server process [2364992]\nINFO:     Waiting for application startup.\nINFO:     Application startup complete.\nINFO:     Uvicorn running on http://localhost:8000 (Press CTRL+C to quit)\n</code></pre> <p>And you should be able to see the following page in your browser:</p> ShortExpand <p></p> <p></p> <p>Tip</p> <p>The command also offers options to serve the documentation on a different host and port.</p>"},{"location":"getting-started/cli/","title":"CLI","text":"<p>FastStream has its own built-in CLI tool for your maximum comfort as a developer.</p> <p>Thanks to typer and watchfiles. Their work is the basis of this tool.</p> <pre><code>faststream --help\n</code></pre> <pre><code>Usage: faststream [OPTIONS] COMMAND [ARGS]...\n\nGenerate, run and manage FastStream apps to greater development experience\n\nOptions:\n  -v, --version                   Show current platform, python and FastStream\n                                  version\n  --install-completion [bash|zsh|fish|powershell|pwsh]\nInstall completion for the specified shell.\n  --show-completion [bash|zsh|fish|powershell|pwsh]\nShow completion for the specified shell, to\n                                  copy it or customize the installation.\n  --help                          Show this message and exit.\n\nCommands:\n  docs  AsyncAPI schema commands\n  run   Run [MODULE:APP] FastStream application\n</code></pre>"},{"location":"getting-started/cli/#running-the-project","title":"Running the Project","text":""},{"location":"getting-started/cli/#multiprocessing-scaling","title":"Multiprocessing Scaling","text":"<p>FastStream allows you to scale application right from the command line by running you application in the Process pool.</p> <p>Just set the <code>--worker</code> option to scale your application:</p> <pre><code>faststream run serve:app --workers 2\n</code></pre> <pre><code>INFO     - Started parent process [7591]\nINFO     - Started child process [7593]\nINFO     - Started child process [7594]\nINFO     - test |            - `Handle` waiting for messages\nINFO     - test |            - `Handle` waiting for messages\n</code></pre>"},{"location":"getting-started/cli/#hot-reload","title":"Hot Reload","text":"<p>Thanks to watchfiles, written in Rust, you can work with your project easily. Edit the code as much as you like - the new version has already been launched and is waiting for your requests!</p> <pre><code>faststream run serve:app --reload\n</code></pre> <pre><code>INFO     - Started reloader process [7902] using WatchFiles\nINFO     - FastStream app starting...\nINFO     - test |            - `Handle` waiting for messages\nINFO     - FastStream app started successfully! To exit press CTRL+C\n</code></pre>"},{"location":"getting-started/cli/#environment-management","title":"Environment Management","text":"<p>You can pass any custom flags and launch options to the FastStream CLI even without first registering them. Just use them when launching the application - and they will be right in your environment.</p> <p>Use this option to select environment files, configure logging, or at your discretion.</p> <p>For example, we will pass the .env file to the context of our application:</p> <pre><code>faststream run serve:app --env=.env.dev\n</code></pre> <pre><code>INFO     - FastStream app starting...\nINFO     - test |            - `Handle` waiting for messages\nINFO     - FastStream app started successfully! To exit press CTRL+C\n</code></pre> KafkaRabbitMQ <pre><code>from faststream import FastStream, ContextRepo\nfrom faststream.kafka import KafkaBroker\nfrom pydantic_settings import BaseSettings\nbroker = KafkaBroker()\napp = FastStream(broker)\nclass Settings(BaseSettings):\nhost: str = \"localhost:9092\"\n@app.on_startup\nasync def setup(env: str, context: ContextRepo):\nsettings = Settings(_env_file=env)\nawait broker.connect(settings.host)\ncontext.set_global(\"settings\", settings)\n</code></pre> <pre><code>from faststream import FastStream, ContextRepo\nfrom faststream.rabbit import RabbitBroker\nfrom pydantic_settings import BaseSettings\nbroker = RabbitBroker()\napp = FastStream(broker)\nclass Settings(BaseSettings):\nhost: str = \"amqp://guest:guest@localhost:5672/\" # pragma: allowlist secret\n@app.on_startup\nasync def setup(env: str, context: ContextRepo):\nsettings = Settings(_env_file=env)\nawait broker.connect(settings.host)\ncontext.set_global(\"settings\", settings)\n</code></pre> <p>Note</p> <p>Note that the <code>env</code> parameter was passed to the <code>setup</code> function directly from the command line</p> <p>All passed values can be of type <code>bool</code>, <code>str</code> or <code>list[str]</code>.</p> <p>In this case, the flags will be interpreted as follows:</p> <pre><code>faststream run app:app --flag       # flag = True\nfaststream run app:app --no-flag    # flag = False\nfaststream run app:app --my-flag    # my_flag = True\nfaststream run app:app --key value  # key = \"value\"\nfaststream run app:app --key 1 2    # key = [\"1\", \"2\"]\n</code></pre> <p>You can use them both individually and together in unlimited quantities.</p>"},{"location":"getting-started/cli/#asyncapi-schema","title":"AsyncAPI Schema","text":"<p>Also, the FastStream CLI allows you to work with the AsyncAPI schema in a simple way.</p> <p>You are able to generate <code>.json</code> or <code>.yaml</code> files by your application code or host HTML representation directly:</p> <pre><code>faststream docs --help\n</code></pre> <pre><code>Usage: faststream docs [OPTIONS] COMMAND [ARGS]...\n\nAsyncAPI schema commands\n\nOptions:\n  --help  Show this message and exit.\n\nCommands:\n  gen    Generate project AsyncAPI schema\n  serve  Serve project AsyncAPI schema\n</code></pre> <p>To learn more about the commands above, please visit AsyncAPI export and AsyncAPI hosting.</p>"},{"location":"getting-started/config/","title":"Settings and Environment Variables","text":"<p>In many cases, your application may require external settings or configurations, such as a broker connection or database credentials.</p> <p>To manage these settings effectively, it's common to provide them through environment variables that can be read by the application.</p>"},{"location":"getting-started/config/#pydantic-settings","title":"Pydantic <code>Settings</code>","text":"<p>Fortunately, Pydantic  provides a useful utility for handling settings coming from environment variables with Pydantic: Settings management.</p>"},{"location":"getting-started/config/#install-pydantic-settings","title":"Install <code>pydantic-settings</code>","text":"<p>First, install the <code>pydantic-settings</code> package:</p> <pre><code>pip install pydantic-settings\n</code></pre> <p>Info</p> <p>In Pydantic v1, this functionality was included with the main package. Now it is distributed as an independent package so that you can choose not to install it if you don't need that functionality.</p>"},{"location":"getting-started/config/#create-the-settings-object","title":"Create the <code>Settings</code> Object","text":"<p>Import <code>BaseSettings</code> from Pydantic and create a subclass, similar to what you would do with a Pydantic model.</p> <p>Just like with Pydantic models, you declare class attributes with type annotations and can use all the same validation features and tools, including different data types and additional validations with <code>Field()</code>.</p> Pydantic v2Pydantic v1 config.py<pre><code>from pydantic_settings import BaseSettings\nclass Settings(BaseSettings):\nurl: str = \"\"\nqueue: str = \"test-queue\"\nsettings = Settings()\n</code></pre> <p>Info</p> <p>In Pydantic v1 you would import <code>BaseSettings</code> directly from <code>pydantic</code> instead of from <code>pydantic_settings</code>.</p> config.py<pre><code>from pydantic import BaseSettings\nclass Settings(BaseSettings):\nurl: str = \"\"\nqueue: str = \"test-queue\"\nsettings = Settings()\n</code></pre> <p>When you create an instance of that <code>Settings</code> class (in this case, in the <code>settings</code> object), Pydantic will read the environment variables in a case-insensitive way. For example, an upper-case variable <code>APP_NAME</code> will still be read for the attribute <code>app_name</code>.</p> <p>It will also convert and validate the data, so when you use that <code>settings</code> object, you will have data of the type you declared (e.g. <code>items_per_user</code> will be an <code>int</code>).</p>"},{"location":"getting-started/config/#using-the-settings","title":"Using the <code>settings</code>","text":"<p>Now you can use the new <code>settings</code> object in your application:</p> serve.py<pre><code>import os\nfrom pydantic_settings import BaseSettings\nfrom faststream import FastStream\nfrom faststream.rabbit import RabbitBroker\nclass Settings(BaseSettings):\nurl: str\nqueue: str = \"test-queue\"\nsettings = Settings(_env_file=os.getenv(\"ENV\", \".env\"))\nbroker = RabbitBroker(settings.url)\napp = FastStream(broker)\n@broker.subscriber(settings.queue)\nasync def handler(msg):\n...\n</code></pre>"},{"location":"getting-started/config/#running-the-application","title":"Running the Application","text":"<p>You can run the application while passing the configuration parameters as environment variables. For example, you could set an <code>URL</code>:</p> <pre><code>URL=\"amqp://guest:guest@localhost:5672\" faststream run serve:app\n</code></pre> <p>Tip</p> <p>To set multiple environment variables for a single command, separate them with spaces and put them all before the command.</p>"},{"location":"getting-started/config/#reading-a-env-file","title":"Reading a <code>.env</code> File","text":"<p>If you have many settings that may change frequently, especially in different environments, it might be useful to store them in a file and then read them as if they were environment variables.</p> <p>This practice is common enough that it has a name; these environment variables are typically placed in a file named <code>.env</code>, commonly referred to as a \"dotenv\" file.</p> <p>Tip</p> <p>In Unix-like systems like Linux and macOS, a file starting with a dot (<code>.</code>) is considered a hidden file.</p> <p>But a dotenv file doesn't really have to have that exact filename.</p> <p>Pydantic supports reading from these types of files using an external library. You can learn more at Pydantic Settings: Dotenv (.env) support.</p> <p>Tip</p> <p>To use this feature, you need to install the <code>python-dotenv</code> library.</p>"},{"location":"getting-started/config/#the-env-file","title":"The <code>.env</code> File","text":"<p>You can create a <code>.env</code> file with contents like this:</p> <pre><code>URL=\"amqp://guest:guest@localhost:5672\"\nQUEUE=\"test-queue\"\n</code></pre>"},{"location":"getting-started/config/#reading-settings-from-env","title":"Reading Settings from <code>.env</code>","text":"<p>Then update your <code>config.py</code> as follows:</p> <pre><code>import os\nfrom pydantic_settings import BaseSettings\nclass Settings(BaseSettings):\nurl: str\nqueue: str = \"test-queue\"\nsettings = Settings(_env_file=os.getenv(\"ENV\", \".env\"))\n</code></pre> <p>This way, you can specify different <code>.env</code> files directly from your terminal, which can be extremely helpful for various testing and production scenarios.</p> <p>Note</p> <p>By default, Pydantic will attempt to find a <code>.env</code> file. If it's not present, Pydantic will use the default field values.</p>"},{"location":"getting-started/config/#choosing-the-env-file-at-startup","title":"Choosing the <code>.env</code> File at Startup","text":"<p>Now you can run the apllication with different <code>.env</code> files like so:</p> <pre><code>ENV=.local.env faststream run serve:app\n</code></pre> <p>Or, for a production environment:</p> <pre><code>ENV=.production.env faststream run serve:app\n</code></pre> <p>Or even for a test environment:</p> <pre><code>ENV=.test.env pytest\n</code></pre>"},{"location":"getting-started/context/","title":"Application Context","text":"<p>FastStreams has its own Dependency Injection container - Context, used to store application runtime objects and variables.</p> <p>With this container, you can access both application scope and message processing scope objects. This functionality is similar to <code>Depends</code> usage.</p> KafkaRabbitMQ <pre><code>from faststream import Context, FastStream\nfrom faststream.kafka import KafkaBroker\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\n@broker.subscriber(\"test\")\nasync def base_handler(\nbody: str,\nmessage=Context(),  # get access to raw message\n):\n...\n</code></pre> <pre><code>from faststream import Context, FastStream\nfrom faststream.rabbit import RabbitBroker\nbroker = RabbitBroker(\"amqp://guest:guest@localhost:5672/\")\napp = FastStream(broker)\n@broker.subscriber(\"test\")\nasync def base_handler(\nbody: str,\nmessage=Context(),  # get access to raw message\n):\n...\n</code></pre> <p>But, with the <code>Annotated</code> Python feature usage, it is much closer to <code>@pytest.fixture</code>.</p> KafkaRabbitMQ <pre><code>from typing import Annotated\nfrom faststream import Context, FastStream\nfrom faststream.kafka import KafkaBroker, KafkaMessage\nMessage = Annotated[KafkaMessage, Context()]\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\n@broker.subscriber(\"test\")\nasync def base_handler(\nbody: str,\nmessage: Message,  # get access to raw message\n):\n...\n</code></pre> <pre><code>from typing import Annotated\nfrom faststream import Context, FastStream\nfrom faststream.rabbit import RabbitBroker, RabbitMessage\nMessage = Annotated[RabbitMessage, Context()]\nbroker = RabbitBroker(\"amqp://guest:guest@localhost:5672/\")\napp = FastStream(broker)\n@broker.subscriber(\"test\")\nasync def base_handler(\nbody: str,\nmessage: Message,  # get access to raw message\n):\n...\n</code></pre>"},{"location":"getting-started/context/#usages","title":"Usages","text":"<p>By default, the context is available in the same place as <code>Depends</code>:</p> <ul> <li>at lifespan hooks</li> <li>message subscribers</li> <li>nested dependencies</li> </ul> <p>Tip</p> <p>Fields obtained from the <code>Context</code> are editable, so editing them in a function means editing them everywhere.</p>"},{"location":"getting-started/context/#compatibility-with-regular-functions","title":"Compatibility with Regular Functions","text":"<p>To use context in other functions, use the <code>@apply_types</code> decorator. In this case, the context of the called function will correspond to the context of the event handler from which it was called.</p> <pre><code>from faststream import Context, apply_types\n@broker.subscriber(\"test\")\nasync def handler(body):\nnested_func(body)\n@apply_types\ndef nested_func(body, logger=Context()):\nlogger.info(body)\n</code></pre> <p>In the example above, we did not pass the <code>logger</code> function at calling it; it was placed outside of context.</p>"},{"location":"getting-started/context/custom/","title":"Context Fields Declaration","text":"<p>You can also store your own objects in the <code>Context</code>.</p>"},{"location":"getting-started/context/custom/#global","title":"Global","text":"<p>To declare an application-level context field, you need to call the <code>context.set_global</code> method with with a key to indicate where the object will be placed in the context.</p> KafkaRabbitMQ <pre><code>from faststream import FastStream, ContextRepo, Context\nfrom faststream.kafka import KafkaBroker\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\n@app.on_startup\nasync def set_global(context: ContextRepo):\ncontext.set_global(\"secret_str\", \"my-perfect-secret\")\n</code></pre> <pre><code>from faststream import FastStream, ContextRepo, Context\nfrom faststream.rabbit import RabbitBroker\nbroker = RabbitBroker(\"amqp://guest:guest@localhost:5672/\")\napp = FastStream(broker)\n@app.on_startup\nasync def set_global(context: ContextRepo):\ncontext.set_global(\"secret_str\", \"my-perfect-secret\")\n</code></pre> <p>Afterward, you can access your <code>secret</code> field in the usual way:</p> KafkaRabbitMQ <pre><code>@broker.subscriber(\"test-topic\")\nasync def handle(\nmsg: str,\nsecret_str: str=Context(),\n):\nassert secret_str == \"my-perfect-secret\" # pragma: allowlist secret\n</code></pre> <pre><code>@broker.subscriber(\"test-queue\")\nasync def handle(\nmsg: str,\nsecret_str: str=Context(),\n):\nassert secret_str == \"my-perfect-secret\" # pragma: allowlist secret\n</code></pre> <p>In this case, the field becomes a global context field: it does not depend on the current message handler (unlike <code>message</code>)</p> <p>To remove a field from the context use the <code>reset_global</code> method:</p> <pre><code>context.reset_global(\"my_key\")\n</code></pre>"},{"location":"getting-started/context/custom/#local","title":"Local","text":"<p>To set a local context (available only within the message processing scope), use the context manager <code>scope</code></p> KafkaRabbitMQ <pre><code>from faststream import Context, FastStream, apply_types\nfrom faststream.kafka import KafkaBroker\nfrom faststream.kafka.annotations import ContextRepo, KafkaMessage\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\n@broker.subscriber(\"test-topic\")\nasync def handle(\nmsg: str,\nmessage: KafkaMessage,\ncontext: ContextRepo,\n):\nwith context.scope(\"correlation_id\", message.correlation_id):\ncall()\n@apply_types\ndef call(\nmessage: KafkaMessage,\ncorrelation_id=Context(),\n):\nassert correlation_id == message.correlation_id\n</code></pre> <pre><code>from faststream import Context, FastStream, apply_types\nfrom faststream.rabbit import RabbitBroker\nfrom faststream.rabbit.annotations import ContextRepo, RabbitMessage\nbroker = RabbitBroker(\"amqp://guest:guest@localhost:5672/\")\napp = FastStream(broker)\n@broker.subscriber(\"test-queue\")\nasync def handle(\nmsg: str,\nmessage: RabbitMessage,\ncontext: ContextRepo,\n):\nwith context.scope(\"correlation_id\", message.correlation_id):\ncall()\n@apply_types\ndef call(\nmessage: RabbitMessage,\ncorrelation_id=Context(),\n):\nassert correlation_id == message.correlation_id\n</code></pre> <p>You can also set the context yourself, and it will remain within the current call stack until you clear it.</p> KafkaRabbitMQ <pre><code>from faststream import Context, FastStream, apply_types, context\nfrom faststream.kafka import KafkaBroker\nfrom faststream.kafka.annotations import KafkaMessage\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\n@broker.subscriber(\"test-topic\")\nasync def handle(\nmsg: str,\nmessage: KafkaMessage,\n):\ntag = context.set_local(\"correlation_id\", message.correlation_id)\ncall(tag)\n@apply_types\ndef call(\ntag,\nmessage: KafkaMessage,\ncorrelation_id=Context(),\n):\nassert correlation_id == message.correlation_id\ncontext.reset_local(\"correlation_id\", tag)\n</code></pre> <pre><code>from faststream import Context, FastStream, apply_types, context\nfrom faststream.rabbit import RabbitBroker\nfrom faststream.rabbit.annotations import RabbitMessage\nbroker = RabbitBroker(\"amqp://guest:guest@localhost:5672/\")\napp = FastStream(broker)\n@broker.subscriber(\"test-queue\")\nasync def handle(\nmsg: str,\nmessage: RabbitMessage,\n):\ntag = context.set_local(\"correlation_id\", message.correlation_id)\ncall(tag)\n@apply_types\ndef call(\ntag,\nmessage: RabbitMessage,\ncorrelation_id=Context(),\n):\nassert correlation_id == message.correlation_id\ncontext.reset_local(\"correlation_id\", tag)\n</code></pre>"},{"location":"getting-started/context/existed/","title":"Existing Fields","text":"<p>Context already contains some global objects that you can always access:</p> <ul> <li>broker - the current broker</li> <li>context - the context itself, in which you can write your own fields</li> <li>logger - the logger used for your broker (tags messages with message_id)</li> <li>message - the raw message (if you need access to it)</li> </ul> <p>At the same time, thanks to <code>contextlib.ContextVar</code>, message is local for you current consumer scope.</p>"},{"location":"getting-started/context/existed/#access-to-context-fields","title":"Access to Context Fields","text":"<p>By default, the context searches for an object based on the argument name.</p> KafkaRabbitMQ <pre><code>from faststream import Context, FastStream\nfrom faststream.kafka import KafkaBroker\nbroker_object = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker_object)\n@broker_object.subscriber(\"test-topic\")\nasync def handle(\nmsg: str,\nlogger=Context(),\nmessage=Context(),\nbroker=Context(),\ncontext=Context(),\n):\nlogger.info(message)\nawait broker.publish(\"test\", \"response\")\n</code></pre> <pre><code>from faststream import Context, FastStream\nfrom faststream.rabbit import RabbitBroker\nbroker_object = RabbitBroker(\"amqp://guest:guest@localhost:5672/\")\napp = FastStream(broker_object)\n@broker_object.subscriber(\"test-queue\")\nasync def handle(\nmsg: str,\nlogger=Context(),\nmessage=Context(),\nbroker=Context(),\ncontext=Context(),\n):\nlogger.info(message)\nawait broker.publish(\"test\", \"response\")\n</code></pre>"},{"location":"getting-started/context/existed/#annotated-aliases","title":"Annotated Aliases","text":"<p>Also, FastStream has already created <code>Annotated</code> aliases to provide you with comfortable access to existing objects. You can import them directly from <code>faststream</code> or your broker-specific modules:</p> <ul> <li>Shared aliases</li> </ul> <pre><code>from faststream import Logger, ContextRepo\n</code></pre> <ul> <li>Kafka aliases</li> </ul> <pre><code>from faststream.kafka.annotations import (\nLogger, ContextRepo, KafkaMessage, KafkaBroker, KafkaProducer\n)\n</code></pre> <ul> <li>RabbitMQ aliases</li> </ul> <pre><code>from faststream.rabbit.annotations import (\nLogger, ContextRepo, RabbitMessage, RabbitBroker, RabbitProducer\n)\n</code></pre> <p>To use them, simply import and use them as subscriber argument annotations.</p> KafkaRabbitMQ <pre><code>from faststream import Context, FastStream\nfrom faststream.kafka import KafkaBroker\nfrom faststream.kafka.annotations import (\nContextRepo,\nKafkaMessage,\nLogger,\nKafkaBroker as BrokerAnnotation,\n)\nbroker_object = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker_object)\n@broker_object.subscriber(\"response-topic\")\nasync def handle_response(\nmsg: str,\nlogger: Logger,\nmessage: KafkaMessage,\ncontext: ContextRepo,\nbroker: BrokerAnnotation,\n):\nlogger.info(message)\nawait broker.publish(\"test\", \"response\")\n</code></pre> <pre><code>from faststream import Context, FastStream\nfrom faststream.rabbit import RabbitBroker\nfrom faststream.rabbit.annotations import (\nContextRepo,\nRabbitMessage,\nLogger,\nRabbitBroker as BrokerAnnotation,\n)\nbroker_object = RabbitBroker(\"amqp://guest:guest@localhost:5672/\")\napp = FastStream(broker_object)\n@broker_object.subscriber(\"response-queue\")\nasync def handle_response(\nmsg: str,\nlogger: Logger,\nmessage: RabbitMessage,\ncontext: ContextRepo,\nbroker: BrokerAnnotation,\n):\nlogger.info(message)\nawait broker.publish(\"test\", \"response\")\n</code></pre>"},{"location":"getting-started/context/extra/","title":"Context Extra Options","text":"<p>Additionally, <code>Context</code> provides you with some extra capabilities for working with containing objects.</p>"},{"location":"getting-started/context/extra/#default-values","title":"Default Values","text":"<p>For instance, if you attempt to access a field that doesn't exist in the global context, you will receive a <code>pydantic.ValidationError</code> exception.</p> <p>However, you can set default values if needed.</p> KafkaRabbitMQ <pre><code>@broker.subscriber(\"test-topic\")\nasync def handle(\nnot_existed: None = Context(\"not_existed\", default=None),\n):\nassert not_existed is None\n</code></pre> <pre><code>@broker.subscriber(\"test-queue\")\nasync def handle(\nnot_existed: None = Context(\"not_existed\", default=None),\n):\nassert not_existed is None\n</code></pre>"},{"location":"getting-started/context/extra/#cast-context-types","title":"Cast Context Types","text":"<p>By default, context fields are NOT CAST to the type specified in their annotation.</p> KafkaRabbitMQ <pre><code>from faststream import Context, FastStream, context\nfrom faststream.kafka import KafkaBroker\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\ncontext.set_global(\"secret\", \"1\")\n@broker.subscriber(\"test-topic\")\nasync def handle(\nsecret: int = Context(),\n):\nassert secret == \"1\"\n</code></pre> <pre><code>from faststream import Context, FastStream, context\nfrom faststream.rabbit import RabbitBroker\nbroker = RabbitBroker(\"amqp://guest:guest@localhost:5672/\")\napp = FastStream(broker)\ncontext.set_global(\"secret\", \"1\")\n@broker.subscriber(\"test-queue\")\nasync def handle(\nsecret: int = Context(),\n):\nassert secret == \"1\"\n</code></pre> <p>If you require this functionality, you can enable the appropriate flag.</p> KafkaRabbitMQ <pre><code>@broker.subscriber(\"test-topic2\")\nasync def handle_int(\nsecret: int = Context(cast=True),\n):\nassert secret == 1\n</code></pre> <pre><code>@broker.subscriber(\"test-queue2\")\nasync def handle_int(\nsecret: int = Context(cast=True),\n):\nassert secret == 1\n</code></pre>"},{"location":"getting-started/context/fields/","title":"Access by Name","text":"<p>Sometimes, you may need to use a different name for the argument (not the one under which it is stored in the context) or get access to specific parts of the object. To do this, simply specify the name of what you want to access, and the context will provide you with the object.</p> KafkaRabbitMQ <pre><code>from faststream import Context, FastStream\nfrom faststream.kafka import KafkaBroker, KafkaMessage\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\n@broker.subscriber(\"test-topic\")\nasync def handle(\nmsg: KafkaMessage = Context(\"message\"),\ncorrelation_id: str = Context(\"message.correlation_id\"),\n):\nassert msg.correlation_id == correlation_id\n</code></pre> <pre><code>from faststream import Context, FastStream\nfrom faststream.rabbit import RabbitBroker, RabbitMessage\nbroker = RabbitBroker(\"amqp://guest:guest@localhost:5672/\")\napp = FastStream(broker)\n@broker.subscriber(\"test-queue\")\nasync def handle(\nmsg: RabbitMessage = Context(\"message\"),\ncorrelation_id: str = Context(\"message.correlation_id\"),\n):\nassert msg.correlation_id == correlation_id\n</code></pre> <p>This way you can get access to context object by its name</p> KafkaRabbitMQ <pre><code>    msg: KafkaMessage = Context(\"message\"),\n</code></pre> <pre><code>    msg: RabbitMessage = Context(\"message\"),\n</code></pre> <p>This way you can get access to context object specific field</p> KafkaRabbitMQ <pre><code>    correlation_id: str = Context(\"message.correlation_id\"),\n</code></pre> <pre><code>    correlation_id: str = Context(\"message.correlation_id\"),\n</code></pre>"},{"location":"getting-started/contributing/CONTRIBUTING/","title":"Development","text":"<p>After cloning the project, you'll need to set up the development environment. Here are the guidelines on how to do this.</p>"},{"location":"getting-started/contributing/CONTRIBUTING/#virtual-environment-with-venv","title":"Virtual Environment with <code>venv</code>","text":"<p>Create a virtual environment in a directory using Python's <code>venv</code> module:</p> <pre><code>python -m venv venv\n</code></pre> <p>That will create a <code>./venv/</code> directory with Python binaries, allowing you to install packages in an isolated environment.</p>"},{"location":"getting-started/contributing/CONTRIBUTING/#activate-the-environment","title":"Activate the Environment","text":"<p>Activate the new environment with:</p> <pre><code>source ./venv/bin/activate\n</code></pre> <p>Ensure you have the latest pip version in your virtual environment:</p> <pre><code>python -m pip install --upgrade pip\n</code></pre>"},{"location":"getting-started/contributing/CONTRIBUTING/#installing-dependencies","title":"Installing Dependencies","text":"<p>After activating the virtual environment as described above, run:</p> <pre><code>pip install -e \".[dev]\"\n</code></pre> <p>This will install all the dependencies and your local FastStream in your virtual environment.</p>"},{"location":"getting-started/contributing/CONTRIBUTING/#using-your-local-faststream","title":"Using Your local FastStream","text":"<p>If you create a Python file that imports and uses FastStream, and run it with the Python from your local environment, it will use your local FastStream source code.</p> <p>Whenever you update your local FastStream source code, it will automatically use the latest version when you run your Python file again. This is because it is installed with <code>-e</code>.</p> <p>This way, you don't have to \"install\" your local version to be able to test every change.</p> <p>To use your local FastStream CLI, type:</p> <pre><code>python -m faststream ...\n</code></pre>"},{"location":"getting-started/contributing/CONTRIBUTING/#running-tests","title":"Running Tests","text":""},{"location":"getting-started/contributing/CONTRIBUTING/#pytest","title":"Pytest","text":"<p>To run tests with your current FastStream application and Python environment, use:</p> <pre><code>pytest tests\n# or\n./scripts/test.sh\n# with coverage output\n./scripts/test-cov.sh\n</code></pre> <p>In your project, you'll find some pytest marks:</p> <ul> <li>slow</li> <li>rabbit</li> <li>kafka</li> <li>all</li> </ul> <p>By default, running pytest will execute \"not slow\" tests.</p> <p>To run all tests use:</p> <pre><code>pytest -m 'all'\n</code></pre> <p>If you don't have a local RabbitMQ or Kafka instance running, you can run tests without those dependencies:</p> <pre><code>pytest -m 'not rabbit and not kafka'\n</code></pre> <p>To run tests based on RabbitMQ, Kafka, or other dependencies, the following dependencies are needed to be started as docker containers:</p> <pre><code>version: \"3\"\nservices:\n# nosemgrep: yaml.docker-compose.security.writable-filesystem-service.writable-filesystem-service\nrabbitmq:\nimage: rabbitmq:alpine\nports:\n- \"5672:5672\"\n# https://semgrep.dev/r?q=yaml.docker-compose.security.no-new-privileges.no-new-privileges\nsecurity_opt:\n- no-new-privileges:true\n# nosemgrep: yaml.docker-compose.security.writable-filesystem-service.writable-filesystem-service\nkafka:\nimage: bitnami/kafka:3.5.0\nports:\n- \"9092:9092\"\nenvironment:\nKAFKA_ENABLE_KRAFT: \"true\"\nKAFKA_CFG_NODE_ID: \"1\"\nKAFKA_CFG_PROCESS_ROLES: \"broker,controller\"\nKAFKA_CFG_CONTROLLER_LISTENER_NAMES: \"CONTROLLER\"\nKAFKA_CFG_LISTENERS: \"PLAINTEXT://:9092,CONTROLLER://:9093\"\nKAFKA_CFG_LISTENER_SECURITY_PROTOCOL_MAP: \"CONTROLLER:PLAINTEXT,PLAINTEXT:PLAINTEXT\"\nKAFKA_CFG_ADVERTISED_LISTENERS: \"PLAINTEXT://127.0.0.1:9092\"\nKAFKA_BROKER_ID: \"1\"\nKAFKA_CFG_CONTROLLER_QUORUM_VOTERS: \"1@kafka:9093\"\nALLOW_PLAINTEXT_LISTENER: \"true\"\n# https://semgrep.dev/r?q=yaml.docker-compose.security.no-new-privileges.no-new-privileges\nsecurity_opt:\n- no-new-privileges:true\n</code></pre> <p>You can start the dependencies easily using provided script by running:</p> <pre><code>./scripts/start_test_env.sh\n</code></pre> <p>Once you are done with development and running tests, you can stop the dependencies' docker containers by running:</p> <pre><code>./scripts/stop_test_env.sh\n</code></pre>"},{"location":"getting-started/contributing/docs/","title":"Documentation","text":""},{"location":"getting-started/contributing/docs/#how-to-help","title":"How to help","text":"<p>You will be of invaluable help if you contribute to the documentation.</p> <p>Such a contribution can be:</p> <ul> <li>Indications of inaccuracies, errors, typos</li> <li>Suggestions for editing specific sections</li> <li>Making additions</li> </ul> <p>You can report all this in discussions on GitHub, start issue, or write about it in our discord group.</p> <p>Note</p> <p>Special thanks to those who are ready to offer help with the case and help in developing documentation, as well as translating it into other languages.</p>"},{"location":"getting-started/contributing/docs/#how-to-get-started","title":"How to get started","text":"<p>To develop the documentation, you don't even need to install the entire FastStream project as a whole.</p> <p>Enough:</p> <ol> <li>Clone the project repository</li> <li>Create a virtual environment     <pre><code>python -m venv venv\n</code></pre></li> <li>Activate it     <pre><code>source venv/bin/activate\n</code></pre></li> <li>Install documentation dependencies     <pre><code>pip install \".[devdocs]\"\n</code></pre></li> <li>Go to the <code>docs/</code> directory</li> <li>Start the local documentation server     <pre><code>mkdocs serve\n</code></pre></li> </ol> <p>Now all changes in the documentation files will be reflected on your local version of the site. After making all the changes, you can issue a <code>PR</code> with them - and we will gladly accept it!</p>"},{"location":"getting-started/dependencies/","title":"Dependencies","text":"<p>FastStream uses the secondary library FastDepends for dependency management. This dependency system is literally borrowed from FastAPI, so if you know how to work with that framework, you'll be comfortable with dependencies in FastStream.</p> <p>You can visit the FastDepends documentation for more details, but the key points and additions are covered here.</p>"},{"location":"getting-started/dependencies/#type-casting","title":"Type Casting","text":"<p>The key function in the dependency management and type conversion system in FastStream is the decorator <code>@apply_types</code> (also known as <code>@inject</code> in FastDepends).</p> <p>By default, it applies to all event handlers, unless you disabled the same option when creating the broker.</p> KafkaRabbitMQ <pre><code>from faststream.kafka import KafkaBroker\nbroker = KafkaBroker(..., apply_types=False)\n</code></pre> <pre><code>from faststream.rabbit import RabbitBroker\nbroker = RabbitBroker(..., apply_types=False)\n</code></pre> <p>Warning</p> <p>Setting the <code>apply_types=False</code> flag not only disables type casting but also <code>Depends</code> and <code>Context</code>.</p> <p>This flag can be useful if you are using FastStream within another framework and you need to use its native dependency system.</p>"},{"location":"getting-started/dependencies/#dependency-injection","title":"Dependency Injection","text":"<p>To implement dependencies in FastStream, a special class called Depends is used</p> KafkaRabbitMQ <pre><code>from faststream import FastStream, Depends\nfrom faststream.kafka import KafkaBroker\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\ndef simple_dependency():\nreturn 1\n@broker.subscriber(\"test\")\nasync def handler(body: dict, d: int = Depends(simple_dependency)):\nassert d == 1\n</code></pre> <pre><code>from faststream import FastStream, Depends\nfrom faststream.rabbit import RabbitBroker\nbroker = RabbitBroker(\"amqp://guest:guest@localhost:5672/\")\napp = FastStream(broker)\ndef simple_dependency():\nreturn 1\n@broker.subscriber(\"test\")\nasync def handler(body: dict, d: int = Depends(simple_dependency)):\nassert d == 1\n</code></pre> <p>The first step: You need to declare a dependency, which can be any <code>Callable</code> object.</p> Callable <p>A \"Callable\" is an object that can be \"called\". It can be a function, a class, or a class method.</p> <p>In other words, if you can write code like <code>my_object()</code> - <code>my_object</code> is <code>Callable</code></p> KafkaRabbitMQ <pre><code>async def handler(body: dict, d: int = Depends(simple_dependency)):\nassert d == 1\n</code></pre> <pre><code>async def handler(body: dict, d: int = Depends(simple_dependency)):\nassert d == 1\n</code></pre> <p>Second step: Declare which dependencies you need using <code>Depends</code></p> KafkaRabbitMQ <pre><code>async def handler(body: dict, d: int = Depends(simple_dependency)):\nassert d == 1\n</code></pre> <pre><code>async def handler(body: dict, d: int = Depends(simple_dependency)):\nassert d == 1\n</code></pre> <p>The last step: Just use the result of executing your dependency!</p> <p>It's easy, isn't it?</p> <p>Auto <code>@apply_types</code></p> <p>In the code above, we didn't use this decorator for our dependencies. However, it still applies to all functions used as dependencies. Please keep this in your mind.</p>"},{"location":"getting-started/dependencies/#top-level-dependencies","title":"Top-level Dependencies","text":"<p>If you don't need a dependency result, you can use the following code:</p> <pre><code>@broker.subscriber(\"test\")\ndef method(_ = Depends(...)): ...\n</code></pre> <p>But, using a special <code>subscriber</code> parameter is much more suitable:</p> <pre><code>@broker.subscriber(\"test\", dependencies=[Depends(...)])\ndef method(): ...\n</code></pre> <p>You can also declare broker-level dependencies, which will be applied to all broker's handlers:</p> <pre><code>broker = RabbitBroker(dependencies=[Depends(...)])\n</code></pre>"},{"location":"getting-started/dependencies/#nested-dependencies","title":"Nested Dependencies","text":"<p>Dependencies can also contain other dependencies. This works in a very predictable way: just declare <code>Depends</code> in the dependent function.</p> KafkaRabbitMQ <pre><code>from faststream import FastStream, Depends\nfrom faststream.kafka import KafkaBroker\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\ndef another_dependency():\nreturn 1\ndef simple_dependency(b: int = Depends(another_dependency)): # (1)\nreturn b * 2\n@broker.subscriber(\"test\")\nasync def handler(\nbody: dict,\na: int = Depends(another_dependency),\nb: int = Depends(simple_dependency)):\nassert (a + b) == 3\n</code></pre> <ol> <li>A nested dependency is called here</li> </ol> <pre><code>from faststream import FastStream, Depends\nfrom faststream.rabbit import RabbitBroker\nbroker = RabbitBroker(\"amqp://guest:guest@localhost:5672/\")\napp = FastStream(broker)\ndef another_dependency():\nreturn 1\ndef simple_dependency(b: int = Depends(another_dependency)): # (1)\nreturn b * 2\n@broker.subscriber(\"test\")\nasync def handler(\nbody: dict,\na: int = Depends(another_dependency),\nb: int = Depends(simple_dependency)):\nassert (a + b) == 3\n</code></pre> <ol> <li>A nested dependency is called here</li> </ol> <p>Caching</p> <p>In the example above, the <code>another_dependency</code> function will be called at ONCE! FastDepends caches all dependency execution results within ONE <code>@apply_types</code> call stack. This means that all nested dependencies will receive the cached result of dependency execution. But, between different calls of the main function, these results will be different.</p> <p>To prevent this behavior, just use <code>Depends(..., cache=False)</code>. In this case, the dependency will be used for each function in the call stack where it is used.</p>"},{"location":"getting-started/dependencies/#use-with-regular-functions","title":"Use with Regular Functions","text":"<p>You can use the decorator <code>@apply_types</code> not only with <code>@broker.subscriber(...)</code>, but also with regular functions, both synchronous and asynchronous.</p> SyncAsync <pre><code>from faststream import Depends, apply_types\ndef simple_dependency(a: int, b: int = 3):\nreturn a + b\n@apply_types\ndef method(a: int, d: int = Depends(simple_dependency)):\nreturn a + d\nassert method(\"1\") == 5\n</code></pre> <pre><code>import asyncio\nfrom faststream import Depends, apply_types\nasync def simple_dependency(a: int, b: int = 3):\nreturn a + b\ndef another_dependency(a: int):\nreturn a\n@apply_types\nasync def method(\na: int,\nb: int = Depends(simple_dependency),\nc: int = Depends(another_dependency),\n):\nreturn a + b + c\nassert asyncio.run(method(\"1\")) == 6\n</code></pre> <p>Be careful</p> <p>In asynchronous code, you can use both synchronous and asynchronous dependencies. But in synchronous code, only synchronous dependencies are available to you.</p>"},{"location":"getting-started/dependencies/#casting-dependency-types","title":"Casting Dependency Types","text":"<p>FastDepends, used by FastStream, also gives the type <code>return</code>. This means that the value returned by the dependency will be be cast to the type twice: as <code>return</code> for dependencies and as the input argument of the main function. This does not incur additional costs if these types have the same annotation. Just keep it in mind. Or not... Anyway, I've warned you.</p> <pre><code>from faststream import Depends, apply_types\ndef simple_dependency(a: int, b: int = 3) -&gt; str:\nreturn a + b  # 'return' is cast to `str` for the first time\n@inject\ndef method(a: int, d: int = Depends(simple_dependency)):\n# 'd' is cast to `int` for the second time\nreturn a + d\nassert method(\"1\") == 5\n</code></pre> <p>Also, the result of executing the dependency is cached. If you use this dependency in <code>N</code> functions, this cached result will be converted to type <code>N</code> times (at the input to the function being used).</p> <p>To avoid problems with this, use mypy or just be careful with the annotation of types in your project.</p>"},{"location":"getting-started/dependencies/global/","title":"Global","text":"<ul> <li>Broker-level dependencies</li> <li>Subscriber-level dependencies</li> </ul>"},{"location":"getting-started/dependencies/testing/","title":"Testing","text":"<p>https://lancetnik.github.io/FastDepends/tutorial/overrides/</p>"},{"location":"getting-started/integrations/fastapi/","title":"FastAPI Plugin","text":""},{"location":"getting-started/integrations/fastapi/#handling-messages","title":"Handling messages","text":"<p>FastStream can be used as a part of FastAPI.</p> <p>Just import a StreamRouter you need and declare the message handler in the same way as with a regular FastStream application.</p> <p>Tip</p> <p>When used in this way, FastStream does not use its own dependency system but integrates into FastAPI. That is, you can use <code>Depends</code>, <code>BackgroundTasks</code> and other original FastAPI features as if it were a regular HTTP endpoint, but you can't use <code>faststream.Context</code> and <code>faststream.Depends</code>.</p> <p>Note that the code below uses <code>fastapi.Depends</code>, not <code>faststream.Depends</code>.</p> KafkaRabbitMQ <pre><code>from fastapi import Depends, FastAPI\nfrom pydantic import BaseModel\nfrom faststream.kafka.fastapi import KafkaRouter\nrouter = KafkaRouter(\"localhost:9092\")\nclass Incoming(BaseModel):\nm: dict\ndef call():\nreturn True\n@router.subscriber(\"test\")\n@router.publisher(\"response\")\nasync def hello(m: Incoming, d=Depends(call)):\nreturn {\"response\": \"Hello, world!\"}\n@router.get(\"/\")\nasync def hello_http():\nreturn \"Hello, http!\"\napp = FastAPI(lifespan=router.lifespan_context)\napp.include_router(router)\n</code></pre> <pre><code>from fastapi import Depends, FastAPI\nfrom pydantic import BaseModel\nfrom faststream.rabbit.fastapi import RabbitRouter\nrouter = RabbitRouter(\"amqp://guest:guest@localhost:5672/\")\nclass Incoming(BaseModel):\nm: dict\ndef call():\nreturn True\n@router.subscriber(\"test\")\n@router.publisher(\"response\")\nasync def hello(m: Incoming, d=Depends(call)):\nreturn {\"response\": \"Hello, world!\"}\n@router.get(\"/\")\nasync def hello_http():\nreturn \"Hello, http!\"\napp = FastAPI(lifespan=router.lifespan_context)\napp.include_router(router)\n</code></pre> <p>When processing a message from a broker, the entire message body is placed simultaneously in both the <code>body</code> and <code>path</code> request parameters. You can access them in any way convenient for you. The message header is placed in <code>headers</code>.</p> <p>Also, this router can be fully used as an <code>HttpRouter</code> (of which it is the inheritor). So, you can use it to declare any <code>get</code>, <code>post</code>, <code>put</code> and other HTTP methods. For example, this is done at line 19.</p> <p>Warning</p> <p>If your ASGI server does not support installing state inside lifespan, you can disable this behavior as follows:</p> <pre><code>router = StreamRouter(..., setup_state=False)\n</code></pre> <p>However, after that, you will not be able to access the broker from your application's state (but it is still available as the <code>router.broker</code>).</p>"},{"location":"getting-started/integrations/fastapi/#accessing-the-broker-object","title":"Accessing the Broker Object","text":"<p>Inside each router, there is a broker. You can easily access it if you need to send a message to MQ:</p> KafkaRabbitMQ <pre><code>from fastapi import FastAPI\nfrom faststream.kafka.fastapi import KafkaRouter\nrouter = KafkaRouter(\"localhost:9092\")\napp = FastAPI(lifespan=router.lifespan_context)\n@router.get(\"/\")\nasync def hello_http():\nawait router.broker.publish(\"Hello, Kafka!\", \"test\")\nreturn \"Hello, HTTP!\"\napp.include_router(router)\n</code></pre> <pre><code>from fastapi import FastAPI\nfrom faststream.rabbit.fastapi import RabbitRouter\nrouter = RabbitRouter(\"amqp://guest:guest@localhost:5672/\")\napp = FastAPI(lifespan=router.lifespan_context)\n@router.get(\"/\")\nasync def hello_http():\nawait router.broker.publish(\"Hello, Rabbit!\", \"test\")\nreturn \"Hello, HTTP!\"\napp.include_router(router)\n</code></pre> <p>You can use the following <code>Depends</code> to access the broker if you want to use it at different parts of your program:</p> KafkaRabbitMQ <pre><code>from fastapi import Depends, FastAPI\nfrom typing_extensions import Annotated\nfrom faststream.kafka import KafkaBroker, fastapi\nrouter = fastapi.KafkaRouter(\"localhost:9092\")\napp = FastAPI(lifespan=router.lifespan_context)\ndef broker():\nreturn router.broker\n@router.get(\"/\")\nasync def hello_http(broker: Annotated[KafkaBroker, Depends(broker)]):\nawait broker.publish(\"Hello, Kafka!\", \"test\")\nreturn \"Hello, HTTP!\"\napp.include_router(router)\n</code></pre> <pre><code>from fastapi import Depends, FastAPI\nfrom typing_extensions import Annotated\nfrom faststream.rabbit import RabbitBroker, fastapi\nrouter = fastapi.RabbitRouter(\"amqp://guest:guest@localhost:5672/\")\napp = FastAPI(lifespan=router.lifespan_context)\ndef broker():\nreturn router.broker\n@router.get(\"/\")\nasync def hello_http(broker: Annotated[RabbitBroker, Depends(broker)]):\nawait broker.publish(\"Hello, Rabbit!\", \"test\")\nreturn \"Hello, HTTP!\"\napp.include_router(router)\n</code></pre> <p>Or you can access the broker from a FastAPI application state:</p> <pre><code>from fastapi import Request\n@app.get(\"/\")\ndef main(request: Request):\nbroker = request.state.broker\n</code></pre>"},{"location":"getting-started/integrations/fastapi/#after_startup","title":"<code>@after_startup</code>","text":"<p>The <code>FastStream</code> application has the <code>@after_startup</code> hook, which allows you to perform operations with your message broker after the connection is established. This can be extremely convenient for managing your brokers' objects and/or sending messages. This hook is also available for your FastAPI StreamRouter</p> KafkaRabbitMQ <pre><code>from fastapi import FastAPI\nfrom faststream.kafka.fastapi import KafkaRouter\nrouter = KafkaRouter(\"localhost:9092\")\n@router.subscriber(\"test\")\nasync def hello(msg: str):\nreturn {\"response\": \"Hello, world!\"}\n@router.after_startup\nasync def test(app: FastAPI):\nawait router.broker.publish(\"Hello!\", \"test\")\napp = FastAPI(lifespan=router.lifespan_context)\napp.include_router(router)\n</code></pre> <pre><code>from fastapi import FastAPI\nfrom faststream.rabbit.fastapi import RabbitRouter\nrouter = RabbitRouter(\"amqp://guest:guest@localhost:5672/\")\n@router.subscriber(\"test\")\nasync def hello(msg: str):\nreturn {\"response\": \"Hello, world!\"}\n@router.after_startup\nasync def test(app: FastAPI):\nawait router.broker.publish(\"Hello!\", \"test\")\napp = FastAPI(lifespan=router.lifespan_context)\napp.include_router(router)\n</code></pre>"},{"location":"getting-started/integrations/fastapi/#documentation","title":"Documentation","text":"<p>When using FastStream as a router for FastAPI, the framework automatically registers endpoints for hosting AsyncAPI documentation into your application with the following default values:</p> KafkaRabbitMQ <pre><code>from faststream.kafka.fastapi import KafkaRouter\nrouter = KafkaRouter(\n...,\nschema_url=\"/asyncapi\",\ninclude_in_schema=True,\n)\n</code></pre> <pre><code>from faststream.rabbit.fastapi import RabbitRouter\nrouter = RabbitRouter(\n...,\nschema_url=\"/asyncapi\",\ninclude_in_schema=True,\n)\n</code></pre> <p>This way, you will have three routes to interact with your application's AsyncAPI schema:</p> <ul> <li><code>/asyncapi</code> - the same as the CLI created page</li> <li><code>/asyncapi.json</code> - download the JSON schema representation</li> <li><code>/asyncapi.yaml</code> - download the YAML schema representation</li> </ul>"},{"location":"getting-started/integrations/fastapi/#testing","title":"Testing","text":"<p>To test your FastAPI StreamRouter, you can still use it with the TestClient:</p> KafkaRabbitMQ <pre><code>import pytest\nfrom faststream.kafka import TestKafkaBroker, fastapi\nrouter = fastapi.KafkaRouter()\n@router.subscriber(\"test\")\nasync def handler(msg: str):\n...\n@pytest.mark.asyncio\nasync def test_router():\nasync with TestKafkaBroker(router.broker) as br:\nawait br.publish(\"Hi!\", \"test\")\nhandler.mock.assert_called_once_with(\"Hi!\")\n</code></pre> <pre><code>import pytest\nfrom faststream.rabbit import TestRabbitBroker, fastapi\nrouter = fastapi.RabbitRouter()\n@router.subscriber(\"test\")\nasync def handler(msg: str):\n...\n@pytest.mark.asyncio\nasync def test_router():\nasync with TestRabbitBroker(router.broker) as br:\nawait br.publish(\"Hi!\", \"test\")\nhandler.mock.assert_called_once_with(\"Hi!\")\n</code></pre>"},{"location":"getting-started/integrations/frameworks/","title":"INTEGRATIONS","text":"<p>FastStream brokers are very easy to integrate with any of your applications: it is enough to initialize the broker at startup and close it correctly at the end of your application.</p> <p>Most HTTP frameworks have built-in lifecycle hooks for this.</p> FastAPIAiohttpBlacksheepFalconQuartSanic <p>Tip</p> <p>If you want to use FastStream in conjunction with FastAPI, perhaps you should use a special plugin</p> <pre><code>from contextlib import asynccontextmanager\nfrom fastapi import FastAPI\nfrom faststream.kafka import KafkaBroker\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastAPI()\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\nawait broker.start()\nyield\nawait broker.close()\n@broker.subscriber(\"test\")\nasync def base_handler(body):\nprint(body)\n@app.get(\"/\")\ndef read_root():\nreturn {\"Hello\": \"World\"}\n</code></pre> <pre><code>from aiohttp import web\nfrom faststream.kafka import KafkaBroker\nbroker = KafkaBroker(\"localhost:9092\")\n@broker.subscriber(\"test\")\nasync def base_handler(body):\nprint(body)\nasync def start_broker(app):\nawait broker.start()\nasync def stop_broker(app):\nawait broker.close()\nasync def hello(request):\nreturn web.Response(text=\"Hello, world\")\napp = web.Application()\napp.add_routes([web.get(\"/\", hello)])\napp.on_startup.append(start_broker)\napp.on_cleanup.append(stop_broker)\nif __name__ == \"__main__\":\nweb.run_app(app)\n</code></pre> <pre><code>from blacksheep import Application\nfrom faststream.kafka import KafkaBroker\nbroker = KafkaBroker(\"localhost:9092\")\napp = Application()\n@broker.subscriber(\"test\")\nasync def base_handler(body):\nprint(body)\n@app.on_start\nasync def start_broker(application: Application) -&gt; None:\nawait broker.start()\n@app.on_stop\nasync def stop_broker(application: Application) -&gt; None:\nawait broker.close()\n@app.route(\"/\")\nasync def home():\nreturn \"Hello, World!\"\n</code></pre> <pre><code>import falcon\nimport falcon.asgi\nfrom faststream.kafka import KafkaBroker\nbroker = KafkaBroker(\"localhost:9092\")\n@broker.subscriber(\"test\")\nasync def base_handler(body):\nprint(body)\nclass ThingsResource:\nasync def on_get(self, req, resp):\nresp.status = falcon.HTTP_200\nresp.content_type = falcon.MEDIA_TEXT\nresp.text = (\n\"\\nTwo things awe me most, the starry sky \"\n\"above me and the moral law within me.\\n\"\n\"\\n\"\n\"    ~ Immanuel Kant\\n\\n\"\n)\nclass PropanMiddleware:\nasync def process_startup(self, scope, event):\nawait broker.start()\nasync def process_shutdown(self, scope, event):\nawait broker.close()\napp = falcon.asgi.App()\napp.add_middleware(PropanMiddleware())\napp.add_route(\"/things\", ThingsResource())\n</code></pre> <pre><code>from quart import Quart\nfrom faststream.kafka import KafkaBroker\nbroker = KafkaBroker(\"localhost:9092\")\napp = Quart(__name__)\n@broker.subscriber(\"test\")\nasync def base_handler(body):\nprint(body)\n@app.before_serving\nasync def start_broker():\nawait broker.start()\n@app.after_serving\nasync def stop_broker():\nawait broker.close()\n@app.route(\"/\")\nasync def json():\nreturn {\"hello\": \"world\"}\n</code></pre> <pre><code>from sanic import Sanic\nfrom sanic.response import text\nfrom faststream.kafka import KafkaBroker\nbroker = KafkaBroker(\"localhost:9092\")\napp = Sanic(\"MyHelloWorldApp\")\n@broker.subscriber(\"test\")\nasync def base_handler(body):\nprint(body)\n@app.after_server_start\nasync def start_broker(app, loop):\nawait broker.start()\n@app.after_server_stop\nasync def stop_broker(app, loop):\nawait broker.close()\n@app.get(\"/\")\nasync def hello_world(request):\nreturn text(\"Hello, world.\")\n</code></pre> <p>However, even if such a hook is not provided, you can do it yourself.</p> Tornado <pre><code>import asyncio\nimport tornado.web\nfrom faststream.kafka import KafkaBroker\nbroker = KafkaBroker(\"localhost:9092\")\n@broker.subscriber(\"test\")\nasync def base_handler(body):\nprint(body)\nclass MainHandler(tornado.web.RequestHandler):\ndef get(self):\nself.write(\"Hello, world\")\ndef make_app():\nreturn tornado.web.Application(\n[\n(r\"/\", MainHandler),\n]\n)\nasync def main():\napp = make_app()\napp.listen(8888)\nawait broker.start()\ntry:\nawait asyncio.Event().wait()\nfinally:\nawait broker.close()\nif __name__ == \"__main__\":\nasyncio.run(main())\n</code></pre>"},{"location":"getting-started/lifespan/","title":"Lifespan Events","text":"<p>Sometimes you need to define the logic that should be executed before launching the application. This means that the code will be executed once - even before your application starts receiving messages.</p> <p>Also, you may need to terminate some processes after stopping the application. In this case, your code will also be executed exactly once: but after the completion of the main application.</p> <p>Since this code is executed before the application starts and after it stops, it covers the entire lifecycle (lifespan) of the application.</p> <p>This can be very useful for initializing your application settings at startup, raising a pool of connections to a database, or running machine learning models.</p>"},{"location":"getting-started/lifespan/hooks/","title":"Lifespan Hooks","text":""},{"location":"getting-started/lifespan/hooks/#usage-example","title":"Usage example","text":"<p>Let's imagine that your application uses pydantic as your settings manager.</p> <p>I highly recommend using pydantic for these purposes, because this dependency is already used at FastStream and you don't have to install an additional package</p> <p>Also, let's imagine that you have several <code>.env</code>, <code>.env.development</code>, <code>.env.test</code>, <code>.env.production</code> files with your application settings, and you want to switch them at startup without any code changes.</p> <p>By passing optional arguments with the command line to your code FastStream allows you to do this easily.</p>"},{"location":"getting-started/lifespan/hooks/#lifespan","title":"Lifespan","text":"<p>Let's write some code for our example</p> KafkaRabbitMQ <pre><code>from pydantic_settings import BaseSettings\nfrom faststream import ContextRepo, FastStream\nfrom faststream.kafka import KafkaBroker\nbroker = KafkaBroker()\napp = FastStream(broker)\nclass Settings(BaseSettings):\nhost: str = \"localhost:9092\"\n@app.on_startup\nasync def setup(context: ContextRepo, env: str = \".env\"):\nsettings = Settings(_env_file=env)\ncontext.set_global(\"settings\", settings)\nawait broker.connect(settings.host)\n</code></pre> <pre><code>from pydantic_settings import BaseSettings\nfrom faststream import ContextRepo, FastStream\nfrom faststream.rabbit import RabbitBroker\nbroker = RabbitBroker()\napp = FastStream(broker)\nclass Settings(BaseSettings):\nhost: str = \"amqp://guest:guest@localhost:5672/\" # pragma: allowlist secret\n@app.on_startup\nasync def setup(context: ContextRepo, env: str = \".env\"):\nsettings = Settings(_env_file=env)\ncontext.set_global(\"settings\", settings)\nawait broker.connect(settings.host)\n</code></pre> <p>Now this application can be run using the following command to manage the environment:</p> <pre><code>faststream run serve:app --env .env.test\n</code></pre>"},{"location":"getting-started/lifespan/hooks/#details","title":"Details","text":"<p>Now let's look into a little more detail</p> <p>To begin with, we used a decorator</p> KafkaRabbitMQ <pre><code>@app.on_startup\nasync def setup(context: ContextRepo, env: str = \".env\"):\nsettings = Settings(_env_file=env)\ncontext.set_global(\"settings\", settings)\nawait broker.connect(settings.host)\n</code></pre> <pre><code>@app.on_startup\nasync def setup(context: ContextRepo, env: str = \".env\"):\nsettings = Settings(_env_file=env)\ncontext.set_global(\"settings\", settings)\nawait broker.connect(settings.host)\n</code></pre> <p>to declare a function that should run when our application starts</p> <p>The next step is to declare the arguments that our function will receive</p> KafkaRabbitMQ <pre><code>@app.on_startup\nasync def setup(context: ContextRepo, env: str = \".env\"):\nsettings = Settings(_env_file=env)\ncontext.set_global(\"settings\", settings)\nawait broker.connect(settings.host)\n</code></pre> <pre><code>@app.on_startup\nasync def setup(context: ContextRepo, env: str = \".env\"):\nsettings = Settings(_env_file=env)\ncontext.set_global(\"settings\", settings)\nawait broker.connect(settings.host)\n</code></pre> <p>In this case, the <code>env</code> field will be passed to the <code>setup</code> function from the arguments with the command line</p> <p>Tip</p> <p>The default lifecycle functions are used with the decorator <code>@apply_types</code>, therefore, all context fields and dependencies are available in them</p> <p>Then, we initialized the settings of our application using the file passed to us from the command line</p> KafkaRabbitMQ <pre><code>@app.on_startup\nasync def setup(context: ContextRepo, env: str = \".env\"):\nsettings = Settings(_env_file=env)\ncontext.set_global(\"settings\", settings)\nawait broker.connect(settings.host)\n</code></pre> <pre><code>@app.on_startup\nasync def setup(context: ContextRepo, env: str = \".env\"):\nsettings = Settings(_env_file=env)\ncontext.set_global(\"settings\", settings)\nawait broker.connect(settings.host)\n</code></pre> <p>And put these settings in a global context</p> KafkaRabbitMQ <pre><code>@app.on_startup\nasync def setup(context: ContextRepo, env: str = \".env\"):\nsettings = Settings(_env_file=env)\ncontext.set_global(\"settings\", settings)\nawait broker.connect(settings.host)\n</code></pre> <pre><code>@app.on_startup\nasync def setup(context: ContextRepo, env: str = \".env\"):\nsettings = Settings(_env_file=env)\ncontext.set_global(\"settings\", settings)\nawait broker.connect(settings.host)\n</code></pre> Note <p>Now we can access our settings anywhere in the application right from the context</p> <pre><code>from faststream import Context, apply_types\n@apply_types\nasync def func(settings = Context()): ...\n</code></pre> <p>The last step we initialized our broker: now, when the application starts, it will be ready to receive messages</p> KafkaRabbitMQ <pre><code>@app.on_startup\nasync def setup(context: ContextRepo, env: str = \".env\"):\nsettings = Settings(_env_file=env)\ncontext.set_global(\"settings\", settings)\nawait broker.connect(settings.host)\n</code></pre> <pre><code>@app.on_startup\nasync def setup(context: ContextRepo, env: str = \".env\"):\nsettings = Settings(_env_file=env)\ncontext.set_global(\"settings\", settings)\nawait broker.connect(settings.host)\n</code></pre>"},{"location":"getting-started/lifespan/hooks/#another-example","title":"Another example","text":"<p>Now let's imagine that we have a machine learning model that needs to process messages from some broker.</p> <p>Initialization of such models usually takes a long time. It would be wise to do this at the start of the application, and not when processing each message.</p> <p>You can initialize your model somewhere at the top of your module/file. However, in this case, this code will be run even just in case of importing this module, for example, during testing. It is unlikely that you want to run your model on every test run...</p> <p>Therefore, it is worth initializing the model in the <code>@app.on_startup</code> hook.</p> <p>Also, we don't want the model to finish its work incorrectly when the application is stopped. To avoid this, we need the hook <code>@app.on_shutdown</code></p> KafkaRabbitMQ <pre><code>from faststream import Context, ContextRepo, FastStream\nfrom faststream.kafka import KafkaBroker\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\nml_models = {}  # fake ML model\ndef fake_answer_to_everything_ml_model(x: float):\nreturn x * 42\n@app.on_startup\nasync def setup_model(context: ContextRepo):\n# Load the ML model\nml_models[\"answer_to_everything\"] = fake_answer_to_everything_ml_model\ncontext.set_global(\"model\", ml_models)\n@app.on_shutdown\nasync def shutdown_model(model: dict = Context()):\n# Clean up the ML models and release the resources\nmodel.clear()\n@broker.subscriber(\"test\")\nasync def predict(x: float, model=Context()):\nresult = model[\"answer_to_everything\"](x)\nreturn {\"result\": result}\n</code></pre> <pre><code>from faststream import Context, ContextRepo, FastStream\nfrom faststream.rabbit import RabbitBroker\nbroker = RabbitBroker(\"amqp://guest:guest@localhost:5672/\")\napp = FastStream(broker)\nml_models = {}  # fake ML model\ndef fake_answer_to_everything_ml_model(x: float):\nreturn x * 42\n@app.on_startup\nasync def setup_model(context: ContextRepo):\n# Load the ML model\nml_models[\"answer_to_everything\"] = fake_answer_to_everything_ml_model\ncontext.set_global(\"model\", ml_models)\n@app.on_shutdown\nasync def shutdown_model(model: dict = Context()):\n# Clean up the ML models and release the resources\nmodel.clear()\n@broker.subscriber(\"test\")\nasync def predict(x: float, model=Context()):\nresult = model[\"answer_to_everything\"](x)\nreturn {\"result\": result}\n</code></pre>"},{"location":"getting-started/lifespan/hooks/#multiple-hooks","title":"Multiple hooks","text":"<p>If you want to declare multiple lifecycle hooks, they will be used in the order they are registered:</p> <pre><code>from faststream import Context, ContextRepo, FastStream\napp = FastStream()\n@app.on_startup\nasync def setup(context: ContextRepo):\ncontext.set_global(\"field\", 1)\n@app.on_startup\nasync def setup_later(field: int = Context()):\nassert field == 1\n</code></pre>"},{"location":"getting-started/lifespan/hooks/#some-more-details","title":"Some more details","text":""},{"location":"getting-started/lifespan/hooks/#async-or-not-async","title":"Async or not async","text":"<p>In the asynchronous version of the application, both asynchronous and synchronous methods can be used as hooks. In the synchronous version, only synchronous methods are available.</p>"},{"location":"getting-started/lifespan/hooks/#command-line-arguments","title":"Command line arguments","text":"<p>Command line arguments are available in all <code>@app.on_startup</code> hooks. To use them in other parts of the application, put them in the <code>ContextRepo</code>.</p>"},{"location":"getting-started/lifespan/hooks/#broker-initialization","title":"Broker initialization","text":"<p>The <code>@app.on_startup</code> hooks are called BEFORE the broker is launched by the application. The <code>@app.after_shutdown</code> hooks are triggered AFTER stopping the broker.</p> <p>If you want to perform some actions AFTER initializing the broker: send messages, initialize objects, etc., you should use the <code>@app.after_startup</code> hook.</p>"},{"location":"getting-started/lifespan/test/","title":"Events Testing","text":"<p>In the most cases you are testing your subsriber/publisher functions, but sometimes you need to trigger some lifespan hooks in your tests too.</p> <p>For this reason, FastStream has a special TestApp patcher working as a regular async context manager.</p> KafkaRabbitMQ <pre><code>import pytest\nfrom faststream import FastStream, TestApp\nfrom faststream.kafka import KafkaBroker, TestKafkaBroker\napp = FastStream(KafkaBroker())\n@app.after_startup\nasync def handle():\nprint(\"Calls in tests too!\")\n@pytest.mark.asyncio\nasync def test_lifespan():\nasync with TestKafkaBroker(app.broker):\nasync with TestApp(app):\n# test something\npass\n</code></pre> <pre><code>import pytest\nfrom faststream import FastStream, TestApp\nfrom faststream.rabbit import RabbitBroker, TestRabbitBroker\napp = FastStream(RabbitBroker())\n@app.after_startup\nasync def handle():\nprint(\"Calls in tests too!\")\n@pytest.mark.asyncio\nasync def test_lifespan():\nasync with TestRabbitBroker(app.broker):\nasync with TestApp(app):\n# test something\npass\n</code></pre> <p>Tip</p> <p>If you are using a connected broker inside withing your lifespan hooks, it's advisable to patch the broker first (before applying the application patch).</p>"},{"location":"getting-started/middlewares/","title":"Middlewares","text":"<p>Middlewares are a powerful mechanism that allows you to add additional logic to any stage of the message processing pipeline.</p> <p>This way, you can greatly extend your FastStream application with features such as:</p> <ul> <li>Integration with any logging/metrics systems</li> <li>Application-level message serialization logic</li> <li>Rich publishing of messages with extra information</li> <li>And many other capabilities</li> </ul> <p>Middlewares have several methods to override. You can implement some or all of them and use middlewares at the broker, router, or subscriber level. Thus, middlewares are the most flexible  FastStream feature.</p>"},{"location":"getting-started/middlewares/#message-receive-wrapper","title":"Message Receive Wrapper","text":"<p>Unfortunately, this powerful feature has a somewhat complex signature too.</p> <p>Using middlewares, you can wrap the entire message processing pipeline. In this case, you need to specify <code>on_receive</code> and <code>after_processed</code> methods:</p> <pre><code>from faststream import BaseMiddleware\nclass MyMiddleware(BaseMiddleware):\nasync def on_receive(self):\nprint(f\"Received: {self.message}\")\nreturn await super().on_receive()\nasync def after_processed(self, exc_type, exc_val, exec_tb):\nreturn await super().after_processed(exc_type, exc_val, exec_tb)\n</code></pre> <p>These methods should be overwritten only in a broker-level middlewares.</p> <pre><code>Broker(middlewares=[MyMiddleware])\n</code></pre> <p>In other cases, <code>on_receive</code> will be called at every subscriber filter function call.</p> <p>Tip</p> <p>Please always call <code>super()</code> methods at the end of your function; this is important for correct error processing.</p>"},{"location":"getting-started/middlewares/#message-consuming-wrapper","title":"Message Consuming Wrapper","text":"<p>Also, using middlewares, you are able to wrap consumer function calls directly.</p> <p>In this case, you need to specify <code>on_receive</code> and <code>after_processed</code> methods:</p> <pre><code>from typing import Optional\nfrom faststream import BaseMiddleware:\nfrom faststream.types import DecodedMessage\nclass MyMiddleware(BaseMiddleware):\nasync def on_consume(self, msg: DecodedMessage) -&gt; DecodedMessage:\nreturn await super().on_consume(msg)\nasync def after_consume(self, err: Optional[Exception]) -&gt; None:\nreturn await super().after_consume(err)\n</code></pre> <p>This way, you can patch the incoming message body right before passing it to your consumer subscriber.</p> <p>Also, if you have multiple filters for one subscriber, these methods will be called at once when the filtering is completed successfully.</p>"},{"location":"getting-started/middlewares/#message-publishing-wrapper","title":"Message Publishing Wrapper","text":"<p>Finally, using middlewares, you are able to patch outgoing messages too. For example, you can compress/encode outgoing messages at the application level.</p> <p>In this, case you need to specify <code>on_publish</code> and <code>after_publish</code> methods:</p> <pre><code>from typing import Optional\nfrom faststream import BaseMiddleware:\nfrom faststream.types import SendableMessage\nclass MyMiddleware(BaseMiddleware):\nasync def on_publish(self, msg: SendableMessage) -&gt; SendableMessage:\nreturn await super().on_publish(msg)\nasync def after_publish(self, err: Optional[Exception]) -&gt; None:\nreturn await super().after_publish(err)\n</code></pre>"},{"location":"getting-started/publishing/","title":"Publishing Basics","text":"<p>FastStream is broker-agnostic and easy to use, even as a client in non-FastStream applications.</p> <p>It offers several use cases for publishing messages:</p> <ul> <li>Using `broker.publish``</li> <li>Using a decorator</li> <li>Using a publisher object decorator</li> <li>Using a publisher object directly</li> </ul> <p>FastStream allows you to publish any JSON-serializable messages (Python types, Pydantic models, etc.) or raw bytes.</p> <p>It automatically sets up all required headers, especially the correlation_id, which is used to trace message processing pipelines across all services.</p> <p>To publish a message, simply set up the message content and a routing key:</p> KafkaRabbitMQ <pre><code>async with KafkaBroker() as br:\nawait br.publish(\"message\", \"topic\")\n</code></pre> <pre><code>async with RabbitBroker() as br:\nawait br.publish(\"message\", \"queue\")\n</code></pre>"},{"location":"getting-started/publishing/broker/","title":"Broker Publishing","text":"<p>The easiest way to publish a message is to use a Broker, which allows you to use it as a publisher client in any applications.</p> <p>In the FastStream project, this call is not represented in the AsyncAPI scheme. You can use it to send rarely-publishing messages, such as startup or shutdown events.</p> KafkaRabbitMQ <pre><code>from faststream import FastStream\nfrom faststream.kafka import KafkaBroker\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\n@broker.subscriber(\"test-topic\")\nasync def handle():\nawait broker.publish(\"Hi!\", topic=\"another-topic\")\n@broker.subscriber(\"another-topic\")\nasync def handle_next(msg: str):\nassert msg == \"Hi!\"\n@app.after_startup\nasync def test():\nawait broker.publish(\"\", topic=\"test-topic\")\n</code></pre> <pre><code>from faststream import FastStream\nfrom faststream.rabbit import RabbitBroker\nbroker = RabbitBroker(\"amqp://guest:guest@localhost:5672/\")\napp = FastStream(broker)\n@broker.subscriber(\"test-queue\")\nasync def handle():\nawait broker.publish(\"Hi!\", queue=\"another-queue\")\n@broker.subscriber(\"another-queue\")\nasync def handle_next(msg: str):\nassert msg == \"Hi!\"\n@app.after_startup\nasync def test():\nawait broker.publish(\"\", queue=\"test-queue\")\n</code></pre>"},{"location":"getting-started/publishing/decorator/","title":"Publisher Decorator","text":"<p>The second easiest way to publish messages is by using the Publisher Decorator. This method has an AsyncAPI representation and is suitable for quickly creating applications. However, it doesn't provide all testing features.</p> <p>It creates a structured DataPipeline unit with an input and output. The order of Subscriber and Publisher decorators doesn't matter, but they can only be used with functions decorated by a <code>subscriber</code> as well.</p> <p>It uses the handler function's return type annotation to cast the function's return value before sending, so be accurate with it:</p> KafkaRabbitMQ <pre><code>from faststream import FastStream\nfrom faststream.kafka import KafkaBroker\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\n@broker.subscriber(\"test-topic\")\n@broker.publisher(\"another-topic\")\nasync def handle() -&gt; str:\nreturn \"Hi!\"\n@broker.subscriber(\"another-topic\")\nasync def handle_next(msg: str):\nassert msg == \"Hi!\"\n@app.after_startup\nasync def test():\nawait broker.publish(\"\", topic=\"test-topic\")\n</code></pre> <pre><code>from faststream import FastStream\nfrom faststream.rabbit import RabbitBroker\nbroker = RabbitBroker(\"amqp://guest:guest@localhost:5672/\")\napp = FastStream(broker)\n@broker.subscriber(\"test-queue\")\n@broker.publisher(\"another-queue\")\nasync def handle() -&gt; str:\nreturn \"Hi!\"\n@broker.subscriber(\"another-queue\")\nasync def handle_next(msg: str):\nassert msg == \"Hi!\"\n@app.after_startup\nasync def test():\nawait broker.publish(\"\", queue=\"test-queue\")\n</code></pre> <p>It can be used multiple times with one function to broadcast the function's return:</p> <pre><code>@broker.subscriber(\"in\")\n@broker.publisher(\"first-out\")\n@broker.publisher(\"second-out\")\nasync def handle(msg) -&gt; str:\nreturn \"Response\"\n</code></pre> <p>Additionally, it automatically sends a message with the same <code>correlation_id</code> as the incoming message. This way, you get the same <code>correlation_id</code> for the entire message pipeline process across all services, allowing you to collect a trace.</p>"},{"location":"getting-started/publishing/direct/","title":"Publisher Direct Usage","text":"<p>The Publisher Direct Usage is a full-featured way to publish messages. It has AsyncAPI representation and includes testable features. This method creates a reusable Publisher object that can be used directly to publish a message:</p> KafkaRabbitMQ <pre><code>from faststream import FastStream\nfrom faststream.kafka import KafkaBroker\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\npublisher = broker.publisher(\"another-topic\")\n@broker.subscriber(\"test-topic\")\nasync def handle():\nawait publisher.publish(\"Hi!\")\n@broker.subscriber(\"another-topic\")\nasync def handle_next(msg: str):\nassert msg == \"Hi!\"\n@app.after_startup\nasync def test():\nawait broker.publish(\"\", topic=\"test-topic\")\n</code></pre> <pre><code>from faststream import FastStream\nfrom faststream.rabbit import RabbitBroker\nbroker = RabbitBroker(\"amqp://guest:guest@localhost:5672/\")\napp = FastStream(broker)\npublisher = broker.publisher(\"another-queue\")\n@broker.subscriber(\"test-queue\")\nasync def handle():\nawait publisher.publish(\"Hi!\")\n@broker.subscriber(\"another-queue\")\nasync def handle_next(msg: str):\nassert msg == \"Hi!\"\n@app.after_startup\nasync def test():\nawait broker.publish(\"\", queue=\"test-queue\")\n</code></pre> <p>It is suitable for publishing different messages to different outputs within the same processing function:</p> <pre><code>@broker.subscriber(\"in\")\nasync def handle(msg) -&gt; str:\nawait publisher1.publish(\"Response-1\")\nawait publisher2.publish(\"Response-2\")\n</code></pre>"},{"location":"getting-started/publishing/object/","title":"Publisher Object","text":"<p>The Publisher Object provides a full-featured way to publish messages. It has AsyncAPI representation and includes testable features. This method creates a reusable Publisher object.</p> <p>It can be used as a function decorator. The order of Subscriber and Publisher decorators doesn't matter, but they can only be used with functions decorated by a <code>subscriber</code> decorator.</p> <p>It also uses the handler function's return type annotation to cast the function's return value before sending, so be accurate with it:</p> KafkaRabbitMQ <pre><code>from faststream import FastStream\nfrom faststream.kafka import KafkaBroker\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\npublisher = broker.publisher(\"another-topic\")\n@publisher\n@broker.subscriber(\"test-topic\")\nasync def handle() -&gt; str:\nreturn \"Hi!\"\n@broker.subscriber(\"another-topic\")\nasync def handle_next(msg: str):\nassert msg == \"Hi!\"\n@app.after_startup\nasync def test():\nawait broker.publish(\"\", topic=\"test-topic\")\n</code></pre> <pre><code>from faststream import FastStream\nfrom faststream.rabbit import RabbitBroker\nbroker = RabbitBroker(\"amqp://guest:guest@localhost:5672/\")\napp = FastStream(broker)\npublisher = broker.publisher(\"another-queue\")\n@publisher\n@broker.subscriber(\"test-queue\")\nasync def handle() -&gt; str:\nreturn \"Hi!\"\n@broker.subscriber(\"another-queue\")\nasync def handle_next(msg: str):\nassert msg == \"Hi!\"\n@app.after_startup\nasync def test():\nawait broker.publish(\"\", queue=\"test-queue\")\n</code></pre> <p>You can use it multiple times with one function to broadcast the function's return:</p> <pre><code>@publisher1\n@publisher2\n@broker.subscriber(\"in\")\nasync def handle(msg) -&gt; str:\nreturn \"Response\"\n</code></pre> <p>Additionally, it automatically sends a message with the same <code>correlation_id</code> as the incoming message. This way, you get the same correlation_id for the entire message pipeline process across all services, allowing you to collect a trace.</p>"},{"location":"getting-started/publishing/test/","title":"Publisher Testing","text":"<p>If you are working with a Publisher object (either decorator or direct), you can check outgoing messages as well. There are several testing features available:</p> <ul> <li>In-memory TestClient</li> <li>Publishing (including error handling)</li> <li>Checking the incoming message body</li> <li>Note about mock clearing after the context exits</li> </ul>"},{"location":"getting-started/publishing/test/#base-application","title":"Base application","text":"DecoratorDirect KafkaRabbitMQ <pre><code>publisher = broker.publisher(\"another-topic\")\n@publisher\n@broker.subscriber(\"test-topic\")\nasync def handle() -&gt; str:\n</code></pre> <pre><code>publisher = broker.publisher(\"another-queue\")\n@publisher\n@broker.subscriber(\"test-queue\")\nasync def handle() -&gt; str:\n</code></pre> KafkaRabbitMQ <pre><code>publisher = broker.publisher(\"another-topic\")\n@broker.subscriber(\"test-topic\")\nasync def handle():\n</code></pre> <pre><code>publisher = broker.publisher(\"another-queue\")\n@broker.subscriber(\"test-queue\")\nasync def handle():\n</code></pre>"},{"location":"getting-started/publishing/test/#testing","title":"Testing","text":"KafkaRabbitMQ <pre><code>import pytest\nfrom faststream.kafka import TestKafkaBroker\n@pytest.mark.asyncio\nasync def test_handle():\nasync with TestKafkaBroker(broker) as br:\nawait br.publish(\"\", topic=\"test-topic\")\n</code></pre> <pre><code>import pytest\nfrom faststream.rabbit import TestRabbitBroker\n@pytest.mark.asyncio\nasync def test_handle():\nasync with TestRabbitBroker(broker) as br:\nawait br.publish(\"\", queue=\"test-queue\")\n</code></pre> <ul> <li>Testing with a real broker</li> <li>Waiting for the consumer to be called</li> </ul>"},{"location":"getting-started/routers/","title":"Broker Router","text":"<p>Sometimes you want to:</p> <ul> <li>split an application into includable modules</li> <li>separate business logic from your handler registration</li> <li>apply some decoder/middleware/dependencies to a subscribers group</li> </ul> <p>For these reasons, FastStream has a special Broker Router.</p>"},{"location":"getting-started/routers/#router-usage","title":"Router Usage","text":"<p>First, you need to import the Broker Router from the same module from where you imported the broker.</p> <p>When creating a Broker Router, you can specify a prefix that will be automatically applied to all subscribers and publishers of this router.</p> KafkaRabbitMQ <pre><code>from faststream import FastStream\nfrom faststream.kafka import KafkaBroker, KafkaRouter\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\nrouter = KafkaRouter(prefix=\"prefix_\")\n</code></pre> <pre><code>from faststream import FastStream\nfrom faststream.rabbit import RabbitBroker, RabbitRouter\nbroker = RabbitBroker(\"amqp://guest:guest@localhost:5672/\")\napp = FastStream(broker)\nrouter = RabbitRouter(prefix=\"prefix_\")\n</code></pre> <p>Now you can use the created router to register handlers and publishers as if it were a regular broker</p> KafkaRabbitMQ <pre><code>@router.subscriber(\"test-topic\")\n@router.publisher(\"another-topic\")\nasync def handle(name: str, user_id: int) -&gt; str:\nassert name == \"John\"\nassert user_id == 1\nreturn \"Hi!\"\n@router.subscriber(\"another-topic\")\nasync def handle_response(msg: str):\nassert msg == \"Hi!\"\n</code></pre> <pre><code>@router.subscriber(\"test-queue\")\n@router.publisher(\"another-queue\")\nasync def handle(name: str, user_id: int) -&gt; str:\nassert name == \"John\"\nassert user_id == 1\nreturn \"Hi!\"\n@router.subscriber(\"another-queue\")\nasync def handle_response(msg: str):\nassert msg == \"Hi!\"\n</code></pre> <p>Then you can simply include all the handlers declared using the router in your broker</p> KafkaRabbitMQ <pre><code>broker.include_router(router)\n</code></pre> <pre><code>broker.include_router(router)\n</code></pre> <p>Please note that when publishing a message, you now need to specify the same prefix that you used when creating the router</p> KafkaRabbitMQ <pre><code>    await broker.publish(\n{\"name\": \"John\", \"user_id\": 1},\ntopic=\"prefix_test-topic\",\n)\n</code></pre> <pre><code>    await broker.publish(\n{\"name\": \"John\", \"user_id\": 1},\nqueue=\"prefix_test-queue\",\n)\n</code></pre> <p>Tip</p> <p>Also, when creating a Broker Router, you can specify middleware, dependencies, parser and decoder to apply them to all subscribers declared via this router.</p>"},{"location":"getting-started/routers/#delay-handler-registration","title":"Delay Handler Registration","text":"<p>If you want to separate your application's core logic from FastStream's routing logic, you can write some core functions and use them as Broker Router <code>handlers</code> later:</p> KafkaRabbitMQ <pre><code>from faststream import FastStream\nfrom faststream.kafka import KafkaBroker, KafkaRoute, KafkaRouter\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\nasync def handle(name: str, user_id: int):\nassert name == \"John\"\nassert user_id == 1\nrouter = KafkaRouter(handlers=(KafkaRoute(handle, \"test-topic\"),))\nbroker.include_router(router)\n</code></pre> <pre><code>from faststream import FastStream\nfrom faststream.rabbit import RabbitBroker, RabbitRoute, RabbitRouter\nbroker = RabbitBroker(\"amqp://guest:guest@localhost:5672/\")\napp = FastStream(broker)\nasync def handle(name: str, user_id: int):\nassert name == \"John\"\nassert user_id == 1\nrouter = RabbitRouter(handlers=(RabbitRoute(handle, \"test-queue\"),))\nbroker.include_router(router)\n</code></pre> <p>Warning</p> <p>Be careful, this way you won't be able to test your handlers with a <code>mock</code> object.</p>"},{"location":"getting-started/serialization/","title":"Custom Serialization","text":"<p>By default, FastStream uses the JSON format to send and receive messages. However, if you need to handle messages in other formats or with additional serialization steps, such as gzip, lz4, Avro, Protobuf or Msgpack, you can easily modify the serialization logic.</p>"},{"location":"getting-started/serialization/#serialization-steps","title":"Serialization Steps","text":"<p>Before the message reaches your subscriber, FastStream applies two functions to it sequentially: <code>parse_message</code> and <code>decode_message</code>. You can modify one or both stages depending on your needs.</p>"},{"location":"getting-started/serialization/#message-parsing","title":"Message Parsing","text":"<p>At this stage, FastStream serializes an incoming message from the broker's framework into a general format called - StreamMessage. During this stage, the message body remains in the form of raw bytes.</p> <p>This stage is closely related to the features of the broker used, and in most cases, redefining it is not necessary.</p> <p>The parser declared at the <code>broker</code> level will be applied to all subscribers. The parser declared at the <code>subscriber</code> level is applied only to that specific subscriber and overrides the `broker' parser if specified.</p>"},{"location":"getting-started/serialization/#message-decoding","title":"Message Decoding","text":"<p>At this stage, the body of the StreamMessage is transformed into a format suitable for processing within your subscriber function. This is the stage you may need to redefine more often.</p>"},{"location":"getting-started/serialization/decoder/","title":"Custom Decoder","text":"<p>At this stage, the body of a StreamMessage is transformed into the format that it will take when it enters your handler function. This stage is the one you will need to redefine more often.</p>"},{"location":"getting-started/serialization/decoder/#signature","title":"Signature","text":"<p>The original decoder function has a relatively simple signature (this is a simplified version):</p> KafkaRabbitMQ <pre><code>from faststream.types import DecodedMessage\nfrom faststream.kafka import KafkaMessage\ndef decoder(msg: KafkaMessage) -&gt; DecodedMessage:\n...\n</code></pre> <pre><code>from faststream.types import DecodedMessage\nfrom faststream.rabbit import RabbitMessage\ndef decoder(msg: RabbitMessage) -&gt; DecodedMessage:\n...\n</code></pre> <p>Alternatively, you can reuse the original decoder function with the following signature:</p> KafkaRabbitMQ <pre><code>from types import Callable, Awaitable\nfrom faststream.types import DecodedMessage\nfrom faststream.kafka import KafkaMessage\nasync def decoder(\nmsg: KafkaMessage,\noriginal_decoder: Callable[[KafkaMessage], Awaitable[DecodedMessage]],\n) -&gt; DecodedMessage:\nreturn await original_decoder(msg)\n</code></pre> <pre><code>from types import Callable, Awaitable\nfrom faststream.types import DecodedMessage\nfrom faststream.rabbit import RabbitMessage\nasync def decoder(\nmsg: RabbitMessage,\noriginal_decoder: Callable[[RabbitMessage], Awaitable[DecodedMessage]],\n) -&gt; DecodedMessage:\nreturn await original_decoder(msg)\n</code></pre> <p>Note</p> <p>The original decoder is always an asynchronous function, so your custom decoder should also be asynchronous.</p> <p>Afterward, you can set this custom decoder at the broker or subscriber level.</p>"},{"location":"getting-started/serialization/decoder/#example","title":"Example","text":"<p>You can find examples of Protobuf and Msgpack serialization in the next article.</p>"},{"location":"getting-started/serialization/examples/","title":"Serialization examples","text":""},{"location":"getting-started/serialization/examples/#protobuf","title":"Protobuf","text":"<p>In this section, we will explore an example using Protobuf. However, this approach is also applicable to other serialization methods.</p> Protobuf <p>Protobuf is an alternative message serialization method commonly used in GRPC.  Its main advantage is that it results in much smaller message sizes<sup>1</sup> compared to JSON, but it requires a message schema (<code>.proto</code> files) on both the client and server sides.</p> <p>To begin, install the necessary dependencies:</p> <pre><code>pip install grpcio-tools\n</code></pre> <p>Next, let's define the schema for our message:</p> message.proto<pre><code>syntax = \"proto3\";\nmessage Person {\nstring name = 1;\nfloat age = 2;\n}\n</code></pre> <p>Now, generate a Python class to work with messages in Protobuf format:</p> <pre><code>python -m grpc_tools.protoc --python_out=. --pyi_out=. -I . message.proto\n</code></pre> <p>This generates two files: <code>message_pb2.py</code> and <code>message_pb2.pyi</code>. We can use the generated class to serialize our messages:</p> <pre><code>from message_pb2 import Person\nfrom faststream import FastStream, Logger, NoCast\nfrom faststream.rabbit import RabbitBroker, RabbitMessage\nbroker = RabbitBroker()\napp = FastStream(broker)\nasync def decode_message(msg: RabbitMessage) -&gt; Person:\ndecoded = Person()\ndecoded.ParseFromString(msg.body)\nreturn decoded\n@broker.subscriber(\"test\", decoder=decode_message)\nasync def consume(body: NoCast[Person], logger: Logger):\nlogger.info(body)\n@app.after_startup\nasync def publish():\nbody = Person(name=\"John\", age=25).SerializeToString()\nawait broker.publish(body, \"test\")\n</code></pre> <p>Note that we used the <code>NoCast</code> annotation to exclude the message from the <code>pydantic</code> representation of our handler.</p> <pre><code>async def consume(body: NoCast[Person], logger: Logger):\n</code></pre>"},{"location":"getting-started/serialization/examples/#msgpack","title":"Msgpack","text":"<p>Msgpack is another alternative binary data format. Its main advantage is that it results in smaller message sizes<sup>2</sup> compared to JSON, although slightly larger than Protobuf. The key advantage is that it doesn't require a message schema, making it easy to use in most cases.</p> <p>To get started, install the necessary dependencies:</p> <pre><code>pip install msgpack\n</code></pre> <p>Since there is no need for a schema, you can easily write a Msgpack decoder:</p> <pre><code>import msgpack\nfrom faststream import FastStream, Logger\nfrom faststream.rabbit import RabbitBroker, RabbitMessage\nbroker = RabbitBroker()\napp = FastStream(broker)\nasync def decode_message(msg: RabbitMessage):\nreturn msgpack.loads(msg.body)\n@broker.subscriber(\"test\", decoder=decode_message)\nasync def consume(body, logger: Logger):\nlogger.info(body)\n@app.after_startup\nasync def publish():\nbody = msgpack.dumps({\"name\": \"John\", \"age\": 25}, use_bin_type=True)\nawait broker.publish(body, \"test\")\n</code></pre> <p>Using Msgpack is much simpler than using Protobuf schemas. Therefore, if you don't have strict message size limitations, you can use Msgpack serialization in most cases.</p>"},{"location":"getting-started/serialization/examples/#tips","title":"Tips","text":""},{"location":"getting-started/serialization/examples/#data-compression","title":"Data Compression","text":"<p>If you are dealing with very large messages, consider compressing them as well. You can explore libraries such as lz4 or zstd for compression algorithms.</p> <p>Compression can significantly reduce message size, especially if there are repeated blocks. However, in the case of small message bodies, data compression may increase the message size. Therefore, you should assess the compression impact based on your specific application requirements.</p>"},{"location":"getting-started/serialization/examples/#broker-level-serialization","title":"Broker-Level Serialization","text":"<p>You can still set a custom <code>decoder</code> at the Broker or Router level. However, if you want to automatically encode publishing messages as well, you should explore Middleware for serialization implimentation.</p> <ol> <li> <p>For example, a message like <code>{ \"name\": \"John\", \"age\": 25 }</code> in JSON takes 27 bytes, while in Protobuf, it takes only 11 bytes. With lists and more complex structures, the savings can be even more significant (up to 20x times).\u00a0\u21a9</p> </li> <li> <p>A message with Msgpack serialization, such as <code>{ \"name\": \"John\", \"age\": 25 }</code>, takes 16 bytes.\u00a0\u21a9</p> </li> </ol>"},{"location":"getting-started/serialization/parser/","title":"Custom Parser","text":"<p>At this stage, FastStream serializes an incoming message from the broker's framework into a general format called StreamMessage. During this stage, the message body remains in the form of raw bytes.</p> <p>StreamMessage is a general representation of a message within FastStream. It contains all the information required for message processing within FastStreams.  It is even used to represent message batches, so the primary reason to customize it is to redefine the metadata associated with FastStream messages.</p> <p>For example, you can specify your own header with the <code>message_id</code> semantic. This allows you to inform FastStream about this custom header through parser customization.</p>"},{"location":"getting-started/serialization/parser/#signature","title":"Signature","text":"<p>To create a custom message parser, you should write a regular Python function (synchronous or asynchronous) with the following signature:</p> KafkaRabbitMQ <pre><code>from aiokafka import ConsumerRecord\nfrom faststream.kafka import KafkaMessage\ndef parser(msg: ConsumerRecord) -&gt; KafkaMessage:\n...\n</code></pre> <pre><code>from aio_pika import IncomingMessage\nfrom faststream.rabbit import RabbitMessage\ndef parser(msg: IncomingMessage) -&gt; RabbitMessage:\n...\n</code></pre> <p>Alternatively, you can reuse the original parser function with the following signature:</p> KafkaRabbitMQ <pre><code>from types import Callable, Awaitable\nfrom aiokafka import ConsumerRecord\nfrom faststream.kafka import KafkaMessage\nasync def parser(\nmsg: ConsumerRecord,\noriginal_parser: Callable[[ConsumerRecord], Awaitable[KafkaMessage]],\n) -&gt; KafkaMessage:\nreturn await original_parser(msg)\n</code></pre> <pre><code>from types import Callable, Awaitable\nfrom aio_pika import IncomingMessage\nfrom faststream.rabbit import RabbitMessage\nasync def parser(\nmsg: IncomingMessage,\noriginal_parser: Callable[[IncomingMessage], Awaitable[RabbitMessage]],\n) -&gt; RabbitMessage:\nreturn await original_parser(msg)\n</code></pre> <p>The argument naming doesn't matter; the parser will always be placed as the second argument.</p> <p>Note</p> <p>The original parser is always an asynchronous function, so your custom parser should also be asynchronous.</p> <p>Afterward, you can set this custom parser at the broker or subscriber level.</p>"},{"location":"getting-started/serialization/parser/#example","title":"Example","text":"<p>As an example, let's redefine <code>message_id</code> to a custom header:</p> KafkaRabbitMQ <pre><code>from typing import Awaitable, Callable\nfrom aiokafka import ConsumerRecord\nfrom faststream import FastStream\nfrom faststream.kafka import KafkaBroker, KafkaMessage\nasync def custom_parser(\nmsg: ConsumerRecord,\noriginal_parser: Callable[[ConsumerRecord], Awaitable[KafkaMessage]],\n) -&gt; KafkaMessage:\nparsed_msg = await original_parser(msg)\nparsed_msg.message_id = parsed_msg.headers[\"custom_message_id\"]\nreturn parsed_msg\nbroker = KafkaBroker(parser=custom_parser)\napp = FastStream(broker)\n@broker.subscriber(\"test\")\nasync def handle():\n...\n@app.after_startup\nasync def test():\nawait broker.publish(\"\", \"test\", headers={\"custom_message_id\": \"1\"})\n</code></pre> <pre><code>from typing import Awaitable, Callable\nfrom aio_pika import IncomingMessage\nfrom faststream import FastStream\nfrom faststream.rabbit import RabbitBroker, RabbitMessage\nasync def custom_parser(\nmsg: IncomingMessage,\noriginal_parser: Callable[[IncomingMessage], Awaitable[RabbitMessage]],\n) -&gt; RabbitMessage:\nparsed_msg = await original_parser(msg)\nparsed_msg.message_id = parsed_msg.headers[\"custom_message_id\"]\nreturn parsed_msg\nbroker = RabbitBroker(parser=custom_parser)\napp = FastStream(broker)\n@broker.subscriber(\"test\")\nasync def handle():\n...\n@app.after_startup\nasync def test():\nawait broker.publish(\"\", \"test\", headers={\"custom_message_id\": \"1\"})\n</code></pre>"},{"location":"getting-started/subscription/","title":"Subscription Basics","text":"<p>FastStream provides a Message Broker agnostic way to subscribe to event streams.</p> <p>You need not even know about topics/queues/subjects or any broker inner objects you use. The basic syntax is the same for all brokers:</p> KafkaRabbitMQ <pre><code>from faststream.kafka import KafkaBroker\nbroker = KafkaBroker()\n@broker.subscriber(\"test\")  # topic name\nasync def handle_msg(msg_body):\n...\n</code></pre> <pre><code>from faststream.rabbit import RabbitBroker\nbroker = RabbitBroker()\n@broker.subscriber(\"test\")  # queue name\nasync def handle_msg(msg_body):\n...\n</code></pre> <p>Tip</p> <p>If you want to use Message Broker specific features, please visit the corresponding broker documentation section. In the Tutorial section, the general features are described.</p> <p>Also, synchronous functions are supported as well:</p> KafkaRabbitMQ <pre><code>from faststream.kafka import KafkaBroker\nbroker = KafkaBroker()\n@broker.subscriber(\"test\")  # topic name\ndef handle_msg(msg_body):\n...\n</code></pre> <pre><code>from faststream.rabbit import RabbitBroker\nbroker = RabbitBroker()\n@broker.subscriber(\"test\")  # queue name\ndef handle_msg(msg_body):\n...\n</code></pre>"},{"location":"getting-started/subscription/#message-body-serialization","title":"Message Body Serialization","text":"<p>Generally, FastStream uses your function type annotation to serialize incoming message body with Pydantic. This is similar to how FastAPI works (if you are familiar with it).</p> <pre><code>@broker.subscriber(\"test\")\nasync def handle_str(msg_body: str):\n...\n</code></pre> <p>You can also access some extra features through the function arguments, such as Depends and Context if required.</p> <p>However, you can easily disable Pydantic validation by creating a broker with the following option <code>Broker(apply_types=False)</code> (this also disables Context and Depends features).</p> <p>This way FastStream still consumes <code>json.loads</code> result, but without pydantic validation and casting.</p> KafkaRabbitMQ <pre><code>from faststream.kafka import KafkaBroker\nbroker = KafkaBroker(apply_types=False)\n@broker.subscriber(\"test\")\nasync def handle_msg(msg_body: str):  # just an annotation, has no real effect\n...\n</code></pre> <pre><code>from faststream.rabbit import RabbitBroker\nbroker = RabbitBroker(apply_types=False)\n@broker.subscriber(\"test\")\nasync def handle_msg(msg_body: str):  # just an annotation, has no real effect\n...\n</code></pre>"},{"location":"getting-started/subscription/#multiple-subscriptions","title":"Multiple Subscriptions","text":"<p>You can also subscribe to multiple event streams at the same time with one function. Just wrap it with multiple <code>@broker.subscriber(...)</code> decorators (they have no effect on each other).</p> <pre><code>@broker.subscriber(\"first_sub\")\n@broker.subscriber(\"second_sub\")\nasync def handler(msg):\n...\n</code></pre>"},{"location":"getting-started/subscription/annotation/","title":"Annotation Serialization","text":""},{"location":"getting-started/subscription/annotation/#basic-usage","title":"Basic usage","text":"<p>As you already know, FastStream serializes your incoming message body according to the function type annotations using Pydantic.</p> <p>So, there are some valid usecases:</p> <pre><code>@broker.subscriber(\"test\")\nasync def handle(msg: str):\n...\n@broker.subscriber(\"test\")\nasync def handle(msg: bytes):\n...\n@broker.subscriber(\"test\")\nasync def handle(msg: int):\n...\n</code></pre> <p>As with other Python primitive types as well (<code>float</code>, <code>bool</code>, <code>datetime</code>, etc)</p> <p>Note</p> <p>If the incoming message cannot be serialized by the described schema, FastStream raises a <code>pydantic.ValidationError</code> with a correct log message.</p> <p>Also, thanks to Pydantic (again), FastStream is able to serialize (and validate) more complex types like <code>pydantic.HttpUrl</code>, <code>pydantic.PostitiveInt</code>, etc.</p>"},{"location":"getting-started/subscription/annotation/#json-basic-serialization","title":"JSON Basic Serialization","text":"<p>But how can we serialize more complex message, like <code>{ \"name\": \"John\", \"user_id\": 1 }</code> ?</p> <p>For sure, we can serialize it as a simple <code>dict</code></p> <pre><code>from typing import Dict, Any\n@broker.subscriber(\"test\")\nasync def handle(msg: dict[str, Any]):\n...\n</code></pre> <p>But it doesn't looks like a correct message validation, does it?</p> <p>For this reason, FastStream supports per-argument message serialization: you can declare multiple arguments with various types and your message will unpack to them:</p> KafkaRabbitMQ <pre><code>@broker.subscriber(\"test-topic\")\nasync def handle(name: str, user_id: int):\nassert name == \"John\"\nassert user_id == 1\n</code></pre> <pre><code>@broker.subscriber(\"test-queue\")\nasync def handle(name: str, user_id: int):\nassert name == \"John\"\nassert user_id == 1\n</code></pre>"},{"location":"getting-started/subscription/filtering/","title":"Application-level Filtering","text":"<p>FastStream also allows you to specify the message processing way using message headers, body type or something else. The <code>filter</code> feature enables you to consume various messages with different schemas within a single event stream.</p> <p>Tip</p> <p>Message must be consumed at ONCE (crossing filters are not allowed)</p> <p>As an example, let's create a subscriber for both <code>JSON</code> and non-<code>JSON</code> messages:</p> KafkaRabbitMQ <pre><code>from faststream import FastStream\nfrom faststream.kafka import KafkaBroker\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\n@broker.subscriber(\n\"test-topic\",\nfilter=lambda msg: msg.content_type == \"application/json\",\n)\nasync def handle(name: str, user_id: int):\nassert name == \"John\"\nassert user_id == 1\n@broker.subscriber(\"test-topic\")\nasync def default_handler(msg: str):\nassert msg == \"Hello, FastStream!\"\n</code></pre> <pre><code>from faststream import FastStream\nfrom faststream.rabbit import RabbitBroker\nbroker = RabbitBroker(\"amqp://guest:guest@localhost:5672/\")\napp = FastStream(broker)\n@broker.subscriber(\n\"test-queue\",\nfilter=lambda msg: msg.content_type == \"application/json\",\n)\nasync def handle(name: str, user_id: int):\nassert name == \"John\"\nassert user_id == 1\n@broker.subscriber(\"test-queue\")\nasync def default_handler(msg: str):\nassert msg == \"Hello, FastStream!\"\n</code></pre> <p>Note</p> <p>A subscriber without a filter is a default subscriber. It consumes messages that have not been consumed yet.</p> <p>For now, the following message will be delivered to the <code>handle</code> function</p> KafkaRabbitMQ <pre><code>    await broker.publish(\n{\"name\": \"John\", \"user_id\": 1},\ntopic=\"test-topic\",\n)\n</code></pre> <pre><code>    await broker.publish(\n{\"name\": \"John\", \"user_id\": 1},\nqueue=\"test-queue\",\n)\n</code></pre> <p>And this one will be delivered to the <code>default_handler</code></p> KafkaRabbitMQ <pre><code>    await broker.publish(\n\"Hello, FastStream!\",\ntopic=\"test-topic\",\n)\n</code></pre> <pre><code>    await broker.publish(\n\"Hello, FastStream!\",\nqueue=\"test-queue\",\n)\n</code></pre>"},{"location":"getting-started/subscription/pydantic/","title":"Pydantic Serialization","text":""},{"location":"getting-started/subscription/pydantic/#pydanticfield","title":"pydantic.Field","text":"<p>Besides, FastStream uses your handlers' annotations to collect information about the application schema and generate AsyncAPI schema.</p> <p>You can access this information with extra details using <code>pydantic.Field</code> (such as title, description and examples). Additionally, Fields usage allows you to add extra validations to your message schema.</p> <p>Just use <code>pydantic.Field</code> as a function default argument:</p> KafkaRabbitMQ <pre><code>from pydantic import Field, NonNegativeInt\nfrom faststream import FastStream\nfrom faststream.kafka import KafkaBroker\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\n@broker.subscriber(\"test-topic\")\nasync def handle(\nname: str = Field(\n..., examples=[\"John\"], description=\"Registered user name\"\n),\nuser_id: NonNegativeInt = Field(\n..., examples=[1], description=\"Registered user id\"\n),\n):\nassert name == \"John\"\nassert user_id == 1\n</code></pre> <pre><code>from pydantic import Field, NonNegativeInt\nfrom faststream import FastStream\nfrom faststream.rabbit import RabbitBroker\nbroker = RabbitBroker(\"amqp://guest:guest@localhost:5672/\")\napp = FastStream(broker)\n@broker.subscriber(\"test-queue\")\nasync def handle(\nname: str = Field(\n..., examples=[\"John\"], description=\"Registered user name\"\n),\nuser_id: NonNegativeInt = Field(\n..., examples=[1], description=\"Registered user id\"\n),\n):\nassert name == \"John\"\nassert user_id == 1\n</code></pre>"},{"location":"getting-started/subscription/pydantic/#pydanticbasemodel","title":"pydantic.BaseModel","text":"<p>To make your message schema reusable between different subscribers and publishers, you can decalre it as a <code>pydantic.BaseModel</code> and use it as a single message annotation:</p> KafkaRabbitMQ <pre><code>from pydantic import BaseModel, Field, NonNegativeInt\nfrom faststream import FastStream\nfrom faststream.kafka import KafkaBroker\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\nclass UserInfo(BaseModel):\nname: str = Field(\n..., examples=[\"John\"], description=\"Registered user name\"\n)\nuser_id: NonNegativeInt = Field(\n..., examples=[1], description=\"Registered user id\"\n)\n@broker.subscriber(\"test-topic\")\nasync def handle(user: UserInfo):\nassert user.name == \"John\"\nassert user.user_id == 1\n</code></pre> <pre><code>from pydantic import BaseModel, Field, NonNegativeInt\nfrom faststream import FastStream\nfrom faststream.rabbit import RabbitBroker\nbroker = RabbitBroker(\"amqp://guest:guest@localhost:5672/\")\napp = FastStream(broker)\nclass UserInfo(BaseModel):\nname: str = Field(\n..., examples=[\"John\"], description=\"Registered user name\"\n)\nuser_id: NonNegativeInt = Field(\n..., examples=[1], description=\"Registered user id\"\n)\n@broker.subscriber(\"test-queue\")\nasync def handle(user: UserInfo):\nassert user.name == \"John\"\nassert user.user_id == 1\n</code></pre>"},{"location":"getting-started/subscription/test/","title":"Subscriber Testing","text":"<p>Testability is a crucial part of any application, and FastStream provides you with the tools to test your code easily.</p>"},{"location":"getting-started/subscription/test/#original-application","title":"Original Application","text":"<p>Let's take a look at the original application to test</p> KafkaRabbitMQ annotation_kafka.py<pre><code>from faststream import FastStream\nfrom faststream.kafka import KafkaBroker\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\n@broker.subscriber(\"test-topic\")\nasync def handle(name: str, user_id: int):\nassert name == \"John\"\nassert user_id == 1\n</code></pre> annotation_rabbit.py<pre><code>from faststream import FastStream\nfrom faststream.rabbit import RabbitBroker\nbroker = RabbitBroker(\"amqp://guest:guest@localhost:5672/\")\napp = FastStream(broker)\n@broker.subscriber(\"test-queue\")\nasync def handle(name: str, user_id: int):\nassert name == \"John\"\nassert user_id == 1\n</code></pre> <p>It consumes JSON messages like <code>{ \"name\": \"username\", \"user_id\": 1 }</code></p> <p>You can test your consume function like a regular one, for sure:</p> <pre><code>@pytest.mark.asyncio\nasync def test_handler():\nawait handle(\"John\", 1)\n</code></pre> <p>But if you want to test your function closer to your real runtime, you should use the special FastStream test client.</p>"},{"location":"getting-started/subscription/test/#in-memory-testing","title":"In-Memory Testing","text":"<p>Deploying a whole service with a Message Broker is a bit too much just for testing purposes, especially in your CI environment. Not to mention the possible loss of messages due to network failures when working with real brokers.</p> <p>For this reason, FastStream has a special <code>TestClient</code> to make your broker work in <code>InMemory</code> mode.</p> <p>Just use it like a regular async context manager - all published messages will be routed in-memory (without any external dependencies) and consumed by the correct handler.</p> KafkaRabbitMQ <pre><code>import pytest\nfrom pydantic import ValidationError\nfrom faststream.kafka import TestKafkaBroker\nfrom .annotation_kafka import broker, handle\n@pytest.mark.asyncio\nasync def test_handle():\nasync with TestKafkaBroker(broker) as br:\nawait br.publish({\"name\": \"John\", \"user_id\": 1}, topic=\"test-topic\")\n</code></pre> <pre><code>import pytest\nfrom pydantic import ValidationError\nfrom faststream.rabbit import TestRabbitBroker\nfrom .annotation_rabbit import broker, handle\n@pytest.mark.asyncio\nasync def test_handle():\nasync with TestRabbitBroker(broker) as br:\nawait br.publish({\"name\": \"John\", \"user_id\": 1}, queue=\"test-queue\")\n</code></pre>"},{"location":"getting-started/subscription/test/#catching-exceptions","title":"Catching Exceptions","text":"<p>This way you can catch any exceptions that occur inside your handler:</p> KafkaRabbitMQ <pre><code>@pytest.mark.asyncio\nasync def test_validation_error():\nasync with TestKafkaBroker(broker) as br:\nwith pytest.raises(ValidationError):\nawait br.publish(\"wrong message\", topic=\"test-topic\")\n</code></pre> <pre><code>@pytest.mark.asyncio\nasync def test_validation_error():\nasync with TestRabbitBroker(broker) as br:\nwith pytest.raises(ValidationError):\nawait br.publish(\"wrong message\", queue=\"test-queue\")\n</code></pre>"},{"location":"getting-started/subscription/test/#validates-input","title":"Validates Input","text":"<p>Also, your handler has a mock object to validate your input or call counts.</p> KafkaRabbitMQ <pre><code>@pytest.mark.asyncio\nasync def test_handle():\nasync with TestKafkaBroker(broker) as br:\nawait br.publish({\"name\": \"John\", \"user_id\": 1}, topic=\"test-topic\")\nhandle.mock.assert_called_once_with({\"name\": \"John\", \"user_id\": 1})\n</code></pre> <pre><code>@pytest.mark.asyncio\nasync def test_handle():\nasync with TestRabbitBroker(broker) as br:\nawait br.publish({\"name\": \"John\", \"user_id\": 1}, queue=\"test-queue\")\nhandle.mock.assert_called_once_with({\"name\": \"John\", \"user_id\": 1})\n</code></pre> <p>Note</p> <p>The Handler mock has a not-serialized JSON message body. This way you can validate the incoming message view, not python arguments.</p> <p>Thus our example checks not <code>mock.assert_called_with(name=\"John\", user_id=1)</code>, but <code>mock.assert_called_with({ \"name\": \"John\", \"user_id\": 1 })</code>.</p> <p>You should be careful with this feature: all mock objects will be cleared when the context manager exits.</p> KafkaRabbitMQ <pre><code>@pytest.mark.asyncio\nasync def test_handle():\nasync with TestKafkaBroker(broker) as br:\nawait br.publish({\"name\": \"John\", \"user_id\": 1}, topic=\"test-topic\")\nhandle.mock.assert_called_once_with({\"name\": \"John\", \"user_id\": 1})\nassert handle.mock.call_count == 0\n</code></pre> <pre><code>@pytest.mark.asyncio\nasync def test_handle():\nasync with TestRabbitBroker(broker) as br:\nawait br.publish({\"name\": \"John\", \"user_id\": 1}, queue=\"test-queue\")\nhandle.mock.assert_called_once_with({\"name\": \"John\", \"user_id\": 1})\nassert handle.mock.call_count == 0\n</code></pre>"},{"location":"getting-started/subscription/test/#real-broker-testing","title":"Real Broker Testing","text":"<p>If you want to test your application in a real environment, you shouldn't have to rewrite all you tests: just pass <code>with_real</code> optional parameter to your <code>TestClient</code> context manager. This way, <code>TestClient</code> supports all the testing features but uses an unpatched broker to send and consume messages.</p> KafkaRabbitMQ <pre><code>import pytest\nfrom pydantic import ValidationError\nfrom faststream.kafka import TestKafkaBroker\nfrom .pydantic_fields_kafka import broker, handle\n@pytest.mark.asyncio\nasync def test_handle():\nasync with TestKafkaBroker(broker, with_real=True) as br:\nawait br.publish({\"name\": \"John\", \"user_id\": 1}, topic=\"test-topic\")\nawait handle.wait_call(timeout=3)\nhandle.mock.assert_called_once_with({\"name\": \"John\", \"user_id\": 1})\nassert handle.mock.call_count == 0\n@pytest.mark.asyncio\nasync def test_validation_error():\nasync with TestKafkaBroker(broker, with_real=True) as br:\nwith pytest.raises(ValidationError):\nawait br.publish(\"wrong message\", topic=\"test-topic\")\nawait handle.wait_call(timeout=3)\nhandle.mock.assert_called_once_with(\"wrong message\")\n</code></pre> <pre><code>import pytest\nfrom pydantic import ValidationError\nfrom faststream.rabbit import TestRabbitBroker\nfrom .pydantic_fields_rabbit import broker, handle\n@pytest.mark.asyncio\nasync def test_handle():\nasync with TestRabbitBroker(broker, with_real=True) as br:\nawait br.publish({\"name\": \"John\", \"user_id\": 1}, queue=\"test-queue\")\nawait handle.wait_call(timeout=3)\nhandle.mock.assert_called_once_with({\"name\": \"John\", \"user_id\": 1})\nassert handle.mock.call_count == 0\n@pytest.mark.asyncio\nasync def test_validation_error():\nasync with TestRabbitBroker(broker, with_real=True) as br:\nwith pytest.raises(ValidationError):\nawait br.publish(\"wrong message\", queue=\"test-queue\")\nawait handle.wait_call(timeout=3)\nhandle.mock.assert_called_once_with(\"wrong message\")\n</code></pre> <p>Tip</p> <p>When you're using a patched broker to test your consumers, the publish method is called synchronously with a consumer one, so you need not wait until your message is consumed. But in the real broker's case, it doesn't.</p> <p>For this reason, you have to wait for message consumption manually with the special <code>handler.wait_call(timeout)</code> method. Also, inner handler exceptions will be raised in this function, not <code>broker.publish(...)</code>.</p>"},{"location":"getting-started/subscription/test/#a-little-tip","title":"A Little Tip","text":"<p>It can be very helpful to set the <code>with_real</code> flag using an environment variable. This way, you will be able to choose the testing mode right from the command line:</p> <pre><code>WITH_REAL=True/False pytest tests/\n</code></pre> <p>To learn more about managing your application configiruation visit this page.</p>"},{"location":"kafka/","title":"Kafka Routing","text":""},{"location":"kafka/#kafka-overview","title":"Kafka Overview","text":""},{"location":"kafka/#what-is-kafka","title":"What is Kafka?","text":"<p>Kafka is an open-source distributed streaming platform developed by the Apache Software Foundation. It is designed to handle high-throughput, fault-tolerant, real-time data streaming. Kafka is widely used for building real-time data pipelines and streaming applications.</p>"},{"location":"kafka/#key-kafka-concepts","title":"Key Kafka Concepts","text":""},{"location":"kafka/#1-publish-subscribe-model","title":"1. Publish-Subscribe Model","text":"<p>Kafka is built around the publish-subscribe messaging model. In this model, data is published to topics, and multiple consumers can subscribe to these topics to receive the data. This decouples the producers of data from the consumers, allowing for flexibility and scalability.</p>"},{"location":"kafka/#2-topics","title":"2. Topics","text":"<p>A topic in Kafka is a logical channel or category to which messages are published by producers and from which messages are consumed by consumers. Topics are used to organize and categorize data streams. Each topic can have multiple partitions, which enable Kafka to distribute data and provide parallelism for both producers and consumers.</p>"},{"location":"kafka/#kafka-topics","title":"Kafka Topics","text":""},{"location":"kafka/#understanding-kafka-topics","title":"Understanding Kafka Topics","text":"<p>Topics are fundamental to Kafka and serve as the central point of data distribution. Here are some key points about topics:</p> <ul> <li>Topics allow you to logically group and categorize messages.</li> <li>Each message sent to Kafka is associated with a specific topic.</li> <li>Topics can have one or more partitions to enable parallel processing and scaling.</li> <li>Consumers subscribe to topics to receive messages.</li> </ul>"},{"location":"kafka/#faststream-kafkabroker","title":"FastStream KafkaBroker","text":"<p>The FastStream KafkaBroker is a key component of the FastStream framework that enables seamless integration with Apache Kafka. With the KafkaBroker, developers can easily connect to Kafka brokers, produce messages to Kafka topics, and consume messages from Kafka topics within their FastStream applications.</p>"},{"location":"kafka/#establishing-a-connection","title":"Establishing a Connection","text":"<p>To connect to Kafka using the FastStream KafkaBroker module, follow these steps:</p> <ol> <li> <p>Initialize the KafkaBroker instance: Start by initializing a KafkaBroker instance with the necessary configuration, including Kafka broker address.</p> </li> <li> <p>Create your processing logic: Write a function that will consume the incoming messages in the defined format and produce a response to the defined topic</p> </li> <li> <p>Decorate your processing function: To connect your processing function to the desired Kafka topics you need to decorate it with <code>@broker.subscriber</code> and <code>@broker.publisher</code> decorators. Now, after you start your application, your processing function will be called whenever a new message in the subscribed topic is available and produce the function return value to the topic defined in the publisher decorator.</p> </li> </ol> <p>Here's a simplified code example demonstrating how to establish a connection to Kafka using FastStream's KafkaBroker module:</p> <pre><code>from faststream import FastStream\nfrom faststream.kafka import KafkaBroker\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\n@broker.subscriber(\"in-topic\")\n@broker.publisher(\"out-topic\")\nasync def handle_msg(user: str, user_id: int) -&gt; str:\nreturn f\"User: {user_id} - {user} registered\"\n</code></pre> <p>This minimal example illustrates how FastStream simplifies the process of connecting to Kafka and performing basic message processing from the in_topic to the out-topic. Depending on your specific use case and requirements, you can further customize your Kafka integration with FastStream to build robust and efficient streaming applications.</p> <p>For more advanced configuration options and detailed usage instructions, please refer to the FastStream Kafka documentation and the offical Kafka documentation.</p>"},{"location":"kafka/message/","title":"Access to Message Information","text":"<p>As you may know, FastStream serializes a message body and provides you access to it through function arguments. However, there are times when you need to access additional message attributes such as offsets, headers, or other metadata.</p>"},{"location":"kafka/message/#message-access","title":"Message Access","text":"<p>You can easily access this information by referring to the message object in the Context!</p> <p>This object serves as a unified FastStream wrapper around the native broker library message (for example, <code>aiokafka.ConsumerRecord</code> in the case of Kafka). It contains most of the required information, including:</p> <ul> <li><code>body: bytes</code></li> <li><code>checksum: int</code></li> <li><code>headers: Sequence[Tuple[str, bytes]]</code></li> <li><code>key: Optional[aiokafka.structs.KT]</code></li> <li><code>offset: int</code></li> <li><code>partition: int</code></li> <li><code>serialized_key_size: int</code></li> <li><code>serialized_value_size: int</code></li> <li><code>timestamp: int</code></li> <li><code>timestamp_type: int</code></li> <li><code>topic: str</code></li> <li><code>value: Optional[aiokafka.structs.VT]</code></li> </ul> <p>For example, if you would like to access the headers of an incoming message, you would do so like this:</p> <pre><code>from faststream.kafka import KafkaMessage\n@broker.subscriber(\"test\")\nasync def base_handler(\nbody: str,\nmsg: KafkaMessage,\n):\nprint(msg.headers)\n</code></pre>"},{"location":"kafka/message/#message-fields-access","title":"Message Fields Access","text":"<p>In most cases, you don't need all message fields; you need to know just a part of them. You can use Context Fields access feature for this.</p> <p>For example, you can get access to the <code>headers</code> like this:</p> <pre><code>from faststream import Context\n@broker.subscriber(\"test\")\nasync def base_handler(\nbody: str,\nheaders: str = Context(\"message.headers\"),\n):\nprint(headers)\n</code></pre>"},{"location":"kafka/Publisher/","title":"Publishing","text":"<p>FastStream KafkaBroker supports all regular publishing usecases, which you can use without any changes.</p> <p>In the following chapters, we will demonstrate how to use a KafkaBroker publisher in specific use cases, such as publishing batches or publishing with a key.</p>"},{"location":"kafka/Publisher/batch_publisher/","title":"Publishing in Batches","text":"<p>If you want to send your data in batches, <code>@broker.publisher(...)</code> decorator makes that possible for you. To produce in batches, you need to do two things:</p> <ol> <li>When creating your publisher, set the <code>batch</code> argument to <code>True</code>.</li> <li>Return a tuple of the messages you wish to send in a batch. This action will prompt the producer to collect the messages and send them in a batch to a Kafka broker.</li> </ol> <p>Here is an example of an app producing in batches to output_data topic when consuming from input_data_1.</p> <p>In the highligted lines, we can see the steps of creating and using a batch publisher:</p> <ol> <li>Creation of the publisher.</li> <li>Publishing an actual batch of messages.</li> </ol> <pre><code>from typing import Tuple\nfrom pydantic import BaseModel, Field, NonNegativeFloat\nfrom faststream import FastStream, Logger\nfrom faststream.kafka import KafkaBroker\nclass Data(BaseModel):\ndata: NonNegativeFloat = Field(\n..., examples=[0.5], description=\"Float data example\"\n)\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\ndecrease_and_increase = broker.publisher(\"output_data\", batch=True)\n@decrease_and_increase\n@broker.subscriber(\"input_data_1\")\nasync def on_input_data_1(msg: Data, logger: Logger) -&gt; Tuple[Data, Data]:\nlogger.info(msg)\nreturn Data(data=(msg.data * 0.5)), Data(data=(msg.data * 2.0))\n</code></pre>"},{"location":"kafka/Publisher/using_a_key/","title":"Defining a Partition Key","text":"<p>Partition keys are used in Apache Kafka to determine which partition a message should be written to. This ensures that related messages are kept together in the same partition, which can be useful for ensuring order or for grouping related messages together for efficient processing. Additionally, partitioning data across multiple partitions allows Kafka to distribute load across multiple brokers and scale horizontally, while replicating data across multiple brokers provides fault tolerance.</p> <p>You can define your partition keys when using the <code>@KafkaBroker.publisher(...)</code> decorator. This guide will demonstrate this feature to you.</p>"},{"location":"kafka/Publisher/using_a_key/#calling-publish-with-a-key","title":"Calling <code>publish</code> with a Key","text":"<p>To publish a message to a Kafka topic using a key, simply pass the <code>key</code> parameter to the <code>publish</code> function call, like this:</p> <pre><code>    await to_output_data.publish(Data(data=msg.data + 1.0), key=b\"key\")\n</code></pre>"},{"location":"kafka/Publisher/using_a_key/#app-example","title":"App Example","text":"<p>Let's take a look at the whole app example that will consume from the input_data topic and publish with a key to the output_data topic.</p> <p>You can see that the only difference from normal publishing is that now we pass the key to the publisher call.</p> <pre><code>from pydantic import BaseModel, Field, NonNegativeFloat\nfrom faststream import Context, FastStream, Logger\nfrom faststream.kafka import KafkaBroker\nclass Data(BaseModel):\ndata: NonNegativeFloat = Field(\n..., examples=[0.5], description=\"Float data example\"\n)\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\nto_output_data = broker.publisher(\"output_data\")\n@broker.subscriber(\"input_data\")\nasync def on_input_data(\nmsg: Data, logger: Logger, key: bytes = Context(\"message.raw_message.key\")\n) -&gt; None:\nlogger.info(f\"on_input_data({msg=})\")\nawait to_output_data.publish(Data(data=msg.data + 1.0), key=b\"key\")\n</code></pre>"},{"location":"kafka/Subscriber/","title":"Basic Subscriber","text":"<p>To start consuming from a Kafka topic, just decorate your consuming function with a <code>@broker.subscriber(...)</code> decorator, passing a string as a topic key.</p> <p>In the folowing example, we will create a simple FastStream app that will consume <code>HelloWorld</code> messages from a hello_world topic.</p> <p>The full app code looks like this:</p> <pre><code>from pydantic import BaseModel, Field\nfrom faststream import FastStream, Logger\nfrom faststream.kafka import KafkaBroker\nclass HelloWorld(BaseModel):\nmsg: str = Field(\n...,\nexamples=[\"Hello\"],\ndescription=\"Demo hello world message\",\n)\nbroker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\n@broker.subscriber(\"hello_world\")\nasync def on_hello_world(msg: HelloWorld, logger: Logger):\nlogger.info(msg)\n</code></pre>"},{"location":"kafka/Subscriber/#import-faststream-and-kafkabroker","title":"Import FastStream and KafkaBroker","text":"<p>To use the <code>@broker.subscriber(...)</code> decorator, first we need to import the base FastStream app KafkaBroker to create our broker.</p> <pre><code>from faststream import FastStream, Logger\nfrom faststream.kafka import KafkaBroker\n</code></pre>"},{"location":"kafka/Subscriber/#define-the-helloworld-message-structure","title":"Define the HelloWorld Message Structure","text":"<p>Next, you need to define the structure of the messages you want to consume from the topic using Pydantic. For the guide, we\u2019ll stick to something basic, but you are free to define any complex message structure you wish in your project.</p> <pre><code>class HelloWorld(BaseModel):\nmsg: str = Field(\n...,\nexamples=[\"Hello\"],\ndescription=\"Demo hello world message\",\n)\n</code></pre>"},{"location":"kafka/Subscriber/#create-a-kafkabroker","title":"Create a KafkaBroker","text":"<p>Next, we will create a <code>KafkaBroker</code> object and wrap it into the <code>FastStream</code> object so that we can start our app using CLI later.</p> <pre><code>broker = KafkaBroker(\"localhost:9092\")\napp = FastStream(broker)\n</code></pre>"},{"location":"kafka/Subscriber/#create-a-function-that-will-consume-messages-from-a-kafka-hello-world-topic","title":"Create a Function that will Consume Messages from a Kafka hello-world Topic","text":"<p>Let\u2019s create a consumer function that will consume <code>HelloWorld</code> messages from hello_world topic and log them.</p> <pre><code>@broker.subscriber(\"hello_world\")\nasync def on_hello_world(msg: HelloWorld, logger: Logger):\nlogger.info(msg)\n</code></pre> <p>The function decorated with the <code>@broker.subscriber(...)</code> decorator will be called when a message is produced to Kafka.</p> <p>The message will then be injected into the typed <code>msg</code> argument of the function, and its type will be used to parse the message.</p> <p>In this example case, when the message is sent to a hello_world topic, it will be parsed into a <code>HelloWorld</code> class, and the <code>on_hello_world</code> function will be called with the parsed class as the <code>msg</code> argument value.</p>"},{"location":"kafka/Subscriber/batch_subscriber/","title":"Batch Subscriber","text":"<p>If you want to consume data in batches, the <code>@broker.subscriber(...)</code> decorator makes that possible for you. By typing a consumed <code>msg</code> object as a list of messages and setting the <code>batch</code> parameter to <code>True</code>, the subscriber will call your consuming function with a batch of messages consumed from a single partition. Let\u2019s demonstrate that now.</p>"},{"location":"kafka/Subscriber/batch_subscriber/#subscriber-function-with-batching","title":"Subscriber Function with Batching","text":"<p>To consume messages in batches, you need to wrap your message type into a list and and set the <code>batch</code> parameter to <code>True</code>. The <code>@broker.subscriber(...)</code> decorator will take care of the rest for you. Your subscribed function will be called with batches grouped by partition now.</p> <p>Here is an example of consuming in batches from the test_batch topic:</p> <pre><code>@broker.subscriber(\"test_batch\", batch=True)\nasync def handle_batch(msg: List[HelloWorld], logger: Logger):\nlogger.info(msg)\n</code></pre>"},{"location":"rabbit/","title":"Rabbit Routing","text":""},{"location":"rabbit/#advantages","title":"Advantages","text":"<p>The advantage of RabbitMQ is the ability to configure flexible and complex message routing scenarios.</p> <p>RabbitMQ covers the whole range of routing: from one queue - one consumer, to a queue retrieved from several sources, including message prioritization.</p> <p>Note</p> <p>For more information about RabbitMQ, please visit the official documentation</p> <p>It supports the ability to successfully process messages, mark them as processed with an error, remove them from the queue (it is also impossible to re-receive processed messages, unlike Kafka), lock it for the processing duration, and monitor its current status.</p> <p>Having to keep track of the current status of all messages is a cause of the RabbitMQ performance issues. With really large message volumes, RabbitMQ starts to degrade. However, if this was a \"one-time influx\", then consumers will free the queue of messages and the \"health\" of RabbitMQ will be stable.</p> <p>If your scenario is not based on processing millions of messages and also requires building complex routing logic, RabbitMQ will be the right choice.</p>"},{"location":"rabbit/#basic-concepts","title":"Basic Concepts","text":"<p>If you want to totally understand how RabbitMQ works, you should visit their official website. There you will find top-level comments about the basic concepts and usage examples.</p>"},{"location":"rabbit/#entities","title":"Entities","text":"<p>RabbitMQ works with three main entities:</p> <ul> <li><code>Exchange</code> - the point of receiving messages from publisher</li> <li><code>Queue</code> - the point of pushing messages to consumer</li> <li><code>Binding</code> - the relationship between queue-exchange or exchange-exchange</li> </ul>"},{"location":"rabbit/#routing-rules","title":"Routing Rules","text":"<p>The rules for delivering messages to consumers depend on the type of exchange and binding parameters. All the main options will be discussed at examples.</p> <p>In general, the message path looks so:</p> <ol> <li>Publisher sends a message to <code>exchange</code>, specify its <code>routing_key</code> and headers according to which routing will take place.</li> <li><code>Exchange</code>, depending on the message parameters, determines which of the subscribed <code>bindings</code> to send the message to.</li> <li><code>Binding</code> delivers the message to <code>queue</code> or another <code>exchange</code> (in this case it will send it further by its own rules).</li> <li><code>Queue</code>, after receiving a message, sends it to one of subscribed consumers (PUSH API).</li> </ol> <p>Tip</p> <p>By default, all queues have a <code>binding</code> to the <code>default exchange</code> (Direct type) with a routing key corresponding to their name. In FastStream, queues are connected to this <code>exchange</code>, and messages are sent by default unless another <code>exchange</code> is explicitly specified.</p> <p>Connecting the queue to any other <code>exchange</code> will still leave it subscribed to the `default exchange'. Be careful with this.</p> <p>At this stage, the message gets into your application - and you start processing it.</p>"},{"location":"rabbit/#message-statuses","title":"Message Statuses","text":"<p>RabbitMQ requires confirmation of message processing: only after that, it will be removed from the queue.</p> <p>Confirmation can be either positive (<code>Acknowledgment - ack</code>) if the message was successfully processed or negative (<code>Negative Acknowledgment - nack</code>) if the message was processed with an error.</p> <p>At the same time, in case of an error, the message can also be extracted from the queue (<code>reject</code>); otherwise, after a negative confirmation, it will be requeued for processing again.</p> <p>In most cases, FastStream performs all the necessary actions by itself. However, if you want to manage the message lifecycle directly, you can access the message object itself and call the appropriate methods directly. This can be useful if you want to implement an \"at most once\" policy and you need to confirm the consuming of the message before it is actually processed.</p>"},{"location":"rabbit/#faststream-specific","title":"FastStream Specific","text":"<p>FastStream omits the ability to create <code>bindings</code> directly, since in most cases, you do not need to subscribe one queue to several <code>exchanges</code> or subscribe <code>exchanges</code> to each other. On the contrary, this practice leads to over-complication of the message routing scheme, which makes it difficult to maintain and further develop the entire infrastructure of services.</p> <p>FastStream suggests you adhere to the scheme <code>exchange:queue</code> as <code>1:N</code>, which will greatly simplify the scheme of interaction between your services. It is better to create an additional queue for a new <code>exchange</code> than to subscribe to an existing one.</p> <p>However, if you want to reduce the number of entities in your RabbitMQ, and thereby optimize its performance (or you know exactly what you are doing), FastStream leaves you the option to create <code>bindings</code> directly. In other cases, the connection parameters are an integral part of the entities RabbitQueue and RabbitExchange in FastStream.</p>"},{"location":"rabbit/ack/","title":"Consuming Acknowledgements","text":"<p>As you may know, RabbitMQ employs a rather extensive Acknowledgement policy.</p> <p>In most cases, FastStream automatically acknowledges (acks) messages on your behalf. When your function executes correctly, including sending all responses, a message will be acknowledged (and rejected in case of an exception).</p> <p>However, there are situations where you might want to use a different acknowledgement logic.</p>"},{"location":"rabbit/ack/#retries","title":"Retries","text":"<p>If you prefer to use a nack instead of a reject when there's an error in message processing, you can specify the <code>retry</code> flag in the <code>@broker.subscriber(...)</code> method, which is responsible for error handling logic.</p> <p>By default, this flag is set to <code>False</code>, indicating that if an error occurs during message processing, the message can still be retrieved from the queue:</p> <pre><code>@broker.subscriber(\"test\", retry=False) # don't handle exceptions\nasync def base_handler(body: str):\n...\n</code></pre> <p>If this flag is set to <code>True</code>, the message will be nacked and placed back in the queue each time an error occurs. In this scenario, the message can be processed by another consumer (if there are several of them) or by the same one:</p> <pre><code>@broker.subscriber(\"test\", retry=True)  # try again indefinitely\nasync def base_handler(body: str):\n...\n</code></pre> <p>If the <code>retry</code> flag is set to an <code>int</code>, the message will be placed back in the queue, and the number of retries will be limited to this number:</p> <pre><code>@broker.subscriber(\"test\", retry=3)     # make up to 3 attempts\nasync def base_handler(body: str):\n...\n</code></pre> <p>Bug</p> <p>At the moment, attempts are counted only by the current consumer. If the message goes to another consumer, it will have its own counter. Subsequently, this logic will be reworked.</p> <p>Tip</p> <p>For more complex error handling cases, you can use tenacity</p>"},{"location":"rabbit/ack/#manual-acknowledgement","title":"Manual acknowledgement","text":"<p>If you want to acknowledge a message manually, you can get access directy to the message object via the Context and call the method.</p> <pre><code>from faststream.rabbit import RabbitMessage\n@broker.subscriber(\"test\")\nasync def base_handler(body: str, msg: RabbitMessage):\nawait msg.ack()\n# or\nawait msg.nack()\n# or\nawait msg.reject()\n</code></pre> <p>FastStream will see that the message was already acknowledged and will do nothing at process end.</p>"},{"location":"rabbit/ack/#interrupt-process","title":"Interrupt Process","text":"<p>If you want to interrupt message processing at any call stack, you can raise <code>faststream.exceptions.AckMessage</code></p> <pre><code>from faststream import FastStream\nfrom faststream.exceptions import AckMessage\nfrom faststream.rabbit import RabbitBroker\nbroker = RabbitBroker(\"amqp://guest:guest@localhost:5672/\")\napp = FastStream(broker)\n@broker.subscriber(\"test-queue\")\nasync def handle(body):\nsmth_processing(body)\ndef smth_processing(body):\nif True:\nraise AckMessage()\n@app.after_startup\nasync def test_publishing():\nawait broker.publish(\"Hello!\", \"test-queue\")\n</code></pre> <p>This way, FastStream interrupts the current message proccessing and acknowledges it immediately. Also, you can raise <code>NackMessage</code> and <code>RejectMessage</code> too.</p>"},{"location":"rabbit/declare/","title":"RabbitMQ Queue/Exchange Declaration","text":"<p>FastStream declares and validates all exchanges and queues using publishers and subscribers RabbitMQ objects, but sometimes you need to declare them manually.</p> <p>RabbitBroker provides a way to achieve this easily.</p> <pre><code>from faststream import FastStream\nfrom faststream.rabbit import (\nExchangeType,\nRabbitBroker,\nRabbitExchange,\nRabbitQueue,\n)\nbroker = RabbitBroker()\napp = FastStream(broker)\n@app.after_startup\nasync def declare_smth():\nawait broker.declare_exchange(\nRabbitExchange(\nname=\"some-exchange\",\ntype=ExchangeType.FANOUT,\n)\n)\nawait broker.declare_queue(\nRabbitQueue(\nname=\"some-queue\",\ndurable=True,\n)\n)\n</code></pre> <p>These methods require just one argument (<code>RabbitQueue</code>/<code>RabbitExchange</code>) containing information about your RabbitMQ required objects. They declare/validate RabbitMQ objects and return low-level aio-pika robust objects to interact with.</p> <p>Tip</p> <p>Also, these methods are idempotent, so you can call them with the same arguments multiple times, but the objects will be created once; next time the method will return an already stored object. This way you can get access to any queue/exchange created automatically.</p>"},{"location":"rabbit/message/","title":"Access to Message Information","text":"<p>As you know, FastStream serializes a message body and provides you access to it through function arguments. But sometimes you want access to a message_id, headers, or other meta-information.</p>"},{"location":"rabbit/message/#message-access","title":"Message Access","text":"<p>You can get it in a simple way: just acces to the message object in the Context!</p> <p>It is a FastStream wrapper around a native broker library message (<code>aio_pika.IncomingMessage</code> in the RabbitMQ case). It contains the required information such as:</p> <ul> <li><code>body: bytes</code></li> <li><code>decoded_body: Any</code></li> <li><code>content_type: str</code></li> <li><code>reply_to: str</code></li> <li><code>headers: dict[str, Any]</code></li> <li><code>message_id: str</code></li> <li><code>correlation_id: str</code></li> </ul> <pre><code>from faststream.rabbit import RabbitMessage\n@broker.subscriber(\"test\")\nasync def base_handler(\nbody: str,\nmsg: RabbitMessage,\n):\nprint(msg.correlation_id)\n</code></pre> <p>Also, if you can't find the information you reqiure, you can get access directly to the wrapped <code>aio_pika.IncomingMessage</code>, which contains complete message information.</p> <pre><code>from aio_pika import IncomingMessage\nfrom faststream.rabbit import RabbitMessage\n@broker.subscriber(\"test\")\nasync def base_handler(body: str, msg: RabbitMessage):\nraw: IncomingMessage = msg.raw_message\nprint(raw)\n</code></pre>"},{"location":"rabbit/message/#message-fields-access","title":"Message Fields Access","text":"<p>But in the most cases, you don't need all message fields; you need to access some of them. You can use Context Fields access feature for this reason.</p> <p>For example, you can get access to the <code>correlation_id</code> like this:</p> <pre><code>from faststream import Context\n@broker.subscriber(\"test\")\nasync def base_handler(\nbody: str,\ncor_id: str = Context(\"message.correlation_id\"),\n):\nprint(cor_id)\n</code></pre> <p>Or even directly from the raw message:</p> <pre><code>from faststream import Context\n@broker.subscriber(\"test\")\nasync def base_handler(\nbody: str,\ncor_id: str = Context(\"message.raw_message.correlation_id\"),\n):\nprint(cor_id)\n</code></pre> <p>But this code is too long to be reused everywhere. In this case, you can use a Python <code>Annotated</code> feature:</p> python 3.9+python 3.6+ <pre><code>from types import Annotated\nfrom faststream import Context\nCorrelationId = Annotated[str, Context(\"message.correlation_id\")]\n@broker.subscriber(\"test\")\nasync def base_handler(\nbody: str,\ncor_id: CorrelationId,\n):\nprint(cor_id)\n</code></pre> <pre><code>from typing_extensions import Annotated\nfrom faststream import Context\nCorrelationId = Annotated[str, Context(\"message.correlation_id\")]\n@broker.subscriber(\"test\")\nasync def base_handler(\nbody: str,\ncor_id: CorrelationId,\n):\nprint(cor_id)\n</code></pre>"},{"location":"rabbit/publishing/","title":"Publishing","text":"<p>FastStream RabbitBroker supports all regular publishing usecases. you can use them without any changes.</p> <p>However, if you wish to further customize the publishing logic further, you should take a more deep-dive look at specific RabbitBroker parameters.</p>"},{"location":"rabbit/publishing/#rabbit-publishing","title":"Rabbit Publishing","text":"<p><code>RabbitBroker</code> also uses the unified <code>publish</code> method (from a <code>publisher</code> object) to send messages.</p> <p>However, in this case, an object of the <code>aio_pika.Message</code> class (if necessary) can be used as a message (in addition to python primitives and <code>pydantic.BaseModel</code>).</p> <p>You can specify queue (used as a routing_key) and exchange (optionally) to send by their name.</p> <pre><code>import asyncio\nfrom faststream.rabbit import RabbitBroker\nasync def pub():\nasync with RabbitBroker() as broker:\nawait broker.publish(\n\"Hi!\",\nqueue=\"test\",\nexchange=\"test\"\n)\nasyncio.run(pub())\n</code></pre> <p>If you don't specify any exchange, the message will be send to the default one.</p> <p>Also, you are able to use special RabbitQueue and RabbitExchange objects as <code>queue</code> and <code>exchange</code> arguments:</p> <pre><code>from faststream.rabbit import RabbitExchange, RabbitQueue\nawait broker.publish(\n\"Hi!\",\nqueue=RabbitQueue(\"test\"),\nexchange=RabbitExchange(\"test\")\n)\n</code></pre> <p>If you specify exchange that doesn't exist, RabbitBroker will create a required one and then publish a message to it.</p> <p>Tip</p> <p>Be accurate with it: if you have already created an Exchange with specific parameters and try to send a message by exchange name to it, the broker will try to create it. So, Exchange parameters conflict will occur.</p> <p>If you are trying to send a message to a specific Exchange, sending it with a defined RabbitExchange object is the preffered way.</p>"},{"location":"rabbit/publishing/#basic-arguments","title":"Basic Arguments","text":"<p>The <code>publish</code> method takes the following arguments:</p> <ul> <li><code>message = \"\"</code> - message to send</li> <li><code>exchange: str | RabbitExchange | None = None</code> - the exchange where the message will be sent to. If not specified - default is used</li> <li><code>queue: str | RabbitQueue = \"\"</code> - the queue where the message will be sent (since most queues use their name as the routing key, this is a human-readable version of <code>routing_key</code>)</li> <li><code>routing_key: str = \"\"</code> - also a message routing key, if not specified, the <code>queue</code> argument will be used</li> </ul>"},{"location":"rabbit/publishing/#message-parameters","title":"Message Parameters","text":"<p>You can read more about all the available flags in the RabbitMQ documentation</p> <ul> <li><code>headers: dict[str, Any] | None = None</code> - message headers (used by consumers)</li> <li><code>content_type: str | None = None</code> - the content_type of the message being sent (set automatically, used by consumers)</li> <li><code>content_encoding: str | None = None</code> - encoding of the message (used by consumers)</li> <li><code>persist: bool = False</code> - restore messages on RabbitMQ reboot</li> <li><code>priority: int | None = None</code> - the priority of the message</li> <li><code>correlation_id: str | None = None</code> - message id, which helps to match the original message with the reply to it (generated automatically)</li> <li><code>message_id: str | None = None</code> - message ID (generated automatically)</li> <li><code>timestamp: int | float | time delta | datetime | None = None</code> - message sending time (set automatically)</li> <li><code>expiration: int | float | time delta | datetime | None = None</code> - message lifetime (in seconds)</li> <li><code>type: str | None = None</code> - the type of message (used by consumers)</li> <li><code>user_id: str | None = None</code> - ID of the RabbitMQ user who sent the message</li> <li><code>app_id: str | None = None</code> - ID of the application that sent the message (used by consumers)</li> </ul>"},{"location":"rabbit/publishing/#send-flags","title":"Send Flags","text":"<p>Arguments for sending a message:</p> <ul> <li><code>mandatory: bool = True</code> - the client is waiting for confirmation that the message will be placed in some queue (if there are no queues, return it to the sender)</li> <li><code>immediate: bool = False</code> - the client expects that there is a consumer ready to take the message to work \"right now\" (if there is no consumer, return it to the sender)</li> <li><code>timeout: int | float | None = None</code> - send confirmation time from RabbitMQ</li> </ul>"},{"location":"rabbit/rpc/","title":"RPC over RMQ","text":""},{"location":"rabbit/rpc/#blocking-request","title":"Blocking Request","text":"<p>FastStream provides you with the ability to send a blocking RPC request over RabbitMQ in a very simple way.</p> <p>It uses the Direct Reply-To RabbitMQ feature, so you don't need to create any queues to consume a response.</p> <p>Just send a message like a regular one and get a response synchronously.</p> <p>It is very close to common requests syntax:</p> <pre><code>msg = await broker.publish(\n\"Hi!\",\nqueue=\"test\",\nrpc=True,\n)\n</code></pre> <p>Also, you have two extra options to control this behavior:</p> <ul> <li><code>rpc_timeout: Optional[float] = 30.0</code> - controls how long you are waiting for a response</li> <li><code>raise_timeout: bool = False</code> - by default, a timeout request returns <code>None</code>, but if you need to raise a TimeoutException directly, you can specify this option</li> </ul>"},{"location":"rabbit/rpc/#reply-to","title":"Reply-To","text":"<p>Also, if you want to create a permanent request-reply data flow, probably, you should create a permanent queue to consume responses.</p> <p>So, if you have such one, you can specify it with the <code>reply_to</code> argument. This way, FastStream will send a response to this queue automatically.</p> <pre><code>@broker.subscriber(\"response-queue\")\nasync def consume_responses(msg):\n...\nmsg = await broker.publish(\n\"Hi!\",\nqueue=\"test\",\nreply_to=\"response-queue\",\n)\n</code></pre>"},{"location":"rabbit/examples/","title":"Basic Subscriber","text":"<p>If you know nothing about RabbitMQ and how it works, you will still able to use FastStream RabbitBroker.</p> <p>Just use the <code>@broker.subscriber(...)</code> method with a string as a routing key.</p> <pre><code>from faststream import FastStream\nfrom faststream.rabbit import RabbitBroker\nbroker = RabbitBroker()\napp = FastStream(broker)\n@broker.subscriber(\"routing_key\")  # handle messages by routing key\nasync def handle(msg):\nprint(msg)\n@app.after_startup\nasync def test_publish():\nawait broker.publish(\n\"message\",\n\"routing_key\",  # publish message with routing key\n)\n</code></pre> <p>This is the principle all FastStream brokers work by: you don't need to learn them in-depth if you want to just send a message.</p>"},{"location":"rabbit/examples/#rabbitmq-details","title":"RabbitMQ Details","text":"<p>If you are already familiar with RabbitMQ logic, you should also be acquainted with the inner workings of the example mentioned above.</p> <p>In this case, FastStream either creates or validates a queue with a specified routing_key and binds it to the default RabbitMQ exchange.</p> <p>If you want to specify a queue-exchange pair with additional arguments, FastStream provides you with the ability to do so. You can use special <code>RabbitQueue</code> and <code>RabbitExchange</code> objects to configure RabbitMQ queues, exchanges, and binding properties. For examples of using various types of exchanges, please refer to the following articles.</p>"},{"location":"rabbit/examples/direct/","title":"Direct Exchange","text":"<p>The Direct Exchange is the basic way to route messages in RabbitMQ. Its core is very simple: the <code>exchange</code> sends messages to those queues whose <code>routing_key</code> matches the <code>routing_key</code> of the message being sent.</p> <p>Note</p> <p>The Default Exchange, to which all queues in RabbitMQ are subscribed, has the Direct type by default.</p>"},{"location":"rabbit/examples/direct/#scaling","title":"Scaling","text":"<p>If several consumers are listening to the same queue, messages will be distributed to one of them (round-robin). This behavior is common for all types of <code>exchange</code> because it refers to the queue itself. The type of <code>exchange</code> affects which queues the message gets into.</p> <p>Thus, RabbitMQ can independently balance the load on queue consumers. You can increase the processing speed of the message flow from the queue by launching additional instances of a consumer service. You don't need to make changes to the current infrastructure configuration: RabbitMQ will take care of how to distribute messages between your services.</p>"},{"location":"rabbit/examples/direct/#example","title":"Example","text":"<p>Tip</p> <p>The Direct Exchange is the type used in FastStream by default. You can simply declare it as follows:</p> <pre><code>@broker.subscriber(\"test_queue\", \"test_exchange\")\nasync def handler():\n...\n</code></pre> <p>The argument <code>auto_delete=True</code> in this and subsequent examples is used only to clear the state of RabbitMQ after example runs.</p> <pre><code>from faststream import FastStream, Logger\nfrom faststream.rabbit import RabbitBroker, RabbitExchange, RabbitQueue\nbroker = RabbitBroker()\napp = FastStream(broker)\nexch = RabbitExchange(\"exchange\", auto_delete=True)\nqueue_1 = RabbitQueue(\"test-q-1\", auto_delete=True)\nqueue_2 = RabbitQueue(\"test-q-2\", auto_delete=True)\n@broker.subscriber(queue_1, exch)\nasync def base_handler1(logger: Logger):\nlogger.info(\"base_handler1\")\n@broker.subscriber(queue_1, exch)\nasync def base_handler2(logger: Logger):\nlogger.info(\"base_handler2\")\n@broker.subscriber(queue_2, exch)\nasync def base_handler3(logger: Logger):\nlogger.info(\"base_handler3\")\n@app.after_startup\nasync def send_messages():\nawait broker.publish(queue=\"test-q-1\", exchange=exch)  # handlers: 1\nawait broker.publish(queue=\"test-q-1\", exchange=exch)  # handlers: 2\nawait broker.publish(queue=\"test-q-1\", exchange=exch)  # handlers: 1\nawait broker.publish(queue=\"test-q-2\", exchange=exch)  # handlers: 3\n</code></pre>"},{"location":"rabbit/examples/direct/#consumer-announcement","title":"Consumer Announcement","text":"<p>First, we announce our Direct exchange and several queues that will listen to it:</p> <pre><code>exch = RabbitExchange(\"exchange\", auto_delete=True)\nqueue_1 = RabbitQueue(\"test-q-1\", auto_delete=True)\nqueue_2 = RabbitQueue(\"test-q-2\", auto_delete=True)\n</code></pre> <p>Then we sign up several consumers using the advertised queues to the <code>exchange</code> we created:</p> <pre><code>@broker.subscriber(queue_1, exch)\nasync def base_handler1(logger: Logger):\nlogger.info(\"base_handler1\")\n@broker.subscriber(queue_1, exch)\nasync def base_handler2(logger: Logger):\nlogger.info(\"base_handler2\")\n@broker.subscriber(queue_2, exch)\nasync def base_handler3(logger: Logger):\nlogger.info(\"base_handler3\")\n</code></pre> <p>Note</p> <p><code>handler1</code> and <code>handler2</code> are subscribed to the same <code>exchange</code> using the same queue: within a single service, this does not make sense, since messages will come to these handlers in turn. Here we emulate the work of several consumers and load balancing between them.</p>"},{"location":"rabbit/examples/direct/#message-distribution","title":"Message Distribution","text":"<p>Now, the distribution of messages between these consumers will look like this:</p> <pre><code>    await broker.publish(queue=\"test-q-1\", exchange=exch)  # handlers: 1\n</code></pre> <p>Message <code>1</code> will be sent to <code>handler1</code> because it listens to the <code>exchange</code> using a queue with the routing key <code>test-q-1</code>.</p> <pre><code>    await broker.publish(queue=\"test-q-1\", exchange=exch)  # handlers: 2\n</code></pre> <p>Message <code>2</code> will be sent to <code>handler2</code> because it listens to the <code>exchange</code> using the same queue, but <code>handler1</code> is busy.</p> <pre><code>    await broker.publish(queue=\"test-q-1\", exchange=exch)  # handlers: 1\n</code></pre> <p>Message <code>3</code> will be sent to <code>handler1</code> again because it is currently free.</p> <pre><code>    await broker.publish(queue=\"test-q-2\", exchange=exch)  # handlers: 3\n</code></pre> <p>Message <code>4</code> will be sent to <code>handler3</code> because it is the only one listening to the <code>exchange</code> using a queue with the routing key <code>test-q-2</code>.</p>"},{"location":"rabbit/examples/fanout/","title":"Fanout Exchange","text":"<p>The Fanout Exchange is an even simpler, but slightly less popular way of routing in RabbitMQ. This type of <code>exchange</code> sends messages to all queues subscribed to it, ignoring any arguments of the message.</p> <p>At the same time, if the queue listens to several consumers, messages will also be distributed among them.</p>"},{"location":"rabbit/examples/fanout/#example","title":"Example","text":"<pre><code>from faststream import FastStream, Logger\nfrom faststream.rabbit import ExchangeType, RabbitBroker, RabbitExchange, RabbitQueue\nbroker = RabbitBroker()\napp = FastStream(broker)\nexch = RabbitExchange(\"exchange\", auto_delete=True, type=ExchangeType.FANOUT)\nqueue_1 = RabbitQueue(\"test-q-1\", auto_delete=True)\nqueue_2 = RabbitQueue(\"test-q-2\", auto_delete=True)\n@broker.subscriber(queue_1, exch)\nasync def base_handler1(logger: Logger):\nlogger.info(\"base_handler1\")\n@broker.subscriber(queue_1, exch)\nasync def base_handler2(logger: Logger):\nlogger.info(\"base_handler2\")\n@broker.subscriber(queue_2, exch)\nasync def base_handler3(logger: Logger):\nlogger.info(\"base_handler3\")\n@app.after_startup\nasync def send_messages():\nawait broker.publish(exchange=exch)  # handlers: 1, 3\nawait broker.publish(exchange=exch)  # handlers: 2, 3\nawait broker.publish(exchange=exch)  # handlers: 1, 3\nawait broker.publish(exchange=exch)  # handlers: 2, 3\n</code></pre>"},{"location":"rabbit/examples/fanout/#consumer-announcement","title":"Consumer Announcement","text":"<p>To begin with, we announced our Fanout exchange and several queues that will listen to it:</p> <pre><code>exch = RabbitExchange(\"exchange\", auto_delete=True, type=ExchangeType.FANOUT)\nqueue_1 = RabbitQueue(\"test-q-1\", auto_delete=True)\nqueue_2 = RabbitQueue(\"test-q-2\", auto_delete=True)\n</code></pre> <p>Then we signed up several consumers using the advertised queues to the <code>exchange</code> we created:</p> <pre><code>@broker.subscriber(queue_1, exch)\nasync def base_handler1(logger: Logger):\nlogger.info(\"base_handler1\")\n@broker.subscriber(queue_1, exch)\nasync def base_handler2(logger: Logger):\nlogger.info(\"base_handler2\")\n@broker.subscriber(queue_2, exch)\nasync def base_handler3(logger: Logger):\nlogger.info(\"base_handler3\")\n</code></pre> <p>Note</p> <p><code>handler1</code> and <code>handler2</code> are subscribed to the same <code>exchange</code> using the same queue: within a single service, this does not make sense, since messages will come to these handlers in turn. Here we emulate the work of several consumers and load balancing between them.</p>"},{"location":"rabbit/examples/fanout/#message-distribution","title":"Message Distribution","text":"<p>Now the distribution of messages between these consumers will look like this:</p> <pre><code>    await broker.publish(exchange=exch)  # handlers: 1, 3\n</code></pre> <p>Message <code>1</code> will be sent to <code>handler1</code> and <code>handler3</code> because they listen to <code>exchange</code> using different queues.</p> <pre><code>    await broker.publish(exchange=exch)  # handlers: 2, 3\n</code></pre> <p>Message <code>2</code> will be sent to <code>handler2</code> and <code>handler3</code> because <code>handler2</code> listens to <code>exchange</code> using the same queue as <code>handler1</code>.</p> <pre><code>    await broker.publish(exchange=exch)  # handlers: 1, 3\n</code></pre> <p>Message <code>3</code> will be sent to <code>handler1</code> and <code>handler3</code>.</p> <pre><code>    await broker.publish(exchange=exch)  # handlers: 2, 3\n</code></pre> <p>Message <code>4</code> will be sent to <code>handler2</code> and <code>handler3</code>.</p> <p>Note</p> <p>When sending messages to Fanout exchange, it makes no sense to specify the arguments <code>queue</code> or <code>routing_key</code>, because they will be ignored.</p>"},{"location":"rabbit/examples/headers/","title":"Header Exchange","text":"<p>The Header Exchange is the most complex and flexible way to route messages in RabbitMQ. This <code>exchange</code> type sends messages to queues according by matching the queue binding arguments with message headers.</p> <p>At the same time, if several consumers are subscribed to the queue, messages will also be distributed among them.</p>"},{"location":"rabbit/examples/headers/#example","title":"Example","text":"<pre><code>from faststream import FastStream, Logger\nfrom faststream.rabbit import ExchangeType, RabbitBroker, RabbitExchange, RabbitQueue\nbroker = RabbitBroker()\napp = FastStream(broker)\nexch = RabbitExchange(\"exchange\", auto_delete=True, type=ExchangeType.HEADERS)\nqueue_1 = RabbitQueue(\n\"test-queue-1\",\nauto_delete=True,\nbind_arguments={\"key\": 1},\n)\nqueue_2 = RabbitQueue(\n\"test-queue-2\",\nauto_delete=True,\nbind_arguments={\"key\": 2, \"key2\": 2, \"x-match\": \"any\"},\n)\nqueue_3 = RabbitQueue(\n\"test-queue-3\",\nauto_delete=True,\nbind_arguments={\"key\": 2, \"key2\": 2, \"x-match\": \"all\"},\n)\n@broker.subscriber(queue_1, exch)\nasync def base_handler1(logger: Logger):\nlogger.info(\"base_handler1\")\n@broker.subscriber(queue_1, exch)\nasync def base_handler2(logger: Logger):\nlogger.info(\"base_handler2\")\n@broker.subscriber(queue_2, exch)\nasync def base_handler3(logger: Logger):\nlogger.info(\"base_handler3\")\n@broker.subscriber(queue_3, exch)\nasync def base_handler4(logger: Logger):\nlogger.info(\"base_handler4\")\n@app.after_startup\nasync def send_messages():\nawait broker.publish(exchange=exch, headers={\"key\": 1})  # handlers: 1\nawait broker.publish(exchange=exch, headers={\"key\": 1})  # handlers: 2\nawait broker.publish(exchange=exch, headers={\"key\": 1})  # handlers: 1\nawait broker.publish(exchange=exch, headers={\"key\": 2})  # handlers: 3\nawait broker.publish(exchange=exch, headers={\"key2\": 2})  # handlers: 3\nawait broker.publish(\nexchange=exch, headers={\"key\": 2, \"key2\": 2.0}\n)  # handlers: 3, 4\n</code></pre>"},{"location":"rabbit/examples/headers/#consumer-announcement","title":"Consumer Announcement","text":"<p>First, we announce our Header exchange and several queues that will listen to it:</p> <pre><code>exch = RabbitExchange(\"exchange\", auto_delete=True, type=ExchangeType.HEADERS)\nqueue_1 = RabbitQueue(\n\"test-queue-1\",\nauto_delete=True,\nbind_arguments={\"key\": 1},\n)\nqueue_2 = RabbitQueue(\n\"test-queue-2\",\nauto_delete=True,\nbind_arguments={\"key\": 2, \"key2\": 2, \"x-match\": \"any\"},\n)\nqueue_3 = RabbitQueue(\n\"test-queue-3\",\nauto_delete=True,\nbind_arguments={\"key\": 2, \"key2\": 2, \"x-match\": \"all\"},\n)\n</code></pre> <p>The <code>x-match</code> argument indicates whether the arguments should match the message headers in whole or in part.</p> <p>Then we signed up several consumers using the advertised queues to the <code>exchange</code> we created:</p> <pre><code>@broker.subscriber(queue_1, exch)\nasync def base_handler1(logger: Logger):\nlogger.info(\"base_handler1\")\n@broker.subscriber(queue_1, exch)\nasync def base_handler2(logger: Logger):\nlogger.info(\"base_handler2\")\n@broker.subscriber(queue_2, exch)\nasync def base_handler3(logger: Logger):\nlogger.info(\"base_handler3\")\n@broker.subscriber(queue_3, exch)\nasync def base_handler4(logger: Logger):\nlogger.info(\"base_handler4\")\n</code></pre> <p>Note</p> <p><code>handler1</code> and <code>handler2</code> are subscribed to the same <code>exchange</code> using the same queue: within a single service, this does not make sense, since messages will come to these handlers in turn. Here we emulate the work of several consumers and load balancing between them.</p>"},{"location":"rabbit/examples/headers/#message-distribution","title":"Message Distribution","text":"<p>Now the distribution of messages between these consumers will look like this:</p> <pre><code>    await broker.publish(exchange=exch, headers={\"key\": 1})  # handlers: 1\n</code></pre> <p>Message <code>1</code> will be sent to <code>handler1</code> because it listens to a queue whose <code>key</code> header matches the <code>key</code> header of the message.</p> <pre><code>    await broker.publish(exchange=exch, headers={\"key\": 1})  # handlers: 2\n</code></pre> <p>Message <code>2</code> will be sent to <code>handler2</code> because it listens to <code>exchange</code> using the same queue, but <code>handler1</code> is busy.</p> <pre><code>    await broker.publish(exchange=exch, headers={\"key\": 1})  # handlers: 1\n</code></pre> <p>Message <code>3</code> will be sent to <code>handler1</code> again because it is currently free.</p> <pre><code>    await broker.publish(exchange=exch, headers={\"key\": 2})  # handlers: 3\n</code></pre> <p>Message <code>4</code> will be sent to <code>handler3</code> because it listens to a queue whose <code>key</code> header coincided with the <code>key</code> header of the message.</p> <pre><code>    await broker.publish(exchange=exch, headers={\"key2\": 2})  # handlers: 3\n</code></pre> <p>Message <code>5</code> will be sent to <code>handler3</code> because it listens to a queue whose header <code>key2</code> coincided with the header <code>key2</code> of the message.</p> <pre><code>    await broker.publish(\nexchange=exch, headers={\"key\": 2, \"key2\": 2.0}\n)  # handlers: 3, 4\n</code></pre> <p>Message <code>6</code> will be sent to <code>handler3</code> and <code>handler4</code> because the message headers completely match the queue keys.</p> <p>Note</p> <p>When sending messages to Header exchange, it makes no sense to specify the arguments <code>queue</code> or <code>routing_key</code>, because they will be ignored</p> <p>Warning</p> <p>For incredibly complex routes, you can use the option to bind an <code>exchange</code> to another <code>exchange</code>. In this case, all the same rules apply as for queues subscribed to <code>exchange</code>. The only difference is that the signed <code>exchange</code> can further distribute messages according to its own rules.</p> <p>So, for example, you can combine Topic and Header exchange types.</p>"},{"location":"rabbit/examples/stream/","title":"RabbitMQ Streams","text":"<p>RabbitMQ has a Streams feature, which is closely related to Kafka topics.</p> <p>The main difference from regular RabbitMQ queues is that the messages are not deleted after consuming.</p> <p>And FastStream supports this feature as well!</p> <pre><code>from faststream import FastStream, Logger\nfrom faststream.rabbit import RabbitBroker, RabbitQueue\nbroker = RabbitBroker(max_consumers=10)\napp = FastStream(broker)\nqueue = RabbitQueue(\nname=\"test\",\ndurable=True,\narguments={\n\"x-queue-type\": \"stream\",\n},\n)\n@broker.subscriber(\nqueue,\nconsume_args={\"x-stream-offset\": \"first\"},\n)\nasync def handle(msg, logger: Logger):\nlogger.info(msg)\n@app.after_startup\nasync def test():\nawait broker.publish(\"Hi!\", queue)\n</code></pre>"},{"location":"rabbit/examples/topic/","title":"Topic Exchange","text":"<p>The Topic Exchange is a powerful RabbitMQ routing tool. This type of <code>exchange</code> sends messages to the queue in accordance with the pattern specified when they are connected to <code>exchange</code> and the <code>routing_key</code> of the message itself.</p> <p>At the same time, if several consumers are subscribed to the queue, messages will be distributed among them.</p>"},{"location":"rabbit/examples/topic/#example","title":"Example","text":"<pre><code>from faststream import FastStream, Logger\nfrom faststream.rabbit import ExchangeType, RabbitBroker, RabbitExchange, RabbitQueue\nbroker = RabbitBroker()\napp = FastStream(broker)\nexch = RabbitExchange(\"exchange\", auto_delete=True, type=ExchangeType.TOPIC)\nqueue_1 = RabbitQueue(\"test-queue-1\", auto_delete=True, routing_key=\"*.info\")\nqueue_2 = RabbitQueue(\"test-queue-2\", auto_delete=True, routing_key=\"*.debug\")\n@broker.subscriber(queue_1, exch)\nasync def base_handler1(logger: Logger):\nlogger.info(\"base_handler1\")\n@broker.subscriber(queue_1, exch)\nasync def base_handler2(logger: Logger):\nlogger.info(\"base_handler2\")\n@broker.subscriber(queue_2, exch)\nasync def base_handler3(logger: Logger):\nlogger.info(\"base_handler3\")\n@app.after_startup\nasync def send_messages():\nawait broker.publish(routing_key=\"logs.info\", exchange=exch)  # handlers: 1\nawait broker.publish(routing_key=\"logs.info\", exchange=exch)  # handlers: 2\nawait broker.publish(routing_key=\"logs.info\", exchange=exch)  # handlers: 1\nawait broker.publish(routing_key=\"logs.debug\", exchange=exch)  # handlers: 3\n</code></pre>"},{"location":"rabbit/examples/topic/#consumer-announcement","title":"Consumer Announcement","text":"<p>First, we announce our Topic exchange and several queues that will listen to it:</p> <pre><code>exch = RabbitExchange(\"exchange\", auto_delete=True, type=ExchangeType.TOPIC)\nqueue_1 = RabbitQueue(\"test-queue-1\", auto_delete=True, routing_key=\"*.info\")\nqueue_2 = RabbitQueue(\"test-queue-2\", auto_delete=True, routing_key=\"*.debug\")\n</code></pre> <p>At the same time, in the <code>routing_key</code> of our queues, we specify the pattern of routing keys that will be processed by this queue.</p> <p>Then we sign up several consumers using the advertised queues to the <code>exchange</code> we created:</p> <pre><code>@broker.subscriber(queue_1, exch)\nasync def base_handler1(logger: Logger):\nlogger.info(\"base_handler1\")\n@broker.subscriber(queue_1, exch)\nasync def base_handler2(logger: Logger):\nlogger.info(\"base_handler2\")\n@broker.subscriber(queue_2, exch)\nasync def base_handler3(logger: Logger):\nlogger.info(\"base_handler3\")\n</code></pre> <p>Note</p> <p><code>handler1</code> and <code>handler2</code> are subscribed to the same <code>exchange</code> using the same queue: within a single service, this does not make sense, since messages will come to these handlers in turn. Here we emulate the work of several consumers and load balancing between them.</p>"},{"location":"rabbit/examples/topic/#message-distribution","title":"Message Distribution","text":"<p>Now the distribution of messages between these consumers will look like this:</p> <pre><code>    await broker.publish(routing_key=\"logs.info\", exchange=exch)  # handlers: 1\n</code></pre> <p>Message <code>1</code> will be sent to <code>handler1</code> because it listens to <code>exchange</code> using a queue with the routing key <code>*.info</code>.</p> <pre><code>    await broker.publish(routing_key=\"logs.info\", exchange=exch)  # handlers: 2\n</code></pre> <p>Message <code>2</code> will be sent to <code>handler2</code> because it listens to <code>exchange</code> using the same queue, but <code>handler1</code> is busy.</p> <pre><code>    await broker.publish(routing_key=\"logs.info\", exchange=exch)  # handlers: 1\n</code></pre> <p>Message <code>3</code> will be sent to <code>handler1</code> again because it is currently free.</p> <pre><code>    await broker.publish(routing_key=\"logs.debug\", exchange=exch)  # handlers: 3\n</code></pre> <p>Message <code>4</code> will be sent to <code>handler3</code> because it is the only one listening to <code>exchange</code> using a queue with the routing key <code>*.debug</code>.</p>"}]}